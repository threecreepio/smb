                                ;-------------------------------------------------------------------------------------
                                
                                ;SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
                                ;by doppelganger (doppelheathen@gmail.com)
                                
                                ;This file is provided for your own use as-is.  It will require the character rom data
                                ;and an iNES file header to get it to work.
                                
                                ;There are so many people I have to thank for this, that taking all the credit for
                                ;myself would be an unforgivable act of arrogance. Without their help this would
                                ;probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into
                                ;the 6502 and the NES helped me learn how it works (you guys know who you are, there's no 
                                ;way I could have done this without your help), as well as the authors of x816 and SMB 
                                ;Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project, 
                                ;which I compared notes with but did not copy from.  Last but certainly not least, I thank
                                ;Nintendo for creating this game and the NES, without which this disassembly would
                                ;only be theory.
                                
                                ;Assembles with x816.
                                
                                ;-------------------------------------------------------------------------------------
                                ;DEFINES
                                
                                ;NES specific hardware defines
                                
                                PPU_CTRL_REG1         = $2000
                                PPU_CTRL_REG2         = $2001
                                PPU_STATUS            = $2002
                                PPU_SPR_ADDR          = $2003
                                PPU_SPR_DATA          = $2004
                                PPU_SCROLL_REG        = $2005
                                PPU_ADDRESS           = $2006
                                PPU_DATA              = $2007
                                
                                SND_REGISTER          = $4000
                                SND_SQUARE1_REG       = $4000
                                SND_SQUARE2_REG       = $4004
                                SND_TRIANGLE_REG      = $4008
                                SND_NOISE_REG         = $400c
                                SND_DELTA_REG         = $4010
                                SND_MASTERCTRL_REG    = $4015
                                
                                SPR_DMA               = $4014
                                JOYPAD_PORT           = $4016
                                JOYPAD_PORT1          = $4016
                                JOYPAD_PORT2          = $4017
                                
                                FDS_CTRL_REG          = $4025
                                
                                ; GAME SPECIFIC DEFINES
                                
                                ObjectOffset          = $08
                                
                                FrameCounter          = $09
                                
                                SavedJoypadBits       = $06fc
                                SavedJoypad1Bits      = $06fc
                                SavedJoypad2Bits      = $06fd
                                JoypadBitMask         = $074a
                                JoypadOverride        = $0758
                                
                                A_B_Buttons           = $0a
                                PreviousA_B_Buttons   = $0d
                                Up_Down_Buttons       = $0b
                                Left_Right_Buttons    = $0c
                                
                                GameEngineSubroutine  = $0e
                                
                                Mirror_PPU_CTRL_REG1  = $0778
                                Mirror_PPU_CTRL_REG2  = $0779
                                
                                OperMode              = $0770
                                OperMode_Task         = $0772
                                ScreenRoutineTask     = $073c
                                
                                GamePauseStatus       = $0776
                                GamePauseTimer        = $0777
                                
                                DemoAction            = $0717
                                DemoActionTimer       = $0718
                                
                                TimerControl          = $0747
                                IntervalTimerControl  = $077f
                                
                                Timers                = $0780
                                SelectTimer           = $0780
                                PlayerAnimTimer       = $0781
                                JumpSwimTimer         = $0782
                                RunningTimer          = $0783
                                BlockBounceTimer      = $0784
                                SideCollisionTimer    = $0785
                                JumpspringTimer       = $0786
                                GameTimerCtrlTimer    = $0787
                                ClimbSideTimer        = $0789
                                EnemyFrameTimer       = $078a
                                FrenzyEnemyTimer      = $078f
                                BowserFireBreathTimer = $0790
                                StompTimer            = $0791
                                AirBubbleTimer        = $0792
                                ScrollIntervalTimer   = $0795
                                EnemyIntervalTimer    = $0796
                                BrickCoinTimer        = $079d
                                InjuryTimer           = $079e
                                StarInvincibleTimer   = $079f
                                ScreenTimer           = $07a0
                                WorldEndTimer         = $07a1
                                DemoTimer             = $07a2
                                
                                Sprite_Data           = $0200
                                
                                Sprite_Y_Position     = $0200
                                Sprite_Tilenumber     = $0201
                                Sprite_Attributes     = $0202
                                Sprite_X_Position     = $0203
                                
                                ScreenEdge_PageLoc    = $071a
                                ScreenEdge_X_Pos      = $071c
                                ScreenLeft_PageLoc    = $071a
                                ScreenRight_PageLoc   = $071b
                                ScreenLeft_X_Pos      = $071c
                                ScreenRight_X_Pos     = $071d
                                
                                PlayerFacingDir       = $33
                                DestinationPageLoc    = $34
                                VictoryWalkControl    = $35
                                ScrollFractional      = $0768
                                PrimaryMsgCounter     = $0719
                                SecondaryMsgCounter   = $0749
                                
                                HorizontalScroll      = $073f
                                VerticalScroll        = $0740
                                ScrollLock            = $0723
                                ScrollThirtyTwo       = $073d
                                Player_X_Scroll       = $06ff
                                Player_Pos_ForScroll  = $0755
                                ScrollAmount          = $0775
                                
                                AreaData              = $e7
                                AreaDataLow           = $e7
                                AreaDataHigh          = $e8
                                EnemyData             = $e9
                                EnemyDataLow          = $e9
                                EnemyDataHigh         = $ea
                                
                                AreaParserTaskNum     = $071f
                                ColumnSets            = $071e
                                CurrentPageLoc        = $0725
                                CurrentColumnPos      = $0726
                                BackloadingFlag       = $0728
                                BehindAreaParserFlag  = $0729
                                AreaObjectPageLoc     = $072a
                                AreaObjectPageSel     = $072b
                                AreaDataOffset        = $072c
                                AreaObjOffsetBuffer   = $072d
                                AreaObjectLength      = $0730
                                StaircaseControl      = $0734
                                AreaObjectHeight      = $0735
                                MushroomLedgeHalfLen  = $0736
                                EnemyDataOffset       = $0739
                                EnemyObjectPageLoc    = $073a
                                EnemyObjectPageSel    = $073b
                                MetatileBuffer        = $06a1
                                BlockBufferColumnPos  = $06a0
                                CurrentNTAddr_Low     = $0721
                                CurrentNTAddr_High    = $0720
                                AttributeBuffer       = $03f9
                                
                                LoopCommand           = $0745
                                
                                DisplayDigits         = $07d7
                                TopScoreDisplay       = $07d7
                                ScoreAndCoinDisplay   = $07dd
                                PlayerScoreDisplay    = $07dd
                                GameTimerDisplay      = $07f8
                                DigitModifier         = $0134
                                
                                VerticalFlipFlag      = $0109
                                FloateyNum_Control    = $0110
                                ShellChainCounter     = $0125
                                FloateyNum_Timer      = $012c
                                FloateyNum_X_Pos      = $0117
                                FloateyNum_Y_Pos      = $011e
                                FlagpoleFNum_Y_Pos    = $010d
                                FlagpoleFNum_YMFDummy = $010e
                                FlagpoleScore         = $010f
                                FlagpoleCollisionYPos = $070f
                                StompChainCounter     = $0484
                                
                                VRAM_Buffer1_Offset   = $0300
                                VRAM_Buffer1          = $0301
                                VRAM_Buffer2_Offset   = $0340
                                VRAM_Buffer2          = $0341
                                VRAM_Buffer_AddrCtrl  = $0773
                                Sprite0HitDetectFlag  = $0722
                                DisableScreenFlag     = $0774
                                DisableIntermediate   = $0769
                                ColorRotateOffset     = $06d4
                                
                                TerrainControl        = $0727
                                AreaStyle             = $0733
                                ForegroundScenery     = $0741
                                BackgroundScenery     = $0742
                                CloudTypeOverride     = $0743
                                BackgroundColorCtrl   = $0744
                                AreaType              = $074e
                                AreaAddrsLOffset      = $074f
                                AreaPointer           = $0750
                                
                                PlayerEntranceCtrl    = $0710
                                GameTimerSetting      = $0715
                                AltEntranceControl    = $0752
                                EntrancePage          = $0751
                                NumberOfPlayers       = $077a
                                WarpZoneControl       = $06d6
                                ChangeAreaTimer       = $06de
                                
                                MultiLoopCorrectCntr  = $06d9
                                MultiLoopPassCntr     = $06da
                                
                                FetchNewGameTimerFlag = $0757
                                GameTimerExpiredFlag  = $0759
                                
                                PrimaryHardMode       = $076a
                                SecondaryHardMode     = $06cc
                                WorldSelectNumber     = $076b
                                WorldSelectEnableFlag = $07fc
                                ContinueWorld         = $07fd
                                
                                CurrentPlayer         = $0753
                                PlayerSize            = $0754
                                PlayerStatus          = $0756
                                
                                OnscreenPlayerInfo    = $075a
                                NumberofLives         = $075a ;used by current player
                                HalfwayPage           = $075b
                                LevelNumber           = $075c ;the actual dash number
                                Hidden1UpFlag         = $075d
                                CoinTally             = $075e
                                WorldNumber           = $075f
                                AreaNumber            = $0760 ;internal number used to find areas
                                
                                CoinTallyFor1Ups      = $0748
                                
                                OffscreenPlayerInfo   = $0761
                                OffScr_NumberofLives  = $0761 ;used by offscreen player
                                OffScr_HalfwayPage    = $0762
                                OffScr_LevelNumber    = $0763
                                OffScr_Hidden1UpFlag  = $0764
                                OffScr_CoinTally      = $0765
                                OffScr_WorldNumber    = $0766
                                OffScr_AreaNumber     = $0767
                                
                                BalPlatformAlignment  = $03a0
                                Platform_X_Scroll     = $03a1
                                PlatformCollisionFlag = $03a2
                                YPlatformTopYPos      = $0401
                                YPlatformCenterYPos   = $58
                                
                                BrickCoinTimerFlag    = $06bc
                                StarFlagTaskControl   = $0746
                                
                                PseudoRandomBitReg    = $07a7
                                WarmBootValidation    = $07ff
                                
                                SprShuffleAmtOffset   = $06e0
                                SprShuffleAmt         = $06e1
                                SprDataOffset         = $06e4
                                Player_SprDataOffset  = $06e4
                                Enemy_SprDataOffset   = $06e5
                                Block_SprDataOffset   = $06ec
                                Alt_SprDataOffset     = $06ec
                                Bubble_SprDataOffset  = $06ee
                                FBall_SprDataOffset   = $06f1
                                Misc_SprDataOffset    = $06f3
                                SprDataOffset_Ctrl    = $03ee
                                
                                Player_State          = $1d
                                Enemy_State           = $1e
                                Fireball_State        = $24
                                Block_State           = $26
                                Misc_State            = $2a
                                
                                Player_MovingDir      = $45
                                Enemy_MovingDir       = $46
                                
                                SprObject_X_Speed     = $57
                                Player_X_Speed        = $57
                                Enemy_X_Speed         = $58
                                Fireball_X_Speed      = $5e
                                Block_X_Speed         = $60
                                Misc_X_Speed          = $64
                                
                                Jumpspring_FixedYPos  = $58
                                JumpspringAnimCtrl    = $070e
                                JumpspringForce       = $06db
                                
                                SprObject_PageLoc     = $6d
                                Player_PageLoc        = $6d
                                Enemy_PageLoc         = $6e
                                Fireball_PageLoc      = $74
                                Block_PageLoc         = $76
                                Misc_PageLoc          = $7a
                                Bubble_PageLoc        = $83
                                
                                SprObject_X_Position  = $86
                                Player_X_Position     = $86
                                Enemy_X_Position      = $87
                                Fireball_X_Position   = $8d
                                Block_X_Position      = $8f
                                Misc_X_Position       = $93
                                Bubble_X_Position     = $9c
                                
                                SprObject_Y_Speed     = $9f
                                Player_Y_Speed        = $9f
                                Enemy_Y_Speed         = $a0
                                Fireball_Y_Speed      = $a6
                                Block_Y_Speed         = $a8
                                Misc_Y_Speed          = $ac
                                
                                SprObject_Y_HighPos   = $b5
                                Player_Y_HighPos      = $b5
                                Enemy_Y_HighPos       = $b6
                                Fireball_Y_HighPos    = $bc
                                Block_Y_HighPos       = $be
                                Misc_Y_HighPos        = $c2
                                Bubble_Y_HighPos      = $cb
                                
                                SprObject_Y_Position  = $ce
                                Player_Y_Position     = $ce
                                Enemy_Y_Position      = $cf
                                Fireball_Y_Position   = $d5
                                Block_Y_Position      = $d7
                                Misc_Y_Position       = $db
                                Bubble_Y_Position     = $e4
                                
                                SprObject_Rel_XPos    = $03ad
                                Player_Rel_XPos       = $03ad
                                Enemy_Rel_XPos        = $03ae
                                Fireball_Rel_XPos     = $03af
                                Bubble_Rel_XPos       = $03b0
                                Block_Rel_XPos        = $03b1
                                Misc_Rel_XPos         = $03b3
                                
                                SprObject_Rel_YPos    = $03b8
                                Player_Rel_YPos       = $03b8
                                Enemy_Rel_YPos        = $03b9
                                Fireball_Rel_YPos     = $03ba
                                Bubble_Rel_YPos       = $03bb
                                Block_Rel_YPos        = $03bc
                                Misc_Rel_YPos         = $03be
                                
                                SprObject_SprAttrib   = $03c4
                                Player_SprAttrib      = $03c4
                                Enemy_SprAttrib       = $03c5
                                
                                SprObject_X_MoveForce = $0400
                                Enemy_X_MoveForce     = $0401
                                
                                SprObject_YMF_Dummy   = $0416
                                Player_YMF_Dummy      = $0416
                                Enemy_YMF_Dummy       = $0417
                                Bubble_YMF_Dummy      = $042c
                                
                                SprObject_Y_MoveForce = $0433
                                Player_Y_MoveForce    = $0433
                                Enemy_Y_MoveForce     = $0434
                                Block_Y_MoveForce     = $043c
                                
                                DisableCollisionDet   = $0716
                                Player_CollisionBits  = $0490
                                Enemy_CollisionBits   = $0491
                                
                                SprObj_BoundBoxCtrl   = $0499
                                Player_BoundBoxCtrl   = $0499
                                Enemy_BoundBoxCtrl    = $049a
                                Fireball_BoundBoxCtrl = $04a0
                                Misc_BoundBoxCtrl     = $04a2
                                
                                EnemyFrenzyBuffer     = $06cb
                                EnemyFrenzyQueue      = $06cd
                                Enemy_Flag            = $0f
                                Enemy_ID              = $16
                                
                                PlayerGfxOffset       = $06d5
                                Player_XSpeedAbsolute = $0700
                                FrictionAdderHigh     = $0701
                                FrictionAdderLow      = $0702
                                RunningSpeed          = $0703
                                SwimmingFlag          = $0704
                                Player_X_MoveForce    = $0705
                                DiffToHaltJump        = $0706
                                JumpOrigin_Y_HighPos  = $0707
                                JumpOrigin_Y_Position = $0708
                                VerticalForce         = $0709
                                VerticalForceDown     = $070a
                                PlayerChangeSizeFlag  = $070b
                                PlayerAnimTimerSet    = $070c
                                PlayerAnimCtrl        = $070d
                                DeathMusicLoaded      = $0712
                                FlagpoleSoundQueue    = $0713
                                CrouchingFlag         = $0714
                                MaximumLeftSpeed      = $0450
                                MaximumRightSpeed     = $0456
                                
                                SprObject_OffscrBits  = $03d0
                                Player_OffscreenBits  = $03d0
                                Enemy_OffscreenBits   = $03d1
                                FBall_OffscreenBits   = $03d2
                                Bubble_OffscreenBits  = $03d3
                                Block_OffscreenBits   = $03d4
                                Misc_OffscreenBits    = $03d6
                                EnemyOffscrBitsMasked = $03d8
                                
                                Cannon_Offset         = $046a
                                Cannon_PageLoc        = $046b
                                Cannon_X_Position     = $0471
                                Cannon_Y_Position     = $0477
                                Cannon_Timer          = $047d
                                
                                Whirlpool_Offset      = $046a
                                Whirlpool_PageLoc     = $046b
                                Whirlpool_LeftExtent  = $0471
                                Whirlpool_Length      = $0477
                                Whirlpool_Flag        = $047d
                                
                                VineFlagOffset        = $0398
                                VineHeight            = $0399
                                VineObjOffset         = $039a
                                VineStart_Y_Position  = $039d
                                
                                Block_Orig_YPos       = $03e4
                                Block_BBuf_Low        = $03e6
                                Block_Metatile        = $03e8
                                Block_PageLoc2        = $03ea
                                Block_RepFlag         = $03ec
                                Block_ResidualCounter = $03f0
                                Block_Orig_XPos       = $03f1
                                
                                BoundingBox_UL_XPos   = $04ac
                                BoundingBox_UL_YPos   = $04ad
                                BoundingBox_DR_XPos   = $04ae
                                BoundingBox_DR_YPos   = $04af
                                BoundingBox_UL_Corner = $04ac
                                BoundingBox_LR_Corner = $04ae
                                EnemyBoundingBoxCoord = $04b0
                                
                                PowerUpType           = $39
                                
                                FireballBouncingFlag  = $3a
                                FireballCounter       = $06ce
                                FireballThrowingTimer = $0711
                                
                                HammerEnemyOffset     = $06ae
                                JumpCoinMiscOffset    = $06b7
                                
                                Block_Buffer_1        = $0500
                                Block_Buffer_2        = $05d0
                                
                                HammerThrowingTimer   = $03a2
                                HammerBroJumpTimer    = $3c
                                Misc_Collision_Flag   = $06be
                                
                                RedPTroopaOrigXPos    = $0401
                                RedPTroopaCenterYPos  = $58
                                
                                XMovePrimaryCounter   = $a0
                                XMoveSecondaryCounter = $58
                                
                                CheepCheepMoveMFlag   = $58
                                CheepCheepOrigYPos    = $0434
                                BitMFilter            = $06dd
                                
                                LakituReappearTimer   = $06d1
                                LakituMoveSpeed       = $58
                                LakituMoveDirection   = $a0
                                
                                FirebarSpinState_Low  = $58
                                FirebarSpinState_High = $a0
                                FirebarSpinSpeed      = $0388
                                FirebarSpinDirection  = $34
                                
                                DuplicateObj_Offset   = $06cf
                                NumberofGroupEnemies  = $06d3
                                
                                BlooperMoveCounter    = $a0
                                BlooperMoveSpeed      = $58
                                
                                BowserBodyControls    = $0363
                                BowserFeetCounter     = $0364
                                BowserMovementSpeed   = $0365
                                BowserOrigXPos        = $0366
                                BowserFlameTimerCtrl  = $0367
                                BowserFront_Offset    = $0368
                                BridgeCollapseOffset  = $0369
                                BowserGfxFlag         = $036a
                                BowserHitPoints       = $0483
                                MaxRangeFromOrigin    = $06dc
                                
                                BowserFlamePRandomOfs = $0417
                                
                                PiranhaPlantUpYPos    = $0417
                                PiranhaPlantDownYPos  = $0434
                                PiranhaPlant_Y_Speed  = $58
                                PiranhaPlant_MoveFlag = $a0
                                
                                FireworksCounter      = $06d7
                                ExplosionGfxCounter   = $58
                                ExplosionTimerCounter = $a0
                                
                                ;sound related defines
                                Squ2_NoteLenBuffer    = $07b3
                                Squ2_NoteLenCounter   = $07b4
                                Squ2_EnvelopeDataCtrl = $07b5
                                Squ1_NoteLenCounter   = $07b6
                                Squ1_EnvelopeDataCtrl = $07b7
                                Tri_NoteLenBuffer     = $07b8
                                Tri_NoteLenCounter    = $07b9
                                Noise_BeatLenCounter  = $07ba
                                Squ1_SfxLenCounter    = $07bb
                                Squ2_SfxLenCounter    = $07bd
                                Sfx_SecondaryCounter  = $07be
                                Noise_SfxLenCounter   = $07bf
                                
                                PauseSoundQueue       = $fa
                                Square1SoundQueue     = $ff
                                Square2SoundQueue     = $fe
                                NoiseSoundQueue       = $fd
                                AreaMusicQueue        = $fb
                                EventMusicQueue       = $fc
                                
                                Square1SoundBuffer    = $f1
                                Square2SoundBuffer    = $f2
                                NoiseSoundBuffer      = $f3
                                AreaMusicBuffer       = $f4
                                EventMusicBuffer      = $07b1
                                PauseSoundBuffer      = $07b2
                                
                                MusicData             = $f5
                                MusicDataLow          = $f5
                                MusicDataHigh         = $f6
                                MusicOffset_Square2   = $f7
                                MusicOffset_Square1   = $f8
                                MusicOffset_Triangle  = $f9
                                MusicOffset_Noise     = $07b0
                                
                                NoteLenLookupTblOfs   = $f0
                                DAC_Counter           = $07c0
                                NoiseDataLoopbackOfs  = $07c1
                                NoteLengthTblAdder    = $07c4
                                AreaMusicBuffer_Alt   = $07c5
                                PauseModeFlag         = $07c6
                                GroundMusicHeaderOfs  = $07c7
                                AltRegContentFlag     = $07ca
                                
                                ;-------------------------------------------------------------------------------------
                                ;CONSTANTS
                                
                                ;sound effects constants
                                Sfx_SmallJump         = %10000000
                                Sfx_Flagpole          = %01000000
                                Sfx_Fireball          = %00100000
                                Sfx_PipeDown_Injury   = %00010000
                                Sfx_EnemySmack        = %00001000
                                Sfx_EnemyStomp        = %00000100
                                Sfx_Bump              = %00000010
                                Sfx_BigJump           = %00000001
                                
                                Sfx_BowserFall        = %10000000
                                Sfx_ExtraLife         = %01000000
                                Sfx_PowerUpGrab       = %00100000
                                Sfx_TimerTick         = %00010000
                                Sfx_Blast             = %00001000
                                Sfx_GrowVine          = %00000100
                                Sfx_GrowPowerUp       = %00000010
                                Sfx_CoinGrab          = %00000001
                                
                                Sfx_BowserFlame       = %00000010
                                Sfx_BrickShatter      = %00000001
                                
                                ;music constants
                                Silence               = %10000000
                                
                                StarPowerMusic        = %01000000
                                PipeIntroMusic        = %00100000
                                CloudMusic            = %00010000
                                CastleMusic           = %00001000
                                UndergroundMusic      = %00000100
                                WaterMusic            = %00000010
                                GroundMusic           = %00000001
                                
                                TimeRunningOutMusic   = %01000000
                                EndOfLevelMusic       = %00100000
                                AltGameOverMusic      = %00010000
                                EndOfCastleMusic      = %00001000
                                VictoryMusic          = %00000100
                                GameOverMusic         = %00000010
                                DeathMusic            = %00000001
                                
                                ;enemy object constants 
                                GreenKoopa            = $00
                                BuzzyBeetle           = $02
                                RedKoopa              = $03
                                HammerBro             = $05
                                Goomba                = $06
                                Bloober               = $07
                                BulletBill_FrenzyVar  = $08
                                GreyCheepCheep        = $0a
                                RedCheepCheep         = $0b
                                Podoboo               = $0c
                                PiranhaPlant          = $0d
                                GreenParatroopaJump   = $0e
                                RedParatroopa         = $0f
                                GreenParatroopaFly    = $10
                                Lakitu                = $11
                                Spiny                 = $12
                                FlyCheepCheepFrenzy   = $14
                                FlyingCheepCheep      = $14
                                BowserFlame           = $15
                                Fireworks             = $16
                                BBill_CCheep_Frenzy   = $17
                                Stop_Frenzy           = $18
                                Bowser                = $2d
                                PowerUpObject         = $2e
                                VineObject            = $2f
                                FlagpoleFlagObject    = $30
                                StarFlagObject        = $31
                                JumpspringObject      = $32
                                BulletBill_CannonVar  = $33
                                RetainerObject        = $35
                                TallEnemy             = $09
                                
                                ;other constants
                                World1 = 0
                                World2 = 1
                                World3 = 2
                                World4 = 3
                                World5 = 4
                                World6 = 5
                                World7 = 6
                                World8 = 7
                                Level1 = 0
                                Level2 = 1
                                Level3 = 2
                                Level4 = 3
                                
                                WarmBootOffset        = <$07d6
                                ColdBootOffset        = <$07fe
                                TitleScreenDataOffset = $1ec0
                                SoundMemory           = $07b0
                                SwimTileRepOffset     = PlayerGraphicsTable + $9e
                                MusicHeaderOffsetData = MusicHeaderData - 1
                                MHD                   = MusicHeaderData
                                
                                A_Button              = %10000000
                                B_Button              = %01000000
                                Select_Button         = %00100000
                                Start_Button          = %00010000
                                Up_Dir                = %00001000
                                Down_Dir              = %00000100
                                Left_Dir              = %00000010
                                Right_Dir             = %00000001
                                
                                TitleScreenModeValue  = 0
                                GameModeValue         = 1
                                VictoryModeValue      = 2
                                GameOverModeValue     = 3
                                
                                ;-------------------------------------------------------------------------------------
                                ;DIRECTIVES
                                
                                .org $6000
06000                           
06000                           ;-------------------------------------------------------------------------------------
06000                           
06000                           Start:
06000 D8                                     cld
06001 A9 10                                  lda #%00010000               ;init PPU control register 1 
06003 8D 00 20                               sta PPU_CTRL_REG1
06006 A2 FF                                  ldx #$ff                     ;reset stack pointer
06008 9A                                     txs
06009 AD 02 20                  VBlank1:     lda PPU_STATUS               ;wait two frames
0600C 10 FB                                  bpl VBlank1
0600E AD 02 20                  VBlank2:     lda PPU_STATUS
06011 10 FB                                  bpl VBlank2
06013 A0 FE                                  ldy #ColdBootOffset          ;load default cold boot pointer
06015 A2 05                                  ldx #$05                     ;this is where we check for a warm boot
06017 BD D7 07                  WBootCheck:  lda TopScoreDisplay,x        ;check each score digit in the top score
0601A C9 0A                                  cmp #10                      ;to see if we have a valid digit
0601C B0 0C                                  bcs ColdBoot                 ;if not, give up and proceed with cold boot
0601E CA                                     dex                      
0601F 10 F6                                  bpl WBootCheck
06021 AD FF 07                               lda WarmBootValidation       ;second checkpoint, check to see if 
06024 C9 A5                                  cmp #$a5                     ;another location has a specific value
06026 D0 02                                  bne ColdBoot   
06028 A0 D6                                  ldy #WarmBootOffset          ;if passed both, load warm boot pointer
0602A 20 D2 70                  ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
0602D 8D 11 40                               sta SND_DELTA_REG+1          ;reset delta counter load register
06030 8D 70 07                               sta OperMode                 ;reset primary mode of operation
06033 A9 A5                                  lda #$a5                     ;set warm boot flag
06035 8D FF 07                               sta WarmBootValidation     
06038 8D A7 07                               sta PseudoRandomBitReg       ;set seed for pseudorandom register
0603B A9 0F                                  lda #%00001111
0603D 8D 15 40                               sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
06040 A9 06                                  lda #%00000110
06042 8D 01 20                               sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
06045 20 26 62                               jsr MoveAllSpritesOffscreen
06048 20 1F 6E                               jsr InitializeNameTables     ;initialize both name tables
0604B EE 74 07                               inc DisableScreenFlag        ;set flag to disable screen output
0604E A9 27                                  lda #%00100111               ;enable read mode and vertical mirroring
06050 8D 25 40                               sta FDS_CTRL_REG             ;write to FDS control register
06053 58                                     cli                          ;enable FDS IRQs
06054 AD 78 07                               lda Mirror_PPU_CTRL_REG1
06057 09 80                                  ora #%10000000               ;enable NMIs
06059 20 F3 6E                               jsr WritePPUReg1
0605C 4C 5C 60                  EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
0605F                           
0605F                           ;-------------------------------------------------------------------------------------
0605F                           ;$00 - vram buffer address table low, also used for pseudorandom bit
0605F                           ;$01 - vram buffer address table high
0605F                           
0605F                           VRAM_AddrTable_Low:
0605F 01 AA CE                        .db <VRAM_Buffer1, <WaterPaletteData, <GroundPaletteData
06062 F2 16 00                        .db <UndergroundPaletteData, <CastlePaletteData, <VRAM_Buffer1_Offset
06065 41 41 52                        .db <VRAM_Buffer2, <VRAM_Buffer2, <BowserPaletteData
06068 3A 42 4A                        .db <DaySnowPaletteData, <NightSnowPaletteData, <MushroomPaletteData
0606B 5A 6E 82                        .db <MarioThanksMessage, <LuigiThanksMessage, <MushroomRetainerSaved
0606E AE C5 E4                        .db <PrincessSaved1, <PrincessSaved2, <WorldSelectMessage1
06071 F5                              .db <WorldSelectMessage2
06072                           
06072                           VRAM_AddrTable_High:
06072 03 6C 6C                        .db >VRAM_Buffer1, >WaterPaletteData, >GroundPaletteData
06075 6C 6D 03                        .db >UndergroundPaletteData, >CastlePaletteData, >VRAM_Buffer1_Offset
06078 03 03 6D                        .db >VRAM_Buffer2, >VRAM_Buffer2, >BowserPaletteData
0607B 6D 6D 6D                        .db >DaySnowPaletteData, >NightSnowPaletteData, >MushroomPaletteData
0607E 6D 6D 6D                        .db >MarioThanksMessage, >LuigiThanksMessage, >MushroomRetainerSaved
06081 6D 6D 6D                        .db >PrincessSaved1, >PrincessSaved2, >WorldSelectMessage1
06084 6D                              .db >WorldSelectMessage2
06085                           
06085                           VRAM_Buffer_Offset:
06085 00 40                           .db <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
06087                           
06087                           NonMaskableInterrupt:
06087 58                                       cli                       ;enable FDS IRQs
06088 AD 78 07                                 lda Mirror_PPU_CTRL_REG1  ;disable NMIs in mirror reg
0608B 29 7F                                    and #%01111111            ;save all other bits
0608D 8D 78 07                                 sta Mirror_PPU_CTRL_REG1
06090 29 7E                                    and #%01111110            ;alter name table address to be $2800
06092 8D 00 20                                 sta PPU_CTRL_REG1         ;(essentially $2000) but save other bits
06095 AD 79 07                                 lda Mirror_PPU_CTRL_REG2  ;disable OAM and background display by default
06098 29 E6                                    and #%11100110
0609A AC 74 07                                 ldy DisableScreenFlag     ;get screen disable flag
0609D D0 05                                    bne ScreenOff             ;if set, used bits as-is
0609F AD 79 07                                 lda Mirror_PPU_CTRL_REG2  ;otherwise reenable bits and save them
060A2 09 1E                                    ora #%00011110
060A4 8D 79 07                  ScreenOff:     sta Mirror_PPU_CTRL_REG2  ;save bits for later but not in register at the moment
060A7 29 E7                                    and #%11100111            ;disable screen for now
060A9 8D 01 20                                 sta PPU_CTRL_REG2
060AC AE 02 20                                 ldx PPU_STATUS            ;reset flip-flop and reset scroll registers to zero
060AF A9 00                                    lda #$00
060B1 20 EC 6E                                 jsr InitScroll
060B4 8D 03 20                                 sta PPU_SPR_ADDR          ;reset spr-ram address register
060B7 A9 02                                    lda #$02                  ;perform spr-ram DMA access on $0200-$02ff
060B9 8D 14 40                                 sta SPR_DMA
060BC AE 73 07                                 ldx VRAM_Buffer_AddrCtrl  ;load control for pointer to buffer contents
060BF BD 5F 60                                 lda VRAM_AddrTable_Low,x  ;set indirect at $00 to pointer
060C2 85 00                                    sta $00
060C4 BD 72 60                                 lda VRAM_AddrTable_High,x
060C7 85 01                                    sta $01
060C9 20 E3 6E                                 jsr UpdateScreen          ;update screen with buffer contents
060CC A0 00                                    ldy #$00
060CE AE 73 07                                 ldx VRAM_Buffer_AddrCtrl  ;check for usage of $0341
060D1 E0 06                                    cpx #$06
060D3 D0 01                                    bne InitBuffer
060D5 C8                                       iny                       ;get offset based on usage
060D6 BE 85 60                  InitBuffer:    ldx VRAM_Buffer_Offset,y
060D9 A9 00                                    lda #$00                  ;clear buffer header at last location
060DB 9D 00 03                                 sta VRAM_Buffer1_Offset,x        
060DE 9D 01 03                                 sta VRAM_Buffer1,x
060E1 8D 73 07                                 sta VRAM_Buffer_AddrCtrl  ;reinit address control to $0301
060E4 AD 79 07                                 lda Mirror_PPU_CTRL_REG2  ;copy mirror of $2001 to register
060E7 8D 01 20                                 sta PPU_CTRL_REG2
060EA 20 D0 D2                                 jsr SoundEngine           ;play sound
060ED 20 62 6E                                 jsr ReadJoypads           ;read joypads
060F0 20 88 61                                 jsr PauseRoutine          ;handle pause
060F3 20 9D 6F                                 jsr UpdateTopScore
060F6 AD 76 07                                 lda GamePauseStatus       ;check for pause status
060F9 4A                                       lsr
060FA B0 25                                    bcs PauseSkip
060FC AD 47 07                                 lda TimerControl          ;if master timer control not set, decrement
060FF F0 05                                    beq DecTimers             ;all frame and interval timers
06101 CE 47 07                                 dec TimerControl
06104 D0 19                                    bne NoDecTimers
06106 A2 14                     DecTimers:     ldx #$14                  ;load end offset for end of frame timers
06108 CE 7F 07                                 dec IntervalTimerControl  ;decrement interval timer control,
0610B 10 07                                    bpl DecTimersLoop         ;if not expired, only frame timers will decrement
0610D A9 14                                    lda #$14
0610F 8D 7F 07                                 sta IntervalTimerControl  ;if control for interval timers expired,
06112 A2 23                                    ldx #$23                  ;interval timers will decrement along with frame timers
06114 BD 80 07                  DecTimersLoop: lda Timers,x              ;check current timer
06117 F0 03                                    beq SkipExpTimer          ;if current timer expired, branch to skip,
06119 DE 80 07                                 dec Timers,x              ;otherwise decrement the current timer
0611C CA                        SkipExpTimer:  dex                       ;move onto next timer
0611D 10 F5                                    bpl DecTimersLoop         ;do this until all timers are dealt with
0611F E6 09                     NoDecTimers:   inc FrameCounter          ;increment frame counter
06121 A2 00                     PauseSkip:     ldx #$00
06123 A0 07                                    ldy #$07
06125 AD A7 07                                 lda PseudoRandomBitReg    ;get first memory location of LSFR bytes
06128 29 02                                    and #%00000010            ;mask out all but d1
0612A 85 00                                    sta $00                   ;save here
0612C AD A8 07                                 lda PseudoRandomBitReg+1  ;get second memory location
0612F 29 02                                    and #%00000010            ;mask out all but d1
06131 45 00                                    eor $00                   ;perform exclusive-OR on d1 from first and second bytes
06133 18                                       clc                       ;if neither or both are set, carry will be clear
06134 F0 01                                    beq RotPRandomBit
06136 38                                       sec                       ;if one or the other is set, carry will be set
06137 7E A7 07                  RotPRandomBit: ror PseudoRandomBitReg,x  ;rotate carry into d7, and rotate last bit into carry
0613A E8                                       inx                       ;increment to next byte
0613B 88                                       dey                       ;decrement for loop
0613C D0 F9                                    bne RotPRandomBit
0613E AD 22 07                                 lda Sprite0HitDetectFlag  ;check for flag here
06141 F0 1F                                    beq SkipSprite0
06143 AD 02 20                  Sprite0Clr:    lda PPU_STATUS            ;wait for sprite 0 flag to clear, which will
06146 29 40                                    and #%01000000            ;not happen until vblank has ended
06148 D0 F9                                    bne Sprite0Clr
0614A AD 76 07                                 lda GamePauseStatus       ;if in pause mode, do not bother with sprites at all
0614D 4A                                       lsr
0614E B0 06                                    bcs Sprite0Hit
06150 20 29 62                                 jsr MoveSpritesOffscreen
06153 20 CC 61                                 jsr SpriteShuffler
06156 AD 02 20                  Sprite0Hit:    lda PPU_STATUS            ;do sprite #0 hit detection
06159 29 40                                    and #%01000000
0615B F0 F9                                    beq Sprite0Hit
0615D A0 14                                    ldy #$14                  ;small delay, to wait until we hit horizontal blank time
0615F 88                        HBlankDelay:   dey
06160 D0 FD                                    bne HBlankDelay
06162 AD 3F 07                  SkipSprite0:   lda HorizontalScroll      ;set scroll registers from variables
06165 8D 05 20                                 sta PPU_SCROLL_REG
06168 AD 40 07                                 lda VerticalScroll
0616B 8D 05 20                                 sta PPU_SCROLL_REG
0616E AD 78 07                                 lda Mirror_PPU_CTRL_REG1  ;load saved mirror of $2000
06171 48                                       pha
06172 8D 00 20                                 sta PPU_CTRL_REG1
06175 AD 76 07                                 lda GamePauseStatus       ;if in pause mode, do not perform operation mode stuff
06178 4A                                       lsr
06179 B0 03                                    bcs SkipMainOper
0617B 20 18 62                                 jsr OperModeExecutionTree ;otherwise do one of many, many possible subroutines
0617E AD 02 20                  SkipMainOper:  lda PPU_STATUS            ;reset flip-flop
06181 68                                       pla
06182 09 80                                    ora #%10000000            ;reactivate NMIs
06184 8D 00 20                                 sta PPU_CTRL_REG1
06187 40                                       rti                       ;we are done until the next frame!
06188                           
06188                           ;-------------------------------------------------------------------------------------
06188                           
06188                           PauseRoutine:
06188 AD 70 07                                 lda OperMode           ;are we in victory mode?
0618B C9 02                                    cmp #VictoryModeValue  ;if so, go ahead
0618D F0 0B                                    beq ChkPauseTimer
0618F C9 01                                    cmp #GameModeValue     ;are we in game mode?
06191 D0 38                                    bne ExitPause          ;if not, leave
06193 AD 72 07                                 lda OperMode_Task      ;if we are in game mode, are we running game engine?
06196 C9 03                                    cmp #$03
06198 D0 31                                    bne ExitPause          ;if not, leave
0619A AD 77 07                  ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
0619D F0 04                                    beq ChkStart
0619F CE 77 07                                 dec GamePauseTimer     ;if so, decrement and leave
061A2 60                                       rts
061A3 AD FC 06                  ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
061A6 29 10                                    and #Start_Button      ;on controller 1
061A8 F0 19                                    beq ClrPauseTimer
061AA AD 76 07                                 lda GamePauseStatus    ;check to see if timer flag is set
061AD 29 80                                    and #%10000000         ;and if so, do not reset timer (residual,
061AF D0 1A                                    bne ExitPause          ;joypad reading routine makes this unnecessary)
061B1 A9 2B                                    lda #$2b               ;set pause timer
061B3 8D 77 07                                 sta GamePauseTimer
061B6 AD 76 07                                 lda GamePauseStatus
061B9 A8                                       tay
061BA C8                                       iny                    ;set pause sfx queue for next pause mode
061BB 84 FA                                    sty PauseSoundQueue
061BD 49 01                                    eor #%00000001         ;invert d0 and set d7
061BF 09 80                                    ora #%10000000
061C1 D0 05                                    bne SetPause           ;unconditional branch
061C3 AD 76 07                  ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
061C6 29 7F                                    and #%01111111         ;is not pressed
061C8 8D 76 07                  SetPause:      sta GamePauseStatus
061CB 60                        ExitPause:     rts
061CC                           
061CC                           ;-------------------------------------------------------------------------------------
061CC                           ;$00 - used for preset value
061CC                           
061CC                           SpriteShuffler:
061CC AC 4E 07                                 ldy AreaType                ;load level type, likely residual code
061CF A9 28                                    lda #$28                    ;load preset value which will put it at
061D1 85 00                                    sta $00                     ;sprite #10
061D3 A2 0E                                    ldx #$0e                    ;start at the end of OAM data offsets
061D5 BD E4 06                  ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
061D8 C5 00                                    cmp $00                     ;the preset value
061DA 90 0F                                    bcc NextSprOffset           ;if less, skip this part
061DC AC E0 06                                 ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
061DF 18                                       clc
061E0 79 E1 06                                 adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
061E3 90 03                                    bcc StrSprOffset            ;if not exceeded $ff, skip second add
061E5 18                                       clc
061E6 65 00                                    adc $00                     ;otherwise add preset value $28 to offset
061E8 9D E4 06                  StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
061EB CA                        NextSprOffset: dex                         ;move backwards to next one
061EC 10 E7                                    bpl ShuffleLoop
061EE AE E0 06                                 ldx SprShuffleAmtOffset     ;load offset
061F1 E8                                       inx
061F2 E0 03                                    cpx #$03                    ;check if offset + 1 goes to 3
061F4 D0 02                                    bne SetAmtOffset            ;if offset + 1 not 3, store
061F6 A2 00                                    ldx #$00                    ;otherwise, init to 0
061F8 8E E0 06                  SetAmtOffset:  stx SprShuffleAmtOffset
061FB A2 08                                    ldx #$08                    ;load offsets for values and storage
061FD A0 02                                    ldy #$02
061FF B9 E9 06                  SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
06202 9D F1 06                                 sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
06205 18                                       clc                         ;add eight to the second and eight
06206 69 08                                    adc #$08                    ;more to the third one
06208 9D F2 06                                 sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
0620B 18                                       clc                         ;this code loads into the misc sprite offsets
0620C 69 08                                    adc #$08
0620E 9D F3 06                                 sta Misc_SprDataOffset,x        
06211 CA                                       dex
06212 CA                                       dex
06213 CA                                       dex
06214 88                                       dey
06215 10 E8                                    bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
06217 60                                       rts
06218                           
06218                           ;-------------------------------------------------------------------------------------
06218                           
06218                           OperModeExecutionTree:
06218 AD 70 07                        lda OperMode     ;this is the heart of the entire program,
0621B 20 0A 6E                        jsr JumpEngine   ;most of what goes on starts here
0621E                           
0621E 37 62                           .dw TitleScreenMode
06220 E4 8E                           .dw GameMode
06222 91 63                           .dw VictoryMode
06224 22 72                           .dw GameOverMode
06226                           
06226                           ;-------------------------------------------------------------------------------------
06226                           
06226                           MoveAllSpritesOffscreen:
06226 A0 00                                   ldy #$00                ;this routine moves all sprites off the screen
06228 2C                                      .db $2c                 ;BIT instruction opcode
06229                           
06229                           MoveSpritesOffscreen:
06229 A0 04                                   ldy #$04                ;this routine moves all but sprite 0
0622B A9 F8                                   lda #$f8                ;off the screen
0622D 99 00 02                  SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
06230 C8                                      iny                     ;which will move it off the screen
06231 C8                                      iny
06232 C8                                      iny
06233 C8                                      iny
06234 D0 F7                                   bne SprInitLoop
06236 60                                      rts
06237                           
06237                           ;-------------------------------------------------------------------------------------
06237                           
06237                           TitleScreenMode:
06237 AD 72 07                        lda OperMode_Task
0623A 20 0A 6E                        jsr JumpEngine
0623D                           
0623D D5 6F                           .dw InitializeGame
0623F 6D 65                           .dw ScreenRoutines
06241 67 70                           .dw PrimaryGameSetup
06243 4B 62                           .dw GameMenuRoutine
06245                           
06245                           ;-------------------------------------------------------------------------------------
06245                           
06245                           WSelectBufferTemplate:
06245 04 20 73 01 00 00               .db $04, $20, $73, $01, $00, $00
0624B                           
0624B                           GameMenuRoutine:
0624B A0 00                                   ldy #$00
0624D AD FC 06                                lda SavedJoypad1Bits        ;check to see if either player pressed
06250 0D FD 06                                ora SavedJoypad2Bits        ;only the start button (either joypad)
06253 C9 10                                   cmp #Start_Button
06255 F0 04                                   beq StartGame
06257 C9 90                                   cmp #A_Button+Start_Button  ;check to see if A + start was pressed
06259 D0 03                                   bne ChkSelect               ;if not, branch to check select button
0625B 4C DE 62                  StartGame:    jmp ChkContinue             ;if either start or A + start, execute here
0625E C9 20                     ChkSelect:    cmp #Select_Button          ;check to see if the select button was pressed
06260 F0 1A                                   beq SelectBLogic            ;if so, branch reset demo timer
06262 AE A2 07                                ldx DemoTimer               ;otherwise check demo timer
06265 D0 0B                                   bne ChkWorldSel             ;if demo timer not expired, branch to check world selection
06267 8D 80 07                                sta SelectTimer             ;set controller bits here if running demo
0626A 20 71 63                                jsr DemoEngine              ;run through the demo actions
0626D B0 60                                   bcs ResetTitle              ;if carry flag set, demo over, thus branch
0626F 4C C6 62                                jmp RunDemo                 ;otherwise, run game engine for demo
06272 AE FC 07                  ChkWorldSel:  ldx WorldSelectEnableFlag   ;check to see if world selection has been enabled
06275 F0 4A                                   beq NullJoypad
06277 C9 40                                   cmp #B_Button               ;if so, check to see if the B button was pressed
06279 D0 46                                   bne NullJoypad
0627B C8                                      iny                         ;if so, increment Y and execute same code as select
0627C AD A2 07                  SelectBLogic: lda DemoTimer               ;if select or B pressed, check demo timer one last time
0627F F0 4E                                   beq ResetTitle              ;if demo timer expired, branch to reset title screen mode
06281 A9 18                                   lda #$18                    ;otherwise reset demo timer
06283 8D A2 07                                sta DemoTimer
06286 AD 80 07                                lda SelectTimer             ;check select/B button timer
06289 D0 36                                   bne NullJoypad              ;if not expired, branch
0628B A9 10                                   lda #$10                    ;otherwise reset select button timer
0628D 8D 80 07                                sta SelectTimer
06290 C0 01                                   cpy #$01                    ;was the B button pressed earlier?  if so, branch
06292 F0 0E                                   beq IncWorldSel             ;note this will not be run if world selection is disabled
06294 AD 7A 07                                lda NumberOfPlayers         ;if no, must have been the select button, therefore
06297 49 01                                   eor #%00000001              ;change number of players and draw icon accordingly
06299 8D 7A 07                                sta NumberOfPlayers
0629C 20 2B 63                                jsr DrawMushroomIcon
0629F 4C C1 62                                jmp NullJoypad
062A2 AE 6B 07                  IncWorldSel:  ldx WorldSelectNumber       ;increment world select number
062A5 E8                                      inx
062A6 8A                                      txa
062A7 29 07                                   and #%00000111              ;mask out higher bits
062A9 8D 6B 07                                sta WorldSelectNumber       ;store as current world select number
062AC 20 14 63                                jsr GoContinue
062AF BD 45 62                  UpdateShroom: lda WSelectBufferTemplate,x ;write template for world select in vram buffer
062B2 9D 00 03                                sta VRAM_Buffer1-1,x        ;do this until all bytes are written
062B5 E8                                      inx
062B6 E0 06                                   cpx #$06
062B8 30 F5                                   bmi UpdateShroom
062BA AC 5F 07                                ldy WorldNumber             ;get world number from variable and increment for
062BD C8                                      iny                         ;proper display, and put in blank byte before
062BE 8C 04 03                                sty VRAM_Buffer1+3          ;null terminator
062C1 A9 00                     NullJoypad:   lda #$00                    ;clear joypad bits for player 1
062C3 8D FC 06                                sta SavedJoypad1Bits
062C6 20 F2 8E                  RunDemo:      jsr GameCoreRoutine         ;run game engine
062C9 A5 0E                                   lda GameEngineSubroutine    ;check to see if we're running lose life routine
062CB C9 06                                   cmp #$06
062CD D0 44                                   bne ExitMenu                ;if not, do not do all the resetting below
062CF A9 00                     ResetTitle:   lda #$00                    ;reset game modes, disable
062D1 8D 70 07                                sta OperMode                ;sprite 0 check and disable
062D4 8D 72 07                                sta OperMode_Task           ;screen output
062D7 8D 22 07                                sta Sprite0HitDetectFlag
062DA EE 74 07                                inc DisableScreenFlag
062DD 60                                      rts
062DE AC A2 07                  ChkContinue:  ldy DemoTimer               ;if timer for demo has expired, reset modes
062E1 F0 EC                                   beq ResetTitle
062E3 0A                                      asl                         ;check to see if A button was also pushed
062E4 90 06                                   bcc StartWorld1             ;if not, don't load continue function's world number
062E6 AD FD 07                                lda ContinueWorld           ;load previously saved world number for secret
062E9 20 14 63                                jsr GoContinue              ;continue function when pressing A + start
062EC 20 0B 7C                  StartWorld1:  jsr LoadAreaPointer
062EF EE 5D 07                                inc Hidden1UpFlag           ;set 1-up box flag for both players
062F2 EE 64 07                                inc OffScr_Hidden1UpFlag
062F5 EE 57 07                                inc FetchNewGameTimerFlag   ;set fetch new game timer flag
062F8 EE 70 07                                inc OperMode                ;set next game mode
062FB AD FC 07                                lda WorldSelectEnableFlag   ;if world select flag is on, then primary
062FE 8D 6A 07                                sta PrimaryHardMode         ;hard mode must be on as well
06301 A9 00                                   lda #$00
06303 8D 72 07                                sta OperMode_Task           ;set game mode here, and clear demo timer
06306 8D A2 07                                sta DemoTimer
06309 A2 17                                   ldx #$17
0630B A9 00                                   lda #$00
0630D 9D DD 07                  InitScores:   sta ScoreAndCoinDisplay,x   ;clear player scores and coin displays
06310 CA                                      dex
06311 10 FA                                   bpl InitScores
06313 60                        ExitMenu:     rts
06314 8D 5F 07                  GoContinue:   sta WorldNumber             ;start both players at the first area
06317 8D 66 07                                sta OffScr_WorldNumber      ;of the previously saved world number
0631A A2 00                                   ldx #$00                    ;note that on power-up using this function
0631C 8E 60 07                                stx AreaNumber              ;will make no difference
0631F 8E 67 07                                stx OffScr_AreaNumber   
06322 60                                      rts
06323                           
06323                           ;-------------------------------------------------------------------------------------
06323                           
06323                           MushroomIconData:
06323 07 22 49 83 CE 24 24 00         .db $07, $22, $49, $83, $ce, $24, $24, $00
0632B                           
0632B                           DrawMushroomIcon:
0632B A0 07                                   ldy #$07                ;read eight bytes to be read by transfer routine
0632D B9 23 63                  IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
06330 99 00 03                                sta VRAM_Buffer1-1,y    ;1-player game
06333 88                                      dey
06334 10 F7                                   bpl IconDataRead
06336 AD 7A 07                                lda NumberOfPlayers     ;check number of players
06339 F0 0A                                   beq ExitIcon            ;if set to 1-player game, we're done
0633B A9 24                                   lda #$24                ;otherwise, load blank tile in 1-player position
0633D 8D 04 03                                sta VRAM_Buffer1+3
06340 A9 CE                                   lda #$ce                ;then load shroom icon tile in 2-player position
06342 8D 06 03                                sta VRAM_Buffer1+5
06345 60                        ExitIcon:     rts
06346                           
06346                           ;-------------------------------------------------------------------------------------
06346                           
06346                           DemoActionData:
06346 01 80 02 81 41 80 01            .db $01, $80, $02, $81, $41, $80, $01
0634D 42 C2 02 80 41 C1 41 C1         .db $42, $c2, $02, $80, $41, $c1, $41, $c1
06355 01 C1 01 02 80 00               .db $01, $c1, $01, $02, $80, $00
0635B                           
0635B                           DemoTimingData:
0635B 9B 10 18 05 2C 20 24            .db $9b, $10, $18, $05, $2c, $20, $24
06362 15 5A 10 20 28 30 20 10         .db $15, $5a, $10, $20, $28, $30, $20, $10
0636A 80 20 30 30 01 FF 00            .db $80, $20, $30, $30, $01, $ff, $00
06371                           
06371                           DemoEngine:
06371 AE 17 07                            ldx DemoAction         ;load current demo action
06374 AD 18 07                            lda DemoActionTimer    ;load current action timer
06377 D0 0D                               bne DoAction           ;if timer still counting down, skip
06379 E8                                  inx
0637A EE 17 07                            inc DemoAction         ;if expired, increment action, X, and
0637D 38                                  sec                    ;set carry by default for demo over
0637E BD 5A 63                            lda DemoTimingData-1,x ;get next timer
06381 8D 18 07                            sta DemoActionTimer    ;store as current timer
06384 F0 0A                               beq DemoOver           ;if timer already at zero, skip
06386 BD 45 63                  DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
06389 8D FC 06                            sta SavedJoypad1Bits
0638C CE 18 07                            dec DemoActionTimer    ;decrement action timer
0638F 18                                  clc                    ;clear carry if demo still going
06390 60                        DemoOver: rts
06391                           
06391                           ;-------------------------------------------------------------------------------------
06391                           
06391                           VictoryMode:
06391 20 A6 63                              jsr VictoryModeSubroutines  ;run victory mode subroutines
06394 AD 72 07                              lda OperMode_Task           ;get current task of victory mode
06397 F0 07                                 beq AutoPlayer              ;if on bridge collapse, skip enemy processing
06399 A2 00                                 ldx #$00
0639B 86 08                                 stx ObjectOffset            ;otherwise reset enemy object offset 
0639D 20 4F A0                              jsr EnemiesAndLoopsCore     ;and run enemy code
063A0 20 2E D1                  AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
063A3 4C ED CE                              jmp PlayerGfxHandler        ;draw the player, then leave
063A6                           
063A6                           VictoryModeSubroutines:
063A6 AD 72 07                        lda OperMode_Task
063A9 20 0A 6E                        jsr JumpEngine
063AC                           
063AC F4 AF                           .dw BridgeCollapse
063AE B6 63                           .dw SetupVictoryMode
063B0 C3 63                           .dw PlayerVictoryWalk
063B2 FC 63                           .dw PrintVictoryMessages
063B4 67 64                           .dw PlayerEndWorld
063B6                           
063B6                           ;-------------------------------------------------------------------------------------
063B6                           
063B6                           SetupVictoryMode:
063B6 AE 1B 07                        ldx ScreenRight_PageLoc  ;get page location of right side of screen
063B9 E8                              inx                      ;increment to next page
063BA 86 34                           stx DestinationPageLoc   ;store here
063BC A9 08                           lda #EndOfCastleMusic
063BE 85 FC                           sta EventMusicQueue      ;play win castle music
063C0 4C 54 67                        jmp IncModeTask_B        ;jump to set next major task in victory mode
063C3                           
063C3                           ;-------------------------------------------------------------------------------------
063C3                           
063C3                           PlayerVictoryWalk:
063C3 A0 00                                  ldy #$00                ;set value here to not walk player by default
063C5 84 35                                  sty VictoryWalkControl
063C7 A5 6D                                  lda Player_PageLoc      ;get player's page location
063C9 C5 34                                  cmp DestinationPageLoc  ;compare with destination page location
063CB D0 06                                  bne PerformWalk         ;if page locations don't match, branch
063CD A5 86                                  lda Player_X_Position   ;otherwise get player's horizontal position
063CF C9 60                                  cmp #$60                ;compare with preset horizontal position
063D1 B0 03                                  bcs DontWalk            ;if still on other page, branch ahead
063D3 E6 35                     PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
063D5 C8                                     iny                     ;note Y will be used to walk the player
063D6 98                        DontWalk:    tya                     ;put contents of Y in A and
063D7 20 EE 90                               jsr AutoControlPlayer   ;use A to move player to the right or not
063DA AD 1A 07                               lda ScreenLeft_PageLoc  ;check page location of left side of screen
063DD C5 34                                  cmp DestinationPageLoc  ;against set value here
063DF F0 16                                  beq ExitVWalk           ;branch if equal to change modes if necessary
063E1 AD 68 07                               lda ScrollFractional
063E4 18                                     clc                     ;do fixed point math on fractional part of scroll
063E5 69 80                                  adc #$80        
063E7 8D 68 07                               sta ScrollFractional    ;save fractional movement amount
063EA A9 01                                  lda #$01                ;set 1 pixel per frame
063EC 69 00                                  adc #$00                ;add carry from previous addition
063EE A8                                     tay                     ;use as scroll amount
063EF 20 CC 8F                               jsr ScrollScreen        ;do sub to scroll the screen
063F2 20 77 8F                               jsr UpdScrollVar        ;do another sub to update screen and scroll variables
063F5 E6 35                                  inc VictoryWalkControl  ;increment value to stay in this routine
063F7 A5 35                     ExitVWalk:   lda VictoryWalkControl  ;load value set here
063F9 F0 68                                  beq IncModeTask_A       ;if zero, branch to change modes
063FB 60                                     rts                     ;otherwise leave
063FC                           
063FC                           ;-------------------------------------------------------------------------------------
063FC                           
063FC                           PrintVictoryMessages:
063FC AD 49 07                                 lda SecondaryMsgCounter   ;load secondary message counter
063FF D0 48                                    bne IncMsgCounter         ;if set, branch to increment message counters
06401 AD 19 07                                 lda PrimaryMsgCounter     ;otherwise load primary message counter
06404 F0 18                                    beq ThankPlayer           ;if set to zero, branch to print first message
06406 C9 09                                    cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
06408 B0 3F                                    bcs IncMsgCounter         ;is residual code, counter never reaches 9)
0640A AC 5F 07                                 ldy WorldNumber           ;check world number
0640D C0 07                                    cpy #World8
0640F D0 09                                    bne MRetainerMsg          ;if not at world 8, skip to next part
06411 C9 03                                    cmp #$03                  ;check primary message counter again
06413 90 34                                    bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
06415 E9 01                                    sbc #$01                  ;otherwise subtract one
06417 4C 1E 64                                 jmp ThankPlayer           ;and skip to next part
0641A C9 02                     MRetainerMsg:  cmp #$02                  ;check primary message counter
0641C 90 2B                                    bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
0641E A8                        ThankPlayer:   tay                       ;put primary message counter into Y
0641F D0 08                                    bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
06421 AD 53 07                                 lda CurrentPlayer         ;otherwise get player currently on the screen
06424 F0 14                                    beq EvalForMusic          ;if mario, branch
06426 C8                                       iny                       ;otherwise increment Y once for luigi and
06427 D0 11                                    bne EvalForMusic          ;do an unconditional branch to the same place
06429 C8                        SecondPartMsg: iny                       ;increment Y to do world 8's message
0642A AD 5F 07                                 lda WorldNumber
0642D C9 07                                    cmp #World8               ;check world number
0642F F0 09                                    beq EvalForMusic          ;if at world 8, branch to next part
06431 88                                       dey                       ;otherwise decrement Y for world 1-7's message
06432 C0 04                                    cpy #$04                  ;if counter at 4 (world 1-7 only)
06434 B0 26                                    bcs SetEndTimer           ;branch to set victory end timer
06436 C0 03                                    cpy #$03                  ;if counter at 3 (world 1-7 only)
06438 B0 0F                                    bcs IncMsgCounter         ;branch to keep counting
0643A C0 03                     EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
0643C D0 04                                    bne PrintMsg              ;to print message only (note world 1-7 will only
0643E A9 04                                    lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
06440 85 FC                                    sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
06442 98                        PrintMsg:      tya                       ;put primary message counter in A
06443 18                                       clc                       ;add $0c or 12 to counter thus giving an appropriate value,
06444 69 0C                                    adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
06446 8D 73 07                                 sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
06449 AD 49 07                  IncMsgCounter: lda SecondaryMsgCounter
0644C 18                                       clc
0644D 69 04                                    adc #$04                      ;add four to secondary message counter
0644F 8D 49 07                                 sta SecondaryMsgCounter
06452 AD 19 07                                 lda PrimaryMsgCounter
06455 69 00                                    adc #$00                      ;add carry to primary message counter
06457 8D 19 07                                 sta PrimaryMsgCounter
0645A C9 07                                    cmp #$07                      ;check primary counter one more time
0645C 90 08                     SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
0645E A9 06                                    lda #$06
06460 8D A1 07                                 sta WorldEndTimer             ;otherwise set world end timer
06463 EE 72 07                  IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
06466 60                        ExitMsgs:      rts                           ;leave
06467                           
06467                           ;-------------------------------------------------------------------------------------
06467                           
06467                           PlayerEndWorld:
06467 AD A1 07                                 lda WorldEndTimer          ;check to see if world end timer expired
0646A D0 20                                    bne EndExitOne             ;branch to leave if not
0646C AC 5F 07                                 ldy WorldNumber            ;check world number
0646F C0 07                                    cpy #World8                ;if on world 8, player is done with game, 
06471 B0 1A                                    bcs EndChkBButton          ;thus branch to read controller
06473 A9 00                                    lda #$00
06475 8D 60 07                                 sta AreaNumber             ;otherwise initialize area number used as offset
06478 8D 5C 07                                 sta LevelNumber            ;and level number control to start at area 1
0647B 8D 72 07                                 sta OperMode_Task          ;initialize secondary mode of operation
0647E EE 5F 07                                 inc WorldNumber            ;increment world number to move onto the next world
06481 20 0B 7C                                 jsr LoadAreaPointer        ;get area address offset for the next area
06484 EE 57 07                                 inc FetchNewGameTimerFlag  ;set flag to load game timer from header
06487 A9 01                                    lda #GameModeValue
06489 8D 70 07                                 sta OperMode               ;set mode of operation to game mode
0648C 60                        EndExitOne:    rts                        ;and leave
0648D AD FC 06                  EndChkBButton: lda SavedJoypad1Bits
06490 0D FD 06                                 ora SavedJoypad2Bits       ;check to see if B button was pressed on
06493 29 40                                    and #B_Button              ;either controller
06495 F0 0D                                    beq EndExitTwo             ;branch to leave if not
06497 A9 01                                    lda #$01                   ;otherwise set world selection flag
06499 8D FC 07                                 sta WorldSelectEnableFlag
0649C A9 FF                                    lda #$ff                   ;remove onscreen player's lives
0649E 8D 5A 07                                 sta NumberofLives
064A1 20 52 72                                 jsr TerminateGame          ;do sub to continue other player or end game
064A4 60                        EndExitTwo:    rts                        ;leave
064A5                           
064A5                           ;-------------------------------------------------------------------------------------
064A5                           
064A5                           ;data is used as tiles for numbers
064A5                           ;that appear when you defeat enemies
064A5                           FloateyNumTileData:
064A5 FF FF                           .db $ff, $ff ;dummy
064A7 F6 FB                           .db $f6, $fb ; "100"
064A9 F7 FB                           .db $f7, $fb ; "200"
064AB F8 FB                           .db $f8, $fb ; "400"
064AD F9 FB                           .db $f9, $fb ; "500"
064AF FA FB                           .db $fa, $fb ; "800"
064B1 F6 50                           .db $f6, $50 ; "1000"
064B3 F7 50                           .db $f7, $50 ; "2000"
064B5 F8 50                           .db $f8, $50 ; "4000"
064B7 F9 50                           .db $f9, $50 ; "5000"
064B9 FA 50                           .db $fa, $50 ; "8000"
064BB FD FE                           .db $fd, $fe ; "1-UP"
064BD                           
064BD                           ;high nybble is digit number, low nybble is number to
064BD                           ;add to the digit of the player's score
064BD                           ScoreUpdateData:
064BD FF                              .db $ff ;dummy
064BE 41 42 44 45 48                  .db $41, $42, $44, $45, $48
064C3 31 32 34 35 38 00               .db $31, $32, $34, $35, $38, $00
064C9                           
064C9                           FloateyNumbersRoutine:
064C9 BD 10 01                                lda FloateyNum_Control,x     ;load control for floatey number
064CC F0 BE                                   beq EndExitOne               ;if zero, branch to leave
064CE C9 0B                                   cmp #$0b                     ;if less than $0b, branch
064D0 90 05                                   bcc ChkNumTimer
064D2 A9 0B                                   lda #$0b                     ;otherwise set to $0b, thus keeping
064D4 9D 10 01                                sta FloateyNum_Control,x     ;it in range
064D7 A8                        ChkNumTimer:  tay                          ;use as Y
064D8 BD 2C 01                                lda FloateyNum_Timer,x       ;check value here
064DB D0 04                                   bne DecNumTimer              ;if nonzero, branch ahead
064DD 9D 10 01                                sta FloateyNum_Control,x     ;initialize floatey number control and leave
064E0 60                                      rts
064E1 DE 2C 01                  DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
064E4 C9 2B                                   cmp #$2b                     ;if not reached a certain point, branch  
064E6 D0 1E                                   bne ChkTallEnemy
064E8 C0 0B                                   cpy #$0b                     ;check offset for $0b
064EA D0 07                                   bne LoadNumTiles             ;branch ahead if not found
064EC EE 5A 07                                inc NumberofLives            ;give player one extra life (1-up)
064EF A9 40                                   lda #Sfx_ExtraLife
064F1 85 FE                                   sta Square2SoundQueue        ;and play the 1-up sound
064F3 B9 BD 64                  LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
064F6 4A                                      lsr                          ;move high nybble to low
064F7 4A                                      lsr
064F8 4A                                      lsr
064F9 4A                                      lsr
064FA AA                                      tax                          ;use as X offset, essentially the digit
064FB B9 BD 64                                lda ScoreUpdateData,y        ;load again and this time
064FE 29 0F                                   and #%00001111               ;mask out the high nybble
06500 9D 34 01                                sta DigitModifier,x          ;store as amount to add to the digit
06503 20 2F 9C                                jsr AddToScore               ;update the score accordingly
06506 BC E5 06                  ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
06509 B5 16                                   lda Enemy_ID,x               ;get enemy object identifier
0650B C9 12                                   cmp #Spiny
0650D F0 22                                   beq FloateyPart              ;branch if spiny
0650F C9 0D                                   cmp #PiranhaPlant
06511 F0 1E                                   beq FloateyPart              ;branch if piranha plant
06513 C9 05                                   cmp #HammerBro
06515 F0 12                                   beq GetAltOffset             ;branch elsewhere if hammer bro
06517 C9 0A                                   cmp #GreyCheepCheep
06519 F0 16                                   beq FloateyPart              ;branch if cheep-cheep of either color
0651B C9 0B                                   cmp #RedCheepCheep
0651D F0 12                                   beq FloateyPart
0651F C9 09                                   cmp #TallEnemy
06521 B0 06                                   bcs GetAltOffset             ;branch elsewhere if enemy object => $09
06523 B5 1E                                   lda Enemy_State,x
06525 C9 02                                   cmp #$02                     ;if enemy state defeated or otherwise
06527 B0 08                                   bcs FloateyPart              ;$02 or greater, branch beyond this part
06529 AE EE 03                  GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
0652C BC EC 06                                ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
0652F A6 08                                   ldx ObjectOffset             ;get enemy object offset again
06531 BD 1E 01                  FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
06534 C9 18                                   cmp #$18                     ;floatey number, if coordinate in the
06536 90 05                                   bcc SetupNumSpr              ;status bar, branch
06538 E9 01                                   sbc #$01
0653A 9D 1E 01                                sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
0653D BD 1E 01                  SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
06540 E9 08                                   sbc #$08                     ;subtract eight and dump into the
06542 20 C5 C5                                jsr DumpTwoSpr               ;left and right sprite's Y coordinates
06545 BD 17 01                                lda FloateyNum_X_Pos,x       ;get horizontal coordinate
06548 99 03 02                                sta Sprite_X_Position,y      ;store into X coordinate of left sprite
0654B 18                                      clc
0654C 69 08                                   adc #$08                     ;add eight pixels and store into X
0654E 99 07 02                                sta Sprite_X_Position+4,y    ;coordinate of right sprite
06551 A9 02                                   lda #$02
06553 99 02 02                                sta Sprite_Attributes,y      ;set palette control in attribute bytes
06556 99 06 02                                sta Sprite_Attributes+4,y    ;of left and right sprites
06559 BD 10 01                                lda FloateyNum_Control,x
0655C 0A                                      asl                          ;multiply our floatey number control by 2
0655D AA                                      tax                          ;and use as offset for look-up table
0655E BD A5 64                                lda FloateyNumTileData,x
06561 99 01 02                                sta Sprite_Tilenumber,y      ;display first half of number of points
06564 BD A6 64                                lda FloateyNumTileData+1,x
06567 99 05 02                                sta Sprite_Tilenumber+4,y    ;display the second half
0656A A6 08                                   ldx ObjectOffset             ;get enemy object offset and leave
0656C 60                                      rts
0656D                           
0656D                           ;-------------------------------------------------------------------------------------
0656D                           
0656D                           ScreenRoutines:
0656D AD 3C 07                        lda ScreenRoutineTask        ;run one of the following subroutines
06570 20 0A 6E                        jsr JumpEngine
06573                               
06573 91 65                           .dw InitScreen
06575 A1 65                           .dw SetupIntermediate
06577 58 66                           .dw WriteTopStatusLine
06579 60 66                           .dw WriteBottomStatusLine
0657B 99 66                           .dw DisplayTimeUp
0657D A3 68                           .dw ResetSpritesAndScreenTimer
0657F AE 66                           .dw DisplayIntermediate
06581 A3 68                           .dw ResetSpritesAndScreenTimer
06583 EC 66                           .dw AreaParserTaskControl
06585 C5 65                           .dw GetAreaPalette
06587 E9 65                           .dw GetBackgroundColor
06589 49 66                           .dw GetAlternatePalette1
0658B 05 67                           .dw DrawTitleScreen
0658D 38 67                           .dw ClearBuffersDrawIcon
0658F 4F 67                           .dw WriteTopScore
06591                           
06591                           ;-------------------------------------------------------------------------------------
06591                           
06591                           InitScreen:
06591 20 26 62                        jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
06594 20 1F 6E                        jsr InitializeNameTables    ;and erase both name and attribute tables
06597 AD 70 07                        lda OperMode
0659A F0 32                           beq NextSubtask             ;if mode still 0, do not load
0659C A2 03                           ldx #$03                    ;into buffer pointer
0659E 4C CB 65                        jmp SetVRAMAddr_A
065A1                           
065A1                           ;-------------------------------------------------------------------------------------
065A1                           
065A1                           SetupIntermediate:
065A1 AD 44 07                        lda BackgroundColorCtrl  ;save current background color control
065A4 48                              pha                      ;and player status to stack
065A5 AD 56 07                        lda PlayerStatus
065A8 48                              pha
065A9 A9 00                           lda #$00                 ;set background color to black
065AB 8D 56 07                        sta PlayerStatus         ;and player status to not fiery
065AE A9 02                           lda #$02                 ;this is the ONLY time background color control
065B0 8D 44 07                        sta BackgroundColorCtrl  ;is set to less than 4
065B3 20 F7 65                        jsr GetPlayerColors
065B6 68                              pla                      ;we only execute this routine for
065B7 8D 56 07                        sta PlayerStatus         ;the intermediate lives display
065BA 68                              pla                      ;and once we're done, we return bg
065BB 8D 44 07                        sta BackgroundColorCtrl  ;color ctrl and player status from stack
065BE 4C 4B 67                        jmp IncSubtask           ;then move onto the next task
065C1                           
065C1                           ;-------------------------------------------------------------------------------------
065C1                           
065C1                           AreaPalette:
065C1 01 02 03 04                     .db $01, $02, $03, $04
065C5                           
065C5                           GetAreaPalette:
065C5 AC 4E 07                                 ldy AreaType             ;select appropriate palette to load
065C8 BE C1 65                                 ldx AreaPalette,y        ;based on area type
065CB 8E 73 07                  SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
065CE 4C 4B 67                  NextSubtask:   jmp IncSubtask           ;move onto next task
065D1                           
065D1                           ;-------------------------------------------------------------------------------------
065D1                           ;$00 - used as temp counter in GetPlayerColors
065D1                           
065D1                           BGColorCtrl_Addr:
065D1 00 09 0A 04                     .db $00, $09, $0a, $04
065D5                           
065D5                           BackgroundColors:
065D5 22 22 0F 0F                     .db $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
065D9 0F 22 0F 0F                     .db $0f, $22, $0f, $0f ;used by background color control if set
065DD                           
065DD                           PlayerColors:
065DD 22 16 27 18                     .db $22, $16, $27, $18 ;mario's colors
065E1 22 30 27 19                     .db $22, $30, $27, $19 ;luigi's colors
065E5 22 37 27 16                     .db $22, $37, $27, $16 ;fiery (used by both)
065E9                           
065E9                           GetBackgroundColor:
065E9 AC 44 07                             ldy BackgroundColorCtrl   ;check background color control
065EC F0 06                                beq NoBGColor             ;if not set, increment task and fetch palette
065EE B9 CD 65                             lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
065F1 8D 73 07                             sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
065F4 EE 3C 07                  NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
065F7                                 
065F7                           GetPlayerColors:
065F7 AE 00 03                                 ldx VRAM_Buffer1_Offset  ;get current buffer offset
065FA A0 00                                    ldy #$00
065FC AD 53 07                                 lda CurrentPlayer        ;check which player is on the screen
065FF F0 02                                    beq ChkFiery
06601 A0 04                                    ldy #$04                 ;load offset for luigi
06603 AD 56 07                  ChkFiery:      lda PlayerStatus         ;check player status
06606 C9 02                                    cmp #$02
06608 D0 02                                    bne StartClrGet          ;if fiery, load alternate offset for fiery player
0660A A0 08                                    ldy #$08
0660C A9 03                     StartClrGet:   lda #$03                 ;do four colors
0660E 85 00                                    sta $00
06610 B9 DD 65                  ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
06613 9D 04 03                                 sta VRAM_Buffer1+3,x     ;in the buffer
06616 C8                                       iny
06617 E8                                       inx
06618 C6 00                                    dec $00
0661A 10 F4                                    bpl ClrGetLoop
0661C AE 00 03                                 ldx VRAM_Buffer1_Offset  ;load original offset from before
0661F AC 44 07                                 ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
06622 D0 03                                    bne SetBGColor           ;therefore use it as offset to background color
06624 AC 4E 07                                 ldy AreaType             ;otherwise use area type bits from area offset as offset
06627 B9 D5 65                  SetBGColor:    lda BackgroundColors,y   ;to background color instead
0662A 9D 04 03                                 sta VRAM_Buffer1+3,x
0662D A9 3F                                    lda #$3f                 ;set for sprite palette address
0662F 9D 01 03                                 sta VRAM_Buffer1,x       ;save to buffer
06632 A9 10                                    lda #$10
06634 9D 02 03                                 sta VRAM_Buffer1+1,x
06637 A9 04                                    lda #$04                 ;write length byte to buffer
06639 9D 03 03                                 sta VRAM_Buffer1+2,x
0663C A9 00                                    lda #$00                 ;now the null terminator
0663E 9D 08 03                                 sta VRAM_Buffer1+7,x
06641 8A                                       txa                      ;move the buffer pointer ahead 7 bytes
06642 18                                       clc                      ;in case we want to write anything else later
06643 69 07                                    adc #$07
06645 8D 00 03                  SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
06648 60                                       rts
06649                           
06649                           ;-------------------------------------------------------------------------------------
06649                           
06649                           GetAlternatePalette1:
06649 AD 33 07                                 lda AreaStyle            ;check for mushroom level style
0664C C9 01                                    cmp #$01
0664E D0 05                                    bne NoAltPal
06650 A9 0B                                    lda #$0b                 ;if found, load appropriate palette
06652 8D 73 07                  SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
06655 4C 4B 67                  NoAltPal:      jmp IncSubtask           ;now onto the next task
06658                           
06658                           ;-------------------------------------------------------------------------------------
06658                           
06658                           WriteTopStatusLine:
06658 A9 00                           lda #$00          ;select main status bar
0665A 20 0E 68                        jsr WriteGameText ;output it
0665D 4C 4B 67                        jmp IncSubtask    ;onto the next task
06660                           
06660                           ;-------------------------------------------------------------------------------------
06660                           
06660                           WriteBottomStatusLine:
06660 20 38 9C                        jsr GetSBNybbles        ;write player's score and coin tally to screen
06663 AE 00 03                        ldx VRAM_Buffer1_Offset
06666 A9 20                           lda #$20                ;write address for world-area number on screen
06668 9D 01 03                        sta VRAM_Buffer1,x
0666B A9 73                           lda #$73
0666D 9D 02 03                        sta VRAM_Buffer1+1,x
06670 A9 03                           lda #$03                ;write length for it
06672 9D 03 03                        sta VRAM_Buffer1+2,x
06675 AC 5F 07                        ldy WorldNumber         ;first the world number
06678 C8                              iny
06679 98                              tya
0667A 9D 04 03                        sta VRAM_Buffer1+3,x
0667D A9 28                           lda #$28                ;next the dash
0667F 9D 05 03                        sta VRAM_Buffer1+4,x
06682 AC 5C 07                        ldy LevelNumber         ;next the level number
06685 C8                              iny                     ;increment for proper number display
06686 98                              tya
06687 9D 06 03                        sta VRAM_Buffer1+5,x    
0668A A9 00                           lda #$00                ;put null terminator on
0668C 9D 07 03                        sta VRAM_Buffer1+6,x
0668F 8A                              txa                     ;move the buffer offset up by 6 bytes
06690 18                              clc
06691 69 06                           adc #$06
06693 8D 00 03                        sta VRAM_Buffer1_Offset
06696 4C 4B 67                        jmp IncSubtask
06699                           
06699                           ;-------------------------------------------------------------------------------------
06699                           
06699                           DisplayTimeUp:
06699 AD 59 07                            lda GameTimerExpiredFlag  ;if game timer not expired, increment task
0669C F0 0A                               beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
0669E A9 00                               lda #$00
066A0 8D 59 07                            sta GameTimerExpiredFlag  ;reset timer expiration flag
066A3 A9 02                               lda #$02                  ;output time-up screen to buffer
066A5 4C CD 66                            jmp OutputInter
066A8 EE 3C 07                  NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
066AB 4C 4B 67                            jmp IncSubtask
066AE                           
066AE                           ;-------------------------------------------------------------------------------------
066AE                           
066AE                           DisplayIntermediate:
066AE AD 70 07                                 lda OperMode                 ;check primary mode of operation
066B1 F0 33                                    beq NoInter                  ;if in title screen mode, skip this
066B3 C9 03                                    cmp #GameOverModeValue       ;are we in game over mode?
066B5 F0 22                                    beq GameOverInter            ;if so, proceed to display game over screen
066B7 AD 52 07                                 lda AltEntranceControl       ;otherwise check for mode of alternate entry
066BA D0 2A                                    bne NoInter                  ;and branch if found
066BC AC 4E 07                                 ldy AreaType                 ;check if we are on castle level
066BF C0 03                                    cpy #$03                     ;and if so, branch (possibly residual)
066C1 F0 05                                    beq PlayerInter
066C3 AD 69 07                                 lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
066C6 D0 1E                                    bne NoInter                  ;and jump to specific task, otherwise
066C8 20 A8 CF                  PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
066CB A9 01                                    lda #$01                     ;lives display, then output lives display to buffer
066CD 20 0E 68                  OutputInter:   jsr WriteGameText
066D0 20 AB 68                                 jsr ResetScreenTimer
066D3 A9 00                                    lda #$00
066D5 8D 74 07                                 sta DisableScreenFlag        ;reenable screen output
066D8 60                                       rts
066D9 A9 12                     GameOverInter: lda #$12                     ;set screen timer
066DB 8D A0 07                                 sta ScreenTimer
066DE A9 03                                    lda #$03                     ;output game over screen to buffer
066E0 20 0E 68                                 jsr WriteGameText
066E3 4C 54 67                                 jmp IncModeTask_B
066E6 A9 08                     NoInter:       lda #$08                     ;set for specific task and leave
066E8 8D 3C 07                                 sta ScreenRoutineTask
066EB 60                                       rts
066EC                           
066EC                           ;-------------------------------------------------------------------------------------
066EC                           
066EC                           AreaParserTaskControl:
066EC EE 74 07                             inc DisableScreenFlag     ;turn off screen
066EF 20 BA 72                  TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
066F2 AD 1F 07                             lda AreaParserTaskNum     ;check number of tasks
066F5 D0 F8                                bne TaskLoop              ;if tasks still not all done, do another one
066F7 CE 1E 07                             dec ColumnSets            ;do we need to render more column sets?
066FA 10 03                                bpl OutputCol
066FC EE 3C 07                             inc ScreenRoutineTask     ;if not, move on to the next task
066FF A9 06                     OutputCol: lda #$06                  ;set vram buffer to output rendered column set
06701 8D 73 07                             sta VRAM_Buffer_AddrCtrl  ;on next NMI
06704 60                                   rts
06705                           
06705                           ;-------------------------------------------------------------------------------------
06705                           
06705                           ;$00 - vram buffer address table low
06705                           ;$01 - vram buffer address table high
06705                           
06705                           DrawTitleScreen:
06705 AD 70 07                              lda OperMode                 ;are we in title screen mode?
06708 D0 4A                                 bne IncModeTask_B            ;if not, exit
0670A A9 1E                                 lda #>TitleScreenDataOffset  ;load address $1ec0 into
0670C 8D 06 20                              sta PPU_ADDRESS              ;the vram address register
0670F A9 C0                                 lda #<TitleScreenDataOffset
06711 8D 06 20                              sta PPU_ADDRESS
06714 A9 03                                 lda #$03                     ;put address $0300 into
06716 85 01                                 sta $01                      ;the indirect at $00
06718 A0 00                                 ldy #$00
0671A 84 00                                 sty $00
0671C AD 07 20                              lda PPU_DATA                 ;do one garbage read
0671F AD 07 20                  OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
06722 91 00                                 sta ($00),y                  ;store 256 bytes into buffer
06724 C8                                    iny
06725 D0 02                                 bne ChkHiByte                ;if not past 256 bytes, do not increment
06727 E6 01                                 inc $01                      ;otherwise increment high byte of indirect
06729 A5 01                     ChkHiByte:  lda $01                      ;check high byte?
0672B C9 04                                 cmp #$04                     ;at $0400?
0672D D0 F0                                 bne OutputTScr               ;if not, loop back and do another
0672F C0 3A                                 cpy #$3a                     ;check if offset points past end of data
06731 90 EC                                 bcc OutputTScr               ;if not, loop back and do another
06733 A9 05                                 lda #$05                     ;set buffer transfer control to $0300,
06735 4C 52 66                              jmp SetVRAMAddr_B            ;increment task and exit
06738                           
06738                           ;-------------------------------------------------------------------------------------
06738                           
06738                           ClearBuffersDrawIcon:
06738 AD 70 07                               lda OperMode               ;check game mode
0673B D0 17                                  bne IncModeTask_B          ;if not title screen mode, leave
0673D A2 00                                  ldx #$00                   ;otherwise, clear buffer space
0673F 9D 00 03                  TScrClear:   sta VRAM_Buffer1-1,x
06742 9D 00 04                               sta VRAM_Buffer1-1+$100,x
06745 CA                                     dex
06746 D0 F7                                  bne TScrClear
06748 20 2B 63                               jsr DrawMushroomIcon       ;draw player select icon
0674B EE 3C 07                  IncSubtask:  inc ScreenRoutineTask      ;move onto next task
0674E 60                                     rts
0674F                           
0674F                           ;-------------------------------------------------------------------------------------
0674F                           
0674F                           WriteTopScore:
0674F A9 FA                                    lda #$fa           ;run display routine to display top score on title
06751 20 3E 9C                                 jsr UpdateNumber
06754 EE 72 07                  IncModeTask_B: inc OperMode_Task  ;move onto next mode
06757 60                                       rts
06758                           
06758                           ;-------------------------------------------------------------------------------------
06758                           
06758                           GameText:
06758                           TopStatusBarLine:
06758 20 43 05 16 0A 1B 12 18     .db $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
06760 20 52 0B 20 18 1B 15 0D     .db $20, $52, $0b, $20, $18, $1b, $15, $0d ; "WORLD  TIME"
06768 24 24 1D 12 16 0E           .db $24, $24, $1d, $12, $16, $0e
0676E 20 68 05 00 24 24 2E 29     .db $20, $68, $05, $00, $24, $24, $2e, $29 ; score trailing digit and coin display
06776 23 C0 7F AA                 .db $23, $c0, $7f, $aa ; attribute table data, clears name table 0 to palette 2
0677A 23 C2 01 EA                 .db $23, $c2, $01, $ea ; attribute table data, used for coin icon in status bar
0677E FF                          .db $ff ; end of data block
0677F                           
0677F                           WorldLivesDisplay:
0677F 21 CD 07 24 24              .db $21, $cd, $07, $24, $24 ; cross with spaces used on
06784 29 24 24 24 24              .db $29, $24, $24, $24, $24 ; lives display
06789 21 4B 09 20 18              .db $21, $4b, $09, $20, $18 ; "WORLD  - " used on lives display
0678E 1B 15 0D 24 24 28 24        .db $1b, $15, $0d, $24, $24, $28, $24
06795 22 0C 47 24                 .db $22, $0c, $47, $24 ; possibly used to clear time up
06799 23 DC 01 BA                 .db $23, $dc, $01, $ba ; attribute table data for crown if more than 9 lives
0679D FF                          .db $ff
0679E                           
0679E                           TwoPlayerTimeUp:
0679E 21 CD 05 16 0A 1B 12 18     .db $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
067A6                           OnePlayerTimeUp:
067A6 22 0C 07 1D 12 16 0E 24..   .db $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
067B0 FF                          .db $ff
067B1                           
067B1                           TwoPlayerGameOver:
067B1 21 CD 05 16 0A 1B 12 18     .db $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
067B9                           OnePlayerGameOver:
067B9 22 0B 09 10 0A 16 0E 24     .db $22, $0b, $09, $10, $0a, $16, $0e, $24 ; "GAME OVER"
067C1 18 1F 0E 1B                 .db $18, $1f, $0e, $1b
067C5 FF                          .db $ff
067C6                           
067C6                           WarpZoneWelcome:
067C6 25 84 15 20 0E 15 0C 18..   .db $25, $84, $15, $20, $0e, $15, $0c, $18, $16 ; "WELCOME TO WARP ZONE!"
067CF 0E 24 1D 18 24 20 0A 1B..   .db $0e, $24, $1d, $18, $24, $20, $0a, $1b, $19
067D8 24 23 18 17 0E 2B           .db $24, $23, $18, $17, $0e, $2b
067DE 26 25 01 24                 .db $26, $25, $01, $24         ; placeholder for left pipe
067E2 26 2D 01 24                 .db $26, $2d, $01, $24         ; placeholder for middle pipe
067E6 26 35 01 24                 .db $26, $35, $01, $24         ; placeholder for right pipe
067EA 27 D9 46 AA                 .db $27, $d9, $46, $aa         ; attribute data
067EE 27 E1 45 AA                 .db $27, $e1, $45, $aa
067F2 FF                          .db $ff
067F3                           
067F3                           LuigiName:
067F3 15 1E 12 10 12              .db $15, $1e, $12, $10, $12    ; "LUIGI", no address or length
067F8                           
067F8                           WarpZoneNumbers:
067F8 04 03 02 00                 .db $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
067FC 24 05 24 00                 .db $24, $05, $24, $00         ; zone, partly responsible for
06800 08 07 06 00                 .db $08, $07, $06, $00         ; the minus world
06804                           
06804                           GameTextOffsets:
06804 00 00                       .db TopStatusBarLine-GameText, TopStatusBarLine-GameText
06806 27 27                       .db WorldLivesDisplay-GameText, WorldLivesDisplay-GameText
06808 46 4E                       .db TwoPlayerTimeUp-GameText, OnePlayerTimeUp-GameText
0680A 59 61                       .db TwoPlayerGameOver-GameText, OnePlayerGameOver-GameText
0680C 6E 6E                       .db WarpZoneWelcome-GameText, WarpZoneWelcome-GameText
0680E                           
0680E                           WriteGameText:
0680E 48                                       pha                      ;save text number to stack
0680F 0A                                       asl
06810 A8                                       tay                      ;multiply by 2 and use as offset
06811 C0 04                                    cpy #$04                 ;if set to do top status bar or world/lives display,
06813 90 0C                                    bcc LdGameText           ;branch to use current offset as-is
06815 C0 08                                    cpy #$08                 ;if set to do time-up or game over,
06817 90 02                                    bcc Chk2Players          ;branch to check players
06819 A0 08                                    ldy #$08                 ;otherwise warp zone, therefore set offset
0681B AD 7A 07                  Chk2Players:   lda NumberOfPlayers      ;check for number of players
0681E D0 01                                    bne LdGameText           ;if there are two, use current offset to also print name
06820 C8                                       iny                      ;otherwise increment offset by one to not print name
06821 BE 04 68                  LdGameText:    ldx GameTextOffsets,y    ;get offset to message we want to print
06824 A0 00                                    ldy #$00
06826 BD 58 67                  GameTextLoop:  lda GameText,x           ;load message data
06829 C9 FF                                    cmp #$ff                 ;check for terminator
0682B F0 07                                    beq EndGameText          ;branch to end text if found
0682D 99 01 03                                 sta VRAM_Buffer1,y       ;otherwise write data to buffer
06830 E8                                       inx                      ;and increment increment
06831 C8                                       iny
06832 D0 F2                                    bne GameTextLoop         ;do this for 256 bytes if no terminator found
06834 A9 00                     EndGameText:   lda #$00                 ;put null terminator at end
06836 99 01 03                                 sta VRAM_Buffer1,y
06839 68                                       pla                      ;pull original text number from stack
0683A AA                                       tax
0683B C9 04                                    cmp #$04                 ;are we printing warp zone?
0683D B0 49                                    bcs PrintWarpZoneNumbers
0683F CA                                       dex                      ;are we printing the world/lives display?
06840 D0 23                                    bne CheckPlayerName      ;if not, branch to check player's name
06842 AD 5A 07                                 lda NumberofLives        ;otherwise, check number of lives
06845 18                                       clc                      ;and increment by one for display
06846 69 01                                    adc #$01
06848 C9 0A                                    cmp #10                  ;more than 9 lives?
0684A 90 07                                    bcc PutLives
0684C E9 0A                                    sbc #10                  ;if so, subtract 10 and put a crown tile
0684E A0 9F                                    ldy #$9f                 ;next to the difference...strange things happen if
06850 8C 08 03                                 sty VRAM_Buffer1+7       ;the number of lives exceeds 19
06853 8D 09 03                  PutLives:      sta VRAM_Buffer1+8
06856 AC 5F 07                                 ldy WorldNumber          ;write world and level numbers (incremented for display)
06859 C8                                       iny                      ;to the buffer in the spaces surrounding the dash
0685A 8C 14 03                                 sty VRAM_Buffer1+19
0685D AC 5C 07                                 ldy LevelNumber
06860 C8                                       iny
06861 8C 16 03                                 sty VRAM_Buffer1+21      ;we're done here
06864 60                                       rts
06865                           
06865                           CheckPlayerName:
06865 AD 7A 07                               lda NumberOfPlayers    ;check number of players
06868 F0 1D                                  beq ExitChkName        ;if only 1 player, leave
0686A AD 53 07                               lda CurrentPlayer      ;load current player
0686D CA                                     dex                    ;check to see if current message number is for time up
0686E D0 09                                  bne ChkLuigi
06870 AC 70 07                               ldy OperMode           ;check for game over mode
06873 C0 03                                  cpy #GameOverModeValue
06875 F0 02                                  beq ChkLuigi
06877 49 01                                  eor #%00000001         ;if not, must be time up, invert d0 to do other player
06879 4A                        ChkLuigi:    lsr
0687A 90 0B                                  bcc ExitChkName        ;if mario is current player, do not change the name
0687C A0 04                                  ldy #$04
0687E B9 F3 67                  NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
06881 99 04 03                               sta VRAM_Buffer1+3,y
06884 88                                     dey
06885 10 F7                                  bpl NameLoop           ;do this until each letter is replaced
06887 60                        ExitChkName: rts
06888                           
06888                           PrintWarpZoneNumbers:
06888 E9 04                                  sbc #$04               ;subtract 4 and then shift to the left
0688A 0A                                     asl                    ;twice to get proper warp zone number
0688B 0A                                     asl                    ;offset
0688C AA                                     tax
0688D A0 00                                  ldy #$00
0688F BD F8 67                  WarpNumLoop: lda WarpZoneNumbers,x  ;print warp zone numbers into the
06892 99 1C 03                               sta VRAM_Buffer1+27,y  ;placeholders from earlier
06895 E8                                     inx
06896 C8                                     iny                    ;put a number in every fourth space
06897 C8                                     iny
06898 C8                                     iny
06899 C8                                     iny
0689A C0 0C                                  cpy #$0c
0689C 90 F1                                  bcc WarpNumLoop
0689E A9 2C                                  lda #$2c               ;load new buffer pointer at end of message
068A0 4C 45 66                               jmp SetVRAMOffset
068A3                           
068A3                           ;-------------------------------------------------------------------------------------
068A3                           
068A3                           ResetSpritesAndScreenTimer:
068A3 AD A0 07                           lda ScreenTimer             ;check if screen timer has expired
068A6 D0 0B                              bne NoReset                 ;if not, branch to leave
068A8 20 26 62                           jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
068AB                           
068AB                           ResetScreenTimer:
068AB A9 07                              lda #$07                    ;reset timer again
068AD 8D A0 07                           sta ScreenTimer
068B0 EE 3C 07                           inc ScreenRoutineTask       ;move onto next task
068B3 60                        NoReset: rts
068B4                           
068B4                           ;-------------------------------------------------------------------------------------
068B4                           ;$00 - temp vram buffer offset
068B4                           ;$01 - temp metatile buffer offset
068B4                           ;$02 - temp metatile graphics table offset
068B4                           ;$03 - used to store attribute bits
068B4                           ;$04 - used to determine attribute table row
068B4                           ;$05 - used to determine attribute table column
068B4                           ;$06 - metatile graphics table address low
068B4                           ;$07 - metatile graphics table address high
068B4                           
068B4                           RenderAreaGraphics:
068B4 AD 26 07                              lda CurrentColumnPos         ;store LSB of where we're at
068B7 29 01                                 and #$01
068B9 85 05                                 sta $05
068BB AC 40 03                              ldy VRAM_Buffer2_Offset      ;store vram buffer offset
068BE 84 00                                 sty $00
068C0 AD 21 07                              lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
068C3 99 42 03                              sta VRAM_Buffer2+1,y
068C6 AD 20 07                              lda CurrentNTAddr_High
068C9 99 41 03                              sta VRAM_Buffer2,y
068CC A9 9A                                 lda #$9a                     ;store length byte of 26 here with d7 set
068CE 99 43 03                              sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
068D1 A9 00                                 lda #$00                     ;init attribute row
068D3 85 04                                 sta $04
068D5 AA                                    tax
068D6 86 01                     DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
068D8 BD A1 06                              lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
068DB 29 C0                                 and #%11000000
068DD 85 03                                 sta $03                      ;store attribute table bits here
068DF 0A                                    asl                          ;note that metatile format is:
068E0 2A                                    rol                          ;%xx000000 - attribute table bits, 
068E1 2A                                    rol                          ;%00xxxxxx - metatile number
068E2 A8                                    tay                          ;rotate bits to d1-d0 and use as offset here
068E3 B9 0E 6B                              lda MetatileGraphics_Low,y   ;get address to graphics table from here
068E6 85 06                                 sta $06
068E8 B9 12 6B                              lda MetatileGraphics_High,y
068EB 85 07                                 sta $07
068ED BD A1 06                              lda MetatileBuffer,x         ;get metatile number again
068F0 0A                                    asl                          ;multiply by 4 and use as tile offset
068F1 0A                                    asl
068F2 85 02                                 sta $02
068F4 AD 1F 07                              lda AreaParserTaskNum        ;get current task number for level processing and
068F7 29 01                                 and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
068F9 49 01                                 eor #%00000001               ;to get the correct column position in the metatile,
068FB 0A                                    asl                          ;then add to the tile offset so we can draw either side
068FC 65 02                                 adc $02                      ;of the metatiles
068FE A8                                    tay
068FF A6 00                                 ldx $00                      ;use vram buffer offset from before as X
06901 B1 06                                 lda ($06),y
06903 9D 44 03                              sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
06906 C8                                    iny
06907 B1 06                                 lda ($06),y                  ;now get the second (bottom left or bottom right) and store
06909 9D 45 03                              sta VRAM_Buffer2+4,x
0690C A4 04                                 ldy $04                      ;get current attribute row
0690E A5 05                                 lda $05                      ;get LSB of current column where we're at, and
06910 D0 0E                                 bne RightCheck               ;branch if set (clear = left attrib, set = right)
06912 A5 01                                 lda $01                      ;get current row we're rendering
06914 4A                                    lsr                          ;branch if LSB set (clear = top left, set = bottom left)
06915 B0 19                                 bcs LLeft
06917 26 03                                 rol $03                      ;rotate attribute bits 3 to the left
06919 26 03                                 rol $03                      ;thus in d1-d0, for upper left square
0691B 26 03                                 rol $03
0691D 4C 36 69                              jmp SetAttrib
06920 A5 01                     RightCheck: lda $01                      ;get LSB of current row we're rendering
06922 4A                                    lsr                          ;branch if set (clear = top right, set = bottom right)
06923 B0 0F                                 bcs NextMTRow
06925 46 03                                 lsr $03                      ;shift attribute bits 4 to the right
06927 46 03                                 lsr $03                      ;thus in d3-d2, for upper right square
06929 46 03                                 lsr $03
0692B 46 03                                 lsr $03
0692D 4C 36 69                              jmp SetAttrib
06930 46 03                     LLeft:      lsr $03                      ;shift attribute bits 2 to the right
06932 46 03                                 lsr $03                      ;thus in d5-d4 for lower left square
06934 E6 04                     NextMTRow:  inc $04                      ;move onto next attribute row  
06936 B9 F9 03                  SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
06939 05 03                                 ora $03                      ;if any, and put new bits, if any, onto
0693B 99 F9 03                              sta AttributeBuffer,y        ;the old, and store
0693E E6 00                                 inc $00                      ;increment vram buffer offset by 2
06940 E6 00                                 inc $00
06942 A6 01                                 ldx $01                      ;get current gfx buffer row, and check for
06944 E8                                    inx                          ;the bottom of the screen
06945 E0 0D                                 cpx #$0d
06947 90 8D                                 bcc DrawMTLoop               ;if not there yet, loop back
06949 A4 00                                 ldy $00                      ;get current vram buffer offset, increment by 3
0694B C8                                    iny                          ;(for name table address and length bytes)
0694C C8                                    iny
0694D C8                                    iny
0694E A9 00                                 lda #$00
06950 99 41 03                              sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
06953 8C 40 03                              sty VRAM_Buffer2_Offset      ;store new buffer offset
06956 EE 21 07                              inc CurrentNTAddr_Low        ;increment name table address low
06959 AD 21 07                              lda CurrentNTAddr_Low        ;check current low byte
0695C 29 1F                                 and #%00011111               ;if no wraparound, just skip this part
0695E D0 0D                                 bne ExitDrawM
06960 A9 80                                 lda #$80                     ;if wraparound occurs, make sure low byte stays
06962 8D 21 07                              sta CurrentNTAddr_Low        ;just under the status bar
06965 AD 20 07                              lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
06968 49 04                                 eor #%00000100               ;to move onto the next appropriate name table
0696A 8D 20 07                              sta CurrentNTAddr_High
0696D 4C C3 69                  ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
06970                           
06970                           ;-------------------------------------------------------------------------------------
06970                           ;$00 - temp attribute table address high (big endian order this time!)
06970                           ;$01 - temp attribute table address low
06970                           
06970                           RenderAttributeTables:
06970 AD 21 07                               lda CurrentNTAddr_Low    ;get low byte of next name table address
06973 29 1F                                  and #%00011111           ;to be written to, mask out all but 5 LSB,
06975 38                                     sec                      ;subtract four 
06976 E9 04                                  sbc #$04
06978 29 1F                                  and #%00011111           ;mask out bits again and store
0697A 85 01                                  sta $01
0697C AD 20 07                               lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
0697F B0 02                                  bcs SetATHigh
06981 49 04                                  eor #%00000100           ;otherwise invert d2
06983 29 04                     SetATHigh:   and #%00000100           ;mask out all other bits
06985 09 23                                  ora #$23                 ;add $2300 to the high byte and store
06987 85 00                                  sta $00
06989 A5 01                                  lda $01                  ;get low byte - 4, divide by 4, add offset for
0698B 4A                                     lsr                      ;attribute table and store
0698C 4A                                     lsr
0698D 69 C0                                  adc #$c0                 ;we should now have the appropriate block of
0698F 85 01                                  sta $01                  ;attribute table in our temp address
06991 A2 00                                  ldx #$00
06993 AC 40 03                               ldy VRAM_Buffer2_Offset  ;get buffer offset
06996 A5 00                     AttribLoop:  lda $00
06998 99 41 03                               sta VRAM_Buffer2,y       ;store high byte of attribute table address
0699B A5 01                                  lda $01
0699D 18                                     clc                      ;get low byte, add 8 because we want to start
0699E 69 08                                  adc #$08                 ;below the status bar, and store
069A0 99 42 03                               sta VRAM_Buffer2+1,y
069A3 85 01                                  sta $01                  ;also store in temp again
069A5 BD F9 03                               lda AttributeBuffer,x    ;fetch current attribute table byte and store
069A8 99 44 03                               sta VRAM_Buffer2+3,y     ;in the buffer
069AB A9 01                                  lda #$01
069AD 99 43 03                               sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
069B0 4A                                     lsr
069B1 9D F9 03                               sta AttributeBuffer,x    ;clear current byte in attribute buffer
069B4 C8                                     iny                      ;increment buffer offset by 4 bytes
069B5 C8                                     iny
069B6 C8                                     iny
069B7 C8                                     iny
069B8 E8                                     inx                      ;increment attribute offset and check to see
069B9 E0 07                                  cpx #$07                 ;if we're at the end yet
069BB 90 D9                                  bcc AttribLoop
069BD 99 41 03                               sta VRAM_Buffer2,y       ;put null terminator at the end
069C0 8C 40 03                               sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
069C3 A9 06                     SetVRAMCtrl: lda #$06
069C5 8D 73 07                               sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
069C8 60                                     rts
069C9                           
069C9                           ;-------------------------------------------------------------------------------------
069C9                           
069C9                           ;$00 - used as temporary counter in ColorRotation
069C9                           
069C9                           ColorRotatePalette:
069C9 27 27 27 17 07 17                .db $27, $27, $27, $17, $07, $17
069CF                           
069CF                           BlankPalette:
069CF 3F 0C 04 FF FF FF FF 00          .db $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
069D7                           
069D7                           ;used based on area type
069D7                           Palette3Data:
069D7 0F 07 12 0F                      .db $0f, $07, $12, $0f 
069DB 0F 07 17 0F                      .db $0f, $07, $17, $0f
069DF 0F 07 17 1C                      .db $0f, $07, $17, $1c
069E3 0F 07 17 00                      .db $0f, $07, $17, $00
069E7                           
069E7                           ColorRotation:
069E7 A5 09                                   lda FrameCounter         ;get frame counter
069E9 29 07                                   and #$07                 ;mask out all but three LSB
069EB D0 51                                   bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
069ED AE 00 03                                ldx VRAM_Buffer1_Offset  ;check vram buffer offset
069F0 E0 31                                   cpx #$31
069F2 B0 4A                                   bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
069F4 A8                                      tay                      ;otherwise use frame counter's 3 LSB as offset here
069F5 B9 CF 69                  GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
069F8 9D 01 03                                sta VRAM_Buffer1,x       ;store it in the vram buffer
069FB E8                                      inx                      ;increment offsets
069FC C8                                      iny
069FD C0 08                                   cpy #$08
069FF 90 F4                                   bcc GetBlankPal          ;do this until all bytes are copied
06A01 AE 00 03                                ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
06A04 A9 03                                   lda #$03
06A06 85 00                                   sta $00                  ;set counter here
06A08 AD 4E 07                                lda AreaType             ;get area type
06A0B 0A                                      asl                      ;multiply by 4 to get proper offset
06A0C 0A                                      asl
06A0D A8                                      tay                      ;save as offset here
06A0E B9 D7 69                  GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
06A11 9D 04 03                                sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
06A14 C8                                      iny
06A15 E8                                      inx
06A16 C6 00                                   dec $00                  ;decrement counter
06A18 10 F4                                   bpl GetAreaPal           ;do this until the palette is all copied
06A1A AE 00 03                                ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
06A1D AC D4 06                                ldy ColorRotateOffset    ;get color cycling offset
06A20 B9 C9 69                                lda ColorRotatePalette,y
06A23 9D 05 03                                sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
06A26 AD 00 03                                lda VRAM_Buffer1_Offset
06A29 18                                      clc                      ;add seven bytes to vram buffer offset
06A2A 69 07                                   adc #$07
06A2C 8D 00 03                                sta VRAM_Buffer1_Offset
06A2F EE D4 06                                inc ColorRotateOffset    ;increment color cycling offset
06A32 AD D4 06                                lda ColorRotateOffset
06A35 C9 06                                   cmp #$06                 ;check to see if it's still in range
06A37 90 05                                   bcc ExitColorRot         ;if so, branch to leave
06A39 A9 00                                   lda #$00
06A3B 8D D4 06                                sta ColorRotateOffset    ;otherwise, init to keep it in range
06A3E 60                        ExitColorRot: rts                      ;leave
06A3F                           
06A3F                           ;-------------------------------------------------------------------------------------
06A3F                           ;$00 - temp store for offset control bit
06A3F                           ;$01 - temp vram buffer offset
06A3F                           ;$02 - temp store for vertical high nybble in block buffer routine
06A3F                           ;$03 - temp adder for high byte of name table address
06A3F                           ;$04, $05 - name table address low/high
06A3F                           ;$06, $07 - block buffer address low/high
06A3F                           
06A3F                           BlockGfxData:
06A3F 45 45 47 47                      .db $45, $45, $47, $47
06A43 47 47 47 47                      .db $47, $47, $47, $47
06A47 57 58 59 5A                      .db $57, $58, $59, $5a
06A4B 24 24 24 24                      .db $24, $24, $24, $24
06A4F 26 26 26 26                      .db $26, $26, $26, $26
06A53                           
06A53                           RemoveCoin_Axe:
06A53 A0 41                                   ldy #$41                 ;set low byte so offset points to $0341
06A55 A9 03                                   lda #$03                 ;load offset for default blank metatile
06A57 AE 4E 07                                ldx AreaType             ;check area type
06A5A D0 02                                   bne WriteBlankMT         ;if not water type, use offset
06A5C A9 04                                   lda #$04                 ;otherwise load offset for blank metatile used in water
06A5E 20 9D 6A                  WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
06A61 A9 06                                   lda #$06
06A63 8D 73 07                                sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
06A66 60                                      rts
06A67                           
06A67                           ReplaceBlockMetatile:
06A67 20 73 6A                         jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
06A6A EE F0 03                         inc Block_ResidualCounter ;increment unused counter (residual code)
06A6D DE EC 03                         dec Block_RepFlag,x       ;decrement flag (residual code)
06A70 60                               rts                       ;leave
06A71                           
06A71                           DestroyBlockMetatile:
06A71 A9 00                            lda #$00       ;force blank metatile if branched/jumped to this point
06A73                           
06A73                           WriteBlockMetatile:
06A73 A0 03                                  ldy #$03                ;load offset for blank metatile
06A75 C9 00                                  cmp #$00                ;check contents of A for blank metatile
06A77 F0 14                                  beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
06A79 A0 00                                  ldy #$00                ;load offset for brick metatile w/ line
06A7B C9 58                                  cmp #$58
06A7D F0 0E                                  beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
06A7F C9 51                                  cmp #$51
06A81 F0 0A                                  beq UseBOffset          ;use offset if metatile is breakable brick w/ line
06A83 C8                                     iny                     ;increment offset for brick metatile w/o line
06A84 C9 5D                                  cmp #$5d
06A86 F0 05                                  beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
06A88 C9 52                                  cmp #$52
06A8A F0 01                                  beq UseBOffset          ;use offset if metatile is breakable brick w/o line
06A8C C8                                     iny                     ;if any other metatile, increment offset for empty block
06A8D 98                        UseBOffset:  tya                     ;put Y in A
06A8E AC 00 03                               ldy VRAM_Buffer1_Offset ;get vram buffer offset
06A91 C8                                     iny                     ;move onto next byte
06A92 20 9D 6A                               jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
06A95 88                        MoveVOffset: dey                     ;decrement vram buffer offset
06A96 98                                     tya                     ;add 10 bytes to it
06A97 18                                     clc
06A98 69 0A                                  adc #10
06A9A 4C 45 66                               jmp SetVRAMOffset       ;branch to store as new vram buffer offset
06A9D                           
06A9D                           PutBlockMetatile:
06A9D 86 00                                 stx $00               ;store control bit from SprDataOffset_Ctrl
06A9F 84 01                                 sty $01               ;store vram buffer offset for next byte
06AA1 0A                                    asl
06AA2 0A                                    asl                   ;multiply A by four and use as X
06AA3 AA                                    tax
06AA4 A0 20                                 ldy #$20              ;load high byte for name table 0
06AA6 A5 06                                 lda $06               ;get low byte of block buffer pointer
06AA8 C9 D0                                 cmp #$d0              ;check to see if we're on odd-page block buffer
06AAA 90 02                                 bcc SaveHAdder        ;if not, use current high byte
06AAC A0 24                                 ldy #$24              ;otherwise load high byte for name table 1
06AAE 84 03                     SaveHAdder: sty $03               ;save high byte here
06AB0 29 0F                                 and #$0f              ;mask out high nybble of block buffer pointer
06AB2 0A                                    asl                   ;multiply by 2 to get appropriate name table low byte
06AB3 85 04                                 sta $04               ;and then store it here
06AB5 A9 00                                 lda #$00
06AB7 85 05                                 sta $05               ;initialize temp high byte
06AB9 A5 02                                 lda $02               ;get vertical high nybble offset used in block buffer routine
06ABB 18                                    clc
06ABC 69 20                                 adc #$20              ;add 32 pixels for the status bar
06ABE 0A                                    asl
06ABF 26 05                                 rol $05               ;shift and rotate d7 onto d0 and d6 into carry
06AC1 0A                                    asl
06AC2 26 05                                 rol $05               ;shift and rotate d6 onto d0 and d5 into carry
06AC4 65 04                                 adc $04               ;add low byte of name table and carry to vertical high nybble
06AC6 85 04                                 sta $04               ;and store here
06AC8 A5 05                                 lda $05               ;get whatever was in d7 and d6 of vertical high nybble
06ACA 69 00                                 adc #$00              ;add carry
06ACC 18                                    clc
06ACD 65 03                                 adc $03               ;then add high byte of name table
06ACF 85 05                                 sta $05               ;store here
06AD1 A4 01                                 ldy $01               ;get vram buffer offset to be used
06AD3 BD 3F 6A                  RemBridge:  lda BlockGfxData,x    ;write top left and top right
06AD6 99 03 03                              sta VRAM_Buffer1+2,y  ;tile numbers into first spot
06AD9 BD 40 6A                              lda BlockGfxData+1,x
06ADC 99 04 03                              sta VRAM_Buffer1+3,y
06ADF BD 41 6A                              lda BlockGfxData+2,x  ;write bottom left and bottom
06AE2 99 08 03                              sta VRAM_Buffer1+7,y  ;right tiles numbers into
06AE5 BD 42 6A                              lda BlockGfxData+3,x  ;second spot
06AE8 99 09 03                              sta VRAM_Buffer1+8,y
06AEB A5 04                                 lda $04
06AED 99 01 03                              sta VRAM_Buffer1,y    ;write low byte of name table
06AF0 18                                    clc                   ;into first slot as read
06AF1 69 20                                 adc #$20              ;add 32 bytes to value
06AF3 99 06 03                              sta VRAM_Buffer1+5,y  ;write low byte of name table
06AF6 A5 05                                 lda $05               ;plus 32 bytes into second slot
06AF8 99 00 03                              sta VRAM_Buffer1-1,y  ;write high byte of name
06AFB 99 05 03                              sta VRAM_Buffer1+4,y  ;table address to both slots
06AFE A9 02                                 lda #$02
06B00 99 02 03                              sta VRAM_Buffer1+1,y  ;put length of 2 in
06B03 99 07 03                              sta VRAM_Buffer1+6,y  ;both slots
06B06 A9 00                                 lda #$00
06B08 99 0A 03                              sta VRAM_Buffer1+9,y  ;put null terminator at end
06B0B A6 00                                 ldx $00               ;get offset control bit here
06B0D 60                                    rts                   ;and leave
06B0E                           
06B0E                           ;-------------------------------------------------------------------------------------
06B0E                           ;METATILE GRAPHICS TABLE
06B0E                           
06B0E                           MetatileGraphics_Low:
06B0E 16 B2 6A 92                 .db <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
06B12                           
06B12                           MetatileGraphics_High:
06B12 6B 6B 6C 6C                 .db >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
06B16                           
06B16                           Palette0_MTiles:
06B16 24 24 24 24                 .db $24, $24, $24, $24 ;blank
06B1A 27 27 27 27                 .db $27, $27, $27, $27 ;black metatile
06B1E 24 24 24 35                 .db $24, $24, $24, $35 ;bush left
06B22 36 25 37 25                 .db $36, $25, $37, $25 ;bush middle
06B26 24 38 24 24                 .db $24, $38, $24, $24 ;bush right
06B2A 24 30 30 26                 .db $24, $30, $30, $26 ;mountain left
06B2E 26 26 34 26                 .db $26, $26, $34, $26 ;mountain left bottom/middle center
06B32 24 31 24 32                 .db $24, $31, $24, $32 ;mountain middle top
06B36 33 26 24 33                 .db $33, $26, $24, $33 ;mountain right
06B3A 34 26 26 26                 .db $34, $26, $26, $26 ;mountain right bottom
06B3E 26 26 26 26                 .db $26, $26, $26, $26 ;mountain middle bottom
06B42 24 C0 24 C0                 .db $24, $c0, $24, $c0 ;bridge guardrail
06B46 24 7F 7F 24                 .db $24, $7f, $7f, $24 ;chain
06B4A B8 BA B9 BB                 .db $b8, $ba, $b9, $bb ;tall tree top, top half
06B4E B8 BC B9 BD                 .db $b8, $bc, $b9, $bd ;short tree top
06B52 BA BC BB BD                 .db $ba, $bc, $bb, $bd ;tall tree top, bottom half
06B56 60 64 61 65                 .db $60, $64, $61, $65 ;warp pipe end left, points up
06B5A 62 66 63 67                 .db $62, $66, $63, $67 ;warp pipe end right, points up
06B5E 60 64 61 65                 .db $60, $64, $61, $65 ;decoration pipe end left, points up
06B62 62 66 63 67                 .db $62, $66, $63, $67 ;decoration pipe end right, points up
06B66 68 68 69 69                 .db $68, $68, $69, $69 ;pipe shaft left
06B6A 26 26 6A 6A                 .db $26, $26, $6a, $6a ;pipe shaft right
06B6E 4B 4C 4D 4E                 .db $4b, $4c, $4d, $4e ;tree ledge left edge
06B72 4D 4F 4D 4F                 .db $4d, $4f, $4d, $4f ;tree ledge middle
06B76 4D 4E 50 51                 .db $4d, $4e, $50, $51 ;tree ledge right edge
06B7A 6B 70 2C 2D                 .db $6b, $70, $2c, $2d ;mushroom left edge
06B7E 6C 71 6D 72                 .db $6c, $71, $6d, $72 ;mushroom middle
06B82 6E 73 6F 74                 .db $6e, $73, $6f, $74 ;mushroom right edge
06B86 86 8A 87 8B                 .db $86, $8a, $87, $8b ;sideways pipe end top
06B8A 88 8C 88 8C                 .db $88, $8c, $88, $8c ;sideways pipe shaft top
06B8E 89 8D 69 69                 .db $89, $8d, $69, $69 ;sideways pipe joint top
06B92 8E 91 8F 92                 .db $8e, $91, $8f, $92 ;sideways pipe end bottom
06B96 26 93 26 93                 .db $26, $93, $26, $93 ;sideways pipe shaft bottom
06B9A 90 94 69 69                 .db $90, $94, $69, $69 ;sideways pipe joint bottom
06B9E A4 E9 EA EB                 .db $a4, $e9, $ea, $eb ;seaplant
06BA2 24 24 24 24                 .db $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
06BA6 24 2F 24 3D                 .db $24, $2f, $24, $3d ;flagpole ball
06BAA A2 A2 A3 A3                 .db $a2, $a2, $a3, $a3 ;flagpole shaft
06BAE 24 24 24 24                 .db $24, $24, $24, $24 ;blank, used in conjunction with vines
06BB2                           
06BB2                           Palette1_MTiles:
06BB2 A2 A2 A3 A3                 .db $a2, $a2, $a3, $a3 ;vertical rope
06BB6 99 24 99 24                 .db $99, $24, $99, $24 ;horizontal rope
06BBA 24 A2 3E 3F                 .db $24, $a2, $3e, $3f ;left pulley
06BBE 5B 5C 24 A3                 .db $5b, $5c, $24, $a3 ;right pulley
06BC2 24 24 24 24                 .db $24, $24, $24, $24 ;blank used for balance rope
06BC6 9D 47 9E 47                 .db $9d, $47, $9e, $47 ;castle top
06BCA 47 47 27 27                 .db $47, $47, $27, $27 ;castle window left
06BCE 47 47 47 47                 .db $47, $47, $47, $47 ;castle brick wall
06BD2 27 27 47 47                 .db $27, $27, $47, $47 ;castle window right
06BD6 A9 47 AA 47                 .db $a9, $47, $aa, $47 ;castle top w/ brick
06BDA 9B 27 9C 27                 .db $9b, $27, $9c, $27 ;entrance top
06BDE 27 27 27 27                 .db $27, $27, $27, $27 ;entrance bottom
06BE2 52 52 52 52                 .db $52, $52, $52, $52 ;green ledge stump
06BE6 80 A0 81 A1                 .db $80, $a0, $81, $a1 ;fence
06BEA BE BE BF BF                 .db $be, $be, $bf, $bf ;tree trunk
06BEE 75 BA 76 BB                 .db $75, $ba, $76, $bb ;mushroom stump top
06BF2 BA BA BB BB                 .db $ba, $ba, $bb, $bb ;mushroom stump bottom
06BF6 45 47 45 47                 .db $45, $47, $45, $47 ;breakable brick w/ line 
06BFA 47 47 47 47                 .db $47, $47, $47, $47 ;breakable brick 
06BFE 45 47 45 47                 .db $45, $47, $45, $47 ;breakable brick (not used)
06C02 B4 B6 B5 B7                 .db $b4, $b6, $b5, $b7 ;cracked rock terrain
06C06 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (power-up)
06C0A 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (vine)
06C0E 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (star)
06C12 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (coins)
06C16 45 47 45 47                 .db $45, $47, $45, $47 ;brick with line (1-up)
06C1A 47 47 47 47                 .db $47, $47, $47, $47 ;brick (power-up)
06C1E 47 47 47 47                 .db $47, $47, $47, $47 ;brick (vine)
06C22 47 47 47 47                 .db $47, $47, $47, $47 ;brick (star)
06C26 47 47 47 47                 .db $47, $47, $47, $47 ;brick (coins)
06C2A 47 47 47 47                 .db $47, $47, $47, $47 ;brick (1-up)
06C2E 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (1 coin)
06C32 24 24 24 24                 .db $24, $24, $24, $24 ;hidden block (1-up)
06C36 AB AC AD AE                 .db $ab, $ac, $ad, $ae ;solid block (3-d block)
06C3A 5D 5E 5D 5E                 .db $5d, $5e, $5d, $5e ;solid block (white wall)
06C3E C1 24 C1 24                 .db $c1, $24, $c1, $24 ;bridge
06C42 C6 C8 C7 C9                 .db $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
06C46 CA CC CB CD                 .db $ca, $cc, $cb, $cd ;bullet bill cannon top
06C4A 2A 2A 40 40                 .db $2a, $2a, $40, $40 ;bullet bill cannon bottom
06C4E 24 24 24 24                 .db $24, $24, $24, $24 ;blank used for jumpspring
06C52 24 47 24 47                 .db $24, $47, $24, $47 ;half brick used for jumpspring
06C56 82 83 84 85                 .db $82, $83, $84, $85 ;solid block (water level, green rock)
06C5A 24 47 24 47                 .db $24, $47, $24, $47 ;half brick (???)
06C5E 86 8A 87 8B                 .db $86, $8a, $87, $8b ;water pipe top
06C62 8E 91 8F 92                 .db $8e, $91, $8f, $92 ;water pipe bottom
06C66 24 2F 24 3D                 .db $24, $2f, $24, $3d ;flag ball (residual object)
06C6A                           
06C6A                           Palette2_MTiles:
06C6A 24 24 24 35                 .db $24, $24, $24, $35 ;cloud left
06C6E 36 25 37 25                 .db $36, $25, $37, $25 ;cloud middle
06C72 24 38 24 24                 .db $24, $38, $24, $24 ;cloud right
06C76 24 24 39 24                 .db $24, $24, $39, $24 ;cloud bottom left
06C7A 3A 24 3B 24                 .db $3a, $24, $3b, $24 ;cloud bottom middle
06C7E 3C 24 24 24                 .db $3c, $24, $24, $24 ;cloud bottom right
06C82 41 26 41 26                 .db $41, $26, $41, $26 ;water/lava top
06C86 26 26 26 26                 .db $26, $26, $26, $26 ;water/lava
06C8A B0 B1 B2 B3                 .db $b0, $b1, $b2, $b3 ;cloud level terrain
06C8E 77 79 77 79                 .db $77, $79, $77, $79 ;bowser's bridge
06C92                                 
06C92                           Palette3_MTiles:
06C92 53 55 54 56                 .db $53, $55, $54, $56 ;question block (coin)
06C96 53 55 54 56                 .db $53, $55, $54, $56 ;question block (power-up)
06C9A A5 A7 A6 A8                 .db $a5, $a7, $a6, $a8 ;coin
06C9E C2 C4 C3 C5                 .db $c2, $c4, $c3, $c5 ;underwater coin
06CA2 57 59 58 5A                 .db $57, $59, $58, $5a ;empty block
06CA6 7B 7D 7C 7E                 .db $7b, $7d, $7c, $7e ;axe
06CAA                           
06CAA                           ;-------------------------------------------------------------------------------------
06CAA                           ;VRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
06CAA                           
06CAA                           WaterPaletteData:
06CAA 3F 00 20                    .db $3f, $00, $20
06CAD 0F 15 12 25                 .db $0f, $15, $12, $25  
06CB1 0F 3A 1A 0F                 .db $0f, $3a, $1a, $0f
06CB5 0F 30 12 0F                 .db $0f, $30, $12, $0f
06CB9 0F 27 12 0F                 .db $0f, $27, $12, $0f
06CBD 22 16 27 18                 .db $22, $16, $27, $18
06CC1 0F 10 30 27                 .db $0f, $10, $30, $27
06CC5 0F 16 30 27                 .db $0f, $16, $30, $27
06CC9 0F 0F 30 10                 .db $0f, $0f, $30, $10
06CCD 00                          .db $00
06CCE                           
06CCE                           GroundPaletteData:
06CCE 3F 00 20                    .db $3f, $00, $20
06CD1 0F 29 1A 0F                 .db $0f, $29, $1a, $0f
06CD5 0F 36 17 0F                 .db $0f, $36, $17, $0f
06CD9 0F 30 21 0F                 .db $0f, $30, $21, $0f
06CDD 0F 27 17 0F                 .db $0f, $27, $17, $0f
06CE1 0F 16 27 18                 .db $0f, $16, $27, $18
06CE5 0F 1A 30 27                 .db $0f, $1a, $30, $27
06CE9 0F 16 30 27                 .db $0f, $16, $30, $27
06CED 0F 0F 36 17                 .db $0f, $0f, $36, $17
06CF1 00                          .db $00
06CF2                           
06CF2                           UndergroundPaletteData:
06CF2 3F 00 20                    .db $3f, $00, $20
06CF5 0F 29 1A 09                 .db $0f, $29, $1a, $09
06CF9 0F 3C 1C 0F                 .db $0f, $3c, $1c, $0f
06CFD 0F 30 21 1C                 .db $0f, $30, $21, $1c
06D01 0F 27 17 1C                 .db $0f, $27, $17, $1c
06D05 0F 16 27 18                 .db $0f, $16, $27, $18
06D09 0F 1C 36 17                 .db $0f, $1c, $36, $17
06D0D 0F 16 30 27                 .db $0f, $16, $30, $27
06D11 0F 0C 3C 1C                 .db $0f, $0c, $3c, $1c
06D15 00                          .db $00
06D16                           
06D16                           CastlePaletteData:
06D16 3F 00 20                    .db $3f, $00, $20
06D19 0F 30 10 00                 .db $0f, $30, $10, $00
06D1D 0F 30 10 00                 .db $0f, $30, $10, $00
06D21 0F 30 16 00                 .db $0f, $30, $16, $00
06D25 0F 27 17 00                 .db $0f, $27, $17, $00
06D29 0F 16 27 18                 .db $0f, $16, $27, $18
06D2D 0F 1C 36 17                 .db $0f, $1c, $36, $17
06D31 0F 16 30 27                 .db $0f, $16, $30, $27
06D35 0F 00 30 10                 .db $0f, $00, $30, $10
06D39 00                          .db $00
06D3A                           
06D3A                           DaySnowPaletteData:
06D3A 3F 00 04                    .db $3f, $00, $04
06D3D 22 30 00 10                 .db $22, $30, $00, $10
06D41 00                          .db $00
06D42                           
06D42                           NightSnowPaletteData:
06D42 3F 00 04                    .db $3f, $00, $04
06D45 0F 30 00 10                 .db $0f, $30, $00, $10
06D49 00                          .db $00
06D4A                           
06D4A                           MushroomPaletteData:
06D4A 3F 00 04                    .db $3f, $00, $04
06D4D 22 27 16 0F                 .db $22, $27, $16, $0f
06D51 00                          .db $00
06D52                           
06D52                           BowserPaletteData:
06D52 3F 14 04                    .db $3f, $14, $04
06D55 0F 1A 30 27                 .db $0f, $1a, $30, $27
06D59 00                          .db $00
06D5A                           
06D5A                           MarioThanksMessage:
06D5A                           ;"THANK YOU MARIO!"
06D5A 25 48 10                    .db $25, $48, $10
06D5D 1D 11 0A 17 14 24           .db $1d, $11, $0a, $17, $14, $24
06D63 22 18 1E 24                 .db $22, $18, $1e, $24
06D67 16 0A 1B 12 18 2B           .db $16, $0a, $1b, $12, $18, $2b
06D6D 00                          .db $00
06D6E                           
06D6E                           LuigiThanksMessage:
06D6E                           ;"THANK YOU LUIGI!"
06D6E 25 48 10                    .db $25, $48, $10
06D71 1D 11 0A 17 14 24           .db $1d, $11, $0a, $17, $14, $24
06D77 22 18 1E 24                 .db $22, $18, $1e, $24
06D7B 15 1E 12 10 12 2B           .db $15, $1e, $12, $10, $12, $2b
06D81 00                          .db $00
06D82                           
06D82                           MushroomRetainerSaved:
06D82                           ;"BUT OUR PRINCESS IS IN"
06D82 25 C5 16                    .db $25, $c5, $16
06D85 0B 1E 1D 24 18 1E 1B 24     .db $0b, $1e, $1d, $24, $18, $1e, $1b, $24
06D8D 19 1B 12 17 0C 0E 1C 1C..   .db $19, $1b, $12, $17, $0c, $0e, $1c, $1c, $24
06D96 12 1C 24 12 17              .db $12, $1c, $24, $12, $17
06D9B                           ;"ANOTHER CASTLE!"
06D9B 26 05 0F                    .db $26, $05, $0f
06D9E 0A 17 18 1D 11 0E 1B 24     .db $0a, $17, $18, $1d, $11, $0e, $1b, $24
06DA6 0C 0A 1C 1D 15 0E 2B 00     .db $0c, $0a, $1c, $1d, $15, $0e, $2b, $00
06DAE                           
06DAE                           PrincessSaved1:
06DAE                           ;"YOUR QUEST IS OVER."
06DAE 25 A7 13                    .db $25, $a7, $13
06DB1 22 18 1E 1B 24              .db $22, $18, $1e, $1b, $24
06DB6 1A 1E 0E 1C 1D 24           .db $1a, $1e, $0e, $1c, $1d, $24
06DBC 12 1C 24 18 1F 0E 1B AF     .db $12, $1c, $24, $18, $1f, $0e, $1b, $af
06DC4 00                          .db $00
06DC5                           
06DC5                           PrincessSaved2:
06DC5                           ;"WE PRESENT YOU A NEW QUEST."
06DC5 25 E3 1B                    .db $25, $e3, $1b
06DC8 20 0E 24                    .db $20, $0e, $24
06DCB 19 1B 0E 1C 0E 17 1D 24     .db $19, $1b, $0e, $1c, $0e, $17, $1d, $24
06DD3 22 18 1E 24 0A 24 17 0E..   .db $22, $18, $1e, $24, $0a, $24, $17, $0e, $20, $24
06DDD 1A 1E 0E 1C 1D AF           .db $1a, $1e, $0e, $1c, $1d, $af
06DE3 00                          .db $00
06DE4                           
06DE4                           WorldSelectMessage1:
06DE4                           ;"PUSH BUTTON B"
06DE4 26 4A 0D                    .db $26, $4a, $0d
06DE7 19 1E 1C 11 24              .db $19, $1e, $1c, $11, $24
06DEC 0B 1E 1D 1D 18 17 24 0B     .db $0b, $1e, $1d, $1d, $18, $17, $24, $0b
06DF4 00                          .db $00
06DF5                           
06DF5                           WorldSelectMessage2:
06DF5                           ;"TO SELECT A WORLD"
06DF5 26 88 11                    .db $26, $88, $11
06DF8 1D 18 24 1C 0E 15 0E 0C..   .db $1d, $18, $24, $1c, $0e, $15, $0e, $0c, $1d, $24
06E02 0A 24 20 18 1B 15 0D        .db $0a, $24, $20, $18, $1b, $15, $0d
06E09 00                          .db $00
06E0A                           
06E0A                           ;-------------------------------------------------------------------------------------
06E0A                           ;$04 - address low to jump address
06E0A                           ;$05 - address high to jump address
06E0A                           ;$06 - jump address low
06E0A                           ;$07 - jump address high
06E0A                           
06E0A                           JumpEngine:
06E0A 0A                               asl          ;shift bit from contents of A
06E0B A8                               tay
06E0C 68                               pla          ;pull saved return address from stack
06E0D 85 04                            sta $04      ;save to indirect
06E0F 68                               pla
06E10 85 05                            sta $05
06E12 C8                               iny
06E13 B1 04                            lda ($04),y  ;load pointer from indirect
06E15 85 06                            sta $06      ;note that if an RTS is performed in next routine
06E17 C8                               iny          ;it will return to the execution before the sub
06E18 B1 04                            lda ($04),y  ;that called this routine
06E1A 85 07                            sta $07
06E1C 6C 06 00                         jmp ($06)    ;jump to the address we loaded
06E1F                           
06E1F                           ;-------------------------------------------------------------------------------------
06E1F                           
06E1F                           InitializeNameTables:
06E1F AD 02 20                                lda PPU_STATUS            ;reset flip-flop
06E22 AD 78 07                                lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
06E25 09 10                                   ora #%00010000            ;set sprites for first 4k and background for second 4k
06E27 29 F0                                   and #%11110000            ;clear rest of lower nybble, leave higher alone
06E29 20 F3 6E                                jsr WritePPUReg1
06E2C A9 24                                   lda #$24                  ;set vram address to start of name table 1
06E2E 20 33 6E                                jsr WriteNTAddr
06E31 A9 20                                   lda #$20                  ;and then set it to name table 0
06E33 8D 06 20                  WriteNTAddr:  sta PPU_ADDRESS
06E36 A9 00                                   lda #$00
06E38 8D 06 20                                sta PPU_ADDRESS
06E3B A2 04                                   ldx #$04                  ;clear name table with blank tile #24
06E3D A0 C0                                   ldy #$c0
06E3F A9 24                                   lda #$24
06E41 8D 07 20                  InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
06E44 88                                      dey
06E45 D0 FA                                   bne InitNTLoop
06E47 CA                                      dex
06E48 D0 F7                                   bne InitNTLoop
06E4A A0 40                                   ldy #64                   ;now to clear the attribute table (with zero this time)
06E4C 8A                                      txa
06E4D 8D 00 03                                sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
06E50 8D 01 03                                sta VRAM_Buffer1          ;init vram buffer 1
06E53 8D 07 20                  InitATLoop:   sta PPU_DATA
06E56 88                                      dey
06E57 D0 FA                                   bne InitATLoop
06E59 8D 3F 07                                sta HorizontalScroll      ;reset scroll variables
06E5C 8D 40 07                                sta VerticalScroll
06E5F 4C EC 6E                                jmp InitScroll            ;initialize scroll registers to zero
06E62                           
06E62                           ;-------------------------------------------------------------------------------------
06E62                           ;$00 - temp joypad bit
06E62                           
06E62                           ReadJoypads: 
06E62 A9 01                                   lda #$01               ;reset and clear strobe of joypad ports
06E64 8D 16 40                                sta JOYPAD_PORT
06E67 4A                                      lsr
06E68 AA                                      tax                    ;start with joypad 1's port
06E69 8D 16 40                                sta JOYPAD_PORT
06E6C 20 70 6E                                jsr ReadPortBits
06E6F E8                                      inx                    ;increment for joypad 2's port
06E70 A0 08                     ReadPortBits: ldy #$08
06E72 48                        PortLoop:     pha                    ;push previous bit onto stack
06E73 BD 16 40                                lda JOYPAD_PORT,x      ;read current bit on joypad port
06E76 85 00                                   sta $00                ;check d1 and d0 of port output
06E78 4A                                      lsr                    ;this is necessary on the old
06E79 05 00                                   ora $00                ;famicom systems in japan
06E7B 4A                                      lsr
06E7C 68                                      pla                    ;read bits from stack
06E7D 2A                                      rol                    ;rotate bit from carry flag
06E7E 88                                      dey
06E7F D0 F1                                   bne PortLoop           ;count down bits left
06E81 9D FC 06                                sta SavedJoypadBits,x  ;save controller status here always
06E84 48                                      pha
06E85 29 30                                   and #%00110000         ;check for select or start
06E87 3D 4A 07                                and JoypadBitMask,x    ;if neither saved state nor current state
06E8A F0 07                                   beq Save8Bits          ;have any of these two set, branch
06E8C 68                                      pla
06E8D 29 CF                                   and #%11001111         ;otherwise store without select
06E8F 9D FC 06                                sta SavedJoypadBits,x  ;or start bits and leave
06E92 60                                      rts
06E93 68                        Save8Bits:    pla
06E94 9D 4A 07                                sta JoypadBitMask,x    ;save with all bits in another place and leave
06E97 60                                      rts
06E98                           
06E98                           ;-------------------------------------------------------------------------------------
06E98                           ;$00 - vram buffer address table low
06E98                           ;$01 - vram buffer address table high
06E98                           
06E98                           WriteBufferToScreen:
06E98 8D 06 20                                 sta PPU_ADDRESS           ;store high byte of vram address
06E9B C8                                       iny
06E9C B1 00                                    lda ($00),y               ;load next byte (second)
06E9E 8D 06 20                                 sta PPU_ADDRESS           ;store low byte of vram address
06EA1 C8                                       iny
06EA2 B1 00                                    lda ($00),y               ;load next byte (third)
06EA4 0A                                       asl                       ;shift to left and save in stack
06EA5 48                                       pha
06EA6 AD 78 07                                 lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
06EA9 09 04                                    ora #%00000100            ;set ppu to increment by 32 by default
06EAB B0 02                                    bcs SetupWrites           ;if d7 of third byte was clear, ppu will
06EAD 29 FB                                    and #%11111011            ;only increment by 1
06EAF 20 F3 6E                  SetupWrites:   jsr WritePPUReg1          ;write to register
06EB2 68                                       pla                       ;pull from stack and shift to left again
06EB3 0A                                       asl
06EB4 90 03                                    bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
06EB6 09 02                                    ora #%00000010            ;otherwise set d1 and increment Y
06EB8 C8                                       iny
06EB9 4A                        GetLength:     lsr                       ;shift back to the right to get proper length
06EBA 4A                                       lsr                       ;note that d1 will now be in carry
06EBB AA                                       tax
06EBC B0 01                     OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
06EBE C8                                       iny                       ;otherwise increment Y to load next byte
06EBF B1 00                     RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
06EC1 8D 07 20                                 sta PPU_DATA
06EC4 CA                                       dex                       ;done writing?
06EC5 D0 F5                                    bne OutputToVRAM
06EC7 38                                       sec          
06EC8 98                                       tya
06EC9 65 00                                    adc $00                   ;add end length plus one to the indirect at $00
06ECB 85 00                                    sta $00                   ;to allow this routine to read another set of updates
06ECD A9 00                                    lda #$00
06ECF 65 01                                    adc $01
06ED1 85 01                                    sta $01
06ED3 A9 3F                                    lda #$3f                  ;sets vram address to $3f00
06ED5 8D 06 20                                 sta PPU_ADDRESS
06ED8 A9 00                                    lda #$00
06EDA 8D 06 20                                 sta PPU_ADDRESS
06EDD 8D 06 20                                 sta PPU_ADDRESS           ;then reinitializes it for some reason
06EE0 8D 06 20                                 sta PPU_ADDRESS
06EE3 AE 02 20                  UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
06EE6 A0 00                                    ldy #$00                  ;load first byte from indirect as a pointer
06EE8 B1 00                                    lda ($00),y  
06EEA D0 AC                                    bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
06EEC 8D 05 20                  InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
06EEF 8D 05 20                                 sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
06EF2 60                                       rts
06EF3                           
06EF3                           ;-------------------------------------------------------------------------------------
06EF3                           
06EF3                           WritePPUReg1:
06EF3 8D 00 20                                 sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
06EF6 8D 78 07                                 sta Mirror_PPU_CTRL_REG1  ;and its mirror
06EF9 60                                       rts
06EFA                           
06EFA                           ;-------------------------------------------------------------------------------------
06EFA                           ;$00 - used to store status bar nybbles
06EFA                           ;$02 - used as temp vram offset
06EFA                           ;$03 - used to store length of status bar number
06EFA                           
06EFA                           ;status bar name table offset and length data
06EFA                           StatusBarData:
06EFA F0 06                           .db $f0, $06 ; top score display on title screen
06EFC 62 06                           .db $62, $06 ; player score
06EFE 62 06                           .db $62, $06
06F00 6D 02                           .db $6d, $02 ; coin tally
06F02 6D 02                           .db $6d, $02
06F04 7A 03                           .db $7a, $03 ; game timer
06F06                           
06F06                           StatusBarOffset:
06F06 06 0C 12 18 1E 24               .db $06, $0c, $12, $18, $1e, $24
06F0C                           
06F0C                           PrintStatusBarNumbers:
06F0C 85 00                           sta $00            ;store player-specific offset
06F0E 20 17 6F                        jsr OutputNumbers  ;use first nybble to print the coin display
06F11 A5 00                           lda $00            ;move high nybble to low
06F13 4A                              lsr                ;and print to score display
06F14 4A                              lsr
06F15 4A                              lsr
06F16 4A                              lsr
06F17                           
06F17                           OutputNumbers:
06F17 18                                     clc                      ;add 1 to low nybble
06F18 69 01                                  adc #$01
06F1A 29 0F                                  and #%00001111           ;mask out high nybble
06F1C C9 06                                  cmp #$06
06F1E B0 44                                  bcs ExitOutputN
06F20 48                                     pha                      ;save incremented value to stack for now and
06F21 0A                                     asl                      ;shift to left and use as offset
06F22 A8                                     tay
06F23 AE 00 03                               ldx VRAM_Buffer1_Offset  ;get current buffer pointer
06F26 A9 20                                  lda #$20                 ;put at top of screen by default
06F28 C0 00                                  cpy #$00                 ;are we writing top score on title screen?
06F2A D0 02                                  bne SetupNums
06F2C A9 22                                  lda #$22                 ;if so, put further down on the screen
06F2E 9D 01 03                  SetupNums:   sta VRAM_Buffer1,x
06F31 B9 FA 6E                               lda StatusBarData,y      ;write low vram address and length of thing
06F34 9D 02 03                               sta VRAM_Buffer1+1,x     ;we're printing to the buffer
06F37 B9 FB 6E                               lda StatusBarData+1,y
06F3A 9D 03 03                               sta VRAM_Buffer1+2,x
06F3D 85 03                                  sta $03                  ;save length byte in counter
06F3F 86 02                                  stx $02                  ;and buffer pointer elsewhere for now
06F41 68                                     pla                      ;pull original incremented value from stack
06F42 AA                                     tax
06F43 BD 06 6F                               lda StatusBarOffset,x    ;load offset to value we want to write
06F46 38                                     sec
06F47 F9 FB 6E                               sbc StatusBarData+1,y    ;subtract from length byte we read before
06F4A A8                                     tay                      ;use value as offset to display digits
06F4B A6 02                                  ldx $02
06F4D B9 D7 07                  DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
06F50 9D 04 03                               sta VRAM_Buffer1+3,x    
06F53 E8                                     inx
06F54 C8                                     iny
06F55 C6 03                                  dec $03                  ;do this until all the digits are written
06F57 D0 F4                                  bne DigitPLoop
06F59 A9 00                                  lda #$00                 ;put null terminator at end
06F5B 9D 04 03                               sta VRAM_Buffer1+3,x
06F5E E8                                     inx                      ;increment buffer pointer by 3
06F5F E8                                     inx
06F60 E8                                     inx
06F61 8E 00 03                               stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
06F64 60                        ExitOutputN: rts
06F65                           
06F65                           ;-------------------------------------------------------------------------------------
06F65                           
06F65                           DigitsMathRoutine:
06F65 AD 70 07                              lda OperMode              ;check mode of operation
06F68 C9 00                                 cmp #TitleScreenModeValue
06F6A F0 16                                 beq EraseDMods            ;if in title screen mode, branch to lock score
06F6C A2 05                                 ldx #$05
06F6E BD 34 01                  AddModLoop: lda DigitModifier,x       ;load digit amount to increment
06F71 18                                    clc
06F72 79 D7 07                              adc DisplayDigits,y       ;add to current digit
06F75 30 16                                 bmi BorrowOne             ;if result is a negative number, branch to subtract
06F77 C9 0A                                 cmp #10
06F79 B0 19                                 bcs CarryOne              ;if digit greater than $09, branch to add
06F7B 99 D7 07                  StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
06F7E 88                                    dey                       ;move onto next digits in score or game timer
06F7F CA                                    dex                       ;and digit amounts to increment
06F80 10 EC                                 bpl AddModLoop            ;loop back if we're not done yet
06F82 A9 00                     EraseDMods: lda #$00                  ;store zero here
06F84 A2 06                                 ldx #$06                  ;start with the last digit
06F86 9D 33 01                  EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
06F89 CA                                    dex
06F8A 10 FA                                 bpl EraseMLoop            ;do this until they're all reset, then leave
06F8C 60                                    rts
06F8D DE 33 01                  BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
06F90 A9 09                                 lda #$09                  ;the game timer digit we're currently on to "borrow
06F92 D0 E7                                 bne StoreNewD             ;the one", then do an unconditional branch back
06F94 38                        CarryOne:   sec                       ;subtract ten from our digit to make it a
06F95 E9 0A                                 sbc #10                   ;proper BCD number, then increment the digit
06F97 FE 33 01                              inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
06F9A 4C 7B 6F                              jmp StoreNewD             ;go back to just after we branched here
06F9D                           
06F9D                           ;-------------------------------------------------------------------------------------
06F9D                           
06F9D                           UpdateTopScore:
06F9D A2 05                           ldx #$05          ;start with mario's score
06F9F 20 A4 6F                        jsr TopScoreCheck
06FA2 A2 0B                           ldx #$0b          ;now do luigi's score
06FA4                           
06FA4                           TopScoreCheck:
06FA4 A0 05                                   ldy #$05                 ;start with the lowest digit
06FA6 38                                      sec           
06FA7 BD DD 07                  GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
06FAA F9 D7 07                                sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
06FAD CA                                      dex                      ;any player digit, borrow will be set until a subsequent
06FAE 88                                      dey                      ;subtraction clears it (player digit is higher than top)
06FAF 10 F6                                   bpl GetScoreDiff      
06FB1 90 0E                                   bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
06FB3 E8                                      inx                      ;increment X and Y once to the start of the score
06FB4 C8                                      iny
06FB5 BD DD 07                  CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
06FB8 99 D7 07                                sta TopScoreDisplay,y
06FBB E8                                      inx
06FBC C8                                      iny
06FBD C0 06                                   cpy #$06                 ;do this until we have stored them all
06FBF 90 F4                                   bcc CopyScore
06FC1 60                        NoTopSc:      rts
06FC2                           
06FC2                           ;-------------------------------------------------------------------------------------
06FC2                           
06FC2                           DefaultSprOffsets:
06FC2 04 30 48 60 78 90 A8 C0         .db $04, $30, $48, $60, $78, $90, $a8, $c0
06FCA D8 E8 24 F8 FC 28 2C            .db $d8, $e8, $24, $f8, $fc, $28, $2c
06FD1                           
06FD1                           Sprite0Data:
06FD1 18 FF 23 58                     .db $18, $ff, $23, $58
06FD5                           
06FD5                           ;-------------------------------------------------------------------------------------
06FD5                           
06FD5                           InitializeGame:
06FD5 A0 6F                                  ldy #$6f              ;clear all memory as in initialization procedure,
06FD7 20 D2 70                               jsr InitializeMemory  ;but this time, clear only as far as $076f
06FDA A0 1F                                  ldy #$1f
06FDC 99 B0 07                  ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
06FDF 88                                     dey                   ;by the sound engines
06FE0 10 FA                                  bpl ClrSndLoop
06FE2 A9 18                                  lda #$18              ;set demo timer
06FE4 8D A2 07                               sta DemoTimer
06FE7 20 0B 7C                               jsr LoadAreaPointer
06FEA                           
06FEA                           InitializeArea:
06FEA A0 4B                                    ldy #$4b                 ;clear all memory again, only as far as $074b
06FEC 20 D2 70                                 jsr InitializeMemory     ;this is only necessary if branching from
06FEF A2 21                                    ldx #$21
06FF1 A9 00                                    lda #$00
06FF3 9D 80 07                  ClrTimersLoop: sta Timers,x             ;clear out memory between
06FF6 CA                                       dex                      ;$0780 and $07a1
06FF7 10 FA                                    bpl ClrTimersLoop
06FF9 AD 5B 07                                 lda HalfwayPage
06FFC AC 52 07                                 ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
06FFF F0 03                                    beq StartPage
07001 AD 51 07                                 lda EntrancePage         ;otherwise use saved entry page number here
07004 8D 1A 07                  StartPage:     sta ScreenLeft_PageLoc   ;set as value here
07007 8D 25 07                                 sta CurrentPageLoc       ;also set as current page
0700A 8D 28 07                                 sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
0700D 20 40 90                                 jsr GetScreenPosition    ;get pixel coordinates for screen borders
07010 A0 20                                    ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
07012 29 01                                    and #%00000001           ;otherwise use $2080, this address used later as name table
07014 F0 02                                    beq SetInitNTHigh        ;address for rendering of game area
07016 A0 24                                    ldy #$24
07018 8C 20 07                  SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
0701B A0 80                                    ldy #$80
0701D 8C 21 07                                 sty CurrentNTAddr_Low
07020 0A                                       asl                      ;store LSB of page number in high nybble
07021 0A                                       asl                      ;of block buffer column position
07022 0A                                       asl
07023 0A                                       asl
07024 8D A0 06                                 sta BlockBufferColumnPos
07027 CE 30 07                                 dec AreaObjectLength     ;set area object lengths for all empty
0702A CE 31 07                                 dec AreaObjectLength+1
0702D CE 32 07                                 dec AreaObjectLength+2
07030 A9 0B                                    lda #$0b                 ;set value for renderer to update 12 column sets
07032 8D 1E 07                                 sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
07035 20 2A 7C                                 jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
07038 AD 6A 07                                 lda PrimaryHardMode      ;check to see if primary hard mode has been activated
0703B D0 10                                    bne SetSecHard           ;if so, activate the secondary no matter where we're at
0703D AD 5F 07                                 lda WorldNumber          ;otherwise check world number
07040 C9 04                                    cmp #World5              ;if less than 5, do not activate secondary
07042 90 0C                                    bcc CheckHalfway
07044 D0 07                                    bne SetSecHard           ;if not equal to, then world > 5, thus activate
07046 AD 5C 07                                 lda LevelNumber          ;otherwise, world 5, so check level number
07049 C9 02                                    cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
0704B 90 03                                    bcc CheckHalfway
0704D EE CC 06                  SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
07050 AD 5B 07                  CheckHalfway:  lda HalfwayPage
07053 F0 05                                    beq DoneInitArea
07055 A9 02                                    lda #$02                 ;if halfway page set, overwrite start position from header
07057 8D 10 07                                 sta PlayerEntranceCtrl
0705A A9 80                     DoneInitArea:  lda #Silence             ;silence music
0705C 85 FB                                    sta AreaMusicQueue
0705E A9 01                                    lda #$01                 ;disable screen output
07060 8D 74 07                                 sta DisableScreenFlag
07063 EE 72 07                                 inc OperMode_Task        ;increment one of the modes
07066 60                                       rts
07067                           
07067                           ;-------------------------------------------------------------------------------------
07067                           
07067                           PrimaryGameSetup:
07067 A9 01                           lda #$01
07069 8D 57 07                        sta FetchNewGameTimerFlag   ;set flag to load game timer from header
0706C 8D 54 07                        sta PlayerSize              ;set player's size to small
0706F A9 02                           lda #$02
07071 8D 5A 07                        sta NumberofLives           ;give each player three lives
07074 8D 61 07                        sta OffScr_NumberofLives
07077                           
07077                           SecondaryGameSetup:
07077 A9 00                                  lda #$00
07079 8D 74 07                               sta DisableScreenFlag     ;enable screen output
0707C A8                                     tay
0707D 99 00 03                  ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
07080 C8                                     iny
07081 D0 FA                                  bne ClearVRLoop
07083 8D 59 07                               sta GameTimerExpiredFlag  ;clear game timer exp flag
07086 8D 69 07                               sta DisableIntermediate   ;clear skip lives display flag
07089 8D 28 07                               sta BackloadingFlag       ;clear value here
0708C A9 FF                                  lda #$ff
0708E 8D A0 03                               sta BalPlatformAlignment  ;initialize balance platform assignment flag
07091 AD 1A 07                               lda ScreenLeft_PageLoc    ;get left side page location
07094 4E 78 07                               lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
07097 29 01                                  and #$01                  ;mask out all but LSB of page location
07099 6A                                     ror                       ;rotate LSB of page location into carry then onto mirror
0709A 2E 78 07                               rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
0709D 20 F7 70                               jsr GetAreaMusic          ;load proper music into queue
070A0 A9 38                                  lda #$38                  ;load sprite shuffle amounts to be used later
070A2 8D E3 06                               sta SprShuffleAmt+2
070A5 A9 48                                  lda #$48
070A7 8D E2 06                               sta SprShuffleAmt+1
070AA A9 58                                  lda #$58
070AC 8D E1 06                               sta SprShuffleAmt
070AF A2 0E                                  ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
070B1 BD C2 6F                  ShufAmtLoop: lda DefaultSprOffsets,x
070B4 9D E4 06                               sta SprDataOffset,x
070B7 CA                                     dex                       ;do this until they're all set
070B8 10 F7                                  bpl ShufAmtLoop
070BA A0 03                                  ldy #$03                  ;set up sprite #0
070BC B9 D1 6F                  ISpr0Loop:   lda Sprite0Data,y
070BF 99 00 02                               sta Sprite_Data,y
070C2 88                                     dey
070C3 10 F7                                  bpl ISpr0Loop
070C5 20 B9 72                               jsr DoNothing2            ;these jsrs doesn't do anything useful
070C8 20 B4 72                               jsr DoNothing1
070CB EE 22 07                               inc Sprite0HitDetectFlag  ;set sprite #0 check flag
070CE EE 72 07                               inc OperMode_Task         ;increment to next task
070D1 60                                     rts
070D2                           
070D2                           ;-------------------------------------------------------------------------------------
070D2                           
070D2                           ;$06 - RAM address low
070D2                           ;$07 - RAM address high
070D2                           
070D2                           InitializeMemory:
070D2 A2 07                                   ldx #$07          ;set initial high byte to $0700-$07ff
070D4 A9 00                                   lda #$00          ;set initial low byte to start of page (at $00 of page)
070D6 85 06                                   sta $06
070D8 86 07                     InitPageLoop: stx $07
070DA E0 01                     InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
070DC D0 08                                   bne InitByte      ;if not, go ahead anyway
070DE C0 60                                   cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
070E0 B0 06                                   bcs SkipByte      ;if so, skip write
070E2 C0 04                                   cpy #$04          ;check to see if we're at $0100-$0103 (FDS pseudo-registers)
070E4 90 02                                   bcc SkipByte      ;if so, skip write
070E6 91 06                     InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
070E8 88                        SkipByte:     dey
070E9 C0 FF                                   cpy #$ff          ;do this until all bytes in page have been erased
070EB D0 ED                                   bne InitByteLoop
070ED CA                                      dex               ;go onto the next page
070EE 10 E8                                   bpl InitPageLoop  ;do this until all pages of memory have been erased
070F0 60                                      rts
070F1                           
070F1                           ;-------------------------------------------------------------------------------------
070F1                           
070F1                           MusicSelectData:
070F1 02 01 04 08                     .db WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
070F5 10 20                           .db CloudMusic, PipeIntroMusic
070F7                           
070F7                           GetAreaMusic:
070F7 AD 70 07                               lda OperMode           ;if in title screen mode, leave
070FA F0 23                                  beq ExitGetM
070FC AD 52 07                               lda AltEntranceControl ;check for specific alternate mode of entry
070FF C9 02                                  cmp #$02               ;if found, branch without checking starting position
07101 F0 0D                                  beq ChkAreaType        ;from area object data header
07103 A0 05                                  ldy #$05               ;select music for pipe intro scene by default
07105 AD 10 07                               lda PlayerEntranceCtrl ;check value from level header for certain values
07108 C9 06                                  cmp #$06
0710A F0 0E                                  beq StoreMusic         ;load music for pipe intro scene if header
0710C C9 07                                  cmp #$07               ;start position either value $06 or $07
0710E F0 0A                                  beq StoreMusic
07110 AC 4E 07                  ChkAreaType: ldy AreaType           ;load area type as offset for music bit
07113 AD 43 07                               lda CloudTypeOverride
07116 F0 02                                  beq StoreMusic         ;check for cloud type override
07118 A0 04                                  ldy #$04               ;select music for cloud type level if found
0711A B9 F1 70                  StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
0711D 85 FB                                  sta AreaMusicQueue     ;store in queue and leave
0711F 60                        ExitGetM:    rts
07120                           
07120                           ;-------------------------------------------------------------------------------------
07120                           
07120                           PlayerStarting_X_Pos:
07120 28 18                           .db $28, $18
07122 38 28                           .db $38, $28
07124                           
07124                           AltYPosOffset:
07124 08 00                           .db $08, $00
07126                           
07126                           PlayerStarting_Y_Pos:
07126 00 20 B0 50 00 00 B0 B0         .db $00, $20, $b0, $50, $00, $00, $b0, $b0
0712E F0                              .db $f0
0712F                           
0712F                           PlayerBGPriorityData:
0712F 00 20 00 00 00 00 00 00         .db $00, $20, $00, $00, $00, $00, $00, $00
07137                           
07137                           GameTimerData:
07137 20                              .db $20 ;dummy byte, used as part of bg priority data
07138 04 03 02                        .db $04, $03, $02
0713B                           
0713B                           Entrance_GameTimerSetup:
0713B AD 1A 07                            lda ScreenLeft_PageLoc      ;set current page for area objects
0713E 85 6D                               sta Player_PageLoc          ;as page location for player
07140 A9 28                               lda #$28                    ;store value here
07142 8D 0A 07                            sta VerticalForceDown       ;for fractional movement downwards if necessary
07145 A9 01                               lda #$01                    ;set high byte of player position and
07147 85 33                               sta PlayerFacingDir         ;set facing direction so that player faces right
07149 85 B5                               sta Player_Y_HighPos
0714B A9 00                               lda #$00                    ;set player state to on the ground by default
0714D 85 1D                               sta Player_State
0714F CE 90 04                            dec Player_CollisionBits    ;initialize player's collision bits
07152 A0 00                               ldy #$00                    ;initialize halfway page
07154 8C 5B 07                            sty HalfwayPage      
07157 AD 4E 07                            lda AreaType                ;check area type
0715A D0 01                               bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
0715C C8                                  iny
0715D 8C 04 07                  ChkStPos: sty SwimmingFlag
07160 AE 10 07                            ldx PlayerEntranceCtrl      ;get starting position loaded from header
07163 AC 52 07                            ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
07166 F0 07                               beq SetStPos
07168 C0 01                               cpy #$01
0716A F0 03                               beq SetStPos
0716C BE 22 71                            ldx AltYPosOffset-2,y       ;if not 0 or 1, override $0710 with new offset in X
0716F B9 20 71                  SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
07172 85 86                               sta Player_X_Position       ;and vertical positions for the player, using
07174 BD 26 71                            lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
07177 85 CE                               sta Player_Y_Position       ;or value that overwrote $0710 as offset for vertical
07179 BD 2F 71                            lda PlayerBGPriorityData,x
0717C 8D C4 03                            sta Player_SprAttrib        ;set player sprite attributes using offset in X
0717F 20 F7 65                            jsr GetPlayerColors         ;get appropriate player palette
07182 AC 15 07                            ldy GameTimerSetting        ;get timer control value from header
07185 F0 1A                               beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
07187 AD 57 07                            lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use 
0718A F0 15                               beq ChkOverR                ;old game timer setting
0718C B9 37 71                            lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
0718F 8D F8 07                            sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
07192 A9 01                               lda #$01
07194 8D FA 07                            sta GameTimerDisplay+2      ;set last digit of game timer to 1
07197 4A                                  lsr
07198 8D F9 07                            sta GameTimerDisplay+1      ;set second digit of game timer
0719B 8D 57 07                            sta FetchNewGameTimerFlag   ;clear flag for game timer reset
0719E 8D 9F 07                            sta StarInvincibleTimer     ;clear star mario timer
071A1 AC 58 07                  ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
071A4 F0 14                               beq ChkSwimE
071A6 A9 03                               lda #$03                    ;set player state to climbing
071A8 85 1D                               sta Player_State
071AA A2 00                               ldx #$00                    ;set offset for first slot, for block object
071AC 20 8C 9D                            jsr InitBlock_XY_Pos
071AF A9 F0                               lda #$f0                    ;set vertical coordinate for block object
071B1 85 D7                               sta Block_Y_Position
071B3 A2 05                               ldx #$05                    ;set offset in X for last enemy object buffer slot
071B5 A0 00                               ldy #$00                    ;set offset in Y for object coordinates used earlier
071B7 20 26 99                            jsr Setup_Vine              ;do a sub to grow vine
071BA AC 4E 07                  ChkSwimE: ldy AreaType                ;if level not water-type,
071BD D0 03                               bne SetPESub                ;skip this subroutine
071BF 20 13 97                            jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
071C2 A9 07                     SetPESub: lda #$07                    ;set to run player entrance subroutine
071C4 85 0E                               sta GameEngineSubroutine    ;on the next frame of game engine
071C6 60                                  rts
071C7                           
071C7                           ;-------------------------------------------------------------------------------------
071C7                           
071C7                           ;page numbers are in order from -1 to -4
071C7                           HalfwayPageNybbles:
071C7 56 40                           .db $56, $40
071C9 65 70                           .db $65, $70
071CB 66 40                           .db $66, $40
071CD 66 40                           .db $66, $40
071CF 66 40                           .db $66, $40
071D1 66 60                           .db $66, $60
071D3 65 70                           .db $65, $70
071D5 00 00                           .db $00, $00
071D7                           
071D7                           PlayerLoseLife:
071D7 EE 74 07                               inc DisableScreenFlag    ;disable screen and sprite 0 check
071DA A9 00                                  lda #$00
071DC 8D 22 07                               sta Sprite0HitDetectFlag
071DF A9 80                                  lda #Silence             ;silence music
071E1 85 FC                                  sta EventMusicQueue
071E3 CE 5A 07                               dec NumberofLives        ;take one life from player
071E6 10 0B                                  bpl StillInGame          ;if player still has lives, branch
071E8 A9 00                                  lda #$00
071EA 8D 72 07                               sta OperMode_Task        ;initialize mode task,
071ED A9 03                                  lda #GameOverModeValue   ;switch to game over mode
071EF 8D 70 07                               sta OperMode             ;and leave
071F2 60                                     rts
071F3 AD 5F 07                  StillInGame: lda WorldNumber          ;multiply world number by 2 and use
071F6 0A                                     asl                      ;as offset
071F7 AA                                     tax
071F8 AD 5C 07                               lda LevelNumber          ;if in area -3 or -4, increment
071FB 29 02                                  and #$02                 ;offset by one byte, otherwise
071FD F0 01                                  beq GetHalfway           ;leave offset alone
071FF E8                                     inx
07200 BC C7 71                  GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
07203 AD 5C 07                               lda LevelNumber          ;check area number's LSB
07206 4A                                     lsr
07207 98                                     tya                      ;if in area -2 or -4, use lower nybble
07208 B0 04                                  bcs MaskHPNyb
0720A 4A                                     lsr                      ;move higher nybble to lower if area
0720B 4A                                     lsr                      ;number is -1 or -3
0720C 4A                                     lsr
0720D 4A                                     lsr
0720E 29 0F                     MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
07210 CD 1A 07                               cmp ScreenLeft_PageLoc
07213 F0 04                                  beq SetHalfway           ;left side of screen must be at the halfway page,
07215 90 02                                  bcc SetHalfway           ;otherwise player must start at the
07217 A9 00                                  lda #$00                 ;beginning of the level
07219 8D 5B 07                  SetHalfway:  sta HalfwayPage          ;store as halfway page for player
0721C 20 8C 72                               jsr TransposePlayers     ;switch players around if 2-player game
0721F 4C 6E 72                               jmp ContinueGame         ;continue the game
07222                           
07222                           ;-------------------------------------------------------------------------------------
07222                           
07222                           GameOverMode:
07222 AD 72 07                        lda OperMode_Task
07225 20 0A 6E                        jsr JumpEngine
07228                                 
07228 2E 72                           .dw SetupGameOver
0722A 6D 65                           .dw ScreenRoutines
0722C 41 72                           .dw RunGameOver
0722E                           
0722E                           ;-------------------------------------------------------------------------------------
0722E                           
0722E                           SetupGameOver:
0722E A9 00                           lda #$00                  ;reset screen routine task control for title screen, game,
07230 8D 3C 07                        sta ScreenRoutineTask     ;and game over modes
07233 8D 22 07                        sta Sprite0HitDetectFlag  ;disable sprite 0 check
07236 A9 02                           lda #GameOverMusic
07238 85 FC                           sta EventMusicQueue       ;put game over music in secondary queue
0723A EE 74 07                        inc DisableScreenFlag     ;disable screen output
0723D EE 72 07                        inc OperMode_Task         ;set secondary mode to 1
07240 60                              rts
07241                           
07241                           ;-------------------------------------------------------------------------------------
07241                           
07241                           RunGameOver:
07241 A9 00                           lda #$00              ;reenable screen
07243 8D 74 07                        sta DisableScreenFlag
07246 AD FC 06                        lda SavedJoypad1Bits  ;check controller for start pressed
07249 29 10                           and #Start_Button
0724B D0 05                           bne TerminateGame
0724D AD A0 07                        lda ScreenTimer       ;if not pressed, wait for
07250 D0 39                           bne GameIsOn          ;screen timer to expire
07252                           TerminateGame:
07252 A9 80                           lda #Silence          ;silence music
07254 85 FC                           sta EventMusicQueue
07256 20 8C 72                        jsr TransposePlayers  ;check if other player can keep
07259 90 13                           bcc ContinueGame      ;going, and do so if possible
0725B AD 5F 07                        lda WorldNumber       ;otherwise put world number of current
0725E 8D FD 07                        sta ContinueWorld     ;player into secret continue function variable
07261 A9 00                           lda #$00
07263 0A                              asl                   ;residual ASL instruction
07264 8D 72 07                        sta OperMode_Task     ;reset all modes to title screen and
07267 8D A0 07                        sta ScreenTimer       ;leave
0726A 8D 70 07                        sta OperMode
0726D 60                              rts
0726E                           
0726E                           ContinueGame:
0726E 20 0B 7C                             jsr LoadAreaPointer       ;update level pointer with
07271 A9 01                                lda #$01                  ;actual world and area numbers, then
07273 8D 54 07                             sta PlayerSize            ;reset player's size, status, and
07276 EE 57 07                             inc FetchNewGameTimerFlag ;set game timer flag to reload
07279 A9 00                                lda #$00                  ;game timer from header
0727B 8D 47 07                             sta TimerControl          ;also set flag for timers to count again
0727E 8D 56 07                             sta PlayerStatus
07281 85 0E                                sta GameEngineSubroutine  ;reset task for game core
07283 8D 72 07                             sta OperMode_Task         ;set modes and leave
07286 A9 01                                lda #$01                  ;if in game over mode, switch back to
07288 8D 70 07                             sta OperMode              ;game mode, because game is still on
0728B 60                        GameIsOn:  rts
0728C                           
0728C                           TransposePlayers:
0728C 38                                   sec                       ;set carry flag by default to end game
0728D AD 7A 07                             lda NumberOfPlayers       ;if only a 1 player game, leave
07290 F0 21                                beq ExTrans
07292 AD 61 07                             lda OffScr_NumberofLives  ;does offscreen player have any lives left?
07295 30 1C                                bmi ExTrans               ;branch if not
07297 AD 53 07                             lda CurrentPlayer         ;invert bit to update
0729A 49 01                                eor #%00000001            ;which player is on the screen
0729C 8D 53 07                             sta CurrentPlayer
0729F A2 06                                ldx #$06
072A1 BD 5A 07                  TransLoop: lda OnscreenPlayerInfo,x    ;transpose the information
072A4 48                                   pha                         ;of the onscreen player
072A5 BD 61 07                             lda OffscreenPlayerInfo,x   ;with that of the offscreen player
072A8 9D 5A 07                             sta OnscreenPlayerInfo,x
072AB 68                                   pla
072AC 9D 61 07                             sta OffscreenPlayerInfo,x
072AF CA                                   dex
072B0 10 EF                                bpl TransLoop
072B2 18                                   clc            ;clear carry flag to get game going
072B3 60                        ExTrans:   rts
072B4                           
072B4                           ;-------------------------------------------------------------------------------------
072B4                           
072B4                           DoNothing1:
072B4 A9 FF                           lda #$ff       ;this is residual code, this value is
072B6 8D C9 06                        sta $06c9      ;not used anywhere in the program
072B9                           DoNothing2:
072B9 60                              rts
072BA                           
072BA                           ;-------------------------------------------------------------------------------------
072BA                           
072BA                           AreaParserTaskHandler:
072BA AC 1F 07                                ldy AreaParserTaskNum     ;check number of tasks here
072BD D0 05                                   bne DoAPTasks             ;if already set, go ahead
072BF A0 08                                   ldy #$08
072C1 8C 1F 07                                sty AreaParserTaskNum     ;otherwise, set eight by default
072C4 88                        DoAPTasks:    dey
072C5 98                                      tya
072C6 20 D2 72                                jsr AreaParserTasks
072C9 CE 1F 07                                dec AreaParserTaskNum     ;if all tasks not complete do not
072CC D0 03                                   bne SkipATRender          ;render attribute table yet
072CE 20 70 69                                jsr RenderAttributeTables
072D1 60                        SkipATRender: rts
072D2                           
072D2                           AreaParserTasks:
072D2 20 0A 6E                        jsr JumpEngine
072D5                           
072D5 E5 72                           .dw IncrementColumnPos
072D7 B4 68                           .dw RenderAreaGraphics
072D9 B4 68                           .dw RenderAreaGraphics
072DB 06 74                           .dw AreaParserCore
072DD E5 72                           .dw IncrementColumnPos
072DF B4 68                           .dw RenderAreaGraphics
072E1 B4 68                           .dw RenderAreaGraphics
072E3 06 74                           .dw AreaParserCore
072E5                           
072E5                           ;-------------------------------------------------------------------------------------
072E5                           
072E5                           IncrementColumnPos:
072E5 EE 26 07                             inc CurrentColumnPos     ;increment column where we're at
072E8 AD 26 07                             lda CurrentColumnPos
072EB 29 0F                                and #%00001111           ;mask out higher nybble
072ED D0 06                                bne NoColWrap
072EF 8D 26 07                             sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
072F2 EE 25 07                             inc CurrentPageLoc       ;and increment page number where we're at
072F5 EE A0 06                  NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
072F8 AD A0 06                             lda BlockBufferColumnPos
072FB 29 1F                                and #%00011111           ;mask out all but 5 LSB (0-1f)
072FD 8D A0 06                             sta BlockBufferColumnPos ;and save
07300 60                                   rts
07301                           
07301                           ;-------------------------------------------------------------------------------------
07301                           ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
07301                           ;$01 - used to store floor byte for terrain
07301                           ;$07 - used to store terrain metatile
07301                           ;$06-$07 - used to store block buffer address
07301                           
07301                           BSceneDataOffsets:
07301 00 30 60                        .db $00, $30, $60 
07304                           
07304                           BackSceneryData:
07304 93 00 00 11 12 12 13 00      .db $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
0730C 00 51 52 53 00 00 00 00      .db $00, $51, $52, $53, $00, $00, $00, $00
07314 00 00 01 02 02 03 00 00      .db $00, $00, $01, $02, $02, $03, $00, $00
0731C 00 00 00 00 91 92 93 00      .db $00, $00, $00, $00, $91, $92, $93, $00
07324 00 00 00 51 52 53 41 42      .db $00, $00, $00, $51, $52, $53, $41, $42
0732C 43 00 00 00 00 00 91 92      .db $43, $00, $00, $00, $00, $00, $91, $92
07334                           
07334 97 87 88 89 99 00 00 00      .db $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
0733C 11 12 13 A4 A5 A5 A5 A6      .db $11, $12, $13, $a4, $a5, $a5, $a5, $a6
07344 97 98 99 01 02 03 00 A4      .db $97, $98, $99, $01, $02, $03, $00, $a4
0734C A5 A6 00 11 12 12 12 13      .db $a5, $a6, $00, $11, $12, $12, $12, $13
07354 00 00 00 00 01 02 02 03      .db $00, $00, $00, $00, $01, $02, $02, $03
0735C 00 A4 A5 A5 A6 00 00 00      .db $00, $a4, $a5, $a5, $a6, $00, $00, $00
07364                           
07364 11 12 12 13 00 00 00 00      .db $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
0736C 00 00 00 9C 00 8B AA AA      .db $00, $00, $00, $9c, $00, $8b, $aa, $aa
07374 AA AA 11 12 13 8B 00 9C      .db $aa, $aa, $11, $12, $13, $8b, $00, $9c
0737C 9C 00 00 01 02 03 11 12      .db $9c, $00, $00, $01, $02, $03, $11, $12
07384 12 13 00 00 00 00 AA AA      .db $12, $13, $00, $00, $00, $00, $aa, $aa
0738C 9C AA 00 8B 00 01 02 03      .db $9c, $aa, $00, $8b, $00, $01, $02, $03
07394                           
07394                           BackSceneryMetatiles:
07394 80 83 00                     .db $80, $83, $00 ;cloud left
07397 81 84 00                     .db $81, $84, $00 ;cloud middle
0739A 82 85 00                     .db $82, $85, $00 ;cloud right
0739D 02 00 00                     .db $02, $00, $00 ;bush left
073A0 03 00 00                     .db $03, $00, $00 ;bush middle
073A3 04 00 00                     .db $04, $00, $00 ;bush right
073A6 00 05 06                     .db $00, $05, $06 ;mountain left
073A9 07 06 0A                     .db $07, $06, $0a ;mountain middle
073AC 00 08 09                     .db $00, $08, $09 ;mountain right
073AF 4D 00 00                     .db $4d, $00, $00 ;fence
073B2 0D 0F 4E                     .db $0d, $0f, $4e ;tall tree
073B5 0E 4E 4E                     .db $0e, $4e, $4e ;short tree
073B8                           
073B8                           FSceneDataOffsets:
073B8 00 0D 1A                        .db $00, $0d, $1a
073BB                           
073BB                           ForeSceneryData:
073BB 86 87 87 87 87 87 87         .db $86, $87, $87, $87, $87, $87, $87   ;in water
073C2 87 87 87 87 69 69            .db $87, $87, $87, $87, $69, $69
073C8                           
073C8 00 00 00 00 00 45 47         .db $00, $00, $00, $00, $00, $45, $47   ;wall
073CF 47 47 47 47 00 00            .db $47, $47, $47, $47, $00, $00
073D5                           
073D5 00 00 00 00 00 00 00         .db $00, $00, $00, $00, $00, $00, $00   ;over water
073DC 00 00 00 00 86 87            .db $00, $00, $00, $00, $86, $87
073E2                           
073E2                           TerrainMetatiles:
073E2 69 54 52 62                     .db $69, $54, $52, $62
073E6                           
073E6                           TerrainRenderBits:
073E6 00 00                           .db %00000000, %00000000 ;no ceiling or floor
073E8 00 18                           .db %00000000, %00011000 ;no ceiling, floor 2
073EA 01 18                           .db %00000001, %00011000 ;ceiling 1, floor 2
073EC 07 18                           .db %00000111, %00011000 ;ceiling 3, floor 2
073EE 0F 18                           .db %00001111, %00011000 ;ceiling 4, floor 2
073F0 FF 18                           .db %11111111, %00011000 ;ceiling 8, floor 2
073F2 01 1F                           .db %00000001, %00011111 ;ceiling 1, floor 5
073F4 07 1F                           .db %00000111, %00011111 ;ceiling 3, floor 5
073F6 0F 1F                           .db %00001111, %00011111 ;ceiling 4, floor 5
073F8 81 1F                           .db %10000001, %00011111 ;ceiling 1, floor 6
073FA 01 00                           .db %00000001, %00000000 ;ceiling 1, no floor
073FC 8F 1F                           .db %10001111, %00011111 ;ceiling 4, floor 6
073FE F1 1F                           .db %11110001, %00011111 ;ceiling 1, floor 9
07400 F9 18                           .db %11111001, %00011000 ;ceiling 1, middle 5, floor 2
07402 F1 18                           .db %11110001, %00011000 ;ceiling 1, middle 4, floor 2
07404 FF 1F                           .db %11111111, %00011111 ;completely solid top to bottom
07406                           
07406                           AreaParserCore:
07406 AD 28 07                        lda BackloadingFlag       ;check to see if we are starting right of start
07409 F0 03                           beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
0740B 20 12 75                        jsr ProcessAreaData       ;otherwise skip ahead and load level data
0740E                           
0740E                           RenderSceneryTerrain:
0740E A2 0C                               ldx #$0c
07410 A9 00                               lda #$00
07412 9D A1 06                  ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
07415 CA                                  dex
07416 10 FA                               bpl ClrMTBuf
07418 AC 42 07                            ldy BackgroundScenery      ;do we need to render the background scenery?
0741B F0 42                               beq RendFore               ;if not, skip to check the foreground
0741D AD 25 07                            lda CurrentPageLoc         ;otherwise check for every third page
07420 C9 03                     ThirdP:   cmp #$03
07422 30 05                               bmi RendBack               ;if less than three we're there
07424 38                                  sec
07425 E9 03                               sbc #$03                   ;if 3 or more, subtract 3 and 
07427 10 F7                               bpl ThirdP                 ;do an unconditional branch
07429 0A                        RendBack: asl                        ;move results to higher nybble
0742A 0A                                  asl
0742B 0A                                  asl
0742C 0A                                  asl
0742D 79 00 73                            adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
07430 6D 26 07                            adc CurrentColumnPos       ;add to the result our current column position
07433 AA                                  tax
07434 BD 04 73                            lda BackSceneryData,x      ;load data from sum of offsets
07437 F0 26                               beq RendFore               ;if zero, no scenery for that part
07439 48                                  pha
0743A 29 0F                               and #$0f                   ;save to stack and clear high nybble
0743C 38                                  sec
0743D E9 01                               sbc #$01                   ;subtract one (because low nybble is $01-$0c)
0743F 85 00                               sta $00                    ;save low nybble
07441 0A                                  asl                        ;multiply by three (shift to left and add result to old one)
07442 65 00                               adc $00                    ;note that since d7 was nulled, the carry flag is always clear
07444 AA                                  tax                        ;save as offset for background scenery metatile data
07445 68                                  pla                        ;get high nybble from stack, move low
07446 4A                                  lsr
07447 4A                                  lsr
07448 4A                                  lsr
07449 4A                                  lsr
0744A A8                                  tay                        ;use as second offset (used to determine height)
0744B A9 03                               lda #$03                   ;use previously saved memory location for counter
0744D 85 00                               sta $00
0744F BD 94 73                  SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
07452 99 A1 06                            sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
07455 E8                                  inx
07456 C8                                  iny
07457 C0 0B                               cpy #$0b                   ;if at this location, leave loop
07459 F0 04                               beq RendFore
0745B C6 00                               dec $00                    ;decrement until counter expires, barring exception
0745D D0 F0                               bne SceLoop1
0745F AE 41 07                  RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
07462 F0 13                               beq RendTerr               ;if not, skip this part
07464 BC B7 73                            ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
07467 A2 00                               ldx #$00                   ;reinit X
07469 B9 BB 73                  SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
0746C F0 03                               beq NoFore                 ;do not store if zero found
0746E 9D A1 06                            sta MetatileBuffer,x
07471 C8                        NoFore:   iny
07472 E8                                  inx
07473 E0 0D                               cpx #$0d                   ;store up to end of metatile buffer
07475 D0 F2                               bne SceLoop2
07477 AC 4E 07                  RendTerr: ldy AreaType               ;check world type for water level
0747A D0 0C                               bne TerMTile               ;if not water level, skip this part
0747C AD 5F 07                            lda WorldNumber            ;check world number, if not world number eight
0747F C9 07                               cmp #World8                ;then skip this part
07481 D0 05                               bne TerMTile
07483 A9 62                               lda #$62                   ;if set as water level and world number eight,
07485 4C 92 74                            jmp StoreMT                ;use castle wall metatile as terrain type
07488 B9 E2 73                  TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
0748B AC 43 07                            ldy CloudTypeOverride      ;check for cloud type override
0748E F0 02                               beq StoreMT                ;if not set, keep value otherwise
07490 A9 88                               lda #$88                   ;use cloud block terrain
07492 85 07                     StoreMT:  sta $07                    ;store value here
07494 A2 00                               ldx #$00                   ;initialize X, use as metatile buffer offset
07496 AD 27 07                            lda TerrainControl         ;use yet another value from the header
07499 0A                                  asl                        ;multiply by 2 and use as yet another offset
0749A A8                                  tay
0749B B9 E6 73                  TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
0749E 85 00                               sta $00
074A0 C8                                  iny                        ;increment Y and use as offset next time around
074A1 84 01                               sty $01
074A3 AD 43 07                            lda CloudTypeOverride      ;skip if value here is zero
074A6 F0 0A                               beq NoCloud2
074A8 E0 00                               cpx #$00                   ;otherwise, check if we're doing the ceiling byte
074AA F0 06                               beq NoCloud2
074AC A5 00                               lda $00                    ;if not, mask out all but d3
074AE 29 08                               and #%00001000
074B0 85 00                               sta $00
074B2 A0 00                     NoCloud2: ldy #$00                   ;start at beginning of bitmasks
074B4 B9 92 A6                  TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
074B7 24 00                               bit $00
074B9 F0 05                               beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
074BB A5 07                               lda $07
074BD 9D A1 06                            sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
074C0 E8                        NextTBit: inx                        ;continue until end of buffer
074C1 E0 0D                               cpx #$0d
074C3 F0 18                               beq RendBBuf               ;if we're at the end, break out of this loop
074C5 AD 4E 07                            lda AreaType               ;check world type for underground area
074C8 C9 02                               cmp #$02
074CA D0 08                               bne EndUChk                ;if not underground, skip this part
074CC E0 0B                               cpx #$0b
074CE D0 04                               bne EndUChk                ;if we're at the bottom of the screen, override
074D0 A9 54                               lda #$54                   ;old terrain type with ground level terrain type
074D2 85 07                               sta $07
074D4 C8                        EndUChk:  iny                        ;increment bitmasks offset in Y
074D5 C0 08                               cpy #$08
074D7 D0 DB                               bne TerrBChk               ;if not all bits checked, loop back    
074D9 A4 01                               ldy $01
074DB D0 BE                               bne TerrLoop               ;unconditional branch, use Y to load next byte
074DD 20 12 75                  RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
074E0 AD A0 06                            lda BlockBufferColumnPos
074E3 20 EB 7B                            jsr GetBlockBufferAddr     ;get block buffer address from where we're at
074E6 A2 00                               ldx #$00
074E8 A0 00                               ldy #$00                   ;init index regs and start at beginning of smaller buffer
074EA 84 00                     ChkMTLow: sty $00
074EC BD A1 06                            lda MetatileBuffer,x       ;load stored metatile number
074EF 29 C0                               and #%11000000             ;mask out all but 2 MSB
074F1 0A                                  asl
074F2 2A                                  rol                        ;make %xx000000 into %000000xx
074F3 2A                                  rol
074F4 A8                                  tay                        ;use as offset in Y
074F5 BD A1 06                            lda MetatileBuffer,x       ;reload original unmasked value here
074F8 D9 0E 75                            cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
074FB B0 02                               bcs StrBlock               ;if equal or greater, branch
074FD A9 00                               lda #$00                   ;if less, init value before storing
074FF A4 00                     StrBlock: ldy $00                    ;get offset for block buffer
07501 91 06                               sta ($06),y                ;store value into block buffer
07503 98                                  tya
07504 18                                  clc                        ;add 16 (move down one row) to offset
07505 69 10                               adc #$10
07507 A8                                  tay
07508 E8                                  inx                        ;increment column value
07509 E0 0D                               cpx #$0d
0750B 90 DD                               bcc ChkMTLow               ;continue until we pass last row, then leave
0750D 60                                  rts
0750E                           
0750E                           ;numbers lower than these with the same attribute bits
0750E                           ;will not be stored in the block buffer
0750E                           BlockBuffLowBounds:
0750E 10 51 88 C0                     .db $10, $51, $88, $c0
07512                           
07512                           ;-------------------------------------------------------------------------------------
07512                           ;$00 - used to store area object identifier
07512                           ;$07 - used as adder to find proper area object code
07512                           
07512                           ProcessAreaData:
07512 A2 02                                 ldx #$02                 ;start at the end of area object buffer
07514 86 08                     ProcADLoop: stx ObjectOffset
07516 A9 00                                 lda #$00                 ;reset flag
07518 8D 29 07                              sta BehindAreaParserFlag
0751B AC 2C 07                              ldy AreaDataOffset       ;get offset of area data pointer
0751E B1 E7                                 lda (AreaData),y         ;get first byte of area object
07520 C9 FD                                 cmp #$fd                 ;if end-of-area, skip all this crap
07522 F0 4B                                 beq RdyDecode
07524 BD 30 07                              lda AreaObjectLength,x   ;check area object buffer flag
07527 10 46                                 bpl RdyDecode            ;if buffer not negative, branch, otherwise
07529 C8                                    iny
0752A B1 E7                                 lda (AreaData),y         ;get second byte of area object
0752C 0A                                    asl                      ;check for page select bit (d7), branch if not set
0752D 90 0B                                 bcc Chk1Row13
0752F AD 2B 07                              lda AreaObjectPageSel    ;check page select
07532 D0 06                                 bne Chk1Row13
07534 EE 2B 07                              inc AreaObjectPageSel    ;if not already set, set it now
07537 EE 2A 07                              inc AreaObjectPageLoc    ;and increment page location
0753A 88                        Chk1Row13:  dey
0753B B1 E7                                 lda (AreaData),y         ;reread first byte of level object
0753D 29 0F                                 and #$0f                 ;mask out high nybble
0753F C9 0D                                 cmp #$0d                 ;row 13?
07541 D0 1B                                 bne Chk1Row14
07543 C8                                    iny                      ;if so, reread second byte of level object
07544 B1 E7                                 lda (AreaData),y
07546 88                                    dey                      ;decrement to get ready to read first byte
07547 29 40                                 and #%01000000           ;check for d6 set (if not, object is page control)
07549 D0 1C                                 bne CheckRear
0754B AD 2B 07                              lda AreaObjectPageSel    ;if page select is set, do not reread
0754E D0 17                                 bne CheckRear
07550 C8                                    iny                      ;if d6 not set, reread second byte
07551 B1 E7                                 lda (AreaData),y
07553 29 1F                                 and #%00011111           ;mask out all but 5 LSB and store in page control
07555 8D 2A 07                              sta AreaObjectPageLoc
07558 EE 2B 07                              inc AreaObjectPageSel    ;increment page select
0755B 4C 78 75                              jmp NextAObj
0755E C9 0E                     Chk1Row14:  cmp #$0e                 ;row 14?
07560 D0 05                                 bne CheckRear
07562 AD 28 07                              lda BackloadingFlag      ;check flag for saved page number and branch if set
07565 D0 08                                 bne RdyDecode            ;to render the object (otherwise bg might not look right)
07567 AD 2A 07                  CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
0756A CD 25 07                              cmp CurrentPageLoc       ;behind current page of renderer
0756D 90 06                                 bcc SetBehind            ;if so branch
0756F 20 9F 75                  RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
07572 4C 7B 75                              jmp ChkLength
07575 EE 29 07                  SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
07578 20 93 75                  NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
0757B A6 08                     ChkLength:  ldx ObjectOffset         ;get buffer offset
0757D BD 30 07                              lda AreaObjectLength,x   ;check object length for anything stored here
07580 30 03                                 bmi ProcLoopb            ;if not, branch to handle loopback
07582 DE 30 07                              dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
07585 CA                        ProcLoopb:  dex                      ;decrement buffer offset
07586 10 8C                                 bpl ProcADLoop           ;and loopback unless exceeded buffer
07588 AD 29 07                              lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
0758B D0 85                                 bne ProcessAreaData      ;branch if true to load more level data, otherwise
0758D AD 28 07                              lda BackloadingFlag      ;check for flag set if starting right of page $00
07590 D0 80                                 bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
07592 60                        EndAParse:  rts
07593                           
07593                           IncAreaObjOffset:
07593 EE 2C 07                        inc AreaDataOffset    ;increment offset of level pointer
07596 EE 2C 07                        inc AreaDataOffset
07599 A9 00                           lda #$00              ;reset page select
0759B 8D 2B 07                        sta AreaObjectPageSel
0759E 60                              rts
0759F                           
0759F                           DecodeAreaData:
0759F BD 30 07                            lda AreaObjectLength,x     ;check current buffer flag
075A2 30 03                               bmi Chk1stB
075A4 BC 2D 07                            ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
075A7 A2 10                     Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
075A9 B1 E7                               lda (AreaData),y           ;get first byte of level object again
075AB C9 FD                               cmp #$fd
075AD F0 E3                               beq EndAParse              ;if end of level, leave this routine
075AF 29 0F                               and #$0f                   ;otherwise, mask out low nybble
075B1 C9 0F                               cmp #$0f                   ;row 15?
075B3 F0 08                               beq ChkRow14               ;if so, keep the offset of 16
075B5 A2 08                               ldx #$08                   ;otherwise load offset of 8 for special row 12
075B7 C9 0C                               cmp #$0c                   ;row 12?
075B9 F0 02                               beq ChkRow14               ;if so, keep the offset value of 8
075BB A2 00                               ldx #$00                   ;otherwise nullify value by default
075BD 86 07                     ChkRow14: stx $07                    ;store whatever value we just loaded here
075BF A6 08                               ldx ObjectOffset           ;get object offset again
075C1 C9 0E                               cmp #$0e                   ;row 14?
075C3 D0 08                               bne ChkRow13
075C5 A9 00                               lda #$00                   ;if so, load offset with $00
075C7 85 07                               sta $07
075C9 A9 2E                               lda #$2e                   ;and load A with another value
075CB D0 53                               bne NormObj                ;unconditional branch
075CD C9 0D                     ChkRow13: cmp #$0d                   ;row 13?
075CF D0 1B                               bne ChkSRows
075D1 A9 22                               lda #$22                   ;if so, load offset with 34
075D3 85 07                               sta $07
075D5 C8                                  iny                        ;get next byte
075D6 B1 E7                               lda (AreaData),y
075D8 29 40                               and #%01000000             ;mask out all but d6 (page control obj bit)
075DA F0 63                               beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
075DC B1 E7                               lda (AreaData),y           ;otherwise, get byte again
075DE 29 7F                               and #%01111111             ;mask out d7
075E0 C9 4B                               cmp #$4b                   ;check for loop command in low nybble
075E2 D0 03                               bne Mask2MSB               ;(plus d6 set for object other than page control)
075E4 EE 45 07                            inc LoopCommand            ;if loop command, set loop command flag
075E7 29 3F                     Mask2MSB: and #%00111111             ;mask out d7 and d6
075E9 4C 20 76                            jmp NormObj                ;and jump
075EC C9 0C                     ChkSRows: cmp #$0c                   ;row 12-15?
075EE B0 27                               bcs SpecObj
075F0 C8                                  iny                        ;if not, get second byte of level object
075F1 B1 E7                               lda (AreaData),y
075F3 29 70                               and #%01110000             ;mask out all but d6-d4
075F5 D0 0B                               bne LrgObj                 ;if any bits set, branch to handle large object
075F7 A9 16                               lda #$16
075F9 85 07                               sta $07                    ;otherwise set offset of 24 for small object
075FB B1 E7                               lda (AreaData),y           ;reload second byte of level object
075FD 29 0F                               and #%00001111             ;mask out higher nybble and jump
075FF 4C 20 76                            jmp NormObj
07602 85 00                     LrgObj:   sta $00                    ;store value here (branch for large objects)
07604 C9 70                               cmp #$70                   ;check for vertical pipe object
07606 D0 0A                               bne NotWPipe
07608 B1 E7                               lda (AreaData),y           ;if not, reload second byte
0760A 29 08                               and #%00001000             ;mask out all but d3 (usage control bit)
0760C F0 04                               beq NotWPipe               ;if d3 clear, branch to get original value
0760E A9 00                               lda #$00                   ;otherwise, nullify value for warp pipe
07610 85 00                               sta $00
07612 A5 00                     NotWPipe: lda $00                    ;get value and jump ahead
07614 4C 1C 76                            jmp MoveAOId
07617 C8                        SpecObj:  iny                        ;branch here for rows 12-15
07618 B1 E7                               lda (AreaData),y
0761A 29 70                               and #%01110000             ;get next byte and mask out all but d6-d4
0761C 4A                        MoveAOId: lsr                        ;move d6-d4 to lower nybble
0761D 4A                                  lsr
0761E 4A                                  lsr
0761F 4A                                  lsr
07620 85 00                     NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
07622 BD 30 07                            lda AreaObjectLength,x     ;is there something stored here already?
07625 10 42                               bpl RunAObj                ;if so, branch to do its particular sub
07627 AD 2A 07                            lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
0762A CD 25 07                            cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
0762D F0 11                               beq InitRear
0762F AC 2C 07                            ldy AreaDataOffset         ;if not, get old offset of level pointer
07632 B1 E7                               lda (AreaData),y           ;and reload first byte
07634 29 0F                               and #%00001111
07636 C9 0E                               cmp #$0e                   ;row 14?
07638 D0 05                               bne LeavePar
0763A AD 28 07                            lda BackloadingFlag        ;if so, check backloading flag
0763D D0 21                               bne StrAObj                ;if set, branch to render object, else leave
0763F 60                        LeavePar: rts
07640 AD 28 07                  InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
07643 F0 0B                               beq BackColC               ;branch to column-wise check
07645 A9 00                               lda #$00                   ;if not, initialize both backloading and 
07647 8D 28 07                            sta BackloadingFlag        ;behind-renderer flags and leave
0764A 8D 29 07                            sta BehindAreaParserFlag
0764D 85 08                               sta ObjectOffset
0764F 60                        LoopCmdE: rts
07650 AC 2C 07                  BackColC: ldy AreaDataOffset         ;get first byte again
07653 B1 E7                               lda (AreaData),y
07655 29 F0                               and #%11110000             ;mask out low nybble and move high to low
07657 4A                                  lsr
07658 4A                                  lsr
07659 4A                                  lsr
0765A 4A                                  lsr
0765B CD 26 07                            cmp CurrentColumnPos       ;is this where we're at?
0765E D0 DF                               bne LeavePar               ;if not, branch to leave
07660 AD 2C 07                  StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
07663 9D 2D 07                            sta AreaObjOffsetBuffer,x
07666 20 93 75                            jsr IncAreaObjOffset       ;do sub to increment to next object data
07669 A5 00                     RunAObj:  lda $00                    ;get stored value and add offset to it
0766B 18                                  clc                        ;then use the jump engine with current contents of A
0766C 65 07                               adc $07
0766E 20 0A 6E                            jsr JumpEngine
07671                           
07671                           ;large objects (rows $00-$0b or 00-11, d6-d4 set)
07671 EF 78                           .dw VerticalPipe         ;used by warp pipes
07673 4A 77                           .dw AreaStyleObject
07675 38 7A                           .dw RowOfBricks
07677 48 7A                           .dw RowOfSolidBlocks
07679 FC 79                           .dw RowOfCoins
0767B 5A 7A                           .dw ColumnOfBricks
0767D 63 7A                           .dw ColumnOfSolidBlocks
0767F EF 78                           .dw VerticalPipe         ;used by decoration pipes
07681                           
07681                           ;objects for special row $0c or 12
07681 4B 7B                           .dw Hole_Empty
07683 C4 77                           .dw PulleyRopeObject
07685 83 79                           .dw Bridge_High
07687 86 79                           .dw Bridge_Middle
07689 89 79                           .dw Bridge_Low
0768B 61 79                           .dw Hole_Water
0768D 72 79                           .dw QuestionBlockRow_High
0768F 75 79                           .dw QuestionBlockRow_Low
07691                           
07691                           ;objects for special row $0f or 15
07691 DA 79                           .dw EndlessRope
07693 E1 79                           .dw BalancePlatRope
07695 10 78                           .dw CastleObject
07697 C1 7A                           .dw StaircaseObject
07699 B5 78                           .dw ExitPipe
0769B 9E 79                           .dw FlagBalls_Residual
0769D                           
0769D                           ;small objects (rows $00-$0b or 00-11, d6-d4 all clear)
0769D 18 7B                           .dw QuestionBlock     ;power-up
0769F 18 7B                           .dw QuestionBlock     ;coin
076A1 18 7B                           .dw QuestionBlock     ;hidden, coin
076A3 0B 7B                           .dw Hidden1UpBlock    ;hidden, 1-up
076A5 23 7B                           .dw BrickWithItem     ;brick, power-up
076A7 23 7B                           .dw BrickWithItem     ;brick, vine
076A9 23 7B                           .dw BrickWithItem     ;brick, star
076AB 1E 7B                           .dw BrickWithCoins    ;brick, coins
076AD 23 7B                           .dw BrickWithItem     ;brick, 1-up
076AF 79 78                           .dw WaterPipe
076B1 23 7A                           .dw EmptyBlock
076B3 DD 7A                           .dw Jumpspring
076B5                           
076B5                           ;objects for special row $0d or 13 (d6 set)
076B5 8C 78                           .dw IntroPipe
076B7 A8 79                           .dw FlagpoleObject
076B9 13 7A                           .dw AxeObj
076BB 18 7A                           .dw ChainObj
076BD 0B 7A                           .dw CastleBridgeObj
076BF FC 76                           .dw ScrollLockObject_Warp
076C1 17 77                           .dw ScrollLockObject
076C3 17 77                           .dw ScrollLockObject
076C5 35 77                           .dw AreaFrenzy            ;flying cheep-cheeps 
076C7 35 77                           .dw AreaFrenzy            ;bullet bills or swimming cheep-cheeps
076C9 35 77                           .dw AreaFrenzy            ;stop frenzy
076CB 4F 76                           .dw LoopCmdE
076CD                           
076CD                           ;object for special row $0e or 14
076CD CF 76                           .dw AlterAreaAttributes
076CF                           
076CF                           ;-------------------------------------------------------------------------------------
076CF                           ;(these apply to all area object subroutines in this section unless otherwise stated)
076CF                           ;$00 - used to store offset used to find object code
076CF                           ;$07 - starts with adder from area parser, used to store row offset
076CF                           
076CF                           AlterAreaAttributes:
076CF BC 2D 07                           ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
076D2 C8                                 iny                       ;load second byte
076D3 B1 E7                              lda (AreaData),y
076D5 48                                 pha                       ;save in stack for now
076D6 29 40                              and #%01000000
076D8 D0 12                              bne Alter2                ;branch if d6 is set
076DA 68                                 pla
076DB 48                                 pha                       ;pull and push offset to copy to A
076DC 29 0F                              and #%00001111            ;mask out high nybble and store as
076DE 8D 27 07                           sta TerrainControl        ;new terrain height type bits
076E1 68                                 pla
076E2 29 30                              and #%00110000            ;pull and mask out all but d5 and d4
076E4 4A                                 lsr                       ;move bits to lower nybble and store
076E5 4A                                 lsr                       ;as new background scenery bits
076E6 4A                                 lsr
076E7 4A                                 lsr
076E8 8D 42 07                           sta BackgroundScenery     ;then leave
076EB 60                                 rts
076EC 68                        Alter2:  pla
076ED 29 07                              and #%00000111            ;mask out all but 3 LSB
076EF C9 04                              cmp #$04                  ;if four or greater, set color control bits
076F1 90 05                              bcc SetFore               ;and nullify foreground scenery bits
076F3 8D 44 07                           sta BackgroundColorCtrl
076F6 A9 00                              lda #$00
076F8 8D 41 07                  SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
076FB 60                                 rts
076FC                           
076FC                           ;--------------------------------
076FC                           
076FC                           ScrollLockObject_Warp:
076FC A2 04                              ldx #$04            ;load value of 4 for game text routine as default
076FE AD 5F 07                           lda WorldNumber     ;warp zone (4-3-2), then check world number
07701 F0 08                              beq WarpNum
07703 E8                                 inx                 ;if world number > 1, increment for next warp zone (5)
07704 AC 4E 07                           ldy AreaType        ;check area type
07707 88                                 dey
07708 D0 01                              bne WarpNum         ;if ground area type, increment for last warp zone
0770A E8                                 inx                 ;(8-7-6) and move on
0770B 8A                        WarpNum: txa
0770C 8D D6 06                           sta WarpZoneControl ;store number here to be used by warp zone routine
0770F 20 0E 68                           jsr WriteGameText   ;print text and warp zone numbers
07712 A9 0D                              lda #PiranhaPlant
07714 20 20 77                           jsr KillEnemies     ;load identifier for piranha plants and do sub
07717                           
07717                           ScrollLockObject:
07717 AD 23 07                        lda ScrollLock      ;invert scroll lock to turn it on
0771A 49 01                           eor #%00000001
0771C 8D 23 07                        sta ScrollLock
0771F 60                              rts
07720                           
07720                           ;--------------------------------
07720                           ;$00 - used to store enemy identifier in KillEnemies
07720                           
07720                           KillEnemies:
07720 85 00                                sta $00           ;store identifier here
07722 A9 00                                lda #$00
07724 A2 04                                ldx #$04          ;check for identifier in enemy object buffer
07726 B4 16                     KillELoop: ldy Enemy_ID,x
07728 C4 00                                cpy $00           ;if not found, branch
0772A D0 02                                bne NoKillE
0772C 95 0F                                sta Enemy_Flag,x  ;if found, deactivate enemy object flag
0772E CA                        NoKillE:   dex               ;do this until all slots are checked
0772F 10 F5                                bpl KillELoop
07731 60                                   rts
07732                           
07732                           ;--------------------------------
07732                           
07732                           FrenzyIDData:
07732 14 17 18                        .db FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
07735                           
07735 A6 00                     AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
07737 BD 2A 77                               lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
0773A A0 05                                  ldy #$05
0773C 88                        FreCompLoop: dey                   ;check regular slots of enemy object buffer
0773D 30 07                                  bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
0773F D9 16 00                               cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
07742 D0 F8                                  bne FreCompLoop
07744 A9 00                                  lda #$00              ;if enemy object already present, nullify queue and leave
07746 8D CD 06                  ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
07749 60                                     rts
0774A                           
0774A                           ;--------------------------------
0774A                           ;$06 - used by MushroomLedge to store length
0774A                           
0774A                           AreaStyleObject:
0774A AD 33 07                        lda AreaStyle        ;load level object style and jump to the right sub
0774D 20 0A 6E                        jsr JumpEngine 
07750 56 77                           .dw TreeLedge        ;also used for cloud type levels
07752 82 77                           .dw MushroomLedge
07754 73 7A                           .dw BulletBillCannon
07756                           
07756                           TreeLedge:
07756 20 C5 7B                            jsr GetLrgObjAttrib     ;get row and length of green ledge
07759 BD 30 07                            lda AreaObjectLength,x  ;check length counter for expiration
0775C F0 1F                               beq EndTreeL   
0775E 10 11                               bpl MidTreeL
07760 98                                  tya
07761 9D 30 07                            sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
07764 AD 25 07                            lda CurrentPageLoc
07767 0D 26 07                            ora CurrentColumnPos    ;are we at the start of the level?
0776A F0 05                               beq MidTreeL
0776C A9 16                               lda #$16                ;render start of tree ledge
0776E 4C BA 77                            jmp NoUnder
07771 A6 07                     MidTreeL: ldx $07
07773 A9 17                               lda #$17                ;render middle of tree ledge
07775 9D A1 06                            sta MetatileBuffer,x    ;note that this is also used if ledge position is
07778 A9 4C                               lda #$4c                ;at the start of level for continuous effect
0777A 4C B4 77                            jmp AllUnder            ;now render the part underneath
0777D A9 18                     EndTreeL: lda #$18                ;render end of tree ledge
0777F 4C BA 77                            jmp NoUnder
07782                           
07782                           MushroomLedge:
07782 20 B6 7B                            jsr ChkLrgObjLength        ;get shroom dimensions
07785 84 06                               sty $06                    ;store length here for now
07787 90 0C                               bcc EndMushL
07789 BD 30 07                            lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
0778C 4A                                  lsr
0778D 9D 36 07                            sta MushroomLedgeHalfLen,x
07790 A9 19                               lda #$19                   ;render start of mushroom
07792 4C BA 77                            jmp NoUnder
07795 A9 1B                     EndMushL: lda #$1b                   ;if at the end, render end of mushroom
07797 BC 30 07                            ldy AreaObjectLength,x
0779A F0 1E                               beq NoUnder
0779C BD 36 07                            lda MushroomLedgeHalfLen,x ;get divided length and store where length
0779F 85 06                               sta $06                    ;was stored originally
077A1 A6 07                               ldx $07
077A3 A9 1A                               lda #$1a
077A5 9D A1 06                            sta MetatileBuffer,x       ;render middle of mushroom
077A8 C4 06                               cpy $06                    ;are we smack dab in the center?
077AA D0 2C                               bne MushLExit              ;if not, branch to leave
077AC E8                                  inx
077AD A9 4F                               lda #$4f
077AF 9D A1 06                            sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
077B2 A9 50                               lda #$50
077B4 E8                        AllUnder: inx
077B5 A0 0F                               ldy #$0f                   ;set $0f to render all way down
077B7 4C 87 7B                            jmp RenderUnderPart       ;now render the stem of mushroom
077BA A6 07                     NoUnder:  ldx $07                    ;load row of ledge
077BC A0 00                               ldy #$00                   ;set 0 for no bottom on this part
077BE 4C 87 7B                            jmp RenderUnderPart
077C1                           
077C1                           ;--------------------------------
077C1                           
077C1                           ;tiles used by pulleys and rope object
077C1                           PulleyRopeMetatiles:
077C1 42 41 43                        .db $42, $41, $43
077C4                           
077C4                           PulleyRopeObject:
077C4 20 B6 7B                             jsr ChkLrgObjLength       ;get length of pulley/rope object
077C7 A0 00                                ldy #$00                  ;initialize metatile offset
077C9 B0 07                                bcs RenderPul             ;if starting, render left pulley
077CB C8                                   iny
077CC BD 30 07                             lda AreaObjectLength,x    ;if not at the end, render rope
077CF D0 01                                bne RenderPul
077D1 C8                                   iny                       ;otherwise render right pulley
077D2 B9 C1 77                  RenderPul: lda PulleyRopeMetatiles,y
077D5 8D A1 06                             sta MetatileBuffer        ;render at the top of the screen
077D8 60                        MushLExit: rts                       ;and leave
077D9                           
077D9                           ;--------------------------------
077D9                           ;$06 - used to store upper limit of rows for CastleObject
077D9                           
077D9                           CastleMetatiles:
077D9 00 45 45 45 00                  .db $00, $45, $45, $45, $00
077DE 00 48 47 46 00                  .db $00, $48, $47, $46, $00
077E3 45 49 49 49 45                  .db $45, $49, $49, $49, $45
077E8 47 47 4A 47 47                  .db $47, $47, $4a, $47, $47
077ED 47 47 4B 47 47                  .db $47, $47, $4b, $47, $47
077F2 49 49 49 49 49                  .db $49, $49, $49, $49, $49
077F7 47 4A 47 4A 47                  .db $47, $4a, $47, $4a, $47
077FC 47 4B 47 4B 47                  .db $47, $4b, $47, $4b, $47
07801 47 47 47 47 47                  .db $47, $47, $47, $47, $47
07806 4A 47 4A 47 4A                  .db $4a, $47, $4a, $47, $4a
0780B 4B 47 4B 47 4B                  .db $4b, $47, $4b, $47, $4b
07810                           
07810                           CastleObject:
07810 20 C5 7B                              jsr GetLrgObjAttrib      ;save lower nybble as starting row
07813 84 07                                 sty $07                  ;if starting row is above $0a, game will crash!!!
07815 A0 04                                 ldy #$04
07817 20 B9 7B                              jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
0781A 8A                                    txa                  
0781B 48                                    pha                      ;save obj buffer offset to stack
0781C BC 30 07                              ldy AreaObjectLength,x   ;use current length as offset for castle data
0781F A6 07                                 ldx $07                  ;begin at starting row
07821 A9 0B                                 lda #$0b
07823 85 06                                 sta $06                  ;load upper limit of number of rows to print
07825 B9 D9 77                  CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
07828 9D A1 06                              sta MetatileBuffer,x
0782B E8                                    inx                      ;store in buffer and increment buffer offset
0782C A5 06                                 lda $06
0782E F0 07                                 beq ChkCFloor            ;have we reached upper limit yet?
07830 C8                                    iny                      ;if not, increment column-wise
07831 C8                                    iny                      ;to byte in next row
07832 C8                                    iny
07833 C8                                    iny
07834 C8                                    iny
07835 C6 06                                 dec $06                  ;move closer to upper limit
07837 E0 0B                     ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
07839 D0 EA                                 bne CRendLoop            ;if not, go back and do another row
0783B 68                                    pla
0783C AA                                    tax                      ;get obj buffer offset from before
0783D AD 25 07                              lda CurrentPageLoc
07840 F0 36                                 beq ExitCastle           ;if we're at page 0, we do not need to do anything else
07842 BD 30 07                              lda AreaObjectLength,x   ;check length
07845 C9 01                                 cmp #$01                 ;if length almost about to expire, put brick at floor
07847 F0 2A                                 beq PlayerStop
07849 A4 07                                 ldy $07                  ;check starting row for tall castle ($00)
0784B D0 04                                 bne NotTall
0784D C9 03                                 cmp #$03                 ;if found, then check to see if we're at the second column
0784F F0 22                                 beq PlayerStop
07851 C9 02                     NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
07853 D0 23                                 bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
07855 20 D5 7B                              jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
07858 48                                    pha
07859 20 54 79                              jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
0785C 68                                    pla
0785D 95 87                                 sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
0785F AD 25 07                              lda CurrentPageLoc
07862 95 6E                                 sta Enemy_PageLoc,x      ;set page location for star flag
07864 A9 01                                 lda #$01
07866 95 B6                                 sta Enemy_Y_HighPos,x    ;set vertical high byte
07868 95 0F                                 sta Enemy_Flag,x         ;set flag for buffer
0786A A9 90                                 lda #$90
0786C 95 CF                                 sta Enemy_Y_Position,x   ;set vertical coordinate
0786E A9 31                                 lda #StarFlagObject      ;set star flag value in buffer itself
07870 95 16                                 sta Enemy_ID,x
07872 60                                    rts
07873 A0 52                     PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
07875 8C AB 06                              sty MetatileBuffer+10    ;this is only done if we're on the second column
07878 60                        ExitCastle: rts
07879                           
07879                           ;--------------------------------
07879                           
07879                           WaterPipe:
07879 20 C5 7B                        jsr GetLrgObjAttrib     ;get row and lower nybble
0787C BC 30 07                        ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
0787F A6 07                           ldx $07                 ;get row
07881 A9 6B                           lda #$6b
07883 9D A1 06                        sta MetatileBuffer,x    ;draw something here and below it
07886 A9 6C                           lda #$6c
07888 9D A2 06                        sta MetatileBuffer+1,x
0788B 60                              rts
0788C                           
0788C                           ;--------------------------------
0788C                           ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
0788C                           ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
0788C                           ; and vertical length in VerticalPipe and GetPipeHeight
0788C                           
0788C                           IntroPipe:
0788C A0 03                                    ldy #$03                 ;check if length set, if not set, set it
0788E 20 B9 7B                                 jsr ChkLrgObjFixedLength
07891 A0 0A                                    ldy #$0a                 ;set fixed value and render the sideways part
07893 20 BD 78                                 jsr RenderSidewaysPipe
07896 B0 10                                    bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
07898 A2 06                                    ldx #$06                 ;blank everything above the vertical pipe part
0789A A9 00                     VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
0789C 9D A1 06                                 sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
0789F CA                                       dex
078A0 10 F8                                    bpl VPipeSectLoop
078A2 B9 E7 78                                 lda VerticalPipeData,y   ;draw the end of the vertical pipe part
078A5 8D A8 06                                 sta MetatileBuffer+7
078A8 60                        NoBlankP:      rts
078A9                           
078A9                           SidePipeShaftData:
078A9 15 14                           .db $15, $14  ;used to control whether or not vertical pipe shaft
078AB 00 00                           .db $00, $00  ;is drawn, and if so, controls the metatile number
078AD                           SidePipeTopPart:
078AD 15 1E                           .db $15, $1e  ;top part of sideways part of pipe
078AF 1D 1C                           .db $1d, $1c
078B1                           SidePipeBottomPart: 
078B1 15 21                           .db $15, $21  ;bottom part of sideways part of pipe
078B3 20 1F                           .db $20, $1f
078B5                           
078B5                           ExitPipe:
078B5 A0 03                           ldy #$03                 ;check if length set, if not set, set it
078B7 20 B9 7B                        jsr ChkLrgObjFixedLength
078BA 20 C5 7B                        jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
078BD                           
078BD                           RenderSidewaysPipe:
078BD 88                                      dey                       ;decrement twice to make room for shaft at bottom
078BE 88                                      dey                       ;and store here for now as vertical length
078BF 84 05                                   sty $05
078C1 BC 30 07                                ldy AreaObjectLength,x    ;get length left over and store here
078C4 84 06                                   sty $06
078C6 A6 05                                   ldx $05                   ;get vertical length plus one, use as buffer offset
078C8 E8                                      inx
078C9 B9 A9 78                                lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
078CC C9 00                                   cmp #$00
078CE F0 08                                   beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
078D0 A2 00                                   ldx #$00
078D2 A4 05                                   ldy $05                   ;init buffer offset and get vertical length
078D4 20 87 7B                                jsr RenderUnderPart       ;and render vertical shaft using tile number in A
078D7 18                                      clc                       ;clear carry flag to be used by IntroPipe
078D8 A4 06                     DrawSidePart: ldy $06                   ;render side pipe part at the bottom
078DA B9 AD 78                                lda SidePipeTopPart,y
078DD 9D A1 06                                sta MetatileBuffer,x      ;note that the pipe parts are stored
078E0 B9 B1 78                                lda SidePipeBottomPart,y  ;backwards horizontally
078E3 9D A2 06                                sta MetatileBuffer+1,x
078E6 60                                      rts
078E7                           
078E7                           VerticalPipeData:
078E7 11 10                           .db $11, $10 ;used by pipes that lead somewhere
078E9 15 14                           .db $15, $14
078EB 13 12                           .db $13, $12 ;used by decoration pipes
078ED 15 14                           .db $15, $14
078EF                           
078EF                           VerticalPipe:
078EF 20 43 79                            jsr GetPipeHeight
078F2 A5 00                               lda $00                  ;check to see if value was nullified earlier
078F4 F0 04                               beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
078F6 C8                                  iny
078F7 C8                                  iny
078F8 C8                                  iny
078F9 C8                                  iny                      ;add four if usage control bit was not set
078FA 98                        WarpPipe: tya                      ;save value in stack
078FB 48                                  pha
078FC AD 60 07                            lda AreaNumber
078FF 0D 5F 07                            ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
07902 F0 2B                               beq DrawPipe
07904 BC 30 07                            ldy AreaObjectLength,x   ;if on second column of pipe, branch
07907 F0 26                               beq DrawPipe             ;(because we only need to do this once)
07909 20 54 79                            jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
0790C B0 21                               bcs DrawPipe             ;if not found, too many enemies, thus skip
0790E 20 D5 7B                            jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
07911 18                                  clc
07912 69 08                               adc #$08                 ;add eight to put the piranha plant in the center
07914 95 87                               sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
07916 AD 25 07                            lda CurrentPageLoc       ;add carry to current page number
07919 69 00                               adc #$00
0791B 95 6E                               sta Enemy_PageLoc,x      ;store as enemy's page coordinate
0791D A9 01                               lda #$01
0791F 95 B6                               sta Enemy_Y_HighPos,x
07921 95 0F                               sta Enemy_Flag,x         ;activate enemy flag
07923 20 DD 7B                            jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
07926 95 CF                               sta Enemy_Y_Position,x
07928 A9 0D                               lda #PiranhaPlant        ;write piranha plant's value into buffer
0792A 95 16                               sta Enemy_ID,x
0792C 20 8F A7                            jsr InitPiranhaPlant
0792F 68                        DrawPipe: pla                      ;get value saved earlier and use as Y
07930 A8                                  tay
07931 A6 07                               ldx $07                  ;get buffer offset
07933 B9 E7 78                            lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
07936 9D A1 06                            sta MetatileBuffer,x     ;render the top of the pipe
07939 E8                                  inx
0793A B9 E9 78                            lda VerticalPipeData+2,y ;render the rest of the pipe
0793D A4 06                               ldy $06                  ;subtract one from length and render the part underneath
0793F 88                                  dey
07940 4C 87 7B                            jmp RenderUnderPart
07943                                 
07943                           GetPipeHeight:
07943 A0 01                           ldy #$01       ;check for length loaded, if not, load
07945 20 B9 7B                        jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
07948 20 C5 7B                        jsr GetLrgObjAttrib
0794B 98                              tya            ;get saved lower nybble as height
0794C 29 07                           and #$07       ;save only the three lower bits as
0794E 85 06                           sta $06        ;vertical length, then load Y with
07950 BC 30 07                        ldy AreaObjectLength,x    ;length left over
07953 60                              rts
07954                           
07954                           FindEmptyEnemySlot:
07954 A2 00                                   ldx #$00          ;start at first enemy slot
07956 18                        EmptyChkLoop: clc               ;clear carry flag by default
07957 B5 0F                                   lda Enemy_Flag,x  ;check enemy buffer for nonzero
07959 F0 05                                   beq ExitEmptyChk  ;if zero, leave
0795B E8                                      inx
0795C E0 05                                   cpx #$05          ;if nonzero, check next value
0795E D0 F6                                   bne EmptyChkLoop
07960 60                        ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
07961                           
07961                           ;--------------------------------
07961                           
07961                           Hole_Water:
07961 20 B6 7B                        jsr ChkLrgObjLength   ;get low nybble and save as length
07964 A9 86                           lda #$86              ;render waves
07966 8D AB 06                        sta MetatileBuffer+10
07969 A2 0B                           ldx #$0b
0796B A0 01                           ldy #$01              ;now render the water underneath
0796D A9 87                           lda #$87
0796F 4C 87 7B                        jmp RenderUnderPart
07972                           
07972                           ;--------------------------------
07972                           
07972                           QuestionBlockRow_High:
07972 A9 03                           lda #$03    ;start on the fourth row
07974 2C                              .db $2c     ;BIT instruction opcode
07975                           
07975                           QuestionBlockRow_Low:
07975 A9 07                           lda #$07             ;start on the eighth row
07977 48                              pha                  ;save whatever row to the stack for now
07978 20 B6 7B                        jsr ChkLrgObjLength  ;get low nybble and save as length
0797B 68                              pla
0797C AA                              tax                  ;render question boxes with coins
0797D A9 C0                           lda #$c0
0797F 9D A1 06                        sta MetatileBuffer,x
07982 60                              rts
07983                           
07983                           ;--------------------------------
07983                           
07983                           Bridge_High:
07983 A9 06                           lda #$06  ;start on the seventh row from top of screen
07985 2C                              .db $2c   ;BIT instruction opcode
07986                           
07986                           Bridge_Middle:
07986 A9 07                           lda #$07  ;start on the eighth row
07988 2C                              .db $2c   ;BIT instruction opcode
07989                           
07989                           Bridge_Low:
07989 A9 09                           lda #$09             ;start on the tenth row
0798B 48                              pha                  ;save whatever row to the stack for now
0798C 20 B6 7B                        jsr ChkLrgObjLength  ;get low nybble and save as length
0798F 68                              pla
07990 AA                              tax                  ;render bridge railing
07991 A9 0B                           lda #$0b
07993 9D A1 06                        sta MetatileBuffer,x
07996 E8                              inx
07997 A0 00                           ldy #$00             ;now render the bridge itself
07999 A9 63                           lda #$63
0799B 4C 87 7B                        jmp RenderUnderPart
0799E                           
0799E                           ;--------------------------------
0799E                           
0799E                           FlagBalls_Residual:
0799E 20 C5 7B                        jsr GetLrgObjAttrib  ;get low nybble from object byte
079A1 A2 02                           ldx #$02             ;render flag balls on third row from top
079A3 A9 6D                           lda #$6d             ;of screen downwards based on low nybble
079A5 4C 87 7B                        jmp RenderUnderPart
079A8                           
079A8                           ;--------------------------------
079A8                           
079A8                           FlagpoleObject:
079A8 A9 24                           lda #$24                 ;render flagpole ball on top
079AA 8D A1 06                        sta MetatileBuffer
079AD A2 01                           ldx #$01                 ;now render the flagpole shaft
079AF A0 08                           ldy #$08
079B1 A9 25                           lda #$25
079B3 20 87 7B                        jsr RenderUnderPart
079B6 A9 61                           lda #$61                 ;render solid block at the bottom
079B8 8D AB 06                        sta MetatileBuffer+10
079BB 20 D5 7B                        jsr GetAreaObjXPosition
079BE 38                              sec                      ;get pixel coordinate of where the flagpole is,
079BF E9 08                           sbc #$08                 ;subtract eight pixels and use as horizontal
079C1 85 8C                           sta Enemy_X_Position+5   ;coordinate for the flag
079C3 AD 25 07                        lda CurrentPageLoc
079C6 E9 00                           sbc #$00                 ;subtract borrow from page location and use as
079C8 85 73                           sta Enemy_PageLoc+5      ;page location for the flag
079CA A9 30                           lda #$30
079CC 85 D4                           sta Enemy_Y_Position+5   ;set vertical coordinate for flag
079CE A9 B0                           lda #$b0
079D0 8D 0D 01                        sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
079D3 A9 30                           lda #FlagpoleFlagObject
079D5 85 1B                           sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
079D7 E6 14                           inc Enemy_Flag+5         ;use last space in enemy object buffer
079D9 60                              rts
079DA                           
079DA                           ;--------------------------------
079DA                           
079DA                           EndlessRope:
079DA A2 00                           ldx #$00       ;render rope from the top to the bottom of screen
079DC A0 0F                           ldy #$0f
079DE 4C F3 79                        jmp DrawRope
079E1                           
079E1                           BalancePlatRope:
079E1 8A                                  txa                 ;save object buffer offset for now
079E2 48                                  pha
079E3 A2 01                               ldx #$01            ;blank out all from second row to the bottom
079E5 A0 0F                               ldy #$0f            ;with blank used for balance platform rope
079E7 A9 44                               lda #$44
079E9 20 87 7B                            jsr RenderUnderPart
079EC 68                                  pla                 ;get back object buffer offset
079ED AA                                  tax
079EE 20 C5 7B                            jsr GetLrgObjAttrib ;get vertical length from lower nybble
079F1 A2 01                               ldx #$01
079F3 A9 40                     DrawRope: lda #$40            ;render the actual rope
079F5 4C 87 7B                            jmp RenderUnderPart
079F8                           
079F8                           ;--------------------------------
079F8                           
079F8                           CoinMetatileData:
079F8 C3 C2 C2 C2                     .db $c3, $c2, $c2, $c2
079FC                           
079FC                           RowOfCoins:
079FC AC 4E 07                        ldy AreaType            ;get area type
079FF B9 F8 79                        lda CoinMetatileData,y  ;load appropriate coin metatile
07A02 4C 4E 7A                        jmp GetRow
07A05                           
07A05                           ;--------------------------------
07A05                           
07A05                           C_ObjectRow:
07A05 06 07 08                        .db $06, $07, $08
07A08                           
07A08                           C_ObjectMetatile:
07A08 C5 0C 89                        .db $c5, $0c, $89
07A0B                           
07A0B                           CastleBridgeObj:
07A0B A0 0C                           ldy #$0c                  ;load length of 13 columns
07A0D 20 B9 7B                        jsr ChkLrgObjFixedLength
07A10 4C 18 7A                        jmp ChainObj
07A13                           
07A13                           AxeObj:
07A13 A9 08                           lda #$08                  ;load bowser's palette into sprite portion of palette
07A15 8D 73 07                        sta VRAM_Buffer_AddrCtrl
07A18                           
07A18                           ChainObj:
07A18 A4 00                           ldy $00                   ;get value loaded earlier from decoder
07A1A BE 03 7A                        ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
07A1D B9 06 7A                        lda C_ObjectMetatile-2,y
07A20 4C 2A 7A                        jmp ColObj
07A23                           
07A23                           EmptyBlock:
07A23 20 C5 7B                          jsr GetLrgObjAttrib  ;get row location
07A26 A6 07                             ldx $07
07A28 A9 C4                             lda #$c4
07A2A A0 00                     ColObj: ldy #$00             ;column length of 1
07A2C 4C 87 7B                          jmp RenderUnderPart
07A2F                           
07A2F                           ;--------------------------------
07A2F                           
07A2F                           SolidBlockMetatiles:
07A2F 69 61 61 62                     .db $69, $61, $61, $62
07A33                           
07A33                           BrickMetatiles:
07A33 22 51 52 52                     .db $22, $51, $52, $52
07A37 88                              .db $88 ;used only by row of bricks object
07A38                           
07A38                           RowOfBricks:
07A38 AC 4E 07                              ldy AreaType           ;load area type obtained from area offset pointer
07A3B AD 43 07                              lda CloudTypeOverride  ;check for cloud type override
07A3E F0 02                                 beq DrawBricks
07A40 A0 04                                 ldy #$04               ;if cloud type, override area type
07A42 B9 33 7A                  DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
07A45 4C 4E 7A                              jmp GetRow             ;and go render it
07A48                           
07A48                           RowOfSolidBlocks:
07A48 AC 4E 07                           ldy AreaType               ;load area type obtained from area offset pointer
07A4B B9 2F 7A                           lda SolidBlockMetatiles,y  ;get metatile
07A4E 48                        GetRow:  pha                        ;store metatile here
07A4F 20 B6 7B                           jsr ChkLrgObjLength        ;get row number, load length
07A52 A6 07                     DrawRow: ldx $07
07A54 A0 00                              ldy #$00                   ;set vertical height of 1
07A56 68                                 pla
07A57 4C 87 7B                           jmp RenderUnderPart        ;render object
07A5A                           
07A5A                           ColumnOfBricks:
07A5A AC 4E 07                        ldy AreaType          ;load area type obtained from area offset
07A5D B9 33 7A                        lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
07A60 4C 69 7A                        jmp GetRow2
07A63                           
07A63                           ColumnOfSolidBlocks:
07A63 AC 4E 07                           ldy AreaType               ;load area type obtained from area offset
07A66 B9 2F 7A                           lda SolidBlockMetatiles,y  ;get metatile
07A69 48                        GetRow2: pha                        ;save metatile to stack for now
07A6A 20 C5 7B                           jsr GetLrgObjAttrib        ;get length and row
07A6D 68                                 pla                        ;restore metatile
07A6E A6 07                              ldx $07                    ;get starting row
07A70 4C 87 7B                           jmp RenderUnderPart        ;now render the column
07A73                           
07A73                           ;--------------------------------
07A73                           
07A73                           BulletBillCannon:
07A73 20 C5 7B                               jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
07A76 A6 07                                  ldx $07                  ;start at first row
07A78 A9 64                                  lda #$64                 ;render bullet bill cannon
07A7A 9D A1 06                               sta MetatileBuffer,x
07A7D E8                                     inx
07A7E 88                                     dey                      ;done yet?
07A7F 30 0E                                  bmi SetupCannon
07A81 A9 65                                  lda #$65                 ;if not, render middle part
07A83 9D A1 06                               sta MetatileBuffer,x
07A86 E8                                     inx
07A87 88                                     dey                      ;done yet?
07A88 30 05                                  bmi SetupCannon
07A8A A9 66                                  lda #$66                 ;if not, render bottom until length expires
07A8C 20 87 7B                               jsr RenderUnderPart
07A8F AE 6A 04                  SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
07A92 20 DD 7B                               jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
07A95 9D 77 04                               sta Cannon_Y_Position,x  ;and store it here
07A98 AD 25 07                               lda CurrentPageLoc
07A9B 9D 6B 04                               sta Cannon_PageLoc,x     ;store page number for cannon here
07A9E 20 D5 7B                               jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
07AA1 9D 71 04                               sta Cannon_X_Position,x  ;and store it here
07AA4 E8                                     inx
07AA5 E0 06                                  cpx #$06                 ;increment and check offset
07AA7 90 02                                  bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
07AA9 A2 00                                  ldx #$00                 ;otherwise initialize it
07AAB 8E 6A 04                  StrCOffset:  stx Cannon_Offset        ;save new offset and leave
07AAE 60                                     rts
07AAF                           
07AAF                           ;--------------------------------
07AAF                           
07AAF                           StaircaseHeightData:
07AAF 07 07 06 05 04 03 02 01..       .db $07, $07, $06, $05, $04, $03, $02, $01, $00
07AB8                           
07AB8                           StaircaseRowData:
07AB8 03 03 04 05 06 07 08 09..       .db $03, $03, $04, $05, $06, $07, $08, $09, $0a
07AC1                           
07AC1                           StaircaseObject:
07AC1 20 B6 7B                             jsr ChkLrgObjLength       ;check and load length
07AC4 90 05                                bcc NextStair             ;if length already loaded, skip init part
07AC6 A9 09                                lda #$09                  ;start past the end for the bottom
07AC8 8D 34 07                             sta StaircaseControl      ;of the staircase
07ACB CE 34 07                  NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
07ACE AC 34 07                             ldy StaircaseControl
07AD1 BE B8 7A                             ldx StaircaseRowData,y    ;get starting row and height to render
07AD4 B9 AF 7A                             lda StaircaseHeightData,y
07AD7 A8                                   tay
07AD8 A9 61                                lda #$61                  ;now render solid block staircase
07ADA 4C 87 7B                             jmp RenderUnderPart
07ADD                           
07ADD                           ;--------------------------------
07ADD                           
07ADD                           Jumpspring:
07ADD 20 C5 7B                        jsr GetLrgObjAttrib
07AE0 20 54 79                        jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
07AE3 20 D5 7B                        jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
07AE6 95 87                           sta Enemy_X_Position,x      ;and store
07AE8 AD 25 07                        lda CurrentPageLoc          ;store page location of jumpspring
07AEB 95 6E                           sta Enemy_PageLoc,x
07AED 20 DD 7B                        jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
07AF0 95 CF                           sta Enemy_Y_Position,x      ;and store
07AF2 95 58                           sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
07AF4 A9 32                           lda #JumpspringObject
07AF6 95 16                           sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
07AF8 A0 01                           ldy #$01
07AFA 94 B6                           sty Enemy_Y_HighPos,x       ;store vertical high byte
07AFC F6 0F                           inc Enemy_Flag,x            ;set flag for enemy object buffer
07AFE A6 07                           ldx $07
07B00 A9 67                           lda #$67                    ;draw metatiles in two rows where jumpspring is
07B02 9D A1 06                        sta MetatileBuffer,x
07B05 A9 68                           lda #$68
07B07 9D A2 06                        sta MetatileBuffer+1,x
07B0A 60                              rts
07B0B                           
07B0B                           ;--------------------------------
07B0B                           ;$07 - used to save ID of brick object
07B0B                           
07B0B                           Hidden1UpBlock:
07B0B AD 5D 07                        lda Hidden1UpFlag  ;if flag not set, do not render object
07B0E F0 36                           beq ExitDecBlock
07B10 A9 00                           lda #$00           ;if set, init for the next one
07B12 8D 5D 07                        sta Hidden1UpFlag
07B15 4C 23 7B                        jmp BrickWithItem  ;jump to code shared with unbreakable bricks
07B18                           
07B18                           QuestionBlock:
07B18 20 40 7B                        jsr GetAreaObjectID ;get value from level decoder routine
07B1B 4C 36 7B                        jmp DrawQBlk        ;go to render it
07B1E                           
07B1E                           BrickWithCoins:
07B1E A9 00                           lda #$00                 ;initialize multi-coin timer flag
07B20 8D BC 06                        sta BrickCoinTimerFlag
07B23                           
07B23                           BrickWithItem:
07B23 20 40 7B                            jsr GetAreaObjectID         ;save area object ID
07B26 84 07                               sty $07              
07B28 A9 00                               lda #$00                    ;load default adder for bricks with lines
07B2A AC 4E 07                            ldy AreaType                ;check level type for ground level
07B2D 88                                  dey
07B2E F0 02                               beq BWithL                  ;if ground type, do not start with 5
07B30 A9 05                               lda #$05                    ;otherwise use adder for bricks without lines
07B32 18                        BWithL:   clc                         ;add object ID to adder
07B33 65 07                               adc $07
07B35 A8                                  tay                         ;use as offset for metatile
07B36 B9 F0 9D                  DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
07B39 48                                  pha                         ;if branched to here from question block routine)
07B3A 20 C5 7B                            jsr GetLrgObjAttrib         ;get row from location byte
07B3D 4C 52 7A                            jmp DrawRow                 ;now render the object
07B40                           
07B40                           GetAreaObjectID:
07B40 A5 00                                   lda $00    ;get value saved from area parser routine
07B42 38                                      sec
07B43 E9 00                                   sbc #$00   ;possibly residual code
07B45 A8                                      tay        ;save to Y
07B46 60                        ExitDecBlock: rts
07B47                           
07B47                           ;--------------------------------
07B47                           
07B47                           HoleMetatiles:
07B47 87 00 00 00                     .db $87, $00, $00, $00
07B4B                           
07B4B                           Hole_Empty:
07B4B 20 B6 7B                              jsr ChkLrgObjLength          ;get lower nybble and save as length
07B4E 90 2D                                 bcc NoWhirlP                 ;skip this part if length already loaded
07B50 AD 4E 07                              lda AreaType                 ;check for water type level
07B53 D0 28                                 bne NoWhirlP                 ;if not water type, skip this part
07B55 AE 6A 04                              ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
07B58 20 D5 7B                              jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
07B5B 38                                    sec
07B5C E9 10                                 sbc #$10                     ;subtract 16 pixels
07B5E 9D 71 04                              sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
07B61 AD 25 07                              lda CurrentPageLoc           ;get page location of where we're at
07B64 E9 00                                 sbc #$00                     ;subtract borrow
07B66 9D 6B 04                              sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
07B69 C8                                    iny
07B6A C8                                    iny                          ;increment length by 2
07B6B 98                                    tya
07B6C 0A                                    asl                          ;multiply by 16 to get size of whirlpool
07B6D 0A                                    asl                          ;note that whirlpool will always be
07B6E 0A                                    asl                          ;two blocks bigger than actual size of hole
07B6F 0A                                    asl                          ;and extend one block beyond each edge
07B70 9D 77 04                              sta Whirlpool_Length,x       ;save size of whirlpool here
07B73 E8                                    inx
07B74 E0 05                                 cpx #$05                     ;increment and check offset
07B76 90 02                                 bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
07B78 A2 00                                 ldx #$00                     ;otherwise initialize it
07B7A 8E 6A 04                  StrWOffset: stx Whirlpool_Offset         ;save new offset here
07B7D AE 4E 07                  NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
07B80 BD 47 7B                              lda HoleMetatiles,x          ;render the hole proper
07B83 A2 08                                 ldx #$08
07B85 A0 0F                                 ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
07B87                           
07B87                           ;--------------------------------
07B87                           
07B87                           RenderUnderPart:
07B87 8C 35 07                               sty AreaObjectHeight  ;store vertical length to render
07B8A BC A1 06                               ldy MetatileBuffer,x  ;check current spot to see if there's something
07B8D F0 18                                  beq DrawThisRow       ;we need to keep, if nothing, go ahead
07B8F C0 17                                  cpy #$17
07B91 F0 17                                  beq WaitOneRow        ;if middle part (tree ledge), wait until next row
07B93 C0 1A                                  cpy #$1a
07B95 F0 13                                  beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
07B97 C0 C0                                  cpy #$c0
07B99 F0 0C                                  beq DrawThisRow       ;if question block w/ coin, overwrite
07B9B C0 C0                                  cpy #$c0
07B9D B0 0B                                  bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
07B9F C0 54                                  cpy #$54
07BA1 D0 04                                  bne DrawThisRow       ;if cracked rock terrain, overwrite
07BA3 C9 50                                  cmp #$50
07BA5 F0 03                                  beq WaitOneRow        ;if stem top of mushroom, wait until next row
07BA7 9D A1 06                  DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
07BAA E8                        WaitOneRow:  inx
07BAB E0 0D                                  cpx #$0d              ;stop rendering if we're at the bottom of the screen
07BAD B0 06                                  bcs ExitUPartR
07BAF AC 35 07                               ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
07BB2 88                                     dey
07BB3 10 D2                                  bpl RenderUnderPart
07BB5 60                        ExitUPartR:  rts
07BB6                           
07BB6                           ;--------------------------------
07BB6                           
07BB6                           ChkLrgObjLength:
07BB6 20 C5 7B                          jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
07BB9                           
07BB9                           ChkLrgObjFixedLength:
07BB9 BD 30 07                          lda AreaObjectLength,x  ;check for set length counter
07BBC 18                                clc                     ;clear carry flag for not just starting
07BBD 10 05                             bpl LenSet              ;if counter not set, load it, otherwise leave alone
07BBF 98                                tya                     ;save length into length counter
07BC0 9D 30 07                          sta AreaObjectLength,x
07BC3 38                                sec                     ;set carry flag if just starting
07BC4 60                        LenSet: rts
07BC5                           
07BC5                           
07BC5                           GetLrgObjAttrib:
07BC5 BC 2D 07                        ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
07BC8 B1 E7                           lda (AreaData),y          ;get first byte of level object
07BCA 29 0F                           and #%00001111
07BCC 85 07                           sta $07                   ;save row location
07BCE C8                              iny
07BCF B1 E7                           lda (AreaData),y          ;get next byte, save lower nybble (length or height)
07BD1 29 0F                           and #%00001111            ;as Y, then leave
07BD3 A8                              tay
07BD4 60                              rts
07BD5                           
07BD5                           ;--------------------------------
07BD5                           
07BD5                           GetAreaObjXPosition:
07BD5 AD 26 07                        lda CurrentColumnPos    ;multiply current offset where we're at by 16
07BD8 0A                              asl                     ;to obtain horizontal pixel coordinate
07BD9 0A                              asl
07BDA 0A                              asl
07BDB 0A                              asl
07BDC 60                              rts
07BDD                           
07BDD                           ;--------------------------------
07BDD                           
07BDD                           GetAreaObjYPosition:
07BDD A5 07                           lda $07  ;multiply value by 16
07BDF 0A                              asl
07BE0 0A                              asl      ;this will give us the proper vertical pixel coordinate
07BE1 0A                              asl
07BE2 0A                              asl
07BE3 18                              clc
07BE4 69 20                           adc #32  ;add 32 pixels for the status bar
07BE6 60                              rts
07BE7                           
07BE7                           ;-------------------------------------------------------------------------------------
07BE7                           ;$06-$07 - used to store block buffer address used as indirect
07BE7                           
07BE7                           BlockBufferAddr:
07BE7 00 D0                           .db <Block_Buffer_1, <Block_Buffer_2
07BE9 05 05                           .db >Block_Buffer_1, >Block_Buffer_2
07BEB                           
07BEB                           GetBlockBufferAddr:
07BEB 48                              pha                      ;take value of A, save
07BEC 4A                              lsr                      ;move high nybble to low
07BED 4A                              lsr
07BEE 4A                              lsr
07BEF 4A                              lsr
07BF0 A8                              tay                      ;use nybble as pointer to high byte
07BF1 B9 E9 7B                        lda BlockBufferAddr+2,y  ;of indirect here
07BF4 85 07                           sta $07
07BF6 68                              pla
07BF7 29 0F                           and #%00001111           ;pull from stack, mask out high nybble
07BF9 18                              clc
07BFA 79 E7 7B                        adc BlockBufferAddr,y    ;add to low byte
07BFD 85 06                           sta $06                  ;store here and leave
07BFF 60                              rts
07C00                           
07C00                           ;-------------------------------------------------------------------------------------
07C00                           
07C00                           AreaDataOfsLoopback:
07C00 12 36 0E 0E 0E 32 32 32..       .db $12, $36, $0e, $0e, $0e, $32, $32, $32, $0a, $26, $40
07C0B                           
07C0B                           ;-------------------------------------------------------------------------------------
07C0B                           
07C0B                           LoadAreaPointer:
07C0B 20 1B 7C                               jsr FindAreaPointer  ;find it and store it here
07C0E 8D 50 07                               sta AreaPointer
07C11 29 60                     GetAreaType: and #%01100000       ;mask out all but d6 and d5
07C13 0A                                     asl
07C14 2A                                     rol
07C15 2A                                     rol
07C16 2A                                     rol                  ;make %0xx00000 into %000000xx
07C17 8D 4E 07                               sta AreaType         ;save 2 MSB as area type
07C1A 60                                     rts
07C1B                           
07C1B                           FindAreaPointer:
07C1B AC 5F 07                        ldy WorldNumber        ;load offset from world variable
07C1E B9 BC 7C                        lda WorldAddrOffsets,y
07C21 18                              clc                    ;add area number used to find data
07C22 6D 60 07                        adc AreaNumber
07C25 A8                              tay
07C26 B9 C4 7C                        lda AreaAddrOffsets,y  ;from there we have our area pointer
07C29 60                              rts
07C2A                           
07C2A                           
07C2A                           GetAreaDataAddrs:
07C2A AD 50 07                              lda AreaPointer          ;use 2 MSB for Y
07C2D 20 11 7C                              jsr GetAreaType
07C30 A8                                    tay
07C31 AD 50 07                              lda AreaPointer          ;mask out all but 5 LSB
07C34 29 1F                                 and #%00011111
07C36 8D 4F 07                              sta AreaAddrsLOffset     ;save as low offset
07C39 B9 E8 7C                              lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
07C3C 18                                    clc                      ;then add base value to 5 LSB, result
07C3D 6D 4F 07                              adc AreaAddrsLOffset     ;becomes offset for level data
07C40 A8                                    tay
07C41 B9 EC 7C                              lda EnemyDataAddrLow,y   ;use offset to load pointer
07C44 85 E9                                 sta EnemyDataLow
07C46 B9 0E 7D                              lda EnemyDataAddrHigh,y
07C49 85 EA                                 sta EnemyDataHigh
07C4B AC 4E 07                              ldy AreaType             ;use area type as offset
07C4E B9 30 7D                              lda AreaDataHOffsets,y   ;do the same thing but with different base value
07C51 18                                    clc
07C52 6D 4F 07                              adc AreaAddrsLOffset        
07C55 A8                                    tay
07C56 B9 34 7D                              lda AreaDataAddrLow,y    ;use this offset to load another pointer
07C59 85 E7                                 sta AreaDataLow
07C5B B9 56 7D                              lda AreaDataAddrHigh,y
07C5E 85 E8                                 sta AreaDataHigh
07C60 A0 00                                 ldy #$00                 ;load first byte of header
07C62 B1 E7                                 lda (AreaData),y     
07C64 48                                    pha                      ;save it to the stack for now
07C65 29 07                                 and #%00000111           ;save 3 LSB for foreground scenery or bg color control
07C67 C9 04                                 cmp #$04
07C69 90 05                                 bcc StoreFore
07C6B 8D 44 07                              sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
07C6E A9 00                                 lda #$00
07C70 8D 41 07                  StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
07C73 68                                    pla                      ;pull byte from stack and push it back
07C74 48                                    pha
07C75 29 38                                 and #%00111000           ;save player entrance control bits
07C77 4A                                    lsr                      ;shift bits over to LSBs
07C78 4A                                    lsr
07C79 4A                                    lsr
07C7A 8D 10 07                              sta PlayerEntranceCtrl       ;save value here as player entrance control
07C7D 68                                    pla                      ;pull byte again but do not push it back
07C7E 29 C0                                 and #%11000000           ;save 2 MSB for game timer setting
07C80 18                                    clc
07C81 2A                                    rol                      ;rotate bits over to LSBs
07C82 2A                                    rol
07C83 2A                                    rol
07C84 8D 15 07                              sta GameTimerSetting     ;save value here as game timer setting
07C87 C8                                    iny
07C88 B1 E7                                 lda (AreaData),y         ;load second byte of header
07C8A 48                                    pha                      ;save to stack
07C8B 29 0F                                 and #%00001111           ;mask out all but lower nybble
07C8D 8D 27 07                              sta TerrainControl
07C90 68                                    pla                      ;pull and push byte to copy it to A
07C91 48                                    pha
07C92 29 30                                 and #%00110000           ;save 2 MSB for background scenery type
07C94 4A                                    lsr
07C95 4A                                    lsr                      ;shift bits to LSBs
07C96 4A                                    lsr
07C97 4A                                    lsr
07C98 8D 42 07                              sta BackgroundScenery    ;save as background scenery
07C9B 68                                    pla           
07C9C 29 C0                                 and #%11000000
07C9E 18                                    clc
07C9F 2A                                    rol                      ;rotate bits over to LSBs
07CA0 2A                                    rol
07CA1 2A                                    rol
07CA2 C9 03                                 cmp #%00000011           ;if set to 3, store here
07CA4 D0 05                                 bne StoreStyle           ;and nullify other value
07CA6 8D 43 07                              sta CloudTypeOverride    ;otherwise store value in other place
07CA9 A9 00                                 lda #$00
07CAB 8D 33 07                  StoreStyle: sta AreaStyle
07CAE A5 E7                                 lda AreaDataLow          ;increment area data address by 2 bytes
07CB0 18                                    clc
07CB1 69 02                                 adc #$02
07CB3 85 E7                                 sta AreaDataLow
07CB5 A5 E8                                 lda AreaDataHigh
07CB7 69 00                                 adc #$00
07CB9 85 E8                                 sta AreaDataHigh
07CBB 60                                    rts
07CBC                           
07CBC                           ;-------------------------------------------------------------------------------------
07CBC                           ;GAME LEVELS DATA
07CBC                           
07CBC                           WorldAddrOffsets:
07CBC 00 05                           .db World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
07CBE 0A 0E                           .db World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
07CC0 13 17                           .db World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
07CC2 1B 20                           .db World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
07CC4                           
07CC4                           AreaAddrOffsets:
07CC4 25 29 C0 26 60            World1Areas: .db $25, $29, $c0, $26, $60
07CC9 28 29 01 27 62            World2Areas: .db $28, $29, $01, $27, $62
07CCE 24 35 20 63               World3Areas: .db $24, $35, $20, $63
07CD2 22 29 41 2C 61            World4Areas: .db $22, $29, $41, $2c, $61
07CD7 2A 31 26 62               World5Areas: .db $2a, $31, $26, $62
07CDB 2E 23 2D 60               World6Areas: .db $2e, $23, $2d, $60
07CDF 33 29 01 27 64            World7Areas: .db $33, $29, $01, $27, $64
07CE4 30 32 21 65               World8Areas: .db $30, $32, $21, $65
07CE8                           
07CE8                           ;bonus area data offsets, included here for comparison purposes
07CE8                           ;underground bonus area  - c2
07CE8                           ;cloud area 1 (day)      - 2b
07CE8                           ;cloud area 2 (night)    - 34
07CE8                           ;water area (5-2/6-2)    - 00
07CE8                           ;water area (8-4)        - 02
07CE8                           ;warp zone area (4-2)    - 2f
07CE8                           
07CE8                           EnemyAddrHOffsets:
07CE8 1F 06 1C 00                     .db $1f, $06, $1c, $00
07CEC                           
07CEC                           EnemyDataAddrLow:
07CEC 78 9F B8 E7 12 27               .db <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6
07CF2 61 86 A3 B1 D8 09               .db <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6
07CF8 27 44 59 83 84 A8               .db <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12
07CFE B1 D6 F9 02 03 3D               .db <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18
07D04 68 96 B2 BB E0                  .db <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1
07D09 0D 3B 68 79 A3                  .db <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3
07D0E                           
07D0E                           EnemyDataAddrHigh:
07D0E 7D 7D 7D 7D 7E 7E               .db >E_CastleArea1, >E_CastleArea2, >E_CastleArea3, >E_CastleArea4, >E_CastleArea5, >E_CastleArea6
07D14 7E 7E 7E 7E 7E 7F               .db >E_GroundArea1, >E_GroundArea2, >E_GroundArea3, >E_GroundArea4, >E_GroundArea5, >E_GroundArea6
07D1A 7F 7F 7F 7F 7F 7F               .db >E_GroundArea7, >E_GroundArea8, >E_GroundArea9, >E_GroundArea10, >E_GroundArea11, >E_GroundArea12
07D20 7F 7F 7F 80 80 80               .db >E_GroundArea13, >E_GroundArea14, >E_GroundArea15, >E_GroundArea16, >E_GroundArea17, >E_GroundArea18
07D26 80 80 80 80 80                  .db >E_GroundArea19, >E_GroundArea20, >E_GroundArea21, >E_GroundArea22, >E_UndergroundArea1
07D2B 81 81 81 81 81                  .db >E_UndergroundArea2, >E_UndergroundArea3, >E_WaterArea1, >E_WaterArea2, >E_WaterArea3
07D30                           
07D30                           AreaDataHOffsets:
07D30 00 03 19 1C                     .db $00, $03, $19, $1c
07D34                           
07D34                           AreaDataAddrLow:
07D34 0E 4D C8 73 D6 3F               .db <L_WaterArea1, <L_WaterArea2, <L_WaterArea3, <L_GroundArea1, <L_GroundArea2, <L_GroundArea3
07D3A 92 21 96 FB 50 D5               .db <L_GroundArea4, <L_GroundArea5, <L_GroundArea6, <L_GroundArea7, <L_GroundArea8, <L_GroundArea9
07D40 3A 43 82 97 FE 63               .db <L_GroundArea10, <L_GroundArea11, <L_GroundArea12, <L_GroundArea13, <L_GroundArea14, <L_GroundArea15
07D46 D6 07 9A 0D 86 DF               .db <L_GroundArea16, <L_GroundArea17, <L_GroundArea18, <L_GroundArea19, <L_GroundArea20, <L_GroundArea21
07D4C 0A 3D E0 81 B7                  .db <L_GroundArea22, <L_UndergroundArea1, <L_UndergroundArea2, <L_UndergroundArea3, <L_CastleArea1
07D51 18 97 0A 77 02                  .db <L_CastleArea2, <L_CastleArea3, <L_CastleArea4, <L_CastleArea5, <L_CastleArea6
07D56                           
07D56                           AreaDataAddrHigh:
07D56 8E 8E 8E 84 84 85               .db >L_WaterArea1, >L_WaterArea2, >L_WaterArea3, >L_GroundArea1, >L_GroundArea2, >L_GroundArea3
07D5C 85 86 86 86 87 87               .db >L_GroundArea4, >L_GroundArea5, >L_GroundArea6, >L_GroundArea7, >L_GroundArea8, >L_GroundArea9
07D62 88 88 88 88 88 89               .db >L_GroundArea10, >L_GroundArea11, >L_GroundArea12, >L_GroundArea13, >L_GroundArea14, >L_GroundArea15
07D68 89 8A 8A 8B 8B 8B               .db >L_GroundArea16, >L_GroundArea17, >L_GroundArea18, >L_GroundArea19, >L_GroundArea20, >L_GroundArea21
07D6E 8C 8C 8C 8D 81                  .db >L_GroundArea22, >L_UndergroundArea1, >L_UndergroundArea2, >L_UndergroundArea3, >L_CastleArea1
07D73 82 82 83 83 84                  .db >L_CastleArea2, >L_CastleArea3, >L_CastleArea4, >L_CastleArea5, >L_CastleArea6
07D78                           
07D78                           ;ENEMY OBJECT DATA
07D78                           
07D78                           ;level 1-4/6-4
07D78                           E_CastleArea1:
07D78 76 DD BB 4C EA 1D 1B CC..       .db $76, $dd, $bb, $4c, $ea, $1d, $1b, $cc, $56, $5d
07D82 16 9D C6 1D 36 9D C9 1D..       .db $16, $9d, $c6, $1d, $36, $9d, $c9, $1d, $04, $db
07D8C 49 1D 84 1B C9 5D 88 95..       .db $49, $1d, $84, $1b, $c9, $5d, $88, $95, $0f, $08
07D96 30 4C 78 2D A6 28 90 B5         .db $30, $4c, $78, $2d, $a6, $28, $90, $b5
07D9E FF                              .db $ff
07D9F                           
07D9F                           ;level 4-4
07D9F                           E_CastleArea2:
07D9F 0F 03 56 1B C9 1B 0F 07..       .db $0f, $03, $56, $1b, $c9, $1b, $0f, $07, $36, $1b
07DA9 AA 1B 48 95 0F 0A 2A 1B..       .db $aa, $1b, $48, $95, $0f, $0a, $2a, $1b, $5b, $0c
07DB3 78 2D 90 B5                     .db $78, $2d, $90, $b5
07DB7 FF                              .db $ff
07DB8                           
07DB8                           ;level 2-4/5-4
07DB8                           E_CastleArea3:
07DB8 0B 8C 4B 4C 77 5F EB 0C..       .db $0b, $8c, $4b, $4c, $77, $5f, $eb, $0c, $bd, $db
07DC2 19 9D 75 1D 7D 5B D9 1D..       .db $19, $9d, $75, $1d, $7d, $5b, $d9, $1d, $3d, $dd
07DCC 99 1D 26 9D 5A 2B 8A 2C..       .db $99, $1d, $26, $9d, $5a, $2b, $8a, $2c, $ca, $1b
07DD6 20 95 7B 5C DB 4C 1B CC..       .db $20, $95, $7b, $5c, $db, $4c, $1b, $cc, $3b, $cc
07DE0 78 2D A6 28 90 B5               .db $78, $2d, $a6, $28, $90, $b5
07DE6 FF                              .db $ff
07DE7                           
07DE7                           ;level 3-4
07DE7                           E_CastleArea4:
07DE7 0B 8C 3B 1D 8B 1D AB 0C..       .db $0b, $8c, $3b, $1d, $8b, $1d, $ab, $0c, $db, $1d
07DF1 0F 03 65 1D 6B 1B 05 9D..       .db $0f, $03, $65, $1d, $6b, $1b, $05, $9d, $0b, $1b
07DFB 05 9B 0B 1D 8B 0C 1B 8C..       .db $05, $9b, $0b, $1d, $8b, $0c, $1b, $8c, $70, $15
07E05 7B 0C DB 0C 0F 08 78 2D..       .db $7b, $0c, $db, $0c, $0f, $08, $78, $2d, $a6, $28
07E0F 90 B5                           .db $90, $b5
07E11 FF                              .db $ff
07E12                           
07E12                           ;level 7-4
07E12                           E_CastleArea5:
07E12 27 A9 4B 0C 68 29 0F 06..       .db $27, $a9, $4b, $0c, $68, $29, $0f, $06, $77, $1b
07E1C 0F 0B 60 15 4B 8C 78 2D..       .db $0f, $0b, $60, $15, $4b, $8c, $78, $2d, $90, $b5
07E26 FF                              .db $ff
07E27                           
07E27                           ;level 8-4
07E27                           E_CastleArea6:
07E27 0F 03 8E 65 E1 BB 38 6D..       .db $0f, $03, $8e, $65, $e1, $bb, $38, $6d, $a8, $3e, $e5, $e7
07E33 0F 08 0B 02 2B 02 5E 65..       .db $0f, $08, $0b, $02, $2b, $02, $5e, $65, $e1, $bb, $0e
07E3E DB 0E BB 8E DB 0E FE 65..       .db $db, $0e, $bb, $8e, $db, $0e, $fe, $65, $ec, $0f, $0d
07E49 4E 65 E1 0F 0E 4E 02 E0..       .db $4e, $65, $e1, $0f, $0e, $4e, $02, $e0, $0f, $10, $fe, $e5, $e1
07E56 1B 85 7B 0C 5B 95 78 2D..       .db $1b, $85, $7b, $0c, $5b, $95, $78, $2d, $90, $b5
07E60 FF                              .db $ff
07E61                           
07E61                           ;level 3-3
07E61                           E_GroundArea1:
07E61 A5 86 E4 28 18 A8 45 83..       .db $a5, $86, $e4, $28, $18, $a8, $45, $83, $69, $03
07E6B C6 29 9B 83 16 A4 88 24..       .db $c6, $29, $9b, $83, $16, $a4, $88, $24, $e9, $28
07E75 05 A8 7B 28 24 8F C8 03..       .db $05, $a8, $7b, $28, $24, $8f, $c8, $03, $e8, $03
07E7F 46 A8 85 24 C8 24               .db $46, $a8, $85, $24, $c8, $24
07E85 FF                              .db $ff
07E86                           
07E86                           ;level 8-3
07E86                           E_GroundArea2:
07E86 EB 8E 0F 03 FB 05 17 85..       .db $eb, $8e, $0f, $03, $fb, $05, $17, $85, $db, $8e
07E90 0F 07 57 05 7B 05 9B 80..       .db $0f, $07, $57, $05, $7b, $05, $9b, $80, $2b, $85
07E9A FB 05 0F 0B 1B 05 9B 05         .db $fb, $05, $0f, $0b, $1b, $05, $9b, $05
07EA2 FF                              .db $ff
07EA3                           
07EA3                           ;level 4-1
07EA3                           E_GroundArea3:
07EA3 2E C2 66 E2 11 0F 07 02..       .db $2e, $c2, $66, $e2, $11, $0f, $07, $02, $11, $0f, $0c
07EAE 12 11                           .db $12, $11
07EB0 FF                              .db $ff
07EB1                           
07EB1                           ;level 6-2
07EB1                           E_GroundArea4:
07EB1 0E C2 A8 AB 00 BB 8E 6B..       .db $0e, $c2, $a8, $ab, $00, $bb, $8e, $6b, $82, $de, $00, $a0
07EBD 33 86 43 06 3E B4 A0 CB..       .db $33, $86, $43, $06, $3e, $b4, $a0, $cb, $02, $0f, $07
07EC8 7E 42 A6 83 02 0F 0A 3B..       .db $7e, $42, $a6, $83, $02, $0f, $0a, $3b, $02, $cb, $37
07ED3 0F 0C E3 0E                     .db $0f, $0c, $e3, $0e
07ED7 FF                              .db $ff
07ED8                           
07ED8                           ;level 3-1
07ED8                           E_GroundArea5:
07ED8 9B 8E CA 0E EE 42 44 5B..       .db $9b, $8e, $ca, $0e, $ee, $42, $44, $5b, $86, $80, $b8
07EE3 1B 80 50 BA 10 B7 5B 00..       .db $1b, $80, $50, $ba, $10, $b7, $5b, $00, $17, $85
07EED 4B 05 FE 34 40 B7 86 C6..       .db $4b, $05, $fe, $34, $40, $b7, $86, $c6, $06, $5b, $80
07EF8 83 00 D0 38 5B 8E 8A 0E..       .db $83, $00, $d0, $38, $5b, $8e, $8a, $0e, $a6, $00
07F02 BB 0E C5 80 F3 00               .db $bb, $0e, $c5, $80, $f3, $00
07F08 FF                              .db $ff
07F09                           
07F09                           ;level 1-1
07F09                           E_GroundArea6:
07F09 1E C2 00 6B 06 8B 86 63..       .db $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05
07F14 03 06 23 06 4B B7 BB 00..       .db $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7
07F1E FB 37 3B B7 0F 0B 1B 37         .db $fb, $37, $3b, $b7, $0f, $0b, $1b, $37
07F26 FF                              .db $ff
07F27                           
07F27                           ;level 1-3/5-3
07F27                           E_GroundArea7:
07F27 2B D7 E3 03 C2 86 E2 06..       .db $2b, $d7, $e3, $03, $c2, $86, $e2, $06, $76, $a5
07F31 A3 8F 03 86 2B 57 68 28..       .db $a3, $8f, $03, $86, $2b, $57, $68, $28, $e9, $28
07F3B E5 83 24 8F 36 A8 5B 03         .db $e5, $83, $24, $8f, $36, $a8, $5b, $03
07F43 FF                              .db $ff
07F44                           
07F44                           ;level 2-3/7-3
07F44                           E_GroundArea8:
07F44 0F 02 78 40 48 CE F8 C3..       .db $0f, $02, $78, $40, $48, $ce, $f8, $c3, $f8, $c3
07F4E 0F 07 7B 43 C6 D0 0F 8A..       .db $0f, $07, $7b, $43, $c6, $d0, $0f, $8a, $c8, $50
07F58 FF                              .db $ff
07F59                           
07F59                           ;level 2-1
07F59                           E_GroundArea9:
07F59 85 86 0B 80 1B 00 DB 37..       .db $85, $86, $0b, $80, $1b, $00, $db, $37, $77, $80
07F63 EB 37 FE 2B 20 2B 80 7B..       .db $eb, $37, $fe, $2b, $20, $2b, $80, $7b, $38, $ab, $b8
07F6E 77 86 FE 42 20 49 86 8B..       .db $77, $86, $fe, $42, $20, $49, $86, $8b, $06, $9b, $80
07F79 7B 8E 5B B7 9B 0E BB 0E..       .db $7b, $8e, $5b, $b7, $9b, $0e, $bb, $0e, $9b, $80
07F83                           ;end of data terminator here is also used by pipe intro area
07F83                           E_GroundArea10:
07F83 FF                              .db $ff
07F84                           
07F84                           ;level 5-1
07F84                           E_GroundArea11:
07F84 0B 80 60 38 10 B8 C0 3B..       .db $0b, $80, $60, $38, $10, $b8, $c0, $3b, $db, $8e
07F8E 40 B8 F0 38 7B 8E A0 B8..       .db $40, $b8, $f0, $38, $7b, $8e, $a0, $b8, $c0, $b8
07F98 FB 00 A0 B8 30 BB EE 42..       .db $fb, $00, $a0, $b8, $30, $bb, $ee, $42, $88, $0f, $0b
07FA3 2B 0E 67 0E                     .db $2b, $0e, $67, $0e
07FA7 FF                              .db $ff
07FA8                           
07FA8                           ;cloud level used in levels 2-1 and 5-2
07FA8                           E_GroundArea12:
07FA8 0A AA 0E 28 2A 0E 31 88         .db $0a, $aa, $0e, $28, $2a, $0e, $31, $88
07FB0 FF                              .db $ff
07FB1                           
07FB1                           ;level 4-3
07FB1                           E_GroundArea13:
07FB1 C7 83 D7 03 42 8F 7A 03..       .db $c7, $83, $d7, $03, $42, $8f, $7a, $03, $05, $a4
07FBB 78 24 A6 25 E4 25 4B 83..       .db $78, $24, $a6, $25, $e4, $25, $4b, $83, $e3, $03
07FC5 05 A4 89 24 B5 24 09 A4..       .db $05, $a4, $89, $24, $b5, $24, $09, $a4, $65, $24
07FCF C9 24 0F 08 85 25               .db $c9, $24, $0f, $08, $85, $25
07FD5 FF                              .db $ff
07FD6                           
07FD6                           ;level 6-3
07FD6                           E_GroundArea14:
07FD6 CD A5 B5 A8 07 A8 76 28..       .db $cd, $a5, $b5, $a8, $07, $a8, $76, $28, $cc, $25
07FE0 65 A4 A9 24 E5 24 19 A4..       .db $65, $a4, $a9, $24, $e5, $24, $19, $a4, $0f, $07
07FEA 95 28 E6 24 19 A4 D7 29..       .db $95, $28, $e6, $24, $19, $a4, $d7, $29, $16, $a9
07FF4 58 29 97 29                     .db $58, $29, $97, $29
07FF8 FF                              .db $ff
07FF9                           
07FF9                           ;level 6-1
07FF9                           E_GroundArea15:
07FF9 0F 02 02 11 0F 07 02 11         .db $0f, $02, $02, $11, $0f, $07, $02, $11
08001 FF                              .db $ff
08002                           
08002                           ;warp zone area used in level 4-2
08002                           E_GroundArea16:
08002 FF                              .db $ff
08003                           
08003                           ;level 8-1
08003                           E_GroundArea17:
08003 2B 82 AB 38 DE 42 E2 1B..       .db $2b, $82, $ab, $38, $de, $42, $e2, $1b, $b8, $eb
0800D 3B DB 80 8B B8 1B 82 FB..       .db $3b, $db, $80, $8b, $b8, $1b, $82, $fb, $b8, $7b
08017 80 FB 3C 5B BC 7B B8 1B..       .db $80, $fb, $3c, $5b, $bc, $7b, $b8, $1b, $8e, $cb
08021 0E 1B 8E 0F 0D 2B 3B BB..       .db $0e, $1b, $8e, $0f, $0d, $2b, $3b, $bb, $b8, $eb, $82
0802C 4B B8 BB 38 3B B7 BB 02..       .db $4b, $b8, $bb, $38, $3b, $b7, $bb, $02, $0f, $13
08036 1B 00 CB 80 6B BC               .db $1b, $00, $cb, $80, $6b, $bc
0803C FF                              .db $ff
0803D                           
0803D                           ;level 5-2
0803D                           E_GroundArea18:
0803D 7B 80 AE 00 80 8B 8E E8..       .db $7b, $80, $ae, $00, $80, $8b, $8e, $e8, $05, $f9, $86 
08048 17 86 16 85 4E 2B 80 AB..       .db $17, $86, $16, $85, $4e, $2b, $80, $ab, $8e, $87, $85
08053 C3 05 8B 82 9B 02 AB 02..       .db $c3, $05, $8b, $82, $9b, $02, $ab, $02, $bb, $86
0805D CB 06 D3 03 3B 8E 6B 0E..       .db $cb, $06, $d3, $03, $3b, $8e, $6b, $0e, $a7, $8e
08067 FF                              .db $ff
08068                           
08068                           ;level 8-2
08068                           E_GroundArea19:
08068 29 8E 52 11 83 0E 0F 03..       .db $29, $8e, $52, $11, $83, $0e, $0f, $03, $9b, $0e
08072 2B 8E 5B 0E CB 8E FB 0E..       .db $2b, $8e, $5b, $0e, $cb, $8e, $fb, $0e, $fb, $82
0807C 9B 82 BB 02 FE 42 E8 BB..       .db $9b, $82, $bb, $02, $fe, $42, $e8, $bb, $8e, $0f, $0a
08087 AB 0E CB 0E F9 0E 88 86..       .db $ab, $0e, $cb, $0e, $f9, $0e, $88, $86, $a6, $06
08091 DB 02 B6 8E                     .db $db, $02, $b6, $8e
08095 FF                              .db $ff
08096                           
08096                           ;level 7-1
08096                           E_GroundArea20:
08096 AB CE DE 42 C0 CB CE 5B..       .db $ab, $ce, $de, $42, $c0, $cb, $ce, $5b, $8e, $1b, $ce
080A1 4B 85 67 45 0F 07 2B 00..       .db $4b, $85, $67, $45, $0f, $07, $2b, $00, $7b, $85
080AB 97 05 0F 0A 92 02               .db $97, $05, $0f, $0a, $92, $02
080B1 FF                              .db $ff
080B2                           
080B2                           ;cloud level used in levels 3-1 and 6-2
080B2                           E_GroundArea21:
080B2 0A AA 0E 24 4A 1E 23 AA         .db $0a, $aa, $0e, $24, $4a, $1e, $23, $aa
080BA FF                              .db $ff
080BB                           
080BB                           ;level 3-2
080BB                           E_GroundArea22:
080BB 1B 80 BB 38 4B BC EB 3B..       .db $1b, $80, $bb, $38, $4b, $bc, $eb, $3b, $0f, $04
080C5 2B 00 AB 38 EB 00 CB 8E..       .db $2b, $00, $ab, $38, $eb, $00, $cb, $8e, $fb, $80
080CF AB B8 6B 80 FB 3C 9B BB..       .db $ab, $b8, $6b, $80, $fb, $3c, $9b, $bb, $5b, $bc
080D9 FB 00 6B B8 FB 38               .db $fb, $00, $6b, $b8, $fb, $38
080DF FF                              .db $ff
080E0                           
080E0                           ;level 1-2
080E0                           E_UndergroundArea1:
080E0 0B 86 1A 06 DB 06 DE C2..       .db $0b, $86, $1a, $06, $db, $06, $de, $c2, $02, $f0, $3b
080EB BB 80 EB 06 0B 86 93 06..       .db $bb, $80, $eb, $06, $0b, $86, $93, $06, $f0, $39
080F5 0F 06 60 B8 1B 86 A0 B9..       .db $0f, $06, $60, $b8, $1b, $86, $a0, $b9, $b7, $27
080FF BD 27 2B 83 A1 26 A9 26..       .db $bd, $27, $2b, $83, $a1, $26, $a9, $26, $ee, $25, $0b
0810A 27 B4                           .db $27, $b4
0810C FF                              .db $ff
0810D                           
0810D                           ;level 4-2
0810D                           E_UndergroundArea2:
0810D 0F 02 1E 2F 60 E0 3A A5..       .db $0f, $02, $1e, $2f, $60, $e0, $3a, $a5, $a7, $db, $80
08118 3B 82 8B 02 FE 42 68 70..       .db $3b, $82, $8b, $02, $fe, $42, $68, $70, $bb, $25, $a7
08123 2C 27 B2 26 B9 26 9B 80..       .db $2c, $27, $b2, $26, $b9, $26, $9b, $80, $a8, $82
0812D B5 27 BC 27 B0 BB 3B 82..       .db $b5, $27, $bc, $27, $b0, $bb, $3b, $82, $87, $34
08137 EE 25 6B                        .db $ee, $25, $6b
0813A FF                              .db $ff
0813B                           
0813B                           ;underground bonus rooms area used in many levels
0813B                           E_UndergroundArea3:
0813B 1E A5 0A 2E 28 27 2E 33..       .db $1e, $a5, $0a, $2e, $28, $27, $2e, $33, $c7, $0f, $03, $1e, $40, $07
08149 2E 30 E7 0F 05 1E 24 44..       .db $2e, $30, $e7, $0f, $05, $1e, $24, $44, $0f, $07, $1e, $22, $6a
08156 2E 23 AB 0F 09 1E 41 68..       .db $2e, $23, $ab, $0f, $09, $1e, $41, $68, $1e, $2a, $8a, $2e, $23, $a2
08164 2E 32 EA                        .db $2e, $32, $ea
08167 FF                              .db $ff
08168                           
08168                           ;water area used in levels 5-2 and 6-2
08168                           E_WaterArea1:
08168 3B 87 66 27 CC 27 EE 31..       .db $3b, $87, $66, $27, $cc, $27, $ee, $31, $87, $ee, $23, $a7
08174 3B 87 DB 07                     .db $3b, $87, $db, $07
08178 FF                              .db $ff
08179                           
08179                           ;level 2-2/7-2
08179                           E_WaterArea2:
08179 0F 01 2E 25 2B 2E 25 4B..       .db $0f, $01, $2e, $25, $2b, $2e, $25, $4b, $4e, $25, $cb, $6b, $07
08186 97 47 E9 87 47 C7 7A 07..       .db $97, $47, $e9, $87, $47, $c7, $7a, $07, $d6, $c7
08190 78 07 38 87 AB 47 E3 07..       .db $78, $07, $38, $87, $ab, $47, $e3, $07, $9b, $87
0819A 0F 09 68 47 DB C7 3B C7         .db $0f, $09, $68, $47, $db, $c7, $3b, $c7
081A2 FF                              .db $ff
081A3                           
081A3                           ;water area used in level 8-4
081A3                           E_WaterArea3:
081A3 47 9B CB 07 FA 1D 86 9B..       .db $47, $9b, $cb, $07, $fa, $1d, $86, $9b, $3a, $87
081AD 56 07 88 1B 07 9D 2E 65..       .db $56, $07, $88, $1b, $07, $9d, $2e, $65, $f0
081B6 FF                              .db $ff
081B7                           
081B7                           ;AREA OBJECT DATA
081B7                           
081B7                           ;level 1-4/6-4
081B7                           L_CastleArea1:
081B7 9B 07                           .db $9b, $07
081B9 05 32 06 33 07 34 CE 03..       .db $05, $32, $06, $33, $07, $34, $ce, $03, $dc, $51
081C3 EE 07 73 E0 74 0A 7E 06..       .db $ee, $07, $73, $e0, $74, $0a, $7e, $06, $9e, $0a
081CD CE 06 E4 00 E8 0A FE 0A..       .db $ce, $06, $e4, $00, $e8, $0a, $fe, $0a, $2e, $89
081D7 4E 0B 54 0A 14 8A C4 0A..       .db $4e, $0b, $54, $0a, $14, $8a, $c4, $0a, $34, $8a
081E1 7E 06 C7 0A 01 E0 02 0A..       .db $7e, $06, $c7, $0a, $01, $e0, $02, $0a, $47, $0a
081EB 81 60 82 0A C7 0A 0E 87..       .db $81, $60, $82, $0a, $c7, $0a, $0e, $87, $7e, $02
081F5 A7 02 B3 02 D7 02 E3 02..       .db $a7, $02, $b3, $02, $d7, $02, $e3, $02, $07, $82
081FF 13 02 3E 06 7E 02 AE 07..       .db $13, $02, $3e, $06, $7e, $02, $ae, $07, $fe, $0a
08209 0D C4 CD 43 CE 09 DE 0B..       .db $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
08213 FE 02 5D C7                     .db $fe, $02, $5d, $c7
08217 FD                              .db $fd
08218                           
08218                           ;level 4-4
08218                           L_CastleArea2:
08218 5B 07                           .db $5b, $07
0821A 05 32 06 33 07 34 5E 0A..       .db $05, $32, $06, $33, $07, $34, $5e, $0a, $68, $64
08224 98 64 A8 64 CE 06 FE 02..       .db $98, $64, $a8, $64, $ce, $06, $fe, $02, $0d, $01
0822E 1E 0E 7E 02 94 63 B4 63..       .db $1e, $0e, $7e, $02, $94, $63, $b4, $63, $d4, $63
08238 F4 63 14 E3 2E 0E 5E 02..       .db $f4, $63, $14, $e3, $2e, $0e, $5e, $02, $64, $35
08242 88 72 BE 0E 0D 04 AE 02..       .db $88, $72, $be, $0e, $0d, $04, $ae, $02, $ce, $08
0824C CD 4B FE 02 0D 05 68 31..       .db $cd, $4b, $fe, $02, $0d, $05, $68, $31, $7e, $0a
08256 96 31 A9 63 A8 33 D5 30..       .db $96, $31, $a9, $63, $a8, $33, $d5, $30, $ee, $02
08260 E6 62 F4 61 04 B1 08 3F..       .db $e6, $62, $f4, $61, $04, $b1, $08, $3f, $44, $33
0826A 94 63 A4 31 E4 31 04 BF..       .db $94, $63, $a4, $31, $e4, $31, $04, $bf, $08, $3f
08274 04 BF 08 3F CD 4B 03 E4..       .db $04, $bf, $08, $3f, $cd, $4b, $03, $e4, $0e, $03
0827E 2E 01 7E 06 BE 02 DE 06..       .db $2e, $01, $7e, $06, $be, $02, $de, $06, $fe, $0a
08288 0D C4 CD 43 CE 09 DE 0B..       .db $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
08292 FE 02 5D C7                     .db $fe, $02, $5d, $c7
08296 FD                              .db $fd
08297                           
08297                           ;level 2-4/5-4
08297                           L_CastleArea3:
08297 9B 07                           .db $9b, $07
08299 05 32 06 33 07 34 FE 00..       .db $05, $32, $06, $33, $07, $34, $fe, $00, $27, $b1
082A3 65 32 75 0A 71 00 B7 31..       .db $65, $32, $75, $0a, $71, $00, $b7, $31, $08, $e4
082AD 18 64 1E 04 57 3B BB 0A..       .db $18, $64, $1e, $04, $57, $3b, $bb, $0a, $17, $8a
082B7 27 3A 73 0A 7B 0A D7 0A..       .db $27, $3a, $73, $0a, $7b, $0a, $d7, $0a, $e7, $3a
082C1 3B 8A 97 0A FE 08 24 8A..       .db $3b, $8a, $97, $0a, $fe, $08, $24, $8a, $2e, $00
082CB 3E 40 38 64 6F 00 9F 00..       .db $3e, $40, $38, $64, $6f, $00, $9f, $00, $be, $43
082D5 C8 0A C9 63 CE 07 FE 07..       .db $c8, $0a, $c9, $63, $ce, $07, $fe, $07, $2e, $81
082DF 66 42 6A 42 79 0A BE 00..       .db $66, $42, $6a, $42, $79, $0a, $be, $00, $c8, $64
082E9 F8 64 08 E4 2E 07 7E 03..       .db $f8, $64, $08, $e4, $2e, $07, $7e, $03, $9e, $07
082F3 BE 03 DE 07 FE 0A 03 A5..       .db $be, $03, $de, $07, $fe, $0a, $03, $a5, $0d, $44
082FD CD 43 CE 09 DD 42 DE 0B..       .db $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
08307 5D C7                           .db $5d, $c7
08309 FD                              .db $fd
0830A                           
0830A                           ;level 3-4
0830A                           L_CastleArea4:
0830A 9B 07                           .db $9b, $07
0830C 05 32 06 33 07 34 FE 06..       .db $05, $32, $06, $33, $07, $34, $fe, $06, $0c, $81
08316 39 0A 5C 01 89 0A AC 01..       .db $39, $0a, $5c, $01, $89, $0a, $ac, $01, $d9, $0a
08320 FC 01 2E 83 A7 01 B7 00..       .db $fc, $01, $2e, $83, $a7, $01, $b7, $00, $c7, $01
0832A DE 0A FE 02 4E 83 5A 32..       .db $de, $0a, $fe, $02, $4e, $83, $5a, $32, $63, $0a
08334 69 0A 7E 02 EE 03 FA 32..       .db $69, $0a, $7e, $02, $ee, $03, $fa, $32, $03, $8a
0833E 09 0A 1E 02 EE 03 FA 32..       .db $09, $0a, $1e, $02, $ee, $03, $fa, $32, $03, $8a
08348 09 0A 14 42 1E 02 7E 0A..       .db $09, $0a, $14, $42, $1e, $02, $7e, $0a, $9e, $07
08352 FE 0A 2E 86 5E 0A 8E 06..       .db $fe, $0a, $2e, $86, $5e, $0a, $8e, $06, $be, $0a
0835C EE 07 3E 83 5E 07 FE 0A..       .db $ee, $07, $3e, $83, $5e, $07, $fe, $0a, $0d, $c4
08366 41 52 51 52 CD 43 CE 09..       .db $41, $52, $51, $52, $cd, $43, $ce, $09, $de, $0b
08370 DD 42 FE 02 5D C7               .db $dd, $42, $fe, $02, $5d, $c7
08376 FD                              .db $fd
08377                           
08377                           ;level 7-4
08377                           L_CastleArea5:
08377 5B 07                           .db $5b, $07
08379 05 32 06 33 07 34 FE 0A..       .db $05, $32, $06, $33, $07, $34, $fe, $0a, $ae, $86
08383 BE 07 FE 02 0D 02 27 32..       .db $be, $07, $fe, $02, $0d, $02, $27, $32, $46, $61
0838D 55 62 5E 0E 1E 82 68 3C..       .db $55, $62, $5e, $0e, $1e, $82, $68, $3c, $74, $3a
08397 7D 4B 5E 8E 7D 4B 7E 82..       .db $7d, $4b, $5e, $8e, $7d, $4b, $7e, $82, $84, $62
083A1 94 61 A4 31 BD 4B CE 06..       .db $94, $61, $a4, $31, $bd, $4b, $ce, $06, $fe, $02
083AB 0D 06 34 31 3E 0A 64 32..       .db $0d, $06, $34, $31, $3e, $0a, $64, $32, $75, $0a
083B5 7B 61 A4 33 AE 02 DE 0E..       .db $7b, $61, $a4, $33, $ae, $02, $de, $0e, $3e, $82
083BF 64 32 78 32 B4 36 C8 36..       .db $64, $32, $78, $32, $b4, $36, $c8, $36, $dd, $4b
083C9 44 B2 58 32 94 63 A4 3E..       .db $44, $b2, $58, $32, $94, $63, $a4, $3e, $ba, $30
083D3 C9 61 CE 06 DD 4B CE 86..       .db $c9, $61, $ce, $06, $dd, $4b, $ce, $86, $dd, $4b
083DD FE 02 2E 86 5E 02 7E 06..       .db $fe, $02, $2e, $86, $5e, $02, $7e, $06, $fe, $02
083E7 1E 86 3E 02 5E 06 7E 02..       .db $1e, $86, $3e, $02, $5e, $06, $7e, $02, $9e, $06
083F1 FE 0A 0D C4 CD 43 CE 09..       .db $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $de, $0b
083FB DD 42 FE 02 5D C7               .db $dd, $42, $fe, $02, $5d, $c7
08401 FD                              .db $fd
08402                           
08402                           ;level 8-4
08402                           L_CastleArea6:
08402 5B 06                           .db $5b, $06
08404 05 32 06 33 07 34 5E 0A..       .db $05, $32, $06, $33, $07, $34, $5e, $0a, $ae, $02
0840E 0D 01 39 73 0D 03 39 7B..       .db $0d, $01, $39, $73, $0d, $03, $39, $7b, $4d, $4b
08418 DE 06 1E 8A AE 06 C4 33..       .db $de, $06, $1e, $8a, $ae, $06, $c4, $33, $16, $fe
08422 A5 77 FE 02 FE 82 0D 07..       .db $a5, $77, $fe, $02, $fe, $82, $0d, $07, $39, $73
0842C A8 74 ED 4B 49 FB E8 74..       .db $a8, $74, $ed, $4b, $49, $fb, $e8, $74, $fe, $0a
08436 2E 82 67 02 84 7A 87 31..       .db $2e, $82, $67, $02, $84, $7a, $87, $31, $0d, $0b
08440 FE 02 0D 0C 39 73 5E 06..       .db $fe, $02, $0d, $0c, $39, $73, $5e, $06, $c6, $76
0844A 45 FF BE 0A DD 48 FE 06..       .db $45, $ff, $be, $0a, $dd, $48, $fe, $06, $3d, $cb
08454 46 7E AD 4A FE 82 39 F3..       .db $46, $7e, $ad, $4a, $fe, $82, $39, $f3, $a9, $7b
0845E 4E 8A 9E 07 FE 0A 0D C4..       .db $4e, $8a, $9e, $07, $fe, $0a, $0d, $c4, $cd, $43
08468 CE 09 DE 0B DD 42 FE 02..       .db $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7
08472 FD                              .db $fd
08473                           
08473                           ;level 3-3
08473                           L_GroundArea1:
08473 94 11                           .db $94, $11
08475 0F 26 FE 10 28 94 65 15..       .db $0f, $26, $fe, $10, $28, $94, $65, $15, $eb, $12
0847F FA 41 4A 96 54 40 A4 42..       .db $fa, $41, $4a, $96, $54, $40, $a4, $42, $b7, $13
08489 E9 19 F5 15 11 80 47 42..       .db $e9, $19, $f5, $15, $11, $80, $47, $42, $71, $13
08493 80 41 15 92 1B 1F 24 40..       .db $80, $41, $15, $92, $1b, $1f, $24, $40, $55, $12
0849D 64 40 95 12 A4 40 D2 12..       .db $64, $40, $95, $12, $a4, $40, $d2, $12, $e1, $40
084A7 13 C0 2C 17 2F 12 49 13..       .db $13, $c0, $2c, $17, $2f, $12, $49, $13, $83, $40
084B1 9F 14 A3 40 17 92 83 13..       .db $9f, $14, $a3, $40, $17, $92, $83, $13, $92, $41
084BB B9 14 C5 12 C8 40 D4 40..       .db $b9, $14, $c5, $12, $c8, $40, $d4, $40, $4b, $92
084C5 78 1B 9C 94 9F 11 DF 14..       .db $78, $1b, $9c, $94, $9f, $11, $df, $14, $fe, $11
084CF 7D C1 9E 42 CF 20               .db $7d, $c1, $9e, $42, $cf, $20
084D5 FD                              .db $fd
084D6                           
084D6                           ;level 8-3
084D6                           L_GroundArea2:
084D6 90 B1                           .db $90, $b1
084D8 0F 26 29 91 7E 42 FE 40..       .db $0f, $26, $29, $91, $7e, $42, $fe, $40, $28, $92
084E2 4E 42 2E C0 57 73 C3 25..       .db $4e, $42, $2e, $c0, $57, $73, $c3, $25, $c7, $27
084EC 23 84 33 20 5C 01 77 63..       .db $23, $84, $33, $20, $5c, $01, $77, $63, $88, $62
084F6 99 61 AA 60 BC 01 EE 42..       .db $99, $61, $aa, $60, $bc, $01, $ee, $42, $4e, $c0
08500 69 11 7E 42 DE 40 F8 62..       .db $69, $11, $7e, $42, $de, $40, $f8, $62, $0e, $c2
0850A AE 40 D7 63 E7 63 33 A7..       .db $ae, $40, $d7, $63, $e7, $63, $33, $a7, $37, $27
08514 43 04 CC 01 E7 73 0C 81..       .db $43, $04, $cc, $01, $e7, $73, $0c, $81, $3e, $42
0851E 0D 0A 5E 40 88 72 BE 42..       .db $0d, $0a, $5e, $40, $88, $72, $be, $42, $e7, $87
08528 FE 40 39 E1 4E 00 69 60..       .db $fe, $40, $39, $e1, $4e, $00, $69, $60, $87, $60
08532 A5 60 C3 31 FE 31 6D C1..       .db $a5, $60, $c3, $31, $fe, $31, $6d, $c1, $be, $42
0853C EF 20                           .db $ef, $20
0853E FD                              .db $fd
0853F                           
0853F                           ;level 4-1
0853F                           L_GroundArea3:
0853F 52 21                           .db $52, $21
08541 0F 20 6E 40 58 F2 93 01..       .db $0f, $20, $6e, $40, $58, $f2, $93, $01, $97, $00
0854B 0C 81 97 40 A6 41 C7 40..       .db $0c, $81, $97, $40, $a6, $41, $c7, $40, $0d, $04
08555 03 01 07 01 23 01 27 01..       .db $03, $01, $07, $01, $23, $01, $27, $01, $ec, $03
0855F AC F3 C3 03 78 E2 94 43..       .db $ac, $f3, $c3, $03, $78, $e2, $94, $43, $47, $f3
08569 74 43 47 FB 74 43 2C F1..       .db $74, $43, $47, $fb, $74, $43, $2c, $f1, $4c, $63
08573 47 00 57 21 5C 01 7C 72..       .db $47, $00, $57, $21, $5c, $01, $7c, $72, $39, $f1
0857D EC 02 4C 81 D8 62 EC 01..       .db $ec, $02, $4c, $81, $d8, $62, $ec, $01, $0d, $0d
08587 0F 38 C7 07 ED 4A 1D C1..       .db $0f, $38, $c7, $07, $ed, $4a, $1d, $c1, $5f, $26
08591 FD                              .db $fd
08592                           
08592                           ;level 6-2
08592                           L_GroundArea4:
08592 54 21                           .db $54, $21
08594 0F 26 A7 22 37 FB 73 20..       .db $0f, $26, $a7, $22, $37, $fb, $73, $20, $83, $07
0859E 87 02 93 20 C7 73 04 F1..       .db $87, $02, $93, $20, $c7, $73, $04, $f1, $06, $31
085A8 39 71 59 71 E7 73 37 A0..       .db $39, $71, $59, $71, $e7, $73, $37, $a0, $47, $04
085B2 86 7C E5 71 E7 31 33 A4..       .db $86, $7c, $e5, $71, $e7, $31, $33, $a4, $39, $71
085BC A9 71 D3 23 08 F2 13 05..       .db $a9, $71, $d3, $23, $08, $f2, $13, $05, $27, $02
085C6 49 71 75 75 E8 72 67 F3..       .db $49, $71, $75, $75, $e8, $72, $67, $f3, $99, $71
085D0 E7 20 F4 72 F7 31 17 A0..       .db $e7, $20, $f4, $72, $f7, $31, $17, $a0, $33, $20
085DA 39 71 73 28 BC 05 39 F1..       .db $39, $71, $73, $28, $bc, $05, $39, $f1, $79, $71
085E4 A6 21 C3 06 D3 20 DC 00..       .db $a6, $21, $c3, $06, $d3, $20, $dc, $00, $fc, $00
085EE 07 A2 13 21 5F 32 8C 00..       .db $07, $a2, $13, $21, $5f, $32, $8c, $00, $98, $7a
085F8 C7 63 D9 61 03 A2 07 22..       .db $c7, $63, $d9, $61, $03, $a2, $07, $22, $74, $72
08602 77 31 E7 73 39 F1 58 72..       .db $77, $31, $e7, $73, $39, $f1, $58, $72, $77, $73
0860C D8 72 7F B1 97 73 B6 64..       .db $d8, $72, $7f, $b1, $97, $73, $b6, $64, $c5, $65
08616 D4 66 E3 67 F3 67 8D C1..       .db $d4, $66, $e3, $67, $f3, $67, $8d, $c1, $cf, $26
08620 FD                              .db $fd
08621                           
08621                           ;level 3-1
08621                           L_GroundArea5:
08621 52 31                           .db $52, $31
08623 0F 20 6E 66 07 81 36 01..       .db $0f, $20, $6e, $66, $07, $81, $36, $01, $66, $00
0862D A7 22 08 F2 67 7B DC 02..       .db $a7, $22, $08, $f2, $67, $7b, $dc, $02, $98, $f2
08637 D7 20 39 F1 9F 33 DC 27..       .db $d7, $20, $39, $f1, $9f, $33, $dc, $27, $dc, $57
08641 23 83 57 63 6C 51 87 63..       .db $23, $83, $57, $63, $6c, $51, $87, $63, $99, $61
0864B A3 06 B3 21 77 F3 F3 21..       .db $a3, $06, $b3, $21, $77, $f3, $f3, $21, $f7, $2a
08655 13 81 23 22 53 00 63 22..       .db $13, $81, $23, $22, $53, $00, $63, $22, $e9, $0b
0865F 0C 83 13 21 16 22 33 05..       .db $0c, $83, $13, $21, $16, $22, $33, $05, $8f, $35
08669 EC 01 63 A0 67 20 73 01..       .db $ec, $01, $63, $a0, $67, $20, $73, $01, $77, $01
08673 83 20 87 20 B3 20 B7 20..       .db $83, $20, $87, $20, $b3, $20, $b7, $20, $c3, $01
0867D C7 00 D3 20 D7 20 67 A0..       .db $c7, $00, $d3, $20, $d7, $20, $67, $a0, $77, $07
08687 87 22 E8 62 F5 65 1C 82..       .db $87, $22, $e8, $62, $f5, $65, $1c, $82, $7f, $38
08691 8D C1 CF 26                     .db $8d, $c1, $cf, $26
08695 FD                              .db $fd
08696                           
08696                           ;level 1-1
08696                           L_GroundArea6:
08696 50 21                           .db $50, $21
08698 07 81 47 24 57 00 63 01..       .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01
086A2 C9 71 68 F2 E7 73 97 FB..       .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83
086AC 5C 01 D7 22 E7 00 03 A7..       .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02
086B6 B3 22 E3 01 E7 07 47 A0..       .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06
086C0 A7 01 D3 00 D7 01 07 81..       .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20
086CA 93 22 03 A3 1C 61 17 21..       .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33
086D4 C7 63 D8 62 E9 61 FA 60..       .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3
086DE 87 63 9C 01 B7 63 C8 62..       .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61
086E8 EA 60 39 F1 87 21 A7 01..       .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20
086F2 39 F1 5F 38 6D C1 AF 26         .db $39, $f1, $5f, $38, $6d, $c1, $af, $26
086FA FD                              .db $fd
086FB                           
086FB                           ;level 1-3/5-3
086FB                           L_GroundArea7:
086FB 90 11                           .db $90, $11
086FD 0F 26 FE 10 2A 93 87 17..       .db $0f, $26, $fe, $10, $2a, $93, $87, $17, $a3, $14
08707 B2 42 0A 92 19 40 36 14..       .db $b2, $42, $0a, $92, $19, $40, $36, $14, $50, $41
08711 82 16 2B 93 24 41 BB 14..       .db $82, $16, $2b, $93, $24, $41, $bb, $14, $b8, $00
0871B C2 43 C3 13 1B 94 67 12..       .db $c2, $43, $c3, $13, $1b, $94, $67, $12, $c4, $15
08725 53 C1 D2 41 12 C1 29 13..       .db $53, $c1, $d2, $41, $12, $c1, $29, $13, $85, $17
0872F 1B 92 1A 42 47 13 83 41..       .db $1b, $92, $1a, $42, $47, $13, $83, $41, $a7, $13
08739 0E 91 A7 63 B7 63 C5 65..       .db $0e, $91, $a7, $63, $b7, $63, $c5, $65, $d5, $65
08743 DD 4A E3 67 F3 67 8D C1..       .db $dd, $4a, $e3, $67, $f3, $67, $8d, $c1, $ae, $42
0874D DF 20                           .db $df, $20
0874F FD                              .db $fd
08750                           
08750                           ;level 2-3/7-3
08750                           L_GroundArea8:
08750 90 11                           .db $90, $11
08752 0F 26 6E 10 8B 17 AF 32..       .db $0f, $26, $6e, $10, $8b, $17, $af, $32, $d8, $62
0875C E8 62 FC 3F AD C8 F8 64..       .db $e8, $62, $fc, $3f, $ad, $c8, $f8, $64, $0c, $be
08766 43 43 F8 64 0C BF 73 40..       .db $43, $43, $f8, $64, $0c, $bf, $73, $40, $84, $40
08770 93 40 A4 40 B3 40 F8 64..       .db $93, $40, $a4, $40, $b3, $40, $f8, $64, $48, $e4
0877A 5C 39 83 40 92 41 B3 40..       .db $5c, $39, $83, $40, $92, $41, $b3, $40, $f8, $64
08784 48 E4 5C 39 F8 64 13 C2..       .db $48, $e4, $5c, $39, $f8, $64, $13, $c2, $37, $65
0878E 4C 24 63 00 97 65 C3 42..       .db $4c, $24, $63, $00, $97, $65, $c3, $42, $0b, $97
08798 AC 32 F8 64 0C BE 53 45..       .db $ac, $32, $f8, $64, $0c, $be, $53, $45, $9d, $48
087A2 F8 64 2A E2 3C 47 56 43..       .db $f8, $64, $2a, $e2, $3c, $47, $56, $43, $ba, $62
087AC F8 64 0C B7 88 64 BC 31..       .db $f8, $64, $0c, $b7, $88, $64, $bc, $31, $d4, $45
087B6 FC 31 3C B1 78 64 8C 38..       .db $fc, $31, $3c, $b1, $78, $64, $8c, $38, $0b, $9c
087C0 1A 33 18 61 28 61 39 60..       .db $1a, $33, $18, $61, $28, $61, $39, $60, $5d, $4a
087CA EE 11 0F B8 1D C1 3E 42..       .db $ee, $11, $0f, $b8, $1d, $c1, $3e, $42, $6f, $20
087D4 FD                              .db $fd
087D5                           
087D5                           ;level 2-1
087D5                           L_GroundArea9:
087D5 52 31                           .db $52, $31
087D7 0F 20 6E 40 F7 20 07 84..       .db $0f, $20, $6e, $40, $f7, $20, $07, $84, $17, $20
087E1 4F 34 C3 03 C7 02 D3 22..       .db $4f, $34, $c3, $03, $c7, $02, $d3, $22, $27, $e3
087EB 39 61 E7 73 5C E4 57 00..       .db $39, $61, $e7, $73, $5c, $e4, $57, $00, $6c, $73
087F5 47 A0 53 06 63 22 A7 73..       .db $47, $a0, $53, $06, $63, $22, $a7, $73, $fc, $73
087FF 13 A1 33 05 43 21 5C 72..       .db $13, $a1, $33, $05, $43, $21, $5c, $72, $c3, $23
08809 CC 03 77 FB AC 02 39 F1..       .db $cc, $03, $77, $fb, $ac, $02, $39, $f1, $a7, $73
08813 D3 04 E8 72 E3 22 26 F4..       .db $d3, $04, $e8, $72, $e3, $22, $26, $f4, $bc, $02
0881D 8C 81 A8 62 17 87 43 24..       .db $8c, $81, $a8, $62, $17, $87, $43, $24, $a7, $01
08827 C3 04 08 F2 97 21 A3 02..       .db $c3, $04, $08, $f2, $97, $21, $a3, $02, $c9, $0b
08831 E1 69 F1 69 8D C1 CF 26         .db $e1, $69, $f1, $69, $8d, $c1, $cf, $26
08839 FD                              .db $fd
0883A                           
0883A                           ;pipe intro area
0883A                           L_GroundArea10:
0883A 38 11                           .db $38, $11
0883C 0F 26 AD 40 3D C7               .db $0f, $26, $ad, $40, $3d, $c7
08842 FD                              .db $fd
08843                           
08843                           ;level 5-1
08843                           L_GroundArea11:
08843 95 B1                           .db $95, $b1
08845 0F 26 0D 02 C8 72 1C 81..       .db $0f, $26, $0d, $02, $c8, $72, $1c, $81, $38, $72
0884F 0D 05 97 34 98 62 A3 20..       .db $0d, $05, $97, $34, $98, $62, $a3, $20, $b3, $06
08859 C3 20 CC 03 F9 91 2C 81..       .db $c3, $20, $cc, $03, $f9, $91, $2c, $81, $48, $62
08863 0D 09 37 63 47 03 57 21..       .db $0d, $09, $37, $63, $47, $03, $57, $21, $8c, $02
0886D C5 79 C7 31 F9 11 39 F1..       .db $c5, $79, $c7, $31, $f9, $11, $39, $f1, $a9, $11
08877 6F B4 D3 65 E3 65 7D C1..       .db $6f, $b4, $d3, $65, $e3, $65, $7d, $c1, $bf, $26
08881 FD                              .db $fd
08882                           
08882                           ;cloud level used in levels 2-1 and 5-2
08882                           L_GroundArea12:
08882 00 C1                           .db $00, $c1
08884 4C 00 F4 4F 0D 02 02 42..       .db $4c, $00, $f4, $4f, $0d, $02, $02, $42, $43, $4f
0888E 52 C2 DE 00 5A C2 4D C7         .db $52, $c2, $de, $00, $5a, $c2, $4d, $c7
08896 FD                              .db $fd
08897                           
08897                           ;level 4-3
08897                           L_GroundArea13:
08897 90 51                           .db $90, $51
08899 0F 26 EE 10 0B 94 33 14..       .db $0f, $26, $ee, $10, $0b, $94, $33, $14, $42, $42
088A3 77 16 86 44 02 92 4A 16..       .db $77, $16, $86, $44, $02, $92, $4a, $16, $69, $42
088AD 73 14 B0 00 C7 12 05 C0..       .db $73, $14, $b0, $00, $c7, $12, $05, $c0, $1c, $17
088B7 1F 11 36 12 8F 14 91 40..       .db $1f, $11, $36, $12, $8f, $14, $91, $40, $1b, $94
088C1 35 12 34 42 60 42 61 12..       .db $35, $12, $34, $42, $60, $42, $61, $12, $87, $12
088CB 96 40 A3 14 1C 98 1F 11..       .db $96, $40, $a3, $14, $1c, $98, $1f, $11, $47, $12
088D5 9F 15 CC 15 CF 11 05 C0..       .db $9f, $15, $cc, $15, $cf, $11, $05, $c0, $1f, $15
088DF 39 12 7C 16 7F 11 82 40..       .db $39, $12, $7c, $16, $7f, $11, $82, $40, $98, $12
088E9 DF 15 16 C4 17 14 54 12..       .db $df, $15, $16, $c4, $17, $14, $54, $12, $9b, $16
088F3 28 94 CE 01 3D C1 5E 42..       .db $28, $94, $ce, $01, $3d, $c1, $5e, $42, $8f, $20
088FD FD                              .db $fd
088FE                           
088FE                           ;level 6-3
088FE                           L_GroundArea14:
088FE 97 11                           .db $97, $11
08900 0F 26 FE 10 2B 92 57 12..       .db $0f, $26, $fe, $10, $2b, $92, $57, $12, $8b, $12
0890A C0 41 F7 13 5B 92 69 0B..       .db $c0, $41, $f7, $13, $5b, $92, $69, $0b, $bb, $12
08914 B2 46 19 93 71 00 17 94..       .db $b2, $46, $19, $93, $71, $00, $17, $94, $7c, $14
0891E 7F 11 93 41 BF 15 FC 13..       .db $7f, $11, $93, $41, $bf, $15, $fc, $13, $ff, $11
08928 2F 95 50 42 51 12 58 14..       .db $2f, $95, $50, $42, $51, $12, $58, $14, $a6, $12
08932 DB 12 1B 93 46 43 7B 12..       .db $db, $12, $1b, $93, $46, $43, $7b, $12, $8d, $49
0893C B7 14 1B 94 49 0B BB 12..       .db $b7, $14, $1b, $94, $49, $0b, $bb, $12, $fc, $13
08946 FF 12 03 C1 2F 15 43 12..       .db $ff, $12, $03, $c1, $2f, $15, $43, $12, $4b, $13
08950 77 13 9D 4A 15 C1 A1 41..       .db $77, $13, $9d, $4a, $15, $c1, $a1, $41, $c3, $12
0895A FE 01 7D C1 9E 42 CF 20         .db $fe, $01, $7d, $c1, $9e, $42, $cf, $20
08962 FD                              .db $fd
08963                           
08963                           ;level 6-1
08963                           L_GroundArea15:
08963 52 21                           .db $52, $21
08965 0F 20 6E 44 0C F1 4C 01..       .db $0f, $20, $6e, $44, $0c, $f1, $4c, $01, $aa, $35
0896F D9 34 EE 20 08 B3 37 32..       .db $d9, $34, $ee, $20, $08, $b3, $37, $32, $43, $04
08979 4E 21 53 20 7C 01 97 21..       .db $4e, $21, $53, $20, $7c, $01, $97, $21, $b7, $07
08983 9C 81 E7 42 5F B3 97 63..       .db $9c, $81, $e7, $42, $5f, $b3, $97, $63, $ac, $02
0898D C5 41 49 E0 58 61 76 64..       .db $c5, $41, $49, $e0, $58, $61, $76, $64, $85, $65
08997 94 66 A4 22 A6 03 C8 22..       .db $94, $66, $a4, $22, $a6, $03, $c8, $22, $dc, $02
089A1 68 F2 96 42 13 82 17 02..       .db $68, $f2, $96, $42, $13, $82, $17, $02, $af, $34
089AB F6 21 FC 06 26 80 2A 24..       .db $f6, $21, $fc, $06, $26, $80, $2a, $24, $36, $01
089B5 8C 00 FF 35 4E A0 55 21..       .db $8c, $00, $ff, $35, $4e, $a0, $55, $21, $77, $20
089BF 87 07 89 22 AE 21 4C 82..       .db $87, $07, $89, $22, $ae, $21, $4c, $82, $9f, $34
089C9 EC 01 03 E7 13 67 8D 4A..       .db $ec, $01, $03, $e7, $13, $67, $8d, $4a, $ad, $41
089D3 0F A6                           .db $0f, $a6
089D5 FD                              .db $fd
089D6                           
089D6                           ;warp zone area used in level 4-2
089D6                           L_GroundArea16:
089D6 10 51                           .db $10, $51
089D8 4C 00 C7 12 C6 42 03 92..       .db $4c, $00, $c7, $12, $c6, $42, $03, $92, $02, $42
089E2 29 12 63 12 62 42 69 14..       .db $29, $12, $63, $12, $62, $42, $69, $14, $a5, $12
089EC A4 42 E2 14 E1 44 F8 16..       .db $a4, $42, $e2, $14, $e1, $44, $f8, $16, $37, $c1
089F6 8F 38 02 BB 28 7A 68 7A..       .db $8f, $38, $02, $bb, $28, $7a, $68, $7a, $a8, $7a
08A00 E0 6A F0 6A 6D C5               .db $e0, $6a, $f0, $6a, $6d, $c5
08A06 FD                              .db $fd
08A07                           
08A07                           ;level 8-1
08A07                           L_GroundArea17:
08A07 92 31                           .db $92, $31
08A09 0F 20 6E 40 0D 02 37 73..       .db $0f, $20, $6e, $40, $0d, $02, $37, $73, $ec, $00
08A13 0C 80 3C 00 6C 00 9C 00..       .db $0c, $80, $3c, $00, $6c, $00, $9c, $00, $06, $c0
08A1D C7 73 06 83 28 72 96 40..       .db $c7, $73, $06, $83, $28, $72, $96, $40, $e7, $73
08A27 26 C0 87 7B D2 41 39 F1..       .db $26, $c0, $87, $7b, $d2, $41, $39, $f1, $c8, $f2
08A31 97 E3 A3 23 E7 02 E3 07..       .db $97, $e3, $a3, $23, $e7, $02, $e3, $07, $f3, $22
08A3B 37 E3 9C 00 BC 00 EC 00..       .db $37, $e3, $9c, $00, $bc, $00, $ec, $00, $0c, $80
08A45 3C 00 86 21 A6 06 B6 24..       .db $3c, $00, $86, $21, $a6, $06, $b6, $24, $5c, $80
08A4F 7C 00 9C 00 29 E1 DC 05..       .db $7c, $00, $9c, $00, $29, $e1, $dc, $05, $f6, $41
08A59 DC 80 E8 72 0C 81 27 73..       .db $dc, $80, $e8, $72, $0c, $81, $27, $73, $4c, $01
08A63 66 74 0D 11 3F 35 B6 41..       .db $66, $74, $0d, $11, $3f, $35, $b6, $41, $2c, $82
08A6D 36 40 7C 02 86 40 F9 61..       .db $36, $40, $7c, $02, $86, $40, $f9, $61, $39, $e1
08A77 AC 04 C6 41 0C 83 16 41..       .db $ac, $04, $c6, $41, $0c, $83, $16, $41, $88, $f2
08A81 39 F1 7C 00 89 61 9C 00..       .db $39, $f1, $7c, $00, $89, $61, $9c, $00, $a7, $63
08A8B BC 00 C5 65 DC 00 E3 67..       .db $bc, $00, $c5, $65, $dc, $00, $e3, $67, $f3, $67
08A95 8D C1 CF 26                     .db $8d, $c1, $cf, $26
08A99 FD                              .db $fd
08A9A                           
08A9A                           ;level 5-2
08A9A                           L_GroundArea18:
08A9A 55 B1                           .db $55, $b1
08A9C 0F 26 CF 33 07 B2 15 11..       .db $0f, $26, $cf, $33, $07, $b2, $15, $11, $52, $42
08AA6 99 0B AC 02 D3 24 D6 42..       .db $99, $0b, $ac, $02, $d3, $24, $d6, $42, $d7, $25
08AB0 23 84 CF 33 07 E3 19 61..       .db $23, $84, $cf, $33, $07, $e3, $19, $61, $78, $7a
08ABA EF 33 2C 81 46 64 55 65..       .db $ef, $33, $2c, $81, $46, $64, $55, $65, $65, $65
08AC4 EC 74 47 82 53 05 63 21..       .db $ec, $74, $47, $82, $53, $05, $63, $21, $62, $41
08ACE 96 22 9A 41 CC 03 B9 91..       .db $96, $22, $9a, $41, $cc, $03, $b9, $91, $39, $f1
08AD8 63 26 67 27 D3 06 FC 01..       .db $63, $26, $67, $27, $d3, $06, $fc, $01, $18, $e2
08AE2 D9 07 E9 04 0C 86 37 22..       .db $d9, $07, $e9, $04, $0c, $86, $37, $22, $93, $24
08AEC 87 84 AC 02 C2 41 C3 23..       .db $87, $84, $ac, $02, $c2, $41, $c3, $23, $d9, $71
08AF6 FC 01 7F B1 9C 00 A7 63..       .db $fc, $01, $7f, $b1, $9c, $00, $a7, $63, $b6, $64
08B00 CC 00 D4 66 E3 67 F3 67..       .db $cc, $00, $d4, $66, $e3, $67, $f3, $67, $8d, $c1
08B0A CF 26                           .db $cf, $26
08B0C FD                              .db $fd
08B0D                           
08B0D                           ;level 8-2
08B0D                           L_GroundArea19:
08B0D 50 B1                           .db $50, $b1
08B0F 0F 26 FC 00 1F B3 5C 00..       .db $0f, $26, $fc, $00, $1f, $b3, $5c, $00, $65, $65
08B19 74 66 83 67 93 67 DC 73..       .db $74, $66, $83, $67, $93, $67, $dc, $73, $4c, $80
08B23 B3 20 C9 0B C3 08 D3 2F..       .db $b3, $20, $c9, $0b, $c3, $08, $d3, $2f, $dc, $00
08B2D 2C 80 4C 00 8C 00 D3 2E..       .db $2c, $80, $4c, $00, $8c, $00, $d3, $2e, $ed, $4a
08B37 FC 00 D7 A1 EC 01 4C 80..       .db $fc, $00, $d7, $a1, $ec, $01, $4c, $80, $59, $11
08B41 D8 11 DA 10 37 A0 47 04..       .db $d8, $11, $da, $10, $37, $a0, $47, $04, $99, $11
08B4B E7 21 3A 90 67 20 76 10..       .db $e7, $21, $3a, $90, $67, $20, $76, $10, $77, $60
08B55 87 07 D8 12 39 F1 AC 00..       .db $87, $07, $d8, $12, $39, $f1, $ac, $00, $e9, $71
08B5F 0C 80 2C 00 4C 05 C7 7B..       .db $0c, $80, $2c, $00, $4c, $05, $c7, $7b, $39, $f1
08B69 EC 00 F9 11 0C 82 6F 34..       .db $ec, $00, $f9, $11, $0c, $82, $6f, $34, $f8, $11
08B73 FA 10 7F B2 AC 00 B6 64..       .db $fa, $10, $7f, $b2, $ac, $00, $b6, $64, $cc, $01
08B7D E3 67 F3 67 8D C1 CF 26         .db $e3, $67, $f3, $67, $8d, $c1, $cf, $26
08B85 FD                              .db $fd
08B86                           
08B86                           ;level 7-1
08B86                           L_GroundArea20:
08B86 52 B1                           .db $52, $b1
08B88 0F 20 6E 45 39 91 B3 04..       .db $0f, $20, $6e, $45, $39, $91, $b3, $04, $c3, $21
08B92 C8 11 CA 10 49 91 7C 73..       .db $c8, $11, $ca, $10, $49, $91, $7c, $73, $e8, $12
08B9C 88 91 8A 10 E7 21 05 91..       .db $88, $91, $8a, $10, $e7, $21, $05, $91, $07, $30
08BA6 17 07 27 20 49 11 9C 01..       .db $17, $07, $27, $20, $49, $11, $9c, $01, $c8, $72
08BB0 23 A6 27 26 D3 03 D8 7A..       .db $23, $a6, $27, $26, $d3, $03, $d8, $7a, $89, $91
08BBA D8 72 39 F1 A9 11 09 F1..       .db $d8, $72, $39, $f1, $a9, $11, $09, $f1, $63, $24
08BC4 67 24 D8 62 28 91 2A 10..       .db $67, $24, $d8, $62, $28, $91, $2a, $10, $56, $21
08BCE 70 04 79 0B 8C 00 94 21..       .db $70, $04, $79, $0b, $8c, $00, $94, $21, $9f, $35
08BD8 2F B8 3D C1 7F 26               .db $2f, $b8, $3d, $c1, $7f, $26
08BDE FD                              .db $fd
08BDF                           
08BDF                           ;cloud level used in levels 3-1 and 6-2
08BDF                           L_GroundArea21:
08BDF 06 C1                           .db $06, $c1
08BE1 4C 00 F4 4F 0D 02 06 20..       .db $4c, $00, $f4, $4f, $0d, $02, $06, $20, $24, $4f
08BEB 35 A0 36 20 53 46 D5 20..       .db $35, $a0, $36, $20, $53, $46, $d5, $20, $d6, $20
08BF5 34 A1 73 49 74 20 94 20..       .db $34, $a1, $73, $49, $74, $20, $94, $20, $b4, $20
08BFF D4 20 F4 20 2E 80 59 42..       .db $d4, $20, $f4, $20, $2e, $80, $59, $42, $4d, $c7
08C09 FD                              .db $fd
08C0A                           
08C0A                           ;level 3-2
08C0A                           L_GroundArea22:
08C0A 96 31                           .db $96, $31
08C0C 0F 26 0D 03 1A 60 77 42..       .db $0f, $26, $0d, $03, $1a, $60, $77, $42, $c4, $00
08C16 C8 62 B9 E1 D3 06 D7 07..       .db $c8, $62, $b9, $e1, $d3, $06, $d7, $07, $f9, $61
08C20 0C 81 4E B1 8E B1 BC 01..       .db $0c, $81, $4e, $b1, $8e, $b1, $bc, $01, $e4, $50
08C2A E9 61 0C 81 0D 0A 84 43..       .db $e9, $61, $0c, $81, $0d, $0a, $84, $43, $98, $72
08C34 0D 0C 0F 38 1D C1 5F 26         .db $0d, $0c, $0f, $38, $1d, $c1, $5f, $26
08C3C FD                              .db $fd
08C3D                           
08C3D                           ;level 1-2
08C3D                           L_UndergroundArea1:
08C3D 48 0F                           .db $48, $0f
08C3F 0E 01 5E 02 A7 00 BC 73..       .db $0e, $01, $5e, $02, $a7, $00, $bc, $73, $1a, $e0
08C49 39 61 58 62 77 63 97 63..       .db $39, $61, $58, $62, $77, $63, $97, $63, $b8, $62
08C53 D6 07 F8 62 19 E1 75 52..       .db $d6, $07, $f8, $62, $19, $e1, $75, $52, $86, $40
08C5D 87 50 95 52 93 43 A5 21..       .db $87, $50, $95, $52, $93, $43, $a5, $21, $c5, $52
08C67 D6 40 D7 20 E5 06 E6 51..       .db $d6, $40, $d7, $20, $e5, $06, $e6, $51, $3e, $8d
08C71 5E 03 67 52 77 52 7E 02..       .db $5e, $03, $67, $52, $77, $52, $7e, $02, $9e, $03
08C7B A6 43 A7 23 DE 05 FE 02..       .db $a6, $43, $a7, $23, $de, $05, $fe, $02, $1e, $83
08C85 33 54 46 40 47 21 56 04..       .db $33, $54, $46, $40, $47, $21, $56, $04, $5e, $02
08C8F 83 54 93 52 96 07 97 50..       .db $83, $54, $93, $52, $96, $07, $97, $50, $be, $03
08C99 C7 23 FE 02 0C 82 43 45..       .db $c7, $23, $fe, $02, $0c, $82, $43, $45, $45, $24
08CA3 46 24 90 08 95 51 78 FA..       .db $46, $24, $90, $08, $95, $51, $78, $fa, $d7, $73
08CAD 39 F1 8C 01 A8 52 B8 52..       .db $39, $f1, $8c, $01, $a8, $52, $b8, $52, $cc, $01
08CB7 5F B3 97 63 9E 00 0E 81..       .db $5f, $b3, $97, $63, $9e, $00, $0e, $81, $16, $24
08CC1 66 04 8E 00 FE 01 08 D2..       .db $66, $04, $8e, $00, $fe, $01, $08, $d2, $0e, $06
08CCB 6F 47 9E 0F 0E 82 2D 47..       .db $6f, $47, $9e, $0f, $0e, $82, $2d, $47, $28, $7a
08CD5 68 7A A8 7A AE 01 DE 0F..       .db $68, $7a, $a8, $7a, $ae, $01, $de, $0f, $6d, $c5
08CDF FD                              .db $fd
08CE0                           
08CE0                           ;level 4-2
08CE0                           L_UndergroundArea2:
08CE0 48 0F                           .db $48, $0f
08CE2 0E 01 5E 02 BC 01 FC 01..       .db $0e, $01, $5e, $02, $bc, $01, $fc, $01, $2c, $82
08CEC 41 52 4E 04 67 25 68 24..       .db $41, $52, $4e, $04, $67, $25, $68, $24, $69, $24
08CF6 BA 42 C7 04 DE 0B B2 87..       .db $ba, $42, $c7, $04, $de, $0b, $b2, $87, $fe, $02
08D00 2C E1 2C 71 67 01 77 00..       .db $2c, $e1, $2c, $71, $67, $01, $77, $00, $87, $01
08D0A 8E 00 EE 01 F6 02 03 85..       .db $8e, $00, $ee, $01, $f6, $02, $03, $85, $05, $02
08D14 13 21 16 02 27 02 2E 02..       .db $13, $21, $16, $02, $27, $02, $2e, $02, $88, $72
08D1E C7 20 D7 07 E4 76 07 A0..       .db $c7, $20, $d7, $07, $e4, $76, $07, $a0, $17, $06
08D28 48 7A 76 20 98 72 79 E1..       .db $48, $7a, $76, $20, $98, $72, $79, $e1, $88, $62
08D32 9C 01 B7 73 DC 01 F8 62..       .db $9c, $01, $b7, $73, $dc, $01, $f8, $62, $fe, $01
08D3C 08 E2 0E 00 6E 02 73 20..       .db $08, $e2, $0e, $00, $6e, $02, $73, $20, $77, $23
08D46 83 04 93 20 AE 00 FE 0A..       .db $83, $04, $93, $20, $ae, $00, $fe, $0a, $0e, $82
08D50 39 71 A8 72 E7 73 0C 81..       .db $39, $71, $a8, $72, $e7, $73, $0c, $81, $8f, $32
08D5A AE 00 FE 04 04 D1 17 04..       .db $ae, $00, $fe, $04, $04, $d1, $17, $04, $26, $49
08D64 27 29 DF 33 FE 02 44 F6..       .db $27, $29, $df, $33, $fe, $02, $44, $f6, $7c, $01
08D6E 8E 06 BF 47 EE 0F 4D C7..       .db $8e, $06, $bf, $47, $ee, $0f, $4d, $c7, $0e, $82
08D78 68 7A AE 01 DE 0F 6D C5         .db $68, $7a, $ae, $01, $de, $0f, $6d, $c5
08D80 FD                              .db $fd
08D81                           
08D81                           ;underground bonus rooms area used in many levels
08D81                           L_UndergroundArea3:
08D81 48 01                           .db $48, $01
08D83 0E 01 00 5A 3E 06 45 46..       .db $0e, $01, $00, $5a, $3e, $06, $45, $46, $47, $46
08D8D 53 44 AE 01 DF 4A 4D C7..       .db $53, $44, $ae, $01, $df, $4a, $4d, $c7, $0e, $81
08D97 00 5A 2E 04 37 28 3A 48..       .db $00, $5a, $2e, $04, $37, $28, $3a, $48, $46, $47
08DA1 C7 07 CE 0F DF 4A 4D C7..       .db $c7, $07, $ce, $0f, $df, $4a, $4d, $c7, $0e, $81
08DAB 00 5A 33 53 43 51 46 40..       .db $00, $5a, $33, $53, $43, $51, $46, $40, $47, $50
08DB5 53 04 55 40 56 50 62 43..       .db $53, $04, $55, $40, $56, $50, $62, $43, $64, $40
08DBF 65 50 71 41 73 51 83 51..       .db $65, $50, $71, $41, $73, $51, $83, $51, $94, $40
08DC9 95 50 A3 50 A5 40 A6 50..       .db $95, $50, $a3, $50, $a5, $40, $a6, $50, $b3, $51
08DD3 B6 40 B7 50 C3 53 DF 4A..       .db $b6, $40, $b7, $50, $c3, $53, $df, $4a, $4d, $c7
08DDD 0E 81 00 5A 2E 02 36 47..       .db $0e, $81, $00, $5a, $2e, $02, $36, $47, $37, $52
08DE7 3A 49 47 25 A7 52 D7 04..       .db $3a, $49, $47, $25, $a7, $52, $d7, $04, $df, $4a
08DF1 4D C7 0E 81 00 5A 3E 02..       .db $4d, $c7, $0e, $81, $00, $5a, $3e, $02, $44, $51
08DFB 53 44 54 44 55 24 A1 54..       .db $53, $44, $54, $44, $55, $24, $a1, $54, $ae, $01
08E05 B4 21 DF 4A E5 07 4D C7         .db $b4, $21, $df, $4a, $e5, $07, $4d, $c7
08E0D FD                              .db $fd
08E0E                           
08E0E                           ;water area used in levels 5-2 and 6-2
08E0E                           L_WaterArea1:
08E0E 41 01                           .db $41, $01
08E10 B4 34 C8 52 F2 51 47 D3..       .db $b4, $34, $c8, $52, $f2, $51, $47, $d3, $6c, $03
08E1A 65 49 9E 07 BE 01 CC 03..       .db $65, $49, $9e, $07, $be, $01, $cc, $03, $fe, $07
08E24 0D C9 1E 01 6C 01 62 35..       .db $0d, $c9, $1e, $01, $6c, $01, $62, $35, $63, $53
08E2E 8A 41 AC 01 B3 53 E9 51..       .db $8a, $41, $ac, $01, $b3, $53, $e9, $51, $26, $c3
08E38 27 33 63 43 64 33 BA 60..       .db $27, $33, $63, $43, $64, $33, $ba, $60, $c9, $61
08E42 CE 0B E5 09 EE 0F 7D CA..       .db $ce, $0b, $e5, $09, $ee, $0f, $7d, $ca, $7d, $47
08E4C FD                              .db $fd
08E4D                           
08E4D                           ;level 2-2/7-2
08E4D                           L_WaterArea2:
08E4D 41 01                           .db $41, $01
08E4F B8 52 EA 41 27 B2 B3 42..       .db $b8, $52, $ea, $41, $27, $b2, $b3, $42, $16, $d4
08E59 4A 42 A5 51 A7 31 27 D3..       .db $4a, $42, $a5, $51, $a7, $31, $27, $d3, $08, $e2
08E63 16 64 2C 04 38 42 76 64..       .db $16, $64, $2c, $04, $38, $42, $76, $64, $88, $62
08E6D DE 07 FE 01 0D C9 23 32..       .db $de, $07, $fe, $01, $0d, $c9, $23, $32, $31, $51
08E77 98 52 0D C9 59 42 63 53..       .db $98, $52, $0d, $c9, $59, $42, $63, $53, $67, $31
08E81 14 C2 36 31 87 53 17 E3..       .db $14, $c2, $36, $31, $87, $53, $17, $e3, $29, $61
08E8B 30 62 3C 08 42 37 59 40..       .db $30, $62, $3c, $08, $42, $37, $59, $40, $6a, $42
08E95 99 40 C9 61 D7 63 39 D1..       .db $99, $40, $c9, $61, $d7, $63, $39, $d1, $58, $52
08E9F C3 67 D3 31 DC 06 F7 42..       .db $c3, $67, $d3, $31, $dc, $06, $f7, $42, $fa, $42
08EA9 23 B1 43 67 C3 34 C7 34..       .db $23, $b1, $43, $67, $c3, $34, $c7, $34, $d1, $51
08EB3 43 B3 47 33 9A 30 A9 61..       .db $43, $b3, $47, $33, $9a, $30, $a9, $61, $b8, $62
08EBD BE 0B D5 09 DE 0F 0D CA..       .db $be, $0b, $d5, $09, $de, $0f, $0d, $ca, $7d, $47
08EC7 FD                              .db $fd
08EC8                           
08EC8                           ;water area used in level 8-4
08EC8                           L_WaterArea3:
08EC8 49 0F                           .db $49, $0f
08ECA 1E 01 39 73 5E 07 AE 0B..       .db $1e, $01, $39, $73, $5e, $07, $ae, $0b, $1e, $82
08ED4 6E 88 9E 02 0D 04 2E 0B..       .db $6e, $88, $9e, $02, $0d, $04, $2e, $0b, $45, $09
08EDE 4E 0F ED 47                     .db $4e, $0f, $ed, $47
08EE2 FD                              .db $fd
08EE3                           
08EE3                           ;-------------------------------------------------------------------------------------
08EE3                           
08EE3                           ;unused space
08EE3 FF                              .db $ff
08EE4                           
08EE4                           ;-------------------------------------------------------------------------------------
08EE4                           
08EE4                           ;indirect jump routine called when
08EE4                           ;$0770 is set to 1
08EE4                           GameMode:
08EE4 AD 72 07                        lda OperMode_Task
08EE7 20 0A 6E                        jsr JumpEngine
08EEA                           
08EEA EA 6F                           .dw InitializeArea
08EEC 6D 65                           .dw ScreenRoutines
08EEE 77 70                           .dw SecondaryGameSetup
08EF0 F2 8E                           .dw GameCoreRoutine
08EF2                           
08EF2                           ;-------------------------------------------------------------------------------------
08EF2                           
08EF2                           GameCoreRoutine:
08EF2 AE 53 07                        ldx CurrentPlayer          ;get which player is on the screen
08EF5 BD FC 06                        lda SavedJoypadBits,x      ;use appropriate player's controller bits
08EF8 8D FC 06                        sta SavedJoypadBits        ;as the master controller bits
08EFB 20 52 90                        jsr GameRoutines           ;execute one of many possible subs
08EFE AD 72 07                        lda OperMode_Task          ;check major task of operating mode
08F01 C9 03                           cmp #$03                   ;if we are supposed to be here,
08F03 B0 01                           bcs GameEngine             ;branch to the game engine itself
08F05 60                              rts
08F06                           
08F06                           GameEngine:
08F06 20 2C 96                                jsr ProcFireball_Bubble    ;process fireballs and air bubbles
08F09 A2 00                                   ldx #$00
08F0B 86 08                     ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
08F0D 20 4F A0                                jsr EnemiesAndLoopsCore    ;process enemy objects
08F10 20 C9 64                                jsr FloateyNumbersRoutine  ;process floatey numbers
08F13 E8                                      inx
08F14 E0 06                                   cpx #$06                   ;do these two subroutines until the whole buffer is done
08F16 D0 F3                                   bne ProcELoop
08F18 20 84 D1                                jsr GetPlayerOffscreenBits ;get offscreen bits for player object
08F1B 20 2E D1                                jsr RelativePlayerPosition ;get relative coordinates for player object
08F1E 20 ED CE                                jsr PlayerGfxHandler       ;draw the player
08F21 20 DC 9E                                jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
08F24 A2 01                                   ldx #$01
08F26 86 08                                   stx ObjectOffset           ;set offset for second
08F28 20 78 9E                                jsr BlockObjectsCore       ;process second block object
08F2B CA                                      dex
08F2C 86 08                                   stx ObjectOffset           ;set offset for first
08F2E 20 78 9E                                jsr BlockObjectsCore       ;process first block object
08F31 20 9E 9B                                jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
08F34 20 C4 99                                jsr ProcessCannons         ;process bullet bill cannons
08F37 20 C0 97                                jsr ProcessWhirlpools      ;process whirlpools
08F3A 20 5D 98                                jsr FlagpoleRoutine        ;process the flagpole
08F3D 20 57 97                                jsr RunGameTimer           ;count down the game timer
08F40 20 E7 69                                jsr ColorRotation          ;cycle one of the background colors
08F43 A5 B5                                   lda Player_Y_HighPos
08F45 C9 02                                   cmp #$02                   ;if player is below the screen, don't bother with the music
08F47 10 11                                   bpl NoChgMus
08F49 AD 9F 07                                lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
08F4C F0 1E                                   beq ClrPlrPal              ;skip this part
08F4E C9 04                                   cmp #$04
08F50 D0 08                                   bne NoChgMus               ;if not yet at a certain point, continue
08F52 AD 7F 07                                lda IntervalTimerControl   ;if interval timer not yet expired,
08F55 D0 03                                   bne NoChgMus               ;branch ahead, don't bother with the music
08F57 20 F7 70                                jsr GetAreaMusic           ;to re-attain appropriate level music
08F5A AC 9F 07                  NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
08F5D A5 09                                   lda FrameCounter           ;get frame counter
08F5F C0 08                                   cpy #$08                   ;if timer still above certain point,
08F61 B0 02                                   bcs CycleTwo               ;branch to cycle player's palette quickly
08F63 4A                                      lsr                        ;otherwise, divide by 8 to cycle every eighth frame
08F64 4A                                      lsr
08F65 4A                        CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
08F66 20 90 92                                jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
08F69 4C 6F 8F                                jmp SaveAB                 ;then skip this sub to finish up the game engine
08F6C 20 A2 92                  ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
08F6F A5 0A                     SaveAB:       lda A_B_Buttons            ;save current A and B button
08F71 85 0D                                   sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
08F73 A9 00                                   lda #$00
08F75 85 0C                                   sta Left_Right_Buttons     ;nullify left and right buttons temp variable
08F77 AD 73 07                  UpdScrollVar: lda VRAM_Buffer_AddrCtrl
08F7A C9 06                                   cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
08F7C F0 1C                                   beq ExitEng                ;then branch to leave
08F7E AD 1F 07                                lda AreaParserTaskNum      ;otherwise check number of tasks
08F81 D0 14                                   bne RunParser
08F83 AD 3D 07                                lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
08F86 C9 20                                   cmp #$20                   ;check to see if exceeded $21
08F88 30 10                                   bmi ExitEng                ;branch to leave if not
08F8A AD 3D 07                                lda ScrollThirtyTwo
08F8D E9 20                                   sbc #$20                   ;otherwise subtract $20 to set appropriately
08F8F 8D 3D 07                                sta ScrollThirtyTwo        ;and store
08F92 A9 00                                   lda #$00                   ;reset vram buffer offset used in conjunction with
08F94 8D 40 03                                sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
08F97 20 BA 72                  RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
08F9A 60                        ExitEng:      rts                        ;and after all that, we're finally done!
08F9B                           
08F9B                           ;-------------------------------------------------------------------------------------
08F9B                           
08F9B                           ScrollHandler:
08F9B AD FF 06                              lda Player_X_Scroll       ;load value saved here
08F9E 18                                    clc
08F9F 6D A1 03                              adc Platform_X_Scroll     ;add value used by left/right platforms
08FA2 8D FF 06                              sta Player_X_Scroll       ;save as new value here to impose force on scroll
08FA5 AD 23 07                              lda ScrollLock            ;check scroll lock flag
08FA8 D0 59                                 bne InitScrlAmt           ;skip a bunch of code here if set
08FAA AD 55 07                              lda Player_Pos_ForScroll
08FAD C9 50                                 cmp #$50                  ;check player's horizontal screen position
08FAF 90 52                                 bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
08FB1 AD 85 07                              lda SideCollisionTimer    ;if timer related to player's side collision
08FB4 D0 4D                                 bne InitScrlAmt           ;not expired, branch
08FB6 AC FF 06                              ldy Player_X_Scroll       ;get value and decrement by one
08FB9 88                                    dey                       ;if value originally set to zero or otherwise
08FBA 30 47                                 bmi InitScrlAmt           ;negative for left movement, branch
08FBC C8                                    iny
08FBD C0 02                                 cpy #$02                  ;if value $01, branch and do not decrement
08FBF 90 01                                 bcc ChkNearMid
08FC1 88                                    dey                       ;otherwise decrement by one
08FC2 AD 55 07                  ChkNearMid: lda Player_Pos_ForScroll
08FC5 C9 70                                 cmp #$70                  ;check player's horizontal screen position
08FC7 90 03                                 bcc ScrollScreen          ;if less than 112 pixels to the right, branch
08FC9 AC FF 06                              ldy Player_X_Scroll       ;otherwise get original value undecremented
08FCC                           
08FCC                           ScrollScreen:
08FCC 98                                      tya
08FCD 8D 75 07                                sta ScrollAmount          ;save value here
08FD0 18                                      clc
08FD1 6D 3D 07                                adc ScrollThirtyTwo       ;add to value already set here
08FD4 8D 3D 07                                sta ScrollThirtyTwo       ;save as new value here
08FD7 98                                      tya
08FD8 18                                      clc
08FD9 6D 1C 07                                adc ScreenLeft_X_Pos      ;add to left side coordinate
08FDC 8D 1C 07                                sta ScreenLeft_X_Pos      ;save as new left side coordinate
08FDF 8D 3F 07                                sta HorizontalScroll      ;save here also
08FE2 AD 1A 07                                lda ScreenLeft_PageLoc
08FE5 69 00                                   adc #$00                  ;add carry to page location for left
08FE7 8D 1A 07                                sta ScreenLeft_PageLoc    ;side of the screen
08FEA 29 01                                   and #$01                  ;get LSB of page location
08FEC 85 00                                   sta $00                   ;save as temp variable for PPU register 1 mirror
08FEE AD 78 07                                lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
08FF1 29 FE                                   and #%11111110            ;save all bits except d0
08FF3 05 00                                   ora $00                   ;get saved bit here and save in PPU register 1
08FF5 8D 78 07                                sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
08FF8 20 40 90                                jsr GetScreenPosition     ;figure out where the right side is
08FFB A9 08                                   lda #$08
08FFD 8D 95 07                                sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
09000 4C 08 90                                jmp ChkPOffscr            ;skip this part
09003 A9 00                     InitScrlAmt:  lda #$00
09005 8D 75 07                                sta ScrollAmount          ;initialize value here
09008 A2 00                     ChkPOffscr:   ldx #$00                  ;set X for player offset
0900A 20 FA D1                                jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
0900D 85 00                                   sta $00                   ;save them here
0900F A0 00                                   ldy #$00                  ;load default offset (left side)
09011 0A                                      asl                       ;if d7 of offscreen bits are set,
09012 B0 07                                   bcs KeepOnscr             ;branch with default offset
09014 C8                                      iny                         ;otherwise use different offset (right side)
09015 A5 00                                   lda $00
09017 29 20                                   and #%00100000              ;check offscreen bits for d5 set
09019 F0 1B                                   beq InitPlatScrl            ;if not set, branch ahead of this part
0901B B9 1C 07                  KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
0901E 38                                      sec
0901F F9 3C 90                                sbc X_SubtracterData,y      ;subtract amount based on offset
09022 85 86                                   sta Player_X_Position       ;store as player position to prevent movement further
09024 B9 1A 07                                lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
09027 E9 00                                   sbc #$00                    ;subtract borrow
09029 85 6D                                   sta Player_PageLoc          ;save as player's page location
0902B A5 0C                                   lda Left_Right_Buttons      ;check saved controller bits
0902D D9 3E 90                                cmp OffscrJoypadBitsData,y  ;against bits based on offset
09030 F0 04                                   beq InitPlatScrl            ;if not equal, branch
09032 A9 00                                   lda #$00
09034 85 57                                   sta Player_X_Speed          ;otherwise nullify horizontal speed of player
09036 A9 00                     InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
09038 8D A1 03                                sta Platform_X_Scroll
0903B 60                                      rts
0903C                           
0903C                           X_SubtracterData:
0903C 00 10                           .db $00, $10
0903E                           
0903E                           OffscrJoypadBitsData:
0903E 01 02                           .db $01, $02
09040                           
09040                           ;-------------------------------------------------------------------------------------
09040                           
09040                           GetScreenPosition:
09040 AD 1C 07                        lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
09043 18                              clc
09044 69 FF                           adc #$ff                ;add 255 pixels
09046 8D 1D 07                        sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
09049 AD 1A 07                        lda ScreenLeft_PageLoc  ;get page number where left boundary is
0904C 69 00                           adc #$00                ;add carry from before
0904E 8D 1B 07                        sta ScreenRight_PageLoc ;store as page number where right boundary is
09051 60                              rts
09052                           
09052                           ;-------------------------------------------------------------------------------------
09052                           
09052                           GameRoutines:
09052 A5 0E                           lda GameEngineSubroutine  ;run routine based on number (a few of these routines are   
09054 20 0A 6E                        jsr JumpEngine            ;merely placeholders as conditions for other routines)
09057                           
09057 3B 71                           .dw Entrance_GameTimerSetup
09059 CF 91                           .dw Vine_AutoClimb
0905B 0E 92                           .dw SideExitPipeEntry
0905D ED 91                           .dw VerticalPipeEntry
0905F AC 92                           .dw FlagpoleSlide
09061 D2 92                           .dw PlayerEndLevel
09063 D7 71                           .dw PlayerLoseLife
09065 71 90                           .dw PlayerEntrance
09067 F1 90                           .dw PlayerCtrlRoutine
09069 3B 92                           .dw PlayerChangeSize
0906B 4D 92                           .dw PlayerInjuryBlink
0906D 71 92                           .dw PlayerDeath
0906F 85 92                           .dw PlayerFireFlower
09071                           
09071                           ;-------------------------------------------------------------------------------------
09071                           
09071                           PlayerEntrance:
09071 AD 52 07                              lda AltEntranceControl    ;check for mode of alternate entry
09074 C9 02                                 cmp #$02
09076 F0 2B                                 beq EntrMode2             ;if found, branch to enter from pipe or with vine
09078 A9 00                                 lda #$00       
0907A A4 CE                                 ldy Player_Y_Position     ;if vertical position above a certain
0907C C0 30                                 cpy #$30                  ;point, nullify controller bits and continue
0907E 90 6E                                 bcc AutoControlPlayer     ;with player movement code, do not return
09080 AD 10 07                              lda PlayerEntranceCtrl    ;check player entry bits from header
09083 C9 06                                 cmp #$06
09085 F0 04                                 beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
09087 C9 07                                 cmp #$07                  ;otherwise branch to normal entry
09089 D0 50                                 bne PlayerRdy
0908B AD C4 03                  ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
0908E D0 05                                 bne IntroEntr             ;branch if found
09090 A9 01                                 lda #$01
09092 4C EE 90                              jmp AutoControlPlayer     ;force player to walk to the right
09095 20 27 92                  IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
09098 CE DE 06                              dec ChangeAreaTimer       ;decrement timer for change of area
0909B D0 50                                 bne ExitEntr              ;branch to exit if not yet expired
0909D EE 69 07                              inc DisableIntermediate   ;set flag to skip world and lives display
090A0 4C 1D 93                              jmp NextArea              ;jump to increment to next area and set modes
090A3 AD 58 07                  EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
090A6 D0 0C                                 bne VineEntr              ;branch to enter with vine
090A8 A9 FF                                 lda #$ff                  ;otherwise, set value here then execute sub
090AA 20 08 92                              jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
090AD A5 CE                                 lda Player_Y_Position     ;check to see if player is at a specific coordinate
090AF C9 91                                 cmp #$91                  ;if player risen to a certain point (this requires pipes
090B1 90 28                                 bcc PlayerRdy             ;to be at specific height to look/function right) branch
090B3 60                                    rts                       ;to the last part, otherwise leave
090B4 AD 99 03                  VineEntr:   lda VineHeight
090B7 C9 60                                 cmp #$60                  ;check vine height
090B9 D0 32                                 bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
090BB A5 CE                                 lda Player_Y_Position     ;get player's vertical coordinate
090BD C9 99                                 cmp #$99                  ;check player's vertical coordinate against preset value
090BF A0 00                                 ldy #$00                  ;load default values to be written to 
090C1 A9 01                                 lda #$01                  ;this value moves player to the right off the vine
090C3 90 0A                                 bcc OffVine               ;if vertical coordinate < preset value, use defaults
090C5 A9 03                                 lda #$03
090C7 85 1D                                 sta Player_State          ;otherwise set player state to climbing
090C9 C8                                    iny                       ;increment value in Y
090CA A9 08                                 lda #$08                  ;set block in block buffer to cover hole, then 
090CC 8D B4 05                              sta Block_Buffer_1+$b4    ;use same value to force player to climb
090CF 8C 16 07                  OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
090D2 20 EE 90                              jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
090D5 A5 86                                 lda Player_X_Position
090D7 C9 48                                 cmp #$48                  ;check player's horizontal position
090D9 90 12                                 bcc ExitEntr              ;if not far enough to the right, branch to leave
090DB A9 08                     PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
090DD 85 0E                                 sta GameEngineSubroutine
090DF A9 01                                 lda #$01                  ;set to face player to the right
090E1 85 33                                 sta PlayerFacingDir
090E3 4A                                    lsr                       ;init A
090E4 8D 52 07                              sta AltEntranceControl    ;init mode of entry
090E7 8D 16 07                              sta DisableCollisionDet   ;init collision detection disable flag
090EA 8D 58 07                              sta JoypadOverride        ;nullify controller override bits
090ED 60                        ExitEntr:   rts                       ;leave!
090EE                           
090EE                           ;-------------------------------------------------------------------------------------
090EE                           ;$07 - used to hold upper limit of high byte when player falls down hole
090EE                           
090EE                           AutoControlPlayer:
090EE 8D FC 06                        sta SavedJoypadBits         ;override controller bits with contents of A if executing here
090F1                           
090F1                           PlayerCtrlRoutine:
090F1 A5 0E                                 lda GameEngineSubroutine    ;check task here
090F3 C9 0B                                 cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
090F5 F0 3C                                 beq SizeChk
090F7 AD 4E 07                              lda AreaType                ;are we in a water type area?
090FA D0 10                                 bne SaveJoyp                ;if not, branch
090FC A4 B5                                 ldy Player_Y_HighPos
090FE 88                                    dey                         ;if not in vertical area between
090FF D0 06                                 bne DisJoyp                 ;status bar and bottom, branch
09101 A5 CE                                 lda Player_Y_Position
09103 C9 D0                                 cmp #$d0                    ;if nearing the bottom of the screen or
09105 90 05                                 bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
09107 A9 00                     DisJoyp:    lda #$00                    ;disable controller bits
09109 8D FC 06                              sta SavedJoypadBits
0910C AD FC 06                  SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
0910F 29 C0                                 and #%11000000
09111 85 0A                                 sta A_B_Buttons
09113 AD FC 06                              lda SavedJoypadBits         ;store left and right buttons in $0c
09116 29 03                                 and #%00000011
09118 85 0C                                 sta Left_Right_Buttons
0911A AD FC 06                              lda SavedJoypadBits         ;store up and down buttons in $0b
0911D 29 0C                                 and #%00001100
0911F 85 0B                                 sta Up_Down_Buttons
09121 29 04                                 and #%00000100              ;check for pressing down
09123 F0 0E                                 beq SizeChk                 ;if not, branch
09125 A5 1D                                 lda Player_State            ;check player's state
09127 D0 0A                                 bne SizeChk                 ;if not on the ground, branch
09129 A4 0C                                 ldy Left_Right_Buttons      ;check left and right
0912B F0 06                                 beq SizeChk                 ;if neither pressed, branch
0912D A9 00                                 lda #$00
0912F 85 0C                                 sta Left_Right_Buttons      ;if pressing down while on the ground,
09131 85 0B                                 sta Up_Down_Buttons         ;nullify directional bits
09133 20 31 93                  SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
09136 A0 01                                 ldy #$01                    ;is player small?
09138 AD 54 07                              lda PlayerSize
0913B D0 09                                 bne ChkMoveDir
0913D A0 00                                 ldy #$00                    ;check for if crouching
0913F AD 14 07                              lda CrouchingFlag
09142 F0 02                                 beq ChkMoveDir              ;if not, branch ahead
09144 A0 02                                 ldy #$02                    ;if big and crouching, load y with 2
09146 8C 99 04                  ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
09149 A9 01                                 lda #$01                    ;set moving direction to right by default
0914B A4 57                                 ldy Player_X_Speed          ;check player's horizontal speed
0914D F0 05                                 beq PlayerSubs              ;if not moving at all horizontally, skip this part
0914F 10 01                                 bpl SetMoveDir              ;if moving to the right, use default moving direction
09151 0A                                    asl                         ;otherwise change to move to the left
09152 85 45                     SetMoveDir: sta Player_MovingDir        ;set moving direction
09154 20 9B 8F                  PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
09157 20 84 D1                              jsr GetPlayerOffscreenBits  ;get player's offscreen bits
0915A 20 2E D1                              jsr RelativePlayerPosition  ;get coordinates relative to the screen
0915D A2 00                                 ldx #$00                    ;set offset for player object
0915F 20 A1 C2                              jsr BoundingBoxCore         ;get player's bounding box coordinates
09162 20 69 BC                              jsr PlayerBGCollision       ;do collision detection and process
09165 A5 CE                                 lda Player_Y_Position
09167 C9 40                                 cmp #$40                    ;check to see if player is higher than 64th pixel
09169 90 16                                 bcc PlayerHole              ;if so, branch ahead
0916B A5 0E                                 lda GameEngineSubroutine
0916D C9 05                                 cmp #$05                    ;if running end-of-level routine, branch ahead
0916F F0 10                                 beq PlayerHole
09171 C9 07                                 cmp #$07                    ;if running player entrance routine, branch ahead
09173 F0 0C                                 beq PlayerHole
09175 C9 04                                 cmp #$04                    ;if running routines $00-$03, branch ahead
09177 90 08                                 bcc PlayerHole
09179 AD C4 03                              lda Player_SprAttrib
0917C 29 DF                                 and #%11011111              ;otherwise nullify player's
0917E 8D C4 03                              sta Player_SprAttrib        ;background priority flag
09181 A5 B5                     PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
09183 C9 02                                 cmp #$02                    ;for below the screen
09185 30 3B                                 bmi ExitCtrl                ;branch to leave if not that far down
09187 A2 01                                 ldx #$01
09189 8E 23 07                              stx ScrollLock              ;set scroll lock
0918C A0 04                                 ldy #$04
0918E 84 07                                 sty $07                     ;set value here
09190 A2 00                                 ldx #$00                    ;use X as flag, and clear for cloud level
09192 AC 59 07                              ldy GameTimerExpiredFlag    ;check game timer expiration flag
09195 D0 05                                 bne HoleDie                 ;if set, branch
09197 AC 43 07                              ldy CloudTypeOverride       ;check for cloud type override
0919A D0 16                                 bne ChkHoleX                ;skip to last part if found
0919C E8                        HoleDie:    inx                         ;set flag in X for player death
0919D A4 0E                                 ldy GameEngineSubroutine
0919F C0 0B                                 cpy #$0b                    ;check for some other routine running
091A1 F0 0F                                 beq ChkHoleX                ;if so, branch ahead
091A3 AC 12 07                              ldy DeathMusicLoaded        ;check value here
091A6 D0 06                                 bne HoleBottom              ;if already set, branch to next part
091A8 C8                                    iny
091A9 84 FC                                 sty EventMusicQueue         ;otherwise play death music
091AB 8C 12 07                              sty DeathMusicLoaded        ;and set value here
091AE A0 06                     HoleBottom: ldy #$06
091B0 84 07                                 sty $07                     ;change value here
091B2 C5 07                     ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
091B4 30 0C                                 bmi ExitCtrl                ;if less, branch to leave
091B6 CA                                    dex                         ;otherwise decrement flag in X
091B7 30 0A                                 bmi CloudExit               ;if flag was clear, branch to set modes and other values
091B9 AC B1 07                              ldy EventMusicBuffer        ;check to see if music is still playing
091BC D0 04                                 bne ExitCtrl                ;branch to leave if so
091BE A9 06                                 lda #$06                    ;otherwise set to run lose life routine
091C0 85 0E                                 sta GameEngineSubroutine    ;on next frame
091C2 60                        ExitCtrl:   rts                         ;leave
091C3                           
091C3                           CloudExit:
091C3 A9 00                           lda #$00
091C5 8D 58 07                        sta JoypadOverride      ;clear controller override bits if any are set
091C8 20 E5 91                        jsr SetEntr             ;do sub to set secondary mode
091CB EE 52 07                        inc AltEntranceControl  ;set mode of entry to 3
091CE 60                              rts
091CF                           
091CF                           ;-------------------------------------------------------------------------------------
091CF                           
091CF                           Vine_AutoClimb:
091CF A5 B5                                lda Player_Y_HighPos   ;check to see whether player reached position
091D1 D0 06                                bne AutoClimb          ;above the status bar yet and if so, set modes
091D3 A5 CE                                lda Player_Y_Position
091D5 C9 E4                                cmp #$e4
091D7 90 0C                                bcc SetEntr
091D9 A9 08                     AutoClimb: lda #%00001000         ;set controller bits override to up
091DB 8D 58 07                             sta JoypadOverride
091DE A0 03                                ldy #$03               ;set player state to climbing
091E0 84 1D                                sty Player_State
091E2 4C EE 90                             jmp AutoControlPlayer
091E5 A9 02                     SetEntr:   lda #$02               ;set starting position to override
091E7 8D 52 07                             sta AltEntranceControl
091EA 4C 1B 92                             jmp ChgAreaMode        ;set modes
091ED                           
091ED                           ;-------------------------------------------------------------------------------------
091ED                           
091ED                           VerticalPipeEntry:
091ED A9 01                           lda #$01             ;set 1 as movement amount
091EF 20 08 92                        jsr MovePlayerYAxis  ;do sub to move player downwards
091F2 20 9B 8F                        jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
091F5 A0 00                           ldy #$00             ;load default mode of entry
091F7 AD D6 06                        lda WarpZoneControl  ;check warp zone control variable/flag
091FA D0 17                           bne ChgAreaPipe      ;if set, branch to use mode 0
091FC C8                              iny
091FD AD 4E 07                        lda AreaType         ;check for castle level type
09200 C9 03                           cmp #$03
09202 D0 0F                           bne ChgAreaPipe      ;if not castle type level, use mode 1
09204 C8                              iny
09205 4C 13 92                        jmp ChgAreaPipe      ;otherwise use mode 2
09208                           
09208                           MovePlayerYAxis:
09208 18                              clc
09209 65 CE                           adc Player_Y_Position ;add contents of A to player position
0920B 85 CE                           sta Player_Y_Position
0920D 60                              rts
0920E                           
0920E                           ;-------------------------------------------------------------------------------------
0920E                           
0920E                           SideExitPipeEntry:
0920E 20 27 92                               jsr EnterSidePipe         ;execute sub to move player to the right
09211 A0 02                                  ldy #$02
09213 CE DE 06                  ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
09216 D0 0E                                  bne ExitCAPipe
09218 8C 52 07                               sty AltEntranceControl    ;when timer expires set mode of alternate entry
0921B EE 74 07                  ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
0921E A9 00                                  lda #$00
09220 8D 72 07                               sta OperMode_Task         ;set secondary mode of operation
09223 8D 22 07                               sta Sprite0HitDetectFlag  ;disable sprite 0 check
09226 60                        ExitCAPipe:  rts                       ;leave
09227                           
09227                           EnterSidePipe:
09227 A9 08                                lda #$08               ;set player's horizontal speed
09229 85 57                                sta Player_X_Speed
0922B A0 01                                ldy #$01               ;set controller right button by default
0922D A5 86                                lda Player_X_Position  ;mask out higher nybble of player's
0922F 29 0F                                and #%00001111         ;horizontal position
09231 D0 03                                bne RightPipe
09233 85 57                                sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
09235 A8                                   tay                    ;and nullify controller bit override here
09236 98                        RightPipe: tya                    ;use contents of Y to
09237 20 EE 90                             jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
0923A 60                                   rts
0923B                           
0923B                           ;-------------------------------------------------------------------------------------
0923B                           
0923B                           PlayerChangeSize:
0923B AD 47 07                               lda TimerControl    ;check master timer control
0923E C9 F8                                  cmp #$f8            ;for specific moment in time
09240 D0 03                                  bne EndChgSize      ;branch if before or after that point
09242 4C 5D 92                               jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
09245 C9 C4                     EndChgSize:  cmp #$c4            ;check again for another specific moment
09247 D0 03                                  bne ExitChgSize     ;and branch to leave if before or after that point
09249 20 7B 92                               jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
0924C 60                        ExitChgSize: rts                 ;and then leave
0924D                           
0924D                           ;-------------------------------------------------------------------------------------
0924D                           
0924D                           PlayerInjuryBlink:
0924D AD 47 07                             lda TimerControl       ;check master timer control
09250 C9 F0                                cmp #$f0               ;for specific moment in time
09252 B0 07                                bcs ExitBlink          ;branch if before that point
09254 C9 C8                                cmp #$c8               ;check again for another specific point
09256 F0 23                                beq DonePlayerTask     ;branch if at that point, and not before or after
09258 4C F1 90                             jmp PlayerCtrlRoutine  ;otherwise run player control routine
0925B D0 13                     ExitBlink: bne ExitBoth           ;do unconditional branch to leave
0925D                           
0925D                           InitChangeSize:
0925D AC 0B 07                            ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
09260 D0 0E                               bne ExitBoth              ;then branch to leave
09262 8C 0D 07                            sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
09265 EE 0B 07                            inc PlayerChangeSizeFlag  ;set growing/shrinking flag
09268 AD 54 07                            lda PlayerSize
0926B 49 01                               eor #$01                  ;invert player's size
0926D 8D 54 07                            sta PlayerSize
09270 60                        ExitBoth: rts                       ;leave
09271                           
09271                           ;-------------------------------------------------------------------------------------
09271                           ;$00 - used in CyclePlayerPalette to store current palette to cycle
09271                           
09271                           PlayerDeath:
09271 AD 47 07                        lda TimerControl       ;check master timer control
09274 C9 F0                           cmp #$f0               ;for specific moment in time
09276 B0 33                           bcs ExitDeath          ;branch to leave if before that point
09278 4C F1 90                        jmp PlayerCtrlRoutine  ;otherwise run player control routine
0927B                           
0927B                           DonePlayerTask:
0927B A9 00                           lda #$00
0927D 8D 47 07                        sta TimerControl          ;initialize master timer control to continue timers
09280 A9 08                           lda #$08
09282 85 0E                           sta GameEngineSubroutine  ;set player control routine to run next frame
09284 60                              rts                       ;leave
09285                           
09285                           PlayerFireFlower: 
09285 AD 47 07                        lda TimerControl       ;check master timer control
09288 C9 C0                           cmp #$c0               ;for specific moment in time
0928A F0 13                           beq ResetPalFireFlower ;branch if at moment, not before or after
0928C A5 09                           lda FrameCounter       ;get frame counter
0928E 4A                              lsr
0928F 4A                              lsr                    ;divide by four to change every four frames
09290                           
09290                           CyclePlayerPalette:
09290 29 03                           and #$03              ;mask out all but d1-d0 (previously d3-d2)
09292 85 00                           sta $00               ;store result here to use as palette bits
09294 AD C4 03                        lda Player_SprAttrib  ;get player attributes
09297 29 FC                           and #%11111100        ;save any other bits but palette bits
09299 05 00                           ora $00               ;add palette bits
0929B 8D C4 03                        sta Player_SprAttrib  ;store as new player attributes
0929E 60                              rts                   ;and leave
0929F                           
0929F                           ResetPalFireFlower:
0929F 20 7B 92                        jsr DonePlayerTask    ;do sub to init timer control and run player control routine
092A2                           
092A2                           ResetPalStar:
092A2 AD C4 03                        lda Player_SprAttrib  ;get player attributes
092A5 29 FC                           and #%11111100        ;mask out palette bits to force palette 0
092A7 8D C4 03                        sta Player_SprAttrib  ;store as new player attributes
092AA 60                              rts                   ;and leave
092AB                           
092AB                           ExitDeath:
092AB 60                              rts          ;leave from death routine
092AC                           
092AC                           ;-------------------------------------------------------------------------------------
092AC                           
092AC                           FlagpoleSlide:
092AC A5 1B                                  lda Enemy_ID+5           ;check special use enemy slot
092AE C9 30                                  cmp #FlagpoleFlagObject  ;for flagpole flag object
092B0 D0 15                                  bne NoFPObj              ;if not found, branch to something residual
092B2 AD 13 07                               lda FlagpoleSoundQueue   ;load flagpole sound
092B5 85 FF                                  sta Square1SoundQueue    ;into square 1's sfx queue
092B7 A9 00                                  lda #$00
092B9 8D 13 07                               sta FlagpoleSoundQueue   ;init flagpole sound queue
092BC A4 CE                                  ldy Player_Y_Position
092BE C0 9E                                  cpy #$9e                 ;check to see if player has slid down
092C0 B0 02                                  bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
092C2 A9 04                                  lda #$04                 ;otherwise force player to climb down (to slide)
092C4 4C EE 90                  SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
092C7 E6 0E                     NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
092C9 60                                     rts                      ;be residual code)
092CA                           
092CA                           ;-------------------------------------------------------------------------------------
092CA                           
092CA                           Hidden1UpCoinAmts:
092CA 15 23 16 1B 17 18 23 63         .db $15, $23, $16, $1b, $17, $18, $23, $63
092D2                           
092D2                           PlayerEndLevel:
092D2 A9 01                               lda #$01                  ;force player to walk to the right
092D4 20 EE 90                            jsr AutoControlPlayer
092D7 A5 CE                               lda Player_Y_Position     ;check player's vertical position
092D9 C9 AE                               cmp #$ae
092DB 90 0E                               bcc ChkStop               ;if player is not yet off the flagpole, skip this part
092DD AD 23 07                            lda ScrollLock            ;if scroll lock not set, branch ahead to next part
092E0 F0 09                               beq ChkStop               ;because we only need to do this part once
092E2 A9 20                               lda #EndOfLevelMusic
092E4 85 FC                               sta EventMusicQueue       ;load win level music in event music queue
092E6 A9 00                               lda #$00
092E8 8D 23 07                            sta ScrollLock            ;turn off scroll lock to skip this part later
092EB AD 90 04                  ChkStop:  lda Player_CollisionBits  ;get player collision bits
092EE 4A                                  lsr                       ;check for d0 set
092EF B0 0D                               bcs RdyNextA              ;if d0 set, skip to next part
092F1 AD 46 07                            lda StarFlagTaskControl   ;if star flag task control already set,
092F4 D0 03                               bne InCastle              ;go ahead with the rest of the code
092F6 EE 46 07                            inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
092F9 A9 20                     InCastle: lda #%00100000            ;set player's background priority bit to
092FB 8D C4 03                            sta Player_SprAttrib      ;give illusion of being inside the castle
092FE AD 46 07                  RdyNextA: lda StarFlagTaskControl
09301 C9 05                               cmp #$05                  ;if star flag task control not yet set
09303 D0 2B                               bne ExitNA                ;beyond last valid task number, branch to leave
09305 EE 5C 07                            inc LevelNumber           ;increment level number used for game logic
09308 AD 5C 07                            lda LevelNumber
0930B C9 03                               cmp #$03                  ;check to see if we have yet reached level -4
0930D D0 0E                               bne NextArea              ;and skip this last part here if not
0930F AC 5F 07                            ldy WorldNumber           ;get world number as offset
09312 AD 48 07                            lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
09315 D9 CA 92                            cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
09318 90 03                               bcc NextArea              ;at least this number of coins, leave flag clear
0931A EE 5D 07                            inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
0931D EE 60 07                  NextArea: inc AreaNumber            ;increment area number used for address loader
09320 20 0B 7C                            jsr LoadAreaPointer       ;get new level pointer
09323 EE 57 07                            inc FetchNewGameTimerFlag ;set flag to load new game timer
09326 20 1B 92                            jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
09329 8D 5B 07                            sta HalfwayPage           ;reset halfway page to 0 (beginning)
0932C A9 80                               lda #Silence
0932E 85 FC                               sta EventMusicQueue       ;silence music and leave
09330 60                        ExitNA:   rts
09331                           
09331                           ;-------------------------------------------------------------------------------------
09331                           
09331                           PlayerMovementSubs:
09331 A9 00                                lda #$00                  ;set A to init crouch flag by default
09333 AC 54 07                             ldy PlayerSize            ;is player small?
09336 D0 08                                bne SetCrouch             ;if so, branch
09338 A5 1D                                lda Player_State          ;check state of player
0933A D0 07                                bne ProcMove              ;if not on the ground, branch
0933C A5 0B                                lda Up_Down_Buttons       ;load controller bits for up and down
0933E 29 04                                and #%00000100            ;single out bit for down button
09340 8D 14 07                  SetCrouch: sta CrouchingFlag         ;store value in crouch flag
09343 20 58 94                  ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
09346 AD 0B 07                             lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
09349 D0 16                                bne NoMoveSub             ;branch to leave
0934B A5 1D                                lda Player_State
0934D C9 03                                cmp #$03                  ;get player state
0934F F0 05                                beq MoveSubs              ;if climbing, branch ahead, leave timer unset
09351 A0 18                                ldy #$18
09353 8C 89 07                             sty ClimbSideTimer        ;otherwise reset timer now
09356 20 0A 6E                  MoveSubs:  jsr JumpEngine
09359                           
09359 62 93                           .dw OnGroundStateSub
0935B 7E 93                           .dw JumpSwimSub
0935D 75 93                           .dw FallingSub
0935F D7 93                           .dw ClimbingSub
09361                           
09361 60                        NoMoveSub: rts
09362                           
09362                           ;-------------------------------------------------------------------------------------
09362                           ;$00 - used by ClimbingSub to store high vertical adder
09362                           
09362                           OnGroundStateSub:
09362 20 97 95                           jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
09365 A5 0C                              lda Left_Right_Buttons
09367 F0 02                              beq GndMove                ;if left/right controller bits not set, skip instruction
09369 85 33                              sta PlayerFacingDir        ;otherwise set new facing direction
0936B 20 D4 95                  GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
0936E 20 11 9F                           jsr MovePlayerHorizontally ;do another sub to move player horizontally
09371 8D FF 06                           sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
09374 60                                 rts
09375                           
09375                           ;--------------------------------
09375                           
09375                           FallingSub:
09375 AD 0A 07                        lda VerticalForceDown
09378 8D 09 07                        sta VerticalForce      ;dump vertical movement force for falling into main one
0937B 4C B4 93                        jmp LRAir              ;movement force, then skip ahead to process left/right movement
0937E                           
0937E                           ;--------------------------------
0937E                           
0937E                           JumpSwimSub:
0937E A4 9F                               ldy Player_Y_Speed         ;if player's vertical speed zero
09380 10 13                               bpl DumpFall               ;or moving downwards, branch to falling
09382 A5 0A                               lda A_B_Buttons
09384 29 80                               and #A_Button              ;check to see if A button is being pressed
09386 25 0D                               and PreviousA_B_Buttons    ;and was pressed in previous frame
09388 D0 11                               bne ProcSwim               ;if so, branch elsewhere
0938A AD 08 07                            lda JumpOrigin_Y_Position  ;get vertical position player jumped from
0938D 38                                  sec
0938E E5 CE                               sbc Player_Y_Position      ;subtract current from original vertical coordinate
09390 CD 06 07                            cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
09393 90 06                               bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
09395 AD 0A 07                  DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
09398 8D 09 07                            sta VerticalForce
0939B AD 04 07                  ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
0939E F0 14                               beq LRAir                  ;branch ahead to last part
093A0 20 97 95                            jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
093A3 A5 CE                               lda Player_Y_Position
093A5 C9 14                               cmp #$14                   ;check vertical position against preset value
093A7 B0 05                               bcs LRWater                ;if not yet reached a certain position, branch ahead
093A9 A9 18                               lda #$18
093AB 8D 09 07                            sta VerticalForce          ;otherwise set fractional
093AE A5 0C                     LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
093B0 F0 02                               beq LRAir                  ;if not pressing any, skip
093B2 85 33                               sta PlayerFacingDir        ;otherwise set facing direction accordingly
093B4 A5 0C                     LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
093B6 F0 03                               beq JSMove                 ;if not pressing any, skip
093B8 20 D4 95                            jsr ImposeFriction         ;otherwise process horizontal movement
093BB 20 11 9F                  JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
093BE 8D FF 06                            sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
093C1 A5 0E                               lda GameEngineSubroutine
093C3 C9 0B                               cmp #$0b                   ;check for specific routine selected
093C5 D0 05                               bne ExitMov1               ;branch if not set to run
093C7 A9 28                               lda #$28
093C9 8D 09 07                            sta VerticalForce          ;otherwise set fractional
093CC 4C 55 9F                  ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
093CF                           
093CF                           ;--------------------------------
093CF                           
093CF                           ClimbAdderLow:
093CF 0E 04 FC F2                     .db $0e, $04, $fc, $f2
093D3                           ClimbAdderHigh:
093D3 00 00 FF FF                     .db $00, $00, $ff, $ff
093D7                           
093D7                           ClimbingSub:
093D7 AD 16 04                               lda Player_YMF_Dummy
093DA 18                                     clc                      ;add movement force to dummy variable
093DB 6D 33 04                               adc Player_Y_MoveForce   ;save with carry
093DE 8D 16 04                               sta Player_YMF_Dummy
093E1 A0 00                                  ldy #$00                 ;set default adder here
093E3 A5 9F                                  lda Player_Y_Speed       ;get player's vertical speed
093E5 10 01                                  bpl MoveOnVine           ;if not moving upwards, branch
093E7 88                                     dey                      ;otherwise set adder to $ff
093E8 84 00                     MoveOnVine:  sty $00                  ;store adder here
093EA 65 CE                                  adc Player_Y_Position    ;add carry to player's vertical position
093EC 85 CE                                  sta Player_Y_Position    ;and store to move player up or down
093EE A5 B5                                  lda Player_Y_HighPos
093F0 65 00                                  adc $00                  ;add carry to player's page location
093F2 85 B5                                  sta Player_Y_HighPos     ;and store
093F4 A5 0C                                  lda Left_Right_Buttons   ;compare left/right controller bits
093F6 2D 90 04                               and Player_CollisionBits ;to collision flag
093F9 F0 2D                                  beq InitCSTimer          ;if not set, skip to end
093FB AC 89 07                               ldy ClimbSideTimer       ;otherwise check timer 
093FE D0 27                                  bne ExitCSub             ;if timer not expired, branch to leave
09400 A0 18                                  ldy #$18
09402 8C 89 07                               sty ClimbSideTimer       ;otherwise set timer now
09405 A2 00                                  ldx #$00                 ;set default offset here
09407 A4 33                                  ldy PlayerFacingDir      ;get facing direction
09409 4A                                     lsr                      ;move right button controller bit to carry
0940A B0 02                                  bcs ClimbFD              ;if controller right pressed, branch ahead
0940C E8                                     inx
0940D E8                                     inx                      ;otherwise increment offset by 2 bytes
0940E 88                        ClimbFD:     dey                      ;check to see if facing right
0940F F0 01                                  beq CSetFDir             ;if so, branch, do not increment
09411 E8                                     inx                      ;otherwise increment by 1 byte
09412 A5 86                     CSetFDir:    lda Player_X_Position
09414 18                                     clc                      ;add or subtract from player's horizontal position
09415 7D CF 93                               adc ClimbAdderLow,x      ;using value here as adder and X as offset
09418 85 86                                  sta Player_X_Position
0941A A5 6D                                  lda Player_PageLoc       ;add or subtract carry or borrow using value here
0941C 7D D3 93                               adc ClimbAdderHigh,x     ;from the player's page location
0941F 85 6D                                  sta Player_PageLoc
09421 A5 0C                                  lda Left_Right_Buttons   ;get left/right controller bits again
09423 49 03                                  eor #%00000011           ;invert them and store them while player
09425 85 33                                  sta PlayerFacingDir      ;is on vine to face player in opposite direction
09427 60                        ExitCSub:    rts                      ;then leave
09428 8D 89 07                  InitCSTimer: sta ClimbSideTimer       ;initialize timer here
0942B 60                                     rts
0942C                           
0942C                           ;-------------------------------------------------------------------------------------
0942C                           ;$00 - used to store offset to friction data
0942C                           
0942C                           JumpMForceData:
0942C 20 20 1E 28 28 0D 04            .db $20, $20, $1e, $28, $28, $0d, $04
09433                           
09433                           FallMForceData:
09433 70 70 60 90 90 0A 09            .db $70, $70, $60, $90, $90, $0a, $09
0943A                           
0943A                           PlayerYSpdData:
0943A FC FC FC FB FB FE FF            .db $fc, $fc, $fc, $fb, $fb, $fe, $ff
09441                           
09441                           InitMForceData:
09441 00 00 00 00 00 80 00            .db $00, $00, $00, $00, $00, $80, $00
09448                           
09448                           MaxLeftXSpdData:
09448 D8 E8 F0                        .db $d8, $e8, $f0
0944B                           
0944B                           MaxRightXSpdData:
0944B 28 18 10                        .db $28, $18, $10
0944E 0C                              .db $0c ;used for pipe intros
0944F                           
0944F                           FrictionData:
0944F E4 98 D0                        .db $e4, $98, $d0
09452                           
09452                           Climb_Y_SpeedData:
09452 00 FF 01                        .db $00, $ff, $01
09455                           
09455                           Climb_Y_MForceData:
09455 00 20 FF                        .db $00, $20, $ff
09458                           
09458                           PlayerPhysicsSub:
09458 A5 1D                                lda Player_State          ;check player state
0945A C9 03                                cmp #$03
0945C D0 23                                bne CheckForJumping       ;if not climbing, branch
0945E A0 00                                ldy #$00
09460 A5 0B                                lda Up_Down_Buttons       ;get controller bits for up/down
09462 2D 90 04                             and Player_CollisionBits  ;check against player's collision detection bits
09465 F0 06                                beq ProcClimb             ;if not pressing up or down, branch
09467 C8                                   iny
09468 29 08                                and #%00001000            ;check for pressing up
0946A D0 01                                bne ProcClimb
0946C C8                                   iny
0946D BE 55 94                  ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
09470 8E 33 04                             stx Player_Y_MoveForce    ;store as vertical movement force
09473 A9 08                                lda #$08                  ;load default animation timing
09475 BE 52 94                             ldx Climb_Y_SpeedData,y   ;load some other value here
09478 86 9F                                stx Player_Y_Speed        ;store as vertical speed
0947A 30 01                                bmi SetCAnim              ;if climbing down, use default animation timing value
0947C 4A                                   lsr                       ;otherwise divide timer setting by 2
0947D 8D 0C 07                  SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
09480 60                                   rts
09481                           
09481                           CheckForJumping:
09481 AD 0E 07                          lda JumpspringAnimCtrl    ;if jumpspring animating, 
09484 D0 0A                             bne NoJump                ;skip ahead to something else
09486 A5 0A                             lda A_B_Buttons           ;check for A button press
09488 29 80                             and #A_Button
0948A F0 04                             beq NoJump                ;if not, branch to something else
0948C 25 0D                             and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
0948E F0 03                             beq ProcJumping
09490 4C 24 95                  NoJump: jmp X_Physics             ;otherwise, jump to something else
09493                           
09493                           ProcJumping:
09493 A5 1D                                lda Player_State           ;check player state
09495 F0 11                                beq InitJS                 ;if on the ground, branch
09497 AD 04 07                             lda SwimmingFlag           ;if swimming flag not set, jump to do something else
0949A F0 F4                                beq NoJump                 ;to prevent midair jumping, otherwise continue
0949C AD 82 07                             lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
0949F D0 07                                bne InitJS
094A1 A5 9F                                lda Player_Y_Speed         ;check player's vertical speed
094A3 10 03                                bpl InitJS                 ;if player's vertical speed motionless or down, branch
094A5 4C 24 95                             jmp X_Physics              ;if timer at zero and player still rising, do not swim
094A8 A9 20                     InitJS:    lda #$20                   ;set jump/swim timer
094AA 8D 82 07                             sta JumpSwimTimer
094AD A0 00                                ldy #$00                   ;initialize vertical force and dummy variable
094AF 8C 16 04                             sty Player_YMF_Dummy
094B2 8C 33 04                             sty Player_Y_MoveForce
094B5 A5 B5                                lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
094B7 8D 07 07                             sta JumpOrigin_Y_HighPos   ;and store them next to each other here
094BA A5 CE                                lda Player_Y_Position
094BC 8D 08 07                             sta JumpOrigin_Y_Position
094BF A9 01                                lda #$01                   ;set player state to jumping/swimming
094C1 85 1D                                sta Player_State
094C3 AD 00 07                             lda Player_XSpeedAbsolute  ;check value related to walking/running speed
094C6 C9 09                                cmp #$09
094C8 90 10                                bcc ChkWtr                 ;branch if below certain values, increment Y
094CA C8                                   iny                        ;for each amount equal or exceeded
094CB C9 10                                cmp #$10
094CD 90 0B                                bcc ChkWtr
094CF C8                                   iny
094D0 C9 19                                cmp #$19
094D2 90 06                                bcc ChkWtr
094D4 C8                                   iny
094D5 C9 1C                                cmp #$1c
094D7 90 01                                bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
094D9 C8                                   iny
094DA A9 01                     ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
094DC 8D 06 07                             sta DiffToHaltJump
094DF AD 04 07                             lda SwimmingFlag           ;if swimming flag disabled, branch
094E2 F0 08                                beq GetYPhy
094E4 A0 05                                ldy #$05                   ;otherwise set Y to 5, range is 5-6
094E6 AD 7D 04                             lda Whirlpool_Flag         ;if whirlpool flag not set, branch
094E9 F0 01                                beq GetYPhy
094EB C8                                   iny                        ;otherwise increment to 6
094EC B9 2C 94                  GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
094EF 8D 09 07                             sta VerticalForce          ;data here
094F2 B9 33 94                             lda FallMForceData,y
094F5 8D 0A 07                             sta VerticalForceDown
094F8 B9 41 94                             lda InitMForceData,y
094FB 8D 33 04                             sta Player_Y_MoveForce
094FE B9 3A 94                             lda PlayerYSpdData,y
09501 85 9F                                sta Player_Y_Speed
09503 AD 04 07                             lda SwimmingFlag           ;if swimming flag disabled, branch
09506 F0 11                                beq PJumpSnd
09508 A9 04                                lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
0950A 85 FF                                sta Square1SoundQueue      ;square 1's sfx queue
0950C A5 CE                                lda Player_Y_Position
0950E C9 14                                cmp #$14                   ;check vertical low byte of player position
09510 B0 12                                bcs X_Physics              ;if below a certain point, branch
09512 A9 00                                lda #$00                   ;otherwise reset player's vertical speed
09514 85 9F                                sta Player_Y_Speed         ;and jump to something else to keep player
09516 4C 24 95                             jmp X_Physics              ;from swimming above water level
09519 A9 01                     PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
0951B AC 54 07                             ldy PlayerSize             ;is mario big?
0951E F0 02                                beq SJumpSnd
09520 A9 80                                lda #Sfx_SmallJump         ;if not, load small mario's jump sound
09522 85 FF                     SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
09524 A0 00                     X_Physics: ldy #$00
09526 84 00                                sty $00                    ;init value here
09528 A5 1D                                lda Player_State           ;if mario is on the ground, branch
0952A F0 09                                beq ProcPRun
0952C AD 00 07                             lda Player_XSpeedAbsolute  ;check something that seems to be related
0952F C9 19                                cmp #$19                   ;to mario's speed
09531 B0 33                                bcs GetXPhy                ;if =>$19 branch here
09533 90 18                                bcc ChkRFast               ;if not branch elsewhere
09535 C8                        ProcPRun:  iny                        ;if mario on the ground, increment Y
09536 AD 4E 07                             lda AreaType               ;check area type
09539 F0 12                                beq ChkRFast               ;if water type, branch
0953B 88                                   dey                        ;decrement Y by default for non-water type area
0953C A5 0C                                lda Left_Right_Buttons     ;get left/right controller bits
0953E C5 45                                cmp Player_MovingDir       ;check against moving direction
09540 D0 0B                                bne ChkRFast               ;if controller bits <> moving direction, skip this part
09542 A5 0A                                lda A_B_Buttons            ;check for b button pressed
09544 29 40                                and #B_Button
09546 D0 19                                bne SetRTmr                ;if pressed, skip ahead to set timer
09548 AD 83 07                             lda RunningTimer           ;check for running timer set
0954B D0 19                                bne GetXPhy                ;if set, branch
0954D C8                        ChkRFast:  iny                        ;if running timer not set or level type is water, 
0954E E6 00                                inc $00                    ;increment Y again and temp variable in memory
09550 AD 03 07                             lda RunningSpeed
09553 D0 07                                bne FastXSp                ;if running speed set here, branch
09555 AD 00 07                             lda Player_XSpeedAbsolute
09558 C9 21                                cmp #$21                   ;otherwise check player's walking/running speed
0955A 90 0A                                bcc GetXPhy                ;if less than a certain amount, branch ahead
0955C E6 00                     FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
0955E 4C 66 95                             jmp GetXPhy                ;and jump ahead
09561 A9 0A                     SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
09563 8D 83 07                             sta RunningTimer
09566 B9 48 94                  GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
09569 8D 50 04                             sta MaximumLeftSpeed
0956C A5 0E                                lda GameEngineSubroutine   ;check for specific routine running
0956E C9 07                                cmp #$07                   ;(player entrance)
09570 D0 02                                bne GetXPhy2               ;if not running, skip and use old value of Y
09572 A0 03                                ldy #$03                   ;otherwise set Y to 3
09574 B9 4B 94                  GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
09577 8D 56 04                             sta MaximumRightSpeed
0957A A4 00                                ldy $00                    ;get other value in memory
0957C B9 4F 94                             lda FrictionData,y         ;get value using value in memory as offset
0957F 8D 02 07                             sta FrictionAdderLow
09582 A9 00                                lda #$00
09584 8D 01 07                             sta FrictionAdderHigh      ;init something here
09587 A5 33                                lda PlayerFacingDir
09589 C5 45                                cmp Player_MovingDir       ;check facing direction against moving direction
0958B F0 06                                beq ExitPhy                ;if the same, branch to leave
0958D 0E 02 07                             asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
09590 2E 01 07                             rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
09593 60                        ExitPhy:   rts                        ;and then leave
09594                           
09594                           ;-------------------------------------------------------------------------------------
09594                           
09594                           PlayerAnimTmrData:
09594 02 04 07                        .db $02, $04, $07
09597                           
09597                           GetPlayerAnimSpeed:
09597 A0 00                                 ldy #$00                   ;initialize offset in Y
09599 AD 00 07                              lda Player_XSpeedAbsolute  ;check player's walking/running speed
0959C C9 1C                                 cmp #$1c                   ;against preset amount
0959E B0 15                                 bcs SetRunSpd              ;if greater than a certain amount, branch ahead
095A0 C8                                    iny                        ;otherwise increment Y
095A1 C9 0E                                 cmp #$0e                   ;compare against lower amount
095A3 B0 01                                 bcs ChkSkid                ;if greater than this but not greater than first, skip increment
095A5 C8                                    iny                        ;otherwise increment Y again
095A6 AD FC 06                  ChkSkid:    lda SavedJoypadBits        ;get controller bits
095A9 29 7F                                 and #%01111111             ;mask out A button
095AB F0 20                                 beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
095AD 29 03                                 and #$03                   ;mask out all others except left and right
095AF C5 45                                 cmp Player_MovingDir       ;check against moving direction
095B1 D0 08                                 bne ProcSkid               ;if left/right controller bits <> moving direction, branch
095B3 A9 00                                 lda #$00                   ;otherwise set zero value here
095B5 8D 03 07                  SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
095B8 4C CD 95                              jmp SetAnimSpd
095BB AD 00 07                  ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
095BE C9 0B                                 cmp #$0b                   ;against one last amount
095C0 B0 0B                                 bcs SetAnimSpd             ;if greater than this amount, branch
095C2 A5 33                                 lda PlayerFacingDir
095C4 85 45                                 sta Player_MovingDir       ;otherwise use facing direction to set moving direction
095C6 A9 00                                 lda #$00
095C8 85 57                                 sta Player_X_Speed         ;nullify player's horizontal speed
095CA 8D 05 07                              sta Player_X_MoveForce     ;and dummy variable for player
095CD B9 94 95                  SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
095D0 8D 0C 07                              sta PlayerAnimTimerSet
095D3 60                                    rts
095D4                           
095D4                           ;-------------------------------------------------------------------------------------
095D4                           
095D4                           ImposeFriction:
095D4 2D 90 04                             and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
095D7 C9 00                                cmp #$00                  ;then compare to zero (this instruction is redundant)
095D9 D0 08                                bne JoypFrict             ;if any bits set, branch to next part
095DB A5 57                                lda Player_X_Speed
095DD F0 49                                beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
095DF 10 23                                bpl RghtFrict             ;if player moving to the right, branch to slow
095E1 30 03                                bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
095E3 4A                        JoypFrict: lsr                       ;put right controller bit into carry
095E4 90 1E                                bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
095E6 AD 05 07                  LeftFrict: lda Player_X_MoveForce    ;load value set here
095E9 18                                   clc
095EA 6D 02 07                             adc FrictionAdderLow      ;add to it another value set here
095ED 8D 05 07                             sta Player_X_MoveForce    ;store here
095F0 A5 57                                lda Player_X_Speed
095F2 6D 01 07                             adc FrictionAdderHigh     ;add value plus carry to horizontal speed
095F5 85 57                                sta Player_X_Speed        ;set as new horizontal speed
095F7 CD 56 04                             cmp MaximumRightSpeed     ;compare against maximum value for right movement
095FA 30 23                                bmi XSpdSign              ;if horizontal speed greater negatively, branch
095FC AD 56 04                             lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
095FF 85 57                                sta Player_X_Speed        ;thus slowing the player's left movement down
09601 4C 28 96                             jmp SetAbsSpd             ;skip to the end
09604 AD 05 07                  RghtFrict: lda Player_X_MoveForce    ;load value set here
09607 38                                   sec
09608 ED 02 07                             sbc FrictionAdderLow      ;subtract from it another value set here
0960B 8D 05 07                             sta Player_X_MoveForce    ;store here
0960E A5 57                                lda Player_X_Speed
09610 ED 01 07                             sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
09613 85 57                                sta Player_X_Speed        ;set as new horizontal speed
09615 CD 50 04                             cmp MaximumLeftSpeed      ;compare against maximum value for left movement
09618 10 05                                bpl XSpdSign              ;if horizontal speed greater positively, branch
0961A AD 50 04                             lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
0961D 85 57                                sta Player_X_Speed        ;thus slowing the player's right movement down
0961F C9 00                     XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
09621 10 05                                bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
09623 49 FF                                eor #$ff
09625 18                                   clc                       ;otherwise get two's compliment to get absolute
09626 69 01                                adc #$01                  ;unsigned walking/running speed
09628 8D 00 07                  SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
0962B 60                                   rts
0962C                           
0962C                           ;-------------------------------------------------------------------------------------
0962C                           ;$00 - used to store downward movement force in FireballObjCore
0962C                           ;$02 - used to store maximum vertical speed in FireballObjCore
0962C                           ;$07 - used to store pseudorandom bit in BubbleCheck
0962C                           
0962C                           ProcFireball_Bubble:
0962C AD 56 07                        lda PlayerStatus           ;check player's status
0962F C9 02                           cmp #$02
09631 90 43                           bcc ProcAirBubbles         ;if not fiery, branch
09633 A5 0A                           lda A_B_Buttons
09635 29 40                           and #B_Button              ;check for b button pressed
09637 F0 33                           beq ProcFireballs          ;branch if not pressed
09639 25 0D                           and PreviousA_B_Buttons
0963B D0 2F                           bne ProcFireballs          ;if button pressed in previous frame, branch
0963D AD CE 06                        lda FireballCounter        ;load fireball counter
09640 29 01                           and #%00000001             ;get LSB and use as offset for buffer
09642 AA                              tax
09643 B5 24                           lda Fireball_State,x       ;load fireball state
09645 D0 25                           bne ProcFireballs          ;if not inactive, branch
09647 A4 B5                           ldy Player_Y_HighPos       ;if player too high or too low, branch
09649 88                              dey
0964A D0 20                           bne ProcFireballs
0964C AD 14 07                        lda CrouchingFlag          ;if player crouching, branch
0964F D0 1B                           bne ProcFireballs
09651 A5 1D                           lda Player_State           ;if player's state = climbing, branch
09653 C9 03                           cmp #$03
09655 F0 15                           beq ProcFireballs
09657 A9 20                           lda #Sfx_Fireball          ;play fireball sound effect
09659 85 FF                           sta Square1SoundQueue
0965B A9 02                           lda #$02                   ;load state
0965D 95 24                           sta Fireball_State,x
0965F AC 0C 07                        ldy PlayerAnimTimerSet     ;copy animation frame timer setting
09662 8C 11 07                        sty FireballThrowingTimer  ;into fireball throwing timer
09665 88                              dey
09666 8C 81 07                        sty PlayerAnimTimer        ;decrement and store in player's animation timer
09669 EE CE 06                        inc FireballCounter        ;increment fireball counter
0966C                           
0966C                           ProcFireballs:
0966C A2 00                           ldx #$00
0966E 20 91 96                        jsr FireballObjCore  ;process first fireball object
09671 A2 01                           ldx #$01
09673 20 91 96                        jsr FireballObjCore  ;process second fireball object, then do air bubbles
09676                           
09676                           ProcAirBubbles:
09676 AD 4E 07                            lda AreaType                ;if not water type level, skip the rest of this
09679 D0 13                               bne BublExit
0967B A2 02                               ldx #$02                    ;otherwise load counter and use as offset
0967D 86 08                     BublLoop: stx ObjectOffset            ;store offset
0967F 20 01 97                            jsr BubbleCheck             ;check timers and coordinates, create air bubble
09682 20 35 D1                            jsr RelativeBubblePosition  ;get relative coordinates
09685 20 95 D1                            jsr GetBubbleOffscreenBits  ;get offscreen information
09688 20 E5 CD                            jsr DrawBubble              ;draw the air bubble
0968B CA                                  dex
0968C 10 EF                               bpl BublLoop                ;do this until all three are handled
0968E 60                        BublExit: rts                         ;then leave
0968F                           
0968F                           FireballXSpdData:
0968F 40 C0                           .db $40, $c0
09691                           
09691                           FireballObjCore:
09691 86 08                              stx ObjectOffset             ;store offset as current object
09693 B5 24                              lda Fireball_State,x         ;check for d7 = 1
09695 0A                                 asl
09696 B0 63                              bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
09698 B4 24                              ldy Fireball_State,x         ;if fireball inactive, branch to leave
0969A F0 5E                              beq NoFBall
0969C 88                                 dey                          ;if fireball state set to 1, skip this part and just run it
0969D F0 27                              beq RunFB
0969F A5 86                              lda Player_X_Position        ;get player's horizontal position
096A1 69 04                              adc #$04                     ;add four pixels and store as fireball's horizontal position
096A3 95 8D                              sta Fireball_X_Position,x
096A5 A5 6D                              lda Player_PageLoc           ;get player's page location
096A7 69 00                              adc #$00                     ;add carry and store as fireball's page location
096A9 95 74                              sta Fireball_PageLoc,x
096AB A5 CE                              lda Player_Y_Position        ;get player's vertical position and store
096AD 95 D5                              sta Fireball_Y_Position,x
096AF A9 01                              lda #$01                     ;set high byte of vertical position
096B1 95 BC                              sta Fireball_Y_HighPos,x
096B3 A4 33                              ldy PlayerFacingDir          ;get player's facing direction
096B5 88                                 dey                          ;decrement to use as offset here
096B6 B9 8F 96                           lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
096B9 95 5E                              sta Fireball_X_Speed,x
096BB A9 04                              lda #$04                     ;set vertical speed of fireball
096BD 95 A6                              sta Fireball_Y_Speed,x
096BF A9 07                              lda #$07
096C1 9D A0 04                           sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
096C4 D6 24                              dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
096C6 8A                        RunFB:   txa                          ;add 7 to offset to use
096C7 18                                 clc                          ;as fireball offset for next routines
096C8 69 07                              adc #$07
096CA AA                                 tax
096CB A9 50                              lda #$50                     ;set downward movement force here
096CD 85 00                              sta $00
096CF A9 03                              lda #$03                     ;set maximum speed here
096D1 85 02                              sta $02
096D3 A9 00                              lda #$00
096D5 20 DF 9F                           jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
096D8 20 17 9F                           jsr MoveObjectHorizontally   ;do another sub to move it horizontally
096DB A6 08                              ldx ObjectOffset             ;return fireball offset to X
096DD 20 3F D1                           jsr RelativeFireballPosition ;get relative coordinates
096E0 20 8B D1                           jsr GetFireballOffscreenBits ;get offscreen information
096E3 20 32 C2                           jsr GetFireballBoundBox      ;get bounding box coordinates
096E6 20 CD C1                           jsr FireballBGCollision      ;do fireball to background collision detection
096E9 AD D2 03                           lda FBall_OffscreenBits      ;get fireball offscreen bits
096EC 29 CC                              and #%11001100               ;mask out certain bits
096EE D0 06                              bne EraseFB                  ;if any bits still set, branch to kill fireball
096F0 20 DE B6                           jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
096F3 4C E2 CC                           jmp DrawFireball             ;draw fireball appropriately and leave
096F6 A9 00                     EraseFB: lda #$00                     ;erase fireball state
096F8 95 24                              sta Fireball_State,x
096FA 60                        NoFBall: rts                          ;leave
096FB                           
096FB                           FireballExplosion:
096FB 20 3F D1                        jsr RelativeFireballPosition
096FE 4C 0D CD                        jmp DrawExplosion_Fireball
09701                           
09701                           BubbleCheck:
09701 BD A8 07                        lda PseudoRandomBitReg+1,x  ;get part of LSFR
09704 29 01                           and #$01
09706 85 07                           sta $07                     ;store pseudorandom bit here
09708 B5 E4                           lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
0970A C9 F8                           cmp #$f8                    ;if offscreen coordinate not set,
0970C D0 2C                           bne MoveBubl                ;branch to move air bubble
0970E AD 92 07                        lda AirBubbleTimer          ;if air bubble timer not expired,
09711 D0 3F                           bne ExitBubl                ;branch to leave, otherwise create new air bubble
09713                           
09713                           SetupBubble:
09713 A0 00                               ldy #$00                 ;load default value here
09715 A5 33                               lda PlayerFacingDir      ;get player's facing direction
09717 4A                                  lsr                      ;move d0 to carry
09718 90 02                               bcc PosBubl              ;branch to use default value if facing left
0971A A0 08                               ldy #$08                 ;otherwise load alternate value here
0971C 98                        PosBubl:  tya                      ;use value loaded as adder
0971D 65 86                               adc Player_X_Position    ;add to player's horizontal position
0971F 95 9C                               sta Bubble_X_Position,x  ;save as horizontal position for airbubble
09721 A5 6D                               lda Player_PageLoc
09723 69 00                               adc #$00                 ;add carry to player's page location
09725 95 83                               sta Bubble_PageLoc,x     ;save as page location for airbubble
09727 A5 CE                               lda Player_Y_Position
09729 18                                  clc                      ;add eight pixels to player's vertical position
0972A 69 08                               adc #$08
0972C 95 E4                               sta Bubble_Y_Position,x  ;save as vertical position for air bubble
0972E A9 01                               lda #$01
09730 95 CB                               sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
09732 A4 07                               ldy $07                  ;get pseudorandom bit, use as offset
09734 B9 55 97                            lda BubbleTimerData,y    ;get data for air bubble timer
09737 8D 92 07                            sta AirBubbleTimer       ;set air bubble timer
0973A A4 07                     MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
0973C BD 2C 04                            lda Bubble_YMF_Dummy,x
0973F 38                                  sec                      ;subtract pseudorandom amount from dummy variable
09740 F9 53 97                            sbc Bubble_MForceData,y
09743 9D 2C 04                            sta Bubble_YMF_Dummy,x   ;save dummy variable
09746 B5 E4                               lda Bubble_Y_Position,x
09748 E9 00                               sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
0974A C9 20                               cmp #$20                 ;if below the status bar,
0974C B0 02                               bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
0974E A9 F8                               lda #$f8                 ;otherwise set offscreen coordinate
09750 95 E4                     Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
09752 60                        ExitBubl: rts                      ;leave
09753                           
09753                           Bubble_MForceData:
09753 FF 50                           .db $ff, $50
09755                           
09755                           BubbleTimerData:
09755 40 20                           .db $40, $20
09757                           
09757                           ;-------------------------------------------------------------------------------------
09757                           
09757                           RunGameTimer:
09757 AD 70 07                             lda OperMode               ;get primary mode of operation
0975A F0 4F                                beq ExGTimer               ;branch to leave if in title screen mode
0975C A5 0E                                lda GameEngineSubroutine
0975E C9 08                                cmp #$08                   ;if routine number less than eight running,
09760 90 49                                bcc ExGTimer               ;branch to leave
09762 C9 0B                                cmp #$0b                   ;if running death routine,
09764 F0 45                                beq ExGTimer               ;branch to leave
09766 A5 B5                                lda Player_Y_HighPos
09768 C9 02                                cmp #$02                   ;if player below the screen,
0976A B0 3F                                bcs ExGTimer               ;branch to leave regardless of level type
0976C AD 87 07                             lda GameTimerCtrlTimer     ;if game timer control not yet expired,
0976F D0 3A                                bne ExGTimer               ;branch to leave
09771 AD F8 07                             lda GameTimerDisplay
09774 0D F9 07                             ora GameTimerDisplay+1     ;otherwise check game timer digits
09777 0D FA 07                             ora GameTimerDisplay+2
0977A F0 26                                beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
0977C AC F8 07                             ldy GameTimerDisplay       ;otherwise check first digit
0977F 88                                   dey                        ;if first digit not on 1,
09780 D0 0C                                bne ResGTCtrl              ;branch to reset game timer control
09782 AD F9 07                             lda GameTimerDisplay+1     ;otherwise check second and third digits
09785 0D FA 07                             ora GameTimerDisplay+2
09788 D0 04                                bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
0978A A9 40                                lda #TimeRunningOutMusic
0978C 85 FC                                sta EventMusicQueue        ;otherwise load time running out music
0978E A9 18                     ResGTCtrl: lda #$18                   ;reset game timer control
09790 8D 87 07                             sta GameTimerCtrlTimer
09793 A0 23                                ldy #$23                   ;set offset for last digit
09795 A9 FF                                lda #$ff                   ;set value to decrement game timer digit
09797 8D 39 01                             sta DigitModifier+5
0979A 20 65 6F                             jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
0979D A9 A4                                lda #$a4                   ;set status nybbles to update game timer display
0979F 4C 0C 6F                             jmp PrintStatusBarNumbers  ;do sub to update the display
097A2 8D 56 07                  TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
097A5 20 36 B9                             jsr ForceInjury            ;do sub to kill the player (note player is small here)
097A8 EE 59 07                             inc GameTimerExpiredFlag   ;set game timer expiration flag
097AB 60                        ExGTimer:  rts                        ;leave
097AC                           
097AC                           ;-------------------------------------------------------------------------------------
097AC                           
097AC                           WarpZoneObject:
097AC AD 23 07                        lda ScrollLock         ;check for scroll lock flag
097AF F0 FA                           beq ExGTimer           ;branch if not set to leave
097B1 A5 CE                           lda Player_Y_Position  ;check to see if player's vertical coordinate has
097B3 25 B5                           and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
097B5 D0 F4                           bne ExGTimer           ;if so, branch to leave
097B7 8D 23 07                        sta ScrollLock         ;otherwise nullify scroll lock flag
097BA EE D6 06                        inc WarpZoneControl    ;increment warp zone flag to make warp pipes for warp zone
097BD 4C A0 A9                        jmp EraseEnemyObject   ;kill this object
097C0                           
097C0                           ;-------------------------------------------------------------------------------------
097C0                           ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
097C0                           ;and also to store movement force exerted on player
097C0                           ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
097C0                           ;and in WhirlpoolActivate to store center of whirlpool
097C0                           ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
097C0                           ;WhirlpoolActivate to store maximum vertical speed
097C0                           
097C0                           ProcessWhirlpools:
097C0 AD 4E 07                          lda AreaType                ;check for water type level
097C3 D0 37                             bne ExitWh                  ;branch to leave if not found
097C5 8D 7D 04                          sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
097C8 AD 47 07                          lda TimerControl            ;if master timer control set,
097CB D0 2F                             bne ExitWh                  ;branch to leave
097CD A0 04                             ldy #$04                    ;otherwise start with last whirlpool data
097CF B9 71 04                  WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
097D2 18                                clc
097D3 79 77 04                          adc Whirlpool_Length,y      ;add length of whirlpool
097D6 85 02                             sta $02                     ;store result as right extent here
097D8 B9 6B 04                          lda Whirlpool_PageLoc,y     ;get page location
097DB F0 1C                             beq NextWh                  ;if none or page 0, branch to get next data
097DD 69 00                             adc #$00                    ;add carry
097DF 85 01                             sta $01                     ;store result as page location of right extent here
097E1 A5 86                             lda Player_X_Position       ;get player's horizontal position
097E3 38                                sec
097E4 F9 71 04                          sbc Whirlpool_LeftExtent,y  ;subtract left extent
097E7 A5 6D                             lda Player_PageLoc          ;get player's page location
097E9 F9 6B 04                          sbc Whirlpool_PageLoc,y     ;subtract borrow
097EC 30 0B                             bmi NextWh                  ;if player too far left, branch to get next data
097EE A5 02                             lda $02                     ;otherwise get right extent
097F0 38                                sec
097F1 E5 86                             sbc Player_X_Position       ;subtract player's horizontal coordinate
097F3 A5 01                             lda $01                     ;get right extent's page location
097F5 E5 6D                             sbc Player_PageLoc          ;subtract borrow
097F7 10 04                             bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
097F9 88                        NextWh: dey                         ;move onto next whirlpool data
097FA 10 D3                             bpl WhLoop                  ;do this until all whirlpools are checked
097FC 60                        ExitWh: rts                         ;leave
097FD                           
097FD                           WhirlpoolActivate:
097FD B9 77 04                          lda Whirlpool_Length,y      ;get length of whirlpool
09800 4A                                lsr                         ;divide by 2
09801 85 00                             sta $00                     ;save here
09803 B9 71 04                          lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
09806 18                                clc
09807 65 00                             adc $00                     ;add length divided by 2
09809 85 01                             sta $01                     ;save as center of whirlpool
0980B B9 6B 04                          lda Whirlpool_PageLoc,y     ;get page location
0980E 69 00                             adc #$00                    ;add carry
09810 85 00                             sta $00                     ;save as page location of whirlpool center
09812 A5 09                             lda FrameCounter            ;get frame counter
09814 4A                                lsr                         ;shift d0 into carry (to run on every other frame)
09815 90 2C                             bcc WhPull                  ;if d0 not set, branch to last part of code
09817 A5 01                             lda $01                     ;get center
09819 38                                sec
0981A E5 86                             sbc Player_X_Position       ;subtract player's horizontal coordinate
0981C A5 00                             lda $00                     ;get page location of center
0981E E5 6D                             sbc Player_PageLoc          ;subtract borrow
09820 10 0E                             bpl LeftWh                  ;if player to the left of center, branch
09822 A5 86                             lda Player_X_Position       ;otherwise slowly pull player left, towards the center
09824 38                                sec
09825 E9 01                             sbc #$01                    ;subtract one pixel
09827 85 86                             sta Player_X_Position       ;set player's new horizontal coordinate
09829 A5 6D                             lda Player_PageLoc
0982B E9 00                             sbc #$00                    ;subtract borrow
0982D 4C 41 98                          jmp SetPWh                  ;jump to set player's new page location
09830 AD 90 04                  LeftWh: lda Player_CollisionBits    ;get player's collision bits
09833 4A                                lsr                         ;shift d0 into carry
09834 90 0D                             bcc WhPull                  ;if d0 not set, branch
09836 A5 86                             lda Player_X_Position       ;otherwise slowly pull player right, towards the center
09838 18                                clc
09839 69 01                             adc #$01                    ;add one pixel
0983B 85 86                             sta Player_X_Position       ;set player's new horizontal coordinate
0983D A5 6D                             lda Player_PageLoc
0983F 69 00                             adc #$00                    ;add carry
09841 85 6D                     SetPWh: sta Player_PageLoc          ;set player's new page location
09843 A9 10                     WhPull: lda #$10
09845 85 00                             sta $00                     ;set vertical movement force
09847 A9 01                             lda #$01
09849 8D 7D 04                          sta Whirlpool_Flag          ;set whirlpool flag to be used later
0984C 85 02                             sta $02                     ;also set maximum vertical speed
0984E 4A                                lsr
0984F AA                                tax                         ;set X for player offset
09850 4C DF 9F                          jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
09853                           
09853                           ;-------------------------------------------------------------------------------------
09853                           
09853                           FlagpoleScoreMods:
09853 05 02 08 04 01                  .db $05, $02, $08, $04, $01
09858                           
09858                           FlagpoleScoreDigits:
09858 03 03 04 04 04                  .db $03, $03, $04, $04, $04
0985D                           
0985D                           FlagpoleRoutine:
0985D A2 05                                ldx #$05                  ;set enemy object offset
0985F 86 08                                stx ObjectOffset          ;to special use slot
09861 B5 16                                lda Enemy_ID,x
09863 C9 30                                cmp #FlagpoleFlagObject   ;if flagpole flag not found,
09865 D0 56                                bne ExitFlagP             ;branch to leave
09867 A5 0E                                lda GameEngineSubroutine
09869 C9 04                                cmp #$04                  ;if flagpole slide routine not running,
0986B D0 31                                bne SkipScore             ;branch to near the end of code
0986D A5 1D                                lda Player_State
0986F C9 03                                cmp #$03                  ;if player state not climbing,
09871 D0 2B                                bne SkipScore             ;branch to near the end of code
09873 B5 CF                                lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
09875 C9 AA                                cmp #$aa                  ;if flagpole flag down to a certain point,
09877 B0 28                                bcs GiveFPScr             ;branch to end the level
09879 A5 CE                                lda Player_Y_Position     ;check player's vertical coordinate
0987B C9 A2                                cmp #$a2                  ;if player down to a certain point,
0987D B0 22                                bcs GiveFPScr             ;branch to end the level
0987F BD 17 04                             lda Enemy_YMF_Dummy,x
09882 69 FF                                adc #$ff                  ;add movement amount to dummy variable
09884 9D 17 04                             sta Enemy_YMF_Dummy,x     ;save dummy variable
09887 B5 CF                                lda Enemy_Y_Position,x    ;get flag's vertical coordinate
09889 69 01                                adc #$01                  ;add 1 plus carry to move flag, and
0988B 95 CF                                sta Enemy_Y_Position,x    ;store vertical coordinate
0988D AD 0E 01                             lda FlagpoleFNum_YMFDummy
09890 38                                   sec                       ;subtract movement amount from dummy variable
09891 E9 FF                                sbc #$ff
09893 8D 0E 01                             sta FlagpoleFNum_YMFDummy ;save dummy variable
09896 AD 0D 01                             lda FlagpoleFNum_Y_Pos
09899 E9 01                                sbc #$01                  ;subtract one plus borrow to move floatey number,
0989B 8D 0D 01                             sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
0989E 4C B4 98                  SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
098A1 AC 0F 01                  GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
098A4 B9 53 98                             lda FlagpoleScoreMods,y   ;get amount to award player points
098A7 BE 58 98                             ldx FlagpoleScoreDigits,y ;get digit with which to award points
098AA 9D 34 01                             sta DigitModifier,x       ;store in digit modifier
098AD 20 2F 9C                             jsr AddToScore            ;do sub to award player points depending on height of collision
098B0 A9 05                                lda #$05
098B2 85 0E                                sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
098B4 20 B3 D1                  FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
098B7 20 56 D1                             jsr RelativeEnemyPosition ;get relative coordinates
098BA 20 4F C5                             jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
098BD 60                        ExitFlagP: rts
098BE                           
098BE                           ;-------------------------------------------------------------------------------------
098BE                           
098BE                           Jumpspring_Y_PosData:
098BE 08 10 08 00                     .db $08, $10, $08, $00
098C2                           
098C2                           JumpspringHandler:
098C2 20 B3 D1                             jsr GetEnemyOffscreenBits   ;get offscreen information
098C5 AD 47 07                             lda TimerControl            ;check master timer control
098C8 D0 40                                bne DrawJSpr                ;branch to last section if set
098CA AD 0E 07                             lda JumpspringAnimCtrl      ;check jumpspring frame control
098CD F0 3B                                beq DrawJSpr                ;branch to last section if not set
098CF A8                                   tay
098D0 88                                   dey                         ;subtract one from frame control,
098D1 98                                   tya                         ;the only way a poor nmos 6502 can
098D2 29 02                                and #%00000010              ;mask out all but d1, original value still in Y
098D4 D0 07                                bne DownJSpr                ;if set, branch to move player up
098D6 E6 CE                                inc Player_Y_Position
098D8 E6 CE                                inc Player_Y_Position       ;move player's vertical position down two pixels
098DA 4C E1 98                             jmp PosJSpr                 ;skip to next part
098DD C6 CE                     DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
098DF C6 CE                                dec Player_Y_Position
098E1 B5 58                     PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
098E3 18                                   clc
098E4 79 BE 98                             adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
098E7 95 CF                                sta Enemy_Y_Position,x      ;store as new vertical position
098E9 C0 01                                cpy #$01                    ;check frame control offset (second frame is $00)
098EB 90 0F                                bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
098ED A5 0A                                lda A_B_Buttons
098EF 29 80                                and #A_Button               ;check saved controller bits for A button press
098F1 F0 09                                beq BounceJS                ;skip to next part if A not pressed
098F3 25 0D                                and PreviousA_B_Buttons     ;check for A button pressed in previous frame
098F5 D0 05                                bne BounceJS                ;skip to next part if so
098F7 A9 F4                                lda #$f4
098F9 8D DB 06                             sta JumpspringForce         ;otherwise write new jumpspring force here
098FC C0 03                     BounceJS:  cpy #$03                    ;check frame control offset again
098FE D0 0A                                bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
09900 AD DB 06                             lda JumpspringForce
09903 85 9F                                sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
09905 A9 00                                lda #$00
09907 8D 0E 07                             sta JumpspringAnimCtrl      ;initialize jumpspring frame control
0990A 20 56 D1                  DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
0990D 20 81 C8                             jsr EnemyGfxHandler         ;draw jumpspring
09910 20 82 B6                             jsr OffscreenBoundsCheck    ;check to see if we need to kill it
09913 AD 0E 07                             lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
09916 F0 0D                                beq ExJSpring               ;trying to animate it, just leave
09918 AD 86 07                             lda JumpspringTimer
0991B D0 08                                bne ExJSpring               ;if jumpspring timer not expired yet, leave
0991D A9 04                                lda #$04
0991F 8D 86 07                             sta JumpspringTimer         ;otherwise initialize jumpspring timer
09922 EE 0E 07                             inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
09925 60                        ExJSpring: rts                         ;leave
09926                           
09926                           ;-------------------------------------------------------------------------------------
09926                           
09926                           Setup_Vine:
09926 A9 2F                             lda #VineObject          ;load identifier for vine object
09928 95 16                             sta Enemy_ID,x           ;store in buffer
0992A A9 01                             lda #$01
0992C 95 0F                             sta Enemy_Flag,x         ;set flag for enemy object buffer
0992E B9 76 00                          lda Block_PageLoc,y
09931 95 6E                             sta Enemy_PageLoc,x      ;copy page location from previous object
09933 B9 8F 00                          lda Block_X_Position,y
09936 95 87                             sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
09938 B9 D7 00                          lda Block_Y_Position,y
0993B 95 CF                             sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
0993D AC 98 03                          ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
09940 D0 03                             bne NextVO               ;if set at all, don't bother to store vertical
09942 8D 9D 03                          sta VineStart_Y_Position ;otherwise store vertical coordinate here
09945 8A                        NextVO: txa                      ;store object offset to next available vine slot
09946 99 9A 03                          sta VineObjOffset,y      ;using vine flag as offset
09949 EE 98 03                          inc VineFlagOffset       ;increment vine flag offset
0994C A9 04                             lda #Sfx_GrowVine
0994E 85 FE                             sta Square2SoundQueue    ;load vine grow sound
09950 60                                rts
09951                           
09951                           ;-------------------------------------------------------------------------------------
09951                           ;$06-$07 - used as address to block buffer data
09951                           ;$02 - used as vertical high nybble of block buffer offset
09951                           
09951                           VineHeightData:
09951 30 60                           .db $30, $60
09953                           
09953                           VineObjectHandler:
09953 E0 05                                cpx #$05                  ;check enemy offset for special use slot
09955 D0 68                                bne ExitVH                ;if not in last slot, branch to leave
09957 AC 98 03                             ldy VineFlagOffset
0995A 88                                   dey                       ;decrement vine flag in Y, use as offset
0995B AD 99 03                             lda VineHeight
0995E D9 51 99                             cmp VineHeightData,y      ;if vine has reached certain height,
09961 F0 0F                                beq RunVSubs              ;branch ahead to skip this part
09963 A5 09                                lda FrameCounter          ;get frame counter
09965 4A                                   lsr                       ;shift d1 into carry
09966 4A                                   lsr
09967 90 09                                bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
09969 A5 D4                                lda Enemy_Y_Position+5
0996B E9 01                                sbc #$01                  ;subtract vertical position of vine
0996D 85 D4                                sta Enemy_Y_Position+5    ;one pixel every frame it's time
0996F EE 99 03                             inc VineHeight            ;increment vine height
09972 AD 99 03                  RunVSubs:  lda VineHeight            ;if vine still very small,
09975 C9 08                                cmp #$08                  ;branch to leave
09977 90 46                                bcc ExitVH
09979 20 56 D1                             jsr RelativeEnemyPosition ;get relative coordinates of vine,
0997C 20 B3 D1                             jsr GetEnemyOffscreenBits ;and any offscreen bits
0997F A0 00                                ldy #$00                  ;initialize offset used in draw vine sub
09981 20 39 C4                  VDrawLoop: jsr DrawVine              ;draw vine
09984 C8                                   iny                       ;increment offset
09985 CC 98 03                             cpy VineFlagOffset        ;if offset in Y and offset here
09988 D0 F7                                bne VDrawLoop             ;do not yet match, loop back to draw more vine
0998A AD D1 03                             lda Enemy_OffscreenBits
0998D 29 0C                                and #%00001100            ;mask offscreen bits
0998F F0 10                                beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
09991 88                                   dey                       ;otherwise decrement Y to get proper offset again
09992 BE 9A 03                  KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
09995 20 A0 A9                             jsr EraseEnemyObject      ;kill this vine object
09998 88                                   dey                       ;decrement Y
09999 10 F7                                bpl KillVine              ;if any vine objects left, loop back to kill it
0999B 8D 98 03                             sta VineFlagOffset        ;initialize vine flag/offset
0999E 8D 99 03                             sta VineHeight            ;initialize vine height
099A1 AD 99 03                  WrCMTile:  lda VineHeight            ;check vine height
099A4 C9 20                                cmp #$20                  ;if vine small (less than 32 pixels tall)
099A6 90 17                                bcc ExitVH                ;then branch ahead to leave
099A8 A2 06                                ldx #$06                  ;set offset in X to last enemy slot
099AA A9 01                                lda #$01                  ;set A to obtain horizontal in $04, but we don't care
099AC A0 1B                                ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
099AE 20 F5 C3                             jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
099B1 A4 02                                ldy $02
099B3 C0 D0                                cpy #$d0                  ;if vertical high nybble offset beyond extent of
099B5 B0 08                                bcs ExitVH                ;current block buffer, branch to leave, do not write
099B7 B1 06                                lda ($06),y               ;otherwise check contents of block buffer at 
099B9 D0 04                                bne ExitVH                ;current offset, if not empty, branch to leave
099BB A9 26                                lda #$26
099BD 91 06                                sta ($06),y               ;otherwise, write climbing metatile to block buffer
099BF A6 08                     ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
099C1 60                                   rts
099C2                           
099C2                           ;-------------------------------------------------------------------------------------
099C2                           
099C2                           CannonBitmasks:
099C2 0F 07                           .db %00001111, %00000111
099C4                           
099C4                           ProcessCannons:
099C4 AD 4E 07                             lda AreaType                ;get area type
099C7 F0 6F                                beq ExCannon                ;if water type area, branch to leave
099C9 A2 02                                ldx #$02
099CB 86 08                     ThreeSChk: stx ObjectOffset            ;start at third enemy slot
099CD B5 0F                                lda Enemy_Flag,x            ;check enemy buffer flag
099CF D0 51                                bne Chk_BB                  ;if set, branch to check enemy
099D1 BD A8 07                             lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
099D4 AC CC 06                             ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
099D7 39 C2 99                             and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
099DA C9 06                                cmp #$06                    ;check to see if lower nybble is above certain value
099DC B0 44                                bcs Chk_BB                  ;if so, branch to check enemy
099DE A8                                   tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
099DF B9 6B 04                             lda Cannon_PageLoc,y        ;get page location
099E2 F0 3E                                beq Chk_BB                  ;if not set or on page 0, branch to check enemy
099E4 B9 7D 04                             lda Cannon_Timer,y          ;get cannon timer
099E7 F0 08                                beq FireCannon              ;if expired, branch to fire cannon
099E9 E9 00                                sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
099EB 99 7D 04                             sta Cannon_Timer,y          ;to count timer down
099EE 4C 22 9A                             jmp Chk_BB                  ;then jump ahead to check enemy
099F1                           
099F1                           FireCannon:
099F1 AD 47 07                            lda TimerControl           ;if master timer control set,
099F4 D0 2C                               bne Chk_BB                 ;branch to check enemy
099F6 A9 0E                               lda #$0e                   ;otherwise we start creating one
099F8 99 7D 04                            sta Cannon_Timer,y         ;first, reset cannon timer
099FB B9 6B 04                            lda Cannon_PageLoc,y       ;get page location of cannon
099FE 95 6E                               sta Enemy_PageLoc,x        ;save as page location of bullet bill
09A00 B9 71 04                            lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
09A03 95 87                               sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
09A05 B9 77 04                            lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
09A08 38                                  sec
09A09 E9 08                               sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
09A0B 95 CF                               sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
09A0D A9 01                               lda #$01
09A0F 95 B6                               sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
09A11 95 0F                               sta Enemy_Flag,x           ;set buffer flag
09A13 4A                                  lsr                        ;shift right once to init A
09A14 95 1E                               sta Enemy_State,x          ;then initialize enemy's state
09A16 A9 09                               lda #$09
09A18 9D 9A 04                            sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
09A1B A9 33                               lda #BulletBill_CannonVar
09A1D 95 16                               sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
09A1F 4C 35 9A                            jmp Next3Slt               ;move onto next slot
09A22 B5 16                     Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
09A24 C9 33                               cmp #BulletBill_CannonVar
09A26 D0 0D                               bne Next3Slt               ;if not found, branch to get next slot
09A28 20 82 B6                            jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
09A2B B5 0F                               lda Enemy_Flag,x           ;check enemy buffer flag
09A2D F0 06                               beq Next3Slt               ;if not set, branch to get next slot
09A2F 20 B3 D1                            jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
09A32 20 3B 9A                            jsr BulletBillHandler      ;then do sub to handle bullet bill
09A35 CA                        Next3Slt: dex                        ;move onto next slot
09A36 10 93                               bpl ThreeSChk              ;do this until first three slots are checked
09A38 60                        ExCannon: rts                        ;then leave
09A39                           
09A39                           ;--------------------------------
09A39                           
09A39                           BulletBillXSpdData:
09A39 18 E8                           .db $18, $e8
09A3B                           
09A3B                           BulletBillHandler:
09A3B AD 47 07                             lda TimerControl          ;if master timer control set,
09A3E D0 3E                                bne RunBBSubs             ;branch to run subroutines except movement sub
09A40 B5 1E                                lda Enemy_State,x
09A42 D0 2E                                bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
09A44 AD D1 03                             lda Enemy_OffscreenBits   ;otherwise load offscreen bits
09A47 29 0C                                and #%00001100            ;mask out bits
09A49 C9 0C                                cmp #%00001100            ;check to see if all bits are set
09A4B F0 40                                beq KillBB                ;if so, branch to kill this object
09A4D A0 01                                ldy #$01                  ;set to move right by default
09A4F 20 48 C1                             jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
09A52 30 01                                bmi SetupBB               ;if enemy to the left of player, branch
09A54 C8                                   iny                       ;otherwise increment to move left
09A55 94 46                     SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
09A57 88                                   dey                       ;decrement to use as offset
09A58 B9 39 9A                             lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
09A5B 95 58                                sta Enemy_X_Speed,x       ;and store it
09A5D A5 00                                lda $00                   ;get horizontal difference
09A5F 69 28                                adc #$28                  ;add 40 pixels
09A61 C9 50                                cmp #$50                  ;if less than a certain amount, player is too close
09A63 90 28                                bcc KillBB                ;to cannon either on left or right side, thus branch
09A65 A9 01                                lda #$01
09A67 95 1E                                sta Enemy_State,x         ;otherwise set bullet bill's state
09A69 A9 0A                                lda #$0a
09A6B 9D 8A 07                             sta EnemyFrameTimer,x     ;set enemy frame timer
09A6E A9 08                                lda #Sfx_Blast
09A70 85 FE                                sta Square2SoundQueue     ;play fireworks/gunfire sound
09A72 B5 1E                     ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
09A74 29 20                                and #%00100000
09A76 F0 03                                beq BBFly                 ;if not set, skip to move horizontally
09A78 20 6B 9F                             jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
09A7B 20 0A 9F                  BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
09A7E 20 B3 D1                  RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
09A81 20 56 D1                             jsr RelativeEnemyPosition ;get relative coordinates
09A84 20 48 C2                             jsr GetEnemyBoundBox      ;get bounding box coordinates
09A87 20 58 B8                             jsr PlayerEnemyCollision  ;handle player to enemy collisions
09A8A 4C 81 C8                             jmp EnemyGfxHandler       ;draw the bullet bill and leave
09A8D 20 A0 A9                  KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
09A90 60                                   rts
09A91                           
09A91                           ;-------------------------------------------------------------------------------------
09A91                           
09A91                           HammerEnemyOfsData:
09A91 04 04 04 05 05 05               .db $04, $04, $04, $05, $05, $05
09A97 06 06 06                        .db $06, $06, $06
09A9A                           
09A9A                           HammerXSpdData:
09A9A 10 F0                           .db $10, $f0
09A9C                           
09A9C                           SpawnHammerObj:
09A9C AD A8 07                            lda PseudoRandomBitReg+1 ;get pseudorandom bits from
09A9F 29 07                               and #%00000111           ;second part of LSFR
09AA1 D0 05                               bne SetMOfs              ;if any bits are set, branch and use as offset
09AA3 AD A8 07                            lda PseudoRandomBitReg+1
09AA6 29 08                               and #%00001000           ;get d3 from same part of LSFR
09AA8 A8                        SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
09AA9 B9 2A 00                            lda Misc_State,y         ;if any values loaded in
09AAC D0 19                               bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
09AAE BE 91 9A                            ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
09AB1 B5 0F                               lda Enemy_Flag,x         ;check enemy buffer flag at offset
09AB3 D0 12                               bne NoHammer             ;if buffer flag set, branch to leave with carry clear
09AB5 A6 08                               ldx ObjectOffset         ;get original enemy object offset
09AB7 8A                                  txa
09AB8 99 AE 06                            sta HammerEnemyOffset,y  ;save here
09ABB A9 90                               lda #$90
09ABD 99 2A 00                            sta Misc_State,y         ;save hammer's state here
09AC0 A9 07                               lda #$07
09AC2 99 A2 04                            sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
09AC5 38                                  sec                      ;return with carry set
09AC6 60                                  rts
09AC7 A6 08                     NoHammer: ldx ObjectOffset         ;get original enemy object offset
09AC9 18                                  clc                      ;return with carry clear
09ACA 60                                  rts
09ACB                           
09ACB                           ;--------------------------------
09ACB                           ;$00 - used to set downward force
09ACB                           ;$01 - used to set upward force (residual)
09ACB                           ;$02 - used to set maximum speed
09ACB                           
09ACB                           ProcHammerObj:
09ACB AD 47 07                            lda TimerControl           ;if master timer control set
09ACE D0 63                               bne RunHSubs               ;skip all of this code and go to last subs at the end
09AD0 B5 2A                               lda Misc_State,x           ;otherwise get hammer's state
09AD2 29 7F                               and #%01111111             ;mask out d7
09AD4 BC AE 06                            ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
09AD7 C9 02                               cmp #$02                   ;check hammer's state
09AD9 F0 20                               beq SetHSpd                ;if currently at 2, branch
09ADB B0 34                               bcs SetHPos                ;if greater than 2, branch elsewhere
09ADD 8A                                  txa
09ADE 18                                  clc                        ;add 13 bytes to use
09ADF 69 0D                               adc #$0d                   ;proper misc object
09AE1 AA                                  tax                        ;return offset to X
09AE2 A9 10                               lda #$10
09AE4 85 00                               sta $00                    ;set downward movement force
09AE6 A9 0F                               lda #$0f
09AE8 85 01                               sta $01                    ;set upward movement force (not used)
09AEA A9 04                               lda #$04
09AEC 85 02                               sta $02                    ;set maximum vertical speed
09AEE A9 00                               lda #$00                   ;set A to impose gravity on hammer
09AF0 20 DF 9F                            jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
09AF3 20 17 9F                            jsr MoveObjectHorizontally ;do sub to move it horizontally
09AF6 A6 08                               ldx ObjectOffset           ;get original misc object offset
09AF8 4C 30 9B                            jmp RunAllH                ;branch to essential subroutines
09AFB A9 FE                     SetHSpd:  lda #$fe
09AFD 95 AC                               sta Misc_Y_Speed,x         ;set hammer's vertical speed
09AFF B9 1E 00                            lda Enemy_State,y          ;get enemy object state
09B02 29 F7                               and #%11110111             ;mask out d3
09B04 99 1E 00                            sta Enemy_State,y          ;store new state
09B07 B6 46                               ldx Enemy_MovingDir,y      ;get enemy's moving direction
09B09 CA                                  dex                        ;decrement to use as offset
09B0A BD 9A 9A                            lda HammerXSpdData,x       ;get proper speed to use based on moving direction
09B0D A6 08                               ldx ObjectOffset           ;reobtain hammer's buffer offset
09B0F 95 64                               sta Misc_X_Speed,x         ;set hammer's horizontal speed
09B11 D6 2A                     SetHPos:  dec Misc_State,x           ;decrement hammer's state
09B13 B9 87 00                            lda Enemy_X_Position,y     ;get enemy's horizontal position
09B16 18                                  clc
09B17 69 02                               adc #$02                   ;set position 2 pixels to the right
09B19 95 93                               sta Misc_X_Position,x      ;store as hammer's horizontal position
09B1B B9 6E 00                            lda Enemy_PageLoc,y        ;get enemy's page location
09B1E 69 00                               adc #$00                   ;add carry
09B20 95 7A                               sta Misc_PageLoc,x         ;store as hammer's page location
09B22 B9 CF 00                            lda Enemy_Y_Position,y     ;get enemy's vertical position
09B25 38                                  sec
09B26 E9 0A                               sbc #$0a                   ;move position 10 pixels upward
09B28 95 DB                               sta Misc_Y_Position,x      ;store as hammer's vertical position
09B2A A9 01                               lda #$01
09B2C 95 C2                               sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
09B2E D0 03                               bne RunHSubs               ;unconditional branch to skip first routine
09B30 20 C9 B7                  RunAllH:  jsr PlayerHammerCollision  ;handle collisions
09B33 20 9F D1                  RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
09B36 20 4C D1                            jsr RelativeMiscPosition   ;get relative coordinates
09B39 20 3B C2                            jsr GetMiscBoundBox        ;get bounding box coordinates
09B3C 20 E0 C4                            jsr DrawHammer             ;draw the hammer
09B3F 60                                  rts                        ;and we are done here
09B40                           
09B40                           ;-------------------------------------------------------------------------------------
09B40                           ;$02 - used to store vertical high nybble offset from block buffer routine
09B40                           ;$06 - used to store low byte of block buffer address
09B40                           
09B40                           CoinBlock:
09B40 20 8C 9B                        jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
09B43 B5 76                           lda Block_PageLoc,x     ;get page location of block object
09B45 99 7A 00                        sta Misc_PageLoc,y      ;store as page location of misc object
09B48 B5 8F                           lda Block_X_Position,x  ;get horizontal coordinate of block object
09B4A 09 05                           ora #$05                ;add 5 pixels
09B4C 99 93 00                        sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
09B4F B5 D7                           lda Block_Y_Position,x  ;get vertical coordinate of block object
09B51 E9 10                           sbc #$10                ;subtract 16 pixels
09B53 99 DB 00                        sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
09B56 4C 74 9B                        jmp JCoinC              ;jump to rest of code as applies to this misc object
09B59                           
09B59                           SetupJumpCoin:
09B59 20 8C 9B                          jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
09B5C BD EA 03                          lda Block_PageLoc2,x   ;get page location saved earlier
09B5F 99 7A 00                          sta Misc_PageLoc,y     ;and save as page location for misc object
09B62 A5 06                             lda $06                ;get low byte of block buffer offset
09B64 0A                                asl
09B65 0A                                asl                    ;multiply by 16 to use lower nybble
09B66 0A                                asl
09B67 0A                                asl
09B68 09 05                             ora #$05               ;add five pixels
09B6A 99 93 00                          sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
09B6D A5 02                             lda $02                ;get vertical high nybble offset from earlier
09B6F 69 20                             adc #$20               ;add 32 pixels for the status bar
09B71 99 DB 00                          sta Misc_Y_Position,y  ;store as vertical coordinate
09B74 A9 FB                     JCoinC: lda #$fb
09B76 99 AC 00                          sta Misc_Y_Speed,y     ;set vertical speed
09B79 A9 01                             lda #$01
09B7B 99 C2 00                          sta Misc_Y_HighPos,y   ;set vertical high byte
09B7E 99 2A 00                          sta Misc_State,y       ;set state for misc object
09B81 85 FE                             sta Square2SoundQueue  ;load coin grab sound
09B83 86 08                             stx ObjectOffset       ;store current control bit as misc object offset 
09B85 20 06 9C                          jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
09B88 EE 48 07                          inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
09B8B 60                                rts
09B8C                           
09B8C                           FindEmptyMiscSlot:
09B8C A0 08                                ldy #$08                ;start at end of misc objects buffer
09B8E B9 2A 00                  FMiscLoop: lda Misc_State,y        ;get misc object state
09B91 F0 07                                beq UseMiscS            ;branch if none found to use current offset
09B93 88                                   dey                     ;decrement offset
09B94 C0 05                                cpy #$05                ;do this for three slots
09B96 D0 F6                                bne FMiscLoop           ;do this until all slots are checked
09B98 A0 08                                ldy #$08                ;if no empty slots found, use last slot
09B9A 8C B7 06                  UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
09B9D 60                                   rts
09B9E                           
09B9E                           ;-------------------------------------------------------------------------------------
09B9E                           
09B9E                           MiscObjectsCore:
09B9E A2 08                               ldx #$08          ;set at end of misc object buffer
09BA0 86 08                     MiscLoop: stx ObjectOffset  ;store misc object offset here
09BA2 B5 2A                               lda Misc_State,x  ;check misc object state
09BA4 F0 56                               beq MiscLoopBack  ;branch to check next slot
09BA6 0A                                  asl               ;otherwise shift d7 into carry
09BA7 90 06                               bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
09BA9 20 CB 9A                            jsr ProcHammerObj ;otherwise go to process hammer,
09BAC 4C FC 9B                            jmp MiscLoopBack  ;then check next slot
09BAF                           
09BAF                           ;--------------------------------
09BAF                           ;$00 - used to set downward force
09BAF                           ;$01 - used to set upward force (residual)
09BAF                           ;$02 - used to set maximum speed
09BAF                           
09BAF                           ProcJumpCoin:
09BAF B4 2A                                ldy Misc_State,x          ;check misc object state
09BB1 88                                   dey                       ;decrement to see if it's set to 1
09BB2 F0 1D                                beq JCoinRun              ;if so, branch to handle jumping coin
09BB4 F6 2A                                inc Misc_State,x          ;otherwise increment state to either start off or as timer
09BB6 B5 93                                lda Misc_X_Position,x     ;get horizontal coordinate for misc object
09BB8 18                                   clc                       ;whether its jumping coin (state 0 only) or floatey number
09BB9 6D 75 07                             adc ScrollAmount          ;add current scroll speed
09BBC 95 93                                sta Misc_X_Position,x     ;store as new horizontal coordinate
09BBE B5 7A                                lda Misc_PageLoc,x        ;get page location
09BC0 69 00                                adc #$00                  ;add carry
09BC2 95 7A                                sta Misc_PageLoc,x        ;store as new page location
09BC4 B5 2A                                lda Misc_State,x
09BC6 C9 30                                cmp #$30                  ;check state of object for preset value
09BC8 D0 26                                bne RunJCSubs             ;if not yet reached, branch to subroutines
09BCA A9 00                                lda #$00
09BCC 95 2A                                sta Misc_State,x          ;otherwise nullify object state
09BCE 4C FC 9B                             jmp MiscLoopBack          ;and move onto next slot
09BD1 8A                        JCoinRun:  txa             
09BD2 18                                   clc                       ;add 13 bytes to offset for next subroutine
09BD3 69 0D                                adc #$0d
09BD5 AA                                   tax
09BD6 A9 50                                lda #$50                  ;set downward movement amount
09BD8 85 00                                sta $00
09BDA A9 06                                lda #$06                  ;set maximum vertical speed
09BDC 85 02                                sta $02
09BDE 4A                                   lsr                       ;divide by 2 and set
09BDF 85 01                                sta $01                   ;as upward movement amount (apparently residual)
09BE1 A9 00                                lda #$00                  ;set A to impose gravity on jumping coin
09BE3 20 DF 9F                             jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
09BE6 A6 08                                ldx ObjectOffset          ;get original misc object offset
09BE8 B5 AC                                lda Misc_Y_Speed,x        ;check vertical speed
09BEA C9 05                                cmp #$05
09BEC D0 02                                bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
09BEE F6 2A                                inc Misc_State,x          ;otherwise increment state to change to floatey number
09BF0 20 4C D1                  RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
09BF3 20 9F D1                             jsr GetMiscOffscreenBits  ;get offscreen information
09BF6 20 3B C2                             jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
09BF9 20 8A C6                             jsr JCoinGfxHandler       ;draw the coin or floatey number
09BFC                           
09BFC                           MiscLoopBack: 
09BFC CA                                   dex                       ;decrement misc object offset
09BFD 10 A1                                bpl MiscLoop              ;loop back until all misc objects handled
09BFF 60                                   rts                       ;then leave
09C00                           
09C00                           ;-------------------------------------------------------------------------------------
09C00                           
09C00                           CoinTallyOffsets:
09C00 17 1D                           .db $17, $1d
09C02                           
09C02                           ScoreOffsets:
09C02 0B 11                           .db $0b, $11
09C04                           
09C04                           StatusBarNybbles:
09C04 02 13                           .db $02, $13
09C06                           
09C06                           GiveOneCoin:
09C06 A9 01                           lda #$01               ;set digit modifier to add 1 coin
09C08 8D 39 01                        sta DigitModifier+5    ;to the current player's coin tally
09C0B AE 53 07                        ldx CurrentPlayer      ;get current player on the screen
09C0E BC 00 9C                        ldy CoinTallyOffsets,x ;get offset for player's coin tally
09C11 20 65 6F                        jsr DigitsMathRoutine  ;update the coin tally
09C14 EE 5E 07                        inc CoinTally          ;increment onscreen player's coin amount
09C17 AD 5E 07                        lda CoinTally
09C1A C9 64                           cmp #100               ;does player have 100 coins yet?
09C1C D0 0C                           bne CoinPoints         ;if not, skip all of this
09C1E A9 00                           lda #$00
09C20 8D 5E 07                        sta CoinTally          ;otherwise, reinitialize coin amount
09C23 EE 5A 07                        inc NumberofLives      ;give the player an extra life
09C26 A9 40                           lda #Sfx_ExtraLife
09C28 85 FE                           sta Square2SoundQueue  ;play 1-up sound
09C2A                           
09C2A                           CoinPoints:
09C2A A9 02                           lda #$02               ;set digit modifier to award
09C2C 8D 38 01                        sta DigitModifier+4    ;200 points to the player
09C2F                           
09C2F                           AddToScore:
09C2F AE 53 07                        ldx CurrentPlayer      ;get current player
09C32 BC 02 9C                        ldy ScoreOffsets,x     ;get offset for player's score
09C35 20 65 6F                        jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
09C38                           
09C38                           GetSBNybbles:
09C38 AC 53 07                        ldy CurrentPlayer      ;get current player
09C3B B9 04 9C                        lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins
09C3E                           
09C3E                           UpdateNumber:
09C3E 20 0C 6F                          jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
09C41 AC 00 03                          ldy VRAM_Buffer1_Offset   
09C44 B9 FB 02                          lda VRAM_Buffer1-6,y      ;check highest digit of score
09C47 D0 05                             bne NoZSup                ;if zero, overwrite with space tile for zero suppression
09C49 A9 24                             lda #$24
09C4B 99 FB 02                          sta VRAM_Buffer1-6,y
09C4E A6 08                     NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
09C50 60                                rts
09C51                           
09C51                           ;-------------------------------------------------------------------------------------
09C51                           
09C51                           SetupPowerUp:
09C51 A9 2E                                lda #PowerUpObject        ;load power-up identifier into
09C53 85 1B                                sta Enemy_ID+5            ;special use slot of enemy object buffer
09C55 B5 76                                lda Block_PageLoc,x       ;store page location of block object
09C57 85 73                                sta Enemy_PageLoc+5       ;as page location of power-up object
09C59 B5 8F                                lda Block_X_Position,x    ;store horizontal coordinate of block object
09C5B 85 8C                                sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
09C5D A9 01                                lda #$01
09C5F 85 BB                                sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
09C61 B5 D7                                lda Block_Y_Position,x    ;get vertical coordinate of block object
09C63 38                                   sec
09C64 E9 08                                sbc #$08                  ;subtract 8 pixels
09C66 85 D4                                sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
09C68 A9 01                     PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
09C6A 85 23                                sta Enemy_State+5         ;set power-up object's state
09C6C 85 14                                sta Enemy_Flag+5          ;set buffer flag
09C6E A9 03                                lda #$03
09C70 8D 9F 04                             sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
09C73 A5 39                                lda PowerUpType
09C75 C9 02                                cmp #$02                  ;check currently loaded power-up type
09C77 B0 0A                                bcs PutBehind             ;if star or 1-up, branch ahead
09C79 AD 56 07                             lda PlayerStatus          ;otherwise check player's current status
09C7C C9 02                                cmp #$02
09C7E 90 01                                bcc StrType               ;if player not fiery, use status as power-up type
09C80 4A                                   lsr                       ;otherwise shift right to force fire flower type
09C81 85 39                     StrType:   sta PowerUpType           ;store type here
09C83 A9 20                     PutBehind: lda #%00100000
09C85 8D CA 03                             sta Enemy_SprAttrib+5     ;set background priority bit
09C88 A9 02                                lda #Sfx_GrowPowerUp
09C8A 85 FE                                sta Square2SoundQueue     ;load power-up reveal sound and leave
09C8C 60                                   rts
09C8D                           
09C8D                           ;-------------------------------------------------------------------------------------
09C8D                           
09C8D                           PowerUpObjHandler:
09C8D A2 05                              ldx #$05                   ;set object offset for last slot in enemy object buffer
09C8F 86 08                              stx ObjectOffset
09C91 A5 23                              lda Enemy_State+5          ;check power-up object's state
09C93 F0 5D                              beq ExitPUp                ;if not set, branch to leave
09C95 0A                                 asl                        ;shift to check if d7 was set in object state
09C96 90 23                              bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
09C98 AD 47 07                           lda TimerControl           ;if master timer control set,
09C9B D0 43                              bne RunPUSubs              ;branch ahead to enemy object routines
09C9D A5 39                              lda PowerUpType            ;check power-up type
09C9F F0 11                              beq ShroomM                ;if normal mushroom, branch ahead to move it
09CA1 C9 03                              cmp #$03
09CA3 F0 0D                              beq ShroomM                ;if 1-up mushroom, branch ahead to move it
09CA5 C9 02                              cmp #$02
09CA7 D0 37                              bne RunPUSubs              ;if not star, branch elsewhere to skip movement
09CA9 20 01 AB                           jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
09CAC 20 68 C1                           jsr EnemyJump              ;note that green paratroopa shares the same code here 
09CAF 4C E0 9C                           jmp RunPUSubs              ;then jump to other power-up subroutines
09CB2 20 7F AA                  ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
09CB5 20 C6 BF                           jsr EnemyToBGCollisionDet  ;deal with collisions
09CB8 4C E0 9C                           jmp RunPUSubs              ;run the other subroutines
09CBB                           
09CBB                           GrowThePowerUp:
09CBB A5 09                                lda FrameCounter           ;get frame counter
09CBD 29 03                                and #$03                   ;mask out all but 2 LSB
09CBF D0 19                                bne ChkPUSte               ;if any bits set here, branch
09CC1 C6 D4                                dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
09CC3 A5 23                                lda Enemy_State+5          ;load power-up object state
09CC5 E6 23                                inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
09CC7 C9 11                                cmp #$11                   ;if power-up object state not yet past 16th pixel,
09CC9 90 0F                                bcc ChkPUSte               ;branch ahead to last part here
09CCB A9 10                                lda #$10
09CCD 95 58                                sta Enemy_X_Speed,x        ;otherwise set horizontal speed
09CCF A9 80                                lda #%10000000
09CD1 85 23                                sta Enemy_State+5          ;and then set d7 in power-up object's state
09CD3 0A                                   asl                        ;shift once to init A
09CD4 8D CA 03                             sta Enemy_SprAttrib+5      ;initialize background priority bit set here
09CD7 2A                                   rol                        ;rotate A to set right moving direction
09CD8 95 46                                sta Enemy_MovingDir,x      ;set moving direction
09CDA A5 23                     ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
09CDC C9 06                                cmp #$06                   ;for if power-up has risen enough
09CDE 90 12                                bcc ExitPUp                ;if not, don't even bother running these routines
09CE0 20 56 D1                  RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
09CE3 20 B3 D1                             jsr GetEnemyOffscreenBits  ;get offscreen bits
09CE6 20 48 C2                             jsr GetEnemyBoundBox       ;get bounding box coordinates
09CE9 20 D6 C6                             jsr DrawPowerUp            ;draw the power-up object
09CEC 20 58 B8                             jsr PlayerEnemyCollision   ;check for collision with player
09CEF 20 82 B6                             jsr OffscreenBoundsCheck   ;check to see if it went offscreen
09CF2 60                        ExitPUp:   rts                        ;and we're done
09CF3                           
09CF3                           ;-------------------------------------------------------------------------------------
09CF3                           ;These apply to all routines in this section unless otherwise noted:
09CF3                           ;$00 - used to store metatile from block buffer routine
09CF3                           ;$02 - used to store vertical high nybble offset from block buffer routine
09CF3                           ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
09CF3                           ;$06-$07 - used as block buffer address indirect
09CF3                           
09CF3                           BlockYPosAdderData:
09CF3 04 12                           .db $04, $12
09CF5                           
09CF5                           PlayerHeadCollision:
09CF5 48                                   pha                      ;store metatile number to stack
09CF6 A9 11                                lda #$11                 ;load unbreakable block object state by default
09CF8 AE EE 03                             ldx SprDataOffset_Ctrl   ;load offset control bit here
09CFB AC 54 07                             ldy PlayerSize           ;check player's size
09CFE D0 02                                bne DBlockSte            ;if small, branch
09D00 A9 12                                lda #$12                 ;otherwise load breakable block object state
09D02 95 26                     DBlockSte: sta Block_State,x        ;store into block object buffer
09D04 20 71 6A                             jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
09D07 AE EE 03                             ldx SprDataOffset_Ctrl   ;load offset control bit
09D0A A5 02                                lda $02                  ;get vertical high nybble offset used in block buffer routine
09D0C 9D E4 03                             sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
09D0F A8                                   tay
09D10 A5 06                                lda $06                  ;get low byte of block buffer address used in same routine
09D12 9D E6 03                             sta Block_BBuf_Low,x     ;save as offset here to be used later
09D15 B1 06                                lda ($06),y              ;get contents of block buffer at old address at $06, $07
09D17 20 FE 9D                             jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
09D1A 85 00                                sta $00                  ;store metatile here
09D1C AC 54 07                             ldy PlayerSize           ;check player's size
09D1F D0 01                                bne ChkBrick             ;if small, use metatile itself as contents of A
09D21 98                                   tya                      ;otherwise init A (note: big = 0)
09D22 90 25                     ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
09D24 A0 11                                ldy #$11                 ;otherwise load unbreakable state into block object buffer
09D26 94 26                                sty Block_State,x        ;note this applies to both player sizes
09D28 A9 C4                                lda #$c4                 ;load empty block metatile into A for now
09D2A A4 00                                ldy $00                  ;get metatile from before
09D2C C0 58                                cpy #$58                 ;is it brick with coins (with line)?
09D2E F0 04                                beq StartBTmr            ;if so, branch
09D30 C0 5D                                cpy #$5d                 ;is it brick with coins (without line)?
09D32 D0 15                                bne PutMTileB            ;if not, branch ahead to store empty block metatile
09D34 AD BC 06                  StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
09D37 D0 08                                bne ContBTmr             ;if set, timer expired or counting down, thus branch
09D39 A9 0B                                lda #$0b
09D3B 8D 9D 07                             sta BrickCoinTimer       ;if not set, set brick coin timer
09D3E EE BC 06                             inc BrickCoinTimerFlag   ;and set flag linked to it
09D41 AD 9D 07                  ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
09D44 D0 02                                bne PutOldMT             ;if not yet expired, branch to use current metatile
09D46 A0 C4                                ldy #$c4                 ;otherwise use empty block metatile
09D48 98                        PutOldMT:  tya                      ;put metatile into A
09D49 9D E8 03                  PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
09D4C 20 8C 9D                             jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
09D4F A4 02                                ldy $02                  ;get vertical high nybble offset
09D51 A9 23                                lda #$23
09D53 91 06                                sta ($06),y              ;write blank metatile $23 to block buffer
09D55 A9 10                                lda #$10
09D57 8D 84 07                             sta BlockBounceTimer     ;set block bounce timer
09D5A 68                                   pla                      ;pull original metatile from stack
09D5B 85 05                                sta $05                  ;and save here
09D5D A0 00                                ldy #$00                 ;set default offset
09D5F AD 14 07                             lda CrouchingFlag        ;is player crouching?
09D62 D0 05                                bne SmallBP              ;if so, branch to increment offset
09D64 AD 54 07                             lda PlayerSize           ;is player big?
09D67 F0 01                                beq BigBP                ;if so, branch to use default offset
09D69 C8                        SmallBP:   iny                      ;increment for small or big and crouching
09D6A A5 CE                     BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
09D6C 18                                   clc
09D6D 79 F3 9C                             adc BlockYPosAdderData,y ;add value determined by size
09D70 29 F0                                and #$f0                 ;mask out low nybble to get 16-pixel correspondence
09D72 95 D7                                sta Block_Y_Position,x   ;save as vertical coordinate for block object
09D74 B4 26                                ldy Block_State,x        ;get block object state
09D76 C0 11                                cpy #$11
09D78 F0 06                                beq Unbreak              ;if set to value loaded for unbreakable, branch
09D7A 20 0A 9E                             jsr BrickShatter         ;execute code for breakable brick
09D7D 4C 83 9D                             jmp InvOBit              ;skip subroutine to do last part of code here
09D80 20 A3 9D                  Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
09D83 AD EE 03                  InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
09D86 49 01                                eor #$01                 ;and floatey numbers
09D88 8D EE 03                             sta SprDataOffset_Ctrl
09D8B 60                                   rts                      ;leave!
09D8C                           
09D8C                           ;--------------------------------
09D8C                           
09D8C                           InitBlock_XY_Pos:
09D8C A5 86                           lda Player_X_Position   ;get player's horizontal coordinate
09D8E 18                              clc
09D8F 69 08                           adc #$08                ;add eight pixels
09D91 29 F0                           and #$f0                ;mask out low nybble to give 16-pixel correspondence
09D93 95 8F                           sta Block_X_Position,x  ;save as horizontal coordinate for block object
09D95 A5 6D                           lda Player_PageLoc
09D97 69 00                           adc #$00                ;add carry to page location of player
09D99 95 76                           sta Block_PageLoc,x     ;save as page location of block object
09D9B 9D EA 03                        sta Block_PageLoc2,x    ;save elsewhere to be used later
09D9E A5 B5                           lda Player_Y_HighPos
09DA0 95 BE                           sta Block_Y_HighPos,x   ;save vertical high byte of player into
09DA2 60                              rts                     ;vertical high byte of block object and leave
09DA3                           
09DA3                           ;--------------------------------
09DA3                           
09DA3                           BumpBlock:
09DA3 20 27 9E                             jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
09DA6 A9 02                                lda #Sfx_Bump
09DA8 85 FF                                sta Square1SoundQueue   ;play bump sound
09DAA A9 00                                lda #$00
09DAC 95 60                                sta Block_X_Speed,x     ;initialize horizontal speed for block object
09DAE 9D 3C 04                             sta Block_Y_MoveForce,x ;init fractional movement force
09DB1 85 9F                                sta Player_Y_Speed      ;init player's vertical speed
09DB3 A9 FE                                lda #$fe
09DB5 95 A8                                sta Block_Y_Speed,x     ;set vertical speed for block object
09DB7 A5 05                                lda $05                 ;get original metatile from stack
09DB9 20 FE 9D                             jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
09DBC 90 31                                bcc ExitBlockChk        ;if no match was found, branch to leave
09DBE 98                                   tya                     ;move block number to A
09DBF C9 09                                cmp #$09                ;if block number was within 0-8 range,
09DC1 90 02                                bcc BlockCode           ;branch to use current number
09DC3 E9 05                                sbc #$05                ;otherwise subtract 5 for second set to get proper number
09DC5 20 0A 6E                  BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
09DC8                           
09DC8 DA 9D                           .dw MushFlowerBlock
09DCA 40 9B                           .dw CoinBlock
09DCC 40 9B                           .dw CoinBlock
09DCE E0 9D                           .dw ExtraLifeMushBlock
09DD0 DA 9D                           .dw MushFlowerBlock
09DD2 E7 9D                           .dw VineBlock
09DD4 DD 9D                           .dw StarBlock
09DD6 40 9B                           .dw CoinBlock
09DD8 E0 9D                           .dw ExtraLifeMushBlock
09DDA                           
09DDA                           ;--------------------------------
09DDA                           
09DDA                           MushFlowerBlock:
09DDA A9 00                           lda #$00       ;load mushroom/fire flower into power-up type
09DDC 2C                              .db $2c        ;BIT instruction opcode
09DDD                           
09DDD                           StarBlock:
09DDD A9 02                           lda #$02       ;load star into power-up type
09DDF 2C                              .db $2c        ;BIT instruction opcode
09DE0                           
09DE0                           ExtraLifeMushBlock:
09DE0 A9 03                           lda #$03         ;load 1-up mushroom into power-up type
09DE2 85 39                           sta $39          ;store correct power-up type
09DE4 4C 51 9C                        jmp SetupPowerUp
09DE7                           
09DE7                           VineBlock:
09DE7 A2 05                           ldx #$05                ;load last slot for enemy object buffer
09DE9 AC EE 03                        ldy SprDataOffset_Ctrl  ;get control bit
09DEC 20 26 99                        jsr Setup_Vine          ;set up vine object
09DEF                           
09DEF                           ExitBlockChk:
09DEF 60                              rts                     ;leave
09DF0                           
09DF0                           ;--------------------------------
09DF0                           
09DF0                           BrickQBlockMetatiles:
09DF0 C1 C0 5F 60                     .db $c1, $c0, $5f, $60 ;used by question blocks
09DF4                           
09DF4                                 ;these two sets are functionally identical, but look different
09DF4 55 56 57 58 59                  .db $55, $56, $57, $58, $59 ;used by ground level types
09DF9 5A 5B 5C 5D 5E                  .db $5a, $5b, $5c, $5d, $5e ;used by other level types
09DFE                           
09DFE                           BlockBumpedChk:
09DFE A0 0D                                  ldy #$0d                    ;start at end of metatile data
09E00 D9 F0 9D                  BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
09E03 F0 04                                  beq MatchBump               ;metatile found in block buffer, branch if so
09E05 88                                     dey                         ;otherwise move onto next metatile
09E06 10 F8                                  bpl BumpChkLoop             ;do this until all metatiles are checked
09E08 18                                     clc                         ;if none match, return with carry clear
09E09 60                        MatchBump:   rts                         ;note carry is set if found match
09E0A                           
09E0A                           ;--------------------------------
09E0A                           
09E0A                           BrickShatter:
09E0A 20 27 9E                        jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
09E0D A9 01                           lda #Sfx_BrickShatter
09E0F 9D EC 03                        sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
09E12 85 FD                           sta NoiseSoundQueue    ;load brick shatter sound
09E14 20 49 9E                        jsr SpawnBrickChunks   ;create brick chunk objects
09E17 A9 FE                           lda #$fe
09E19 85 9F                           sta Player_Y_Speed     ;set vertical speed for player
09E1B A9 05                           lda #$05
09E1D 8D 39 01                        sta DigitModifier+5    ;set digit modifier to give player 50 points
09E20 20 2F 9C                        jsr AddToScore         ;do sub to update the score
09E23 AE EE 03                        ldx SprDataOffset_Ctrl ;load control bit and leave
09E26 60                              rts
09E27                           
09E27                           ;--------------------------------
09E27                           
09E27                           CheckTopOfBlock:
09E27 AE EE 03                         ldx SprDataOffset_Ctrl  ;load control bit
09E2A A4 02                            ldy $02                 ;get vertical high nybble offset used in block buffer
09E2C F0 1A                            beq TopEx               ;branch to leave if set to zero, because we're at the top
09E2E 98                               tya                     ;otherwise set to A
09E2F 38                               sec
09E30 E9 10                            sbc #$10                ;subtract $10 to move up one row in the block buffer
09E32 85 02                            sta $02                 ;store as new vertical high nybble offset
09E34 A8                               tay 
09E35 B1 06                            lda ($06),y             ;get contents of block buffer in same column, one row up
09E37 C9 C2                            cmp #$c2                ;is it a coin? (not underwater)
09E39 D0 0D                            bne TopEx               ;if not, branch to leave
09E3B A9 00                            lda #$00
09E3D 91 06                            sta ($06),y             ;otherwise put blank metatile where coin was
09E3F 20 53 6A                         jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
09E42 AE EE 03                         ldx SprDataOffset_Ctrl  ;get control bit
09E45 20 59 9B                         jsr SetupJumpCoin       ;create jumping coin object and update coin variables
09E48 60                        TopEx: rts                     ;leave!
09E49                           
09E49                           ;--------------------------------
09E49                           
09E49                           SpawnBrickChunks:
09E49 B5 8F                           lda Block_X_Position,x     ;set horizontal coordinate of block object
09E4B 9D F1 03                        sta Block_Orig_XPos,x      ;as original horizontal coordinate here
09E4E A9 F0                           lda #$f0
09E50 95 60                           sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
09E52 95 62                           sta Block_X_Speed+2,x
09E54 A9 FA                           lda #$fa
09E56 95 A8                           sta Block_Y_Speed,x        ;set vertical speed for one
09E58 A9 FC                           lda #$fc
09E5A 95 AA                           sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
09E5C A9 00                           lda #$00
09E5E 9D 3C 04                        sta Block_Y_MoveForce,x    ;init fractional movement force for both
09E61 9D 3E 04                        sta Block_Y_MoveForce+2,x
09E64 B5 76                           lda Block_PageLoc,x
09E66 95 78                           sta Block_PageLoc+2,x      ;copy page location
09E68 B5 8F                           lda Block_X_Position,x
09E6A 95 91                           sta Block_X_Position+2,x   ;copy horizontal coordinate
09E6C B5 D7                           lda Block_Y_Position,x
09E6E 18                              clc                        ;add 8 pixels to vertical coordinate
09E6F 69 08                           adc #$08                   ;and save as vertical coordinate for one of them
09E71 95 D9                           sta Block_Y_Position+2,x
09E73 A9 FA                           lda #$fa
09E75 95 A8                           sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
09E77 60                              rts
09E78                           
09E78                           ;-------------------------------------------------------------------------------------
09E78                           
09E78                           BlockObjectsCore:
09E78 B5 26                             lda Block_State,x           ;get state of block object
09E7A F0 5D                             beq UpdSte                  ;if not set, branch to leave
09E7C 29 0F                             and #$0f                    ;mask out high nybble
09E7E 48                                pha                         ;push to stack
09E7F A8                                tay                         ;put in Y for now
09E80 8A                                txa
09E81 18                                clc
09E82 69 09                             adc #$09                    ;add 9 bytes to offset (note two block objects are created
09E84 AA                                tax                         ;when using brick chunks, but only one offset for both)
09E85 88                                dey                         ;decrement Y to check for solid block state
09E86 F0 33                             beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
09E88 20 AC 9F                          jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
09E8B 20 17 9F                          jsr MoveObjectHorizontally  ;do another sub to move horizontally
09E8E 8A                                txa
09E8F 18                                clc                         ;move onto next block object
09E90 69 02                             adc #$02
09E92 AA                                tax
09E93 20 AC 9F                          jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
09E96 20 17 9F                          jsr MoveObjectHorizontally  ;do another sub to move horizontally
09E99 A6 08                             ldx ObjectOffset            ;get block object offset used for both
09E9B 20 5D D1                          jsr RelativeBlockPosition   ;get relative coordinates
09E9E 20 BA D1                          jsr GetBlockOffscreenBits   ;get offscreen information
09EA1 20 57 CC                          jsr DrawBrickChunks         ;draw the brick chunks
09EA4 68                                pla                         ;get lower nybble of saved state
09EA5 B4 BE                             ldy Block_Y_HighPos,x       ;check vertical high byte of block object
09EA7 F0 30                             beq UpdSte                  ;if above the screen, branch to kill it
09EA9 48                                pha                         ;otherwise save state back into stack
09EAA A9 F0                             lda #$f0
09EAC D5 D9                             cmp Block_Y_Position+2,x    ;check to see if bottom block object went
09EAE B0 02                             bcs ChkTop                  ;to the bottom of the screen, and branch if not
09EB0 95 D9                             sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
09EB2 B5 D7                     ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
09EB4 C9 F0                             cmp #$f0                    ;see if it went to the bottom of the screen
09EB6 68                                pla                         ;pull block object state from stack
09EB7 90 20                             bcc UpdSte                  ;if not, branch to save state
09EB9 B0 1C                             bcs KillBlock               ;otherwise do unconditional branch to kill it
09EBB                           
09EBB                           BouncingBlockHandler:
09EBB 20 AC 9F                             jsr ImposeGravityBlock     ;do sub to impose gravity on block object
09EBE A6 08                                ldx ObjectOffset           ;get block object offset
09EC0 20 5D D1                             jsr RelativeBlockPosition  ;get relative coordinates
09EC3 20 BA D1                             jsr GetBlockOffscreenBits  ;get offscreen information
09EC6 20 D5 CB                             jsr DrawBlock              ;draw the block
09EC9 B5 D7                                lda Block_Y_Position,x     ;get vertical coordinate
09ECB 29 0F                                and #$0f                   ;mask out high nybble
09ECD C9 05                                cmp #$05                   ;check to see if low nybble wrapped around
09ECF 68                                   pla                        ;pull state from stack
09ED0 B0 07                                bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
09ED2 A9 01                                lda #$01
09ED4 9D EC 03                             sta Block_RepFlag,x        ;otherwise set flag to replace metatile
09ED7 A9 00                     KillBlock: lda #$00                   ;if branched here, nullify object state
09ED9 95 26                     UpdSte:    sta Block_State,x          ;store contents of A in block object state
09EDB 60                                   rts
09EDC                           
09EDC                           ;-------------------------------------------------------------------------------------
09EDC                           ;$02 - used to store offset to block buffer
09EDC                           ;$06-$07 - used to store block buffer address
09EDC                           
09EDC                           BlockObjMT_Updater:
09EDC A2 01                                 ldx #$01                  ;set offset to start with second block object
09EDE 86 08                     UpdateLoop: stx ObjectOffset          ;set offset here
09EE0 AD 01 03                              lda VRAM_Buffer1          ;if vram buffer already being used here,
09EE3 D0 21                                 bne NextBUpd              ;branch to move onto next block object
09EE5 BD EC 03                              lda Block_RepFlag,x       ;if flag for block object already clear,
09EE8 F0 1C                                 beq NextBUpd              ;branch to move onto next block object
09EEA BD E6 03                              lda Block_BBuf_Low,x      ;get low byte of block buffer
09EED 85 06                                 sta $06                   ;store into block buffer address
09EEF A9 05                                 lda #$05
09EF1 85 07                                 sta $07                   ;set high byte of block buffer address
09EF3 BD E4 03                              lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
09EF6 85 02                                 sta $02                   ;store here and use as offset to block buffer
09EF8 A8                                    tay
09EF9 BD E8 03                              lda Block_Metatile,x      ;get metatile to be written
09EFC 91 06                                 sta ($06),y               ;write it to the block buffer
09EFE 20 67 6A                              jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
09F01 A9 00                                 lda #$00
09F03 9D EC 03                              sta Block_RepFlag,x       ;clear block object flag
09F06 CA                        NextBUpd:   dex                       ;decrement block object offset
09F07 10 D5                                 bpl UpdateLoop            ;do this until both block objects are dealt with
09F09 60                                    rts                       ;then leave
09F0A                           
09F0A                           ;-------------------------------------------------------------------------------------
09F0A                           ;$00 - used to store high nybble of horizontal speed as adder
09F0A                           ;$01 - used to store low nybble of horizontal speed
09F0A                           ;$02 - used to store adder to page location
09F0A                           
09F0A                           MoveEnemyHorizontally:
09F0A E8                              inx                         ;increment offset for enemy offset
09F0B 20 17 9F                        jsr MoveObjectHorizontally  ;position object horizontally according to
09F0E A6 08                           ldx ObjectOffset            ;counters, return with saved value in A,
09F10 60                              rts                         ;put enemy offset back in X and leave
09F11                           
09F11                           MovePlayerHorizontally:
09F11 AD 0E 07                        lda JumpspringAnimCtrl  ;if jumpspring currently animating,
09F14 D0 3E                           bne ExXMove             ;branch to leave
09F16 AA                              tax                     ;otherwise set zero for offset to use player's stuff
09F17                           
09F17                           MoveObjectHorizontally:
09F17 B5 57                               lda SprObject_X_Speed,x     ;get currently saved value (horizontal
09F19 0A                                  asl                         ;speed, secondary counter, whatever)
09F1A 0A                                  asl                         ;and move low nybble to high
09F1B 0A                                  asl
09F1C 0A                                  asl
09F1D 85 01                               sta $01                     ;store result here
09F1F B5 57                               lda SprObject_X_Speed,x     ;get saved value again
09F21 4A                                  lsr                         ;move high nybble to low
09F22 4A                                  lsr
09F23 4A                                  lsr
09F24 4A                                  lsr
09F25 C9 08                               cmp #$08                    ;if < 8, branch, do not change
09F27 90 02                               bcc SaveXSpd
09F29 09 F0                               ora #%11110000              ;otherwise alter high nybble
09F2B 85 00                     SaveXSpd: sta $00                     ;save result here
09F2D A0 00                               ldy #$00                    ;load default Y value here
09F2F C9 00                               cmp #$00                    ;if result positive, leave Y alone
09F31 10 01                               bpl UseAdder
09F33 88                                  dey                         ;otherwise decrement Y
09F34 84 02                     UseAdder: sty $02                     ;save Y here
09F36 BD 00 04                            lda SprObject_X_MoveForce,x ;get whatever number's here
09F39 18                                  clc
09F3A 65 01                               adc $01                     ;add low nybble moved to high
09F3C 9D 00 04                            sta SprObject_X_MoveForce,x ;store result here
09F3F A9 00                               lda #$00                    ;init A
09F41 2A                                  rol                         ;rotate carry into d0
09F42 48                                  pha                         ;push onto stack
09F43 6A                                  ror                         ;rotate d0 back onto carry
09F44 B5 86                               lda SprObject_X_Position,x
09F46 65 00                               adc $00                     ;add carry plus saved value (high nybble moved to low
09F48 95 86                               sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
09F4A B5 6D                               lda SprObject_PageLoc,x
09F4C 65 02                               adc $02                     ;add carry plus other saved value to the
09F4E 95 6D                               sta SprObject_PageLoc,x     ;object's page location and save
09F50 68                                  pla
09F51 18                                  clc                         ;pull old carry from stack and add
09F52 65 00                               adc $00                     ;to high nybble moved to low
09F54 60                        ExXMove:  rts                         ;and leave
09F55                           
09F55                           ;-------------------------------------------------------------------------------------
09F55                           ;$00 - used for downward force
09F55                           ;$01 - used for upward force
09F55                           ;$02 - used for maximum vertical speed
09F55                           
09F55                           MovePlayerVertically:
09F55 A2 00                              ldx #$00                ;set X for player offset
09F57 AD 47 07                           lda TimerControl
09F5A D0 05                              bne NoJSChk             ;if master timer control set, branch ahead
09F5C AD 0E 07                           lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
09F5F D0 F3                              bne ExXMove             ;branch to leave if so
09F61 AD 09 07                  NoJSChk: lda VerticalForce       ;dump vertical force 
09F64 85 00                              sta $00
09F66 A9 04                              lda #$04                ;set maximum vertical speed here
09F68 4C B5 9F                           jmp ImposeGravitySprObj ;then jump to move player vertically
09F6B                           
09F6B                           ;--------------------------------
09F6B                           
09F6B                           MoveD_EnemyVertically:
09F6B A0 3D                           ldy #$3d           ;set quick movement amount downwards
09F6D B5 1E                           lda Enemy_State,x  ;then check enemy state
09F6F C9 05                           cmp #$05           ;if not set to unique state for spiny's egg, go ahead
09F71 D0 02                           bne ContVMove      ;and use, otherwise set different movement amount, continue on
09F73                           
09F73                           MoveFallingPlatform:
09F73 A0 20                                ldy #$20       ;set movement amount
09F75 4C 9C 9F                  ContVMove: jmp SetHiMax   ;jump to skip the rest of this
09F78                           
09F78                           ;--------------------------------
09F78                           
09F78                           MoveRedPTroopaDown:
09F78 A0 00                           ldy #$00            ;set Y to move downwards
09F7A 4C 7F 9F                        jmp MoveRedPTroopa  ;skip to movement routine
09F7D                           
09F7D                           MoveRedPTroopaUp:
09F7D A0 01                           ldy #$01            ;set Y to move upwards
09F7F                           
09F7F                           MoveRedPTroopa:
09F7F E8                              inx                 ;increment X for enemy offset
09F80 A9 03                           lda #$03
09F82 85 00                           sta $00             ;set downward movement amount here
09F84 A9 06                           lda #$06
09F86 85 01                           sta $01             ;set upward movement amount here
09F88 A9 02                           lda #$02
09F8A 85 02                           sta $02             ;set maximum speed here
09F8C 98                              tya                 ;set movement direction in A, and
09F8D 4C D9 9F                        jmp RedPTroopaGrav  ;jump to move this thing
09F90                           
09F90                           ;--------------------------------
09F90                           
09F90                           MoveDropPlatform:
09F90 A0 7F                           ldy #$7f      ;set movement amount for drop platform
09F92 D0 02                           bne SetMdMax  ;skip ahead of other value set here
09F94                           
09F94                           MoveEnemySlowVert:
09F94 A0 0F                               ldy #$0f         ;set movement amount for bowser/other objects
09F96 A9 02                     SetMdMax: lda #$02         ;set maximum speed in A
09F98 D0 04                               bne SetXMoveAmt  ;unconditional branch
09F9A                           
09F9A                           ;--------------------------------
09F9A                           
09F9A                           MoveJ_EnemyVertically:
09F9A A0 1C                                  ldy #$1c                ;set movement amount for podoboo/other objects
09F9C A9 03                     SetHiMax:    lda #$03                ;set maximum speed in A
09F9E 84 00                     SetXMoveAmt: sty $00                 ;set movement amount here
09FA0 E8                                     inx                     ;increment X for enemy offset
09FA1 20 B5 9F                               jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
09FA4 A6 08                                  ldx ObjectOffset        ;get enemy object buffer offset and leave
09FA6 60                                     rts
09FA7                           
09FA7                           ;--------------------------------
09FA7                           
09FA7                           MaxSpdBlockData:
09FA7 06 08                           .db $06, $08
09FA9                           
09FA9                           ResidualGravityCode:
09FA9 A0 00                           ldy #$00       ;this part appears to be residual,
09FAB 2C                              .db $2c        ;no code branches or jumps to it...
09FAC                           
09FAC                           ImposeGravityBlock:
09FAC A0 01                           ldy #$01       ;set offset for maximum speed
09FAE A9 50                           lda #$50       ;set movement amount here
09FB0 85 00                           sta $00
09FB2 B9 A7 9F                        lda MaxSpdBlockData,y    ;get maximum speed
09FB5                           
09FB5                           ImposeGravitySprObj:
09FB5 85 02                           sta $02            ;set maximum speed here
09FB7 A9 00                           lda #$00           ;set value to move downwards
09FB9 4C DF 9F                        jmp ImposeGravity  ;jump to the code that actually moves it
09FBC                           
09FBC                           ;--------------------------------
09FBC                           
09FBC                           MovePlatformDown:
09FBC A9 00                           lda #$00    ;save value to stack (if branching here, execute next
09FBE 2C                              .db $2c     ;part as BIT instruction)
09FBF                           
09FBF                           MovePlatformUp:
09FBF A9 01                                lda #$01        ;save value to stack
09FC1 48                                   pha
09FC2 B4 16                                ldy Enemy_ID,x  ;get enemy object identifier
09FC4 E8                                   inx             ;increment offset for enemy object
09FC5 A9 05                                lda #$05        ;load default value here
09FC7 C0 29                                cpy #$29        ;residual comparison, object #29 never executes
09FC9 D0 02                                bne SetDplSpd   ;this code, thus unconditional branch here
09FCB A9 09                                lda #$09        ;residual code
09FCD 85 00                     SetDplSpd: sta $00         ;save downward movement amount here
09FCF A9 0A                                lda #$0a        ;save upward movement amount here
09FD1 85 01                                sta $01
09FD3 A9 03                                lda #$03        ;save maximum vertical speed here
09FD5 85 02                                sta $02
09FD7 68                                   pla             ;get value from stack
09FD8 A8                                   tay             ;use as Y, then move onto code shared by red koopa
09FD9                           
09FD9                           RedPTroopaGrav:
09FD9 20 DF 9F                        jsr ImposeGravity  ;do a sub to move object gradually
09FDC A6 08                           ldx ObjectOffset   ;get enemy object offset and leave
09FDE 60                              rts
09FDF                           
09FDF                           ;-------------------------------------------------------------------------------------
09FDF                           ;$00 - used for downward force
09FDF                           ;$01 - used for upward force
09FDF                           ;$07 - used as adder for vertical position
09FDF                           
09FDF                           ImposeGravity:
09FDF 48                                 pha                          ;push value to stack
09FE0 BD 16 04                           lda SprObject_YMF_Dummy,x
09FE3 18                                 clc                          ;add value in movement force to contents of dummy variable
09FE4 7D 33 04                           adc SprObject_Y_MoveForce,x
09FE7 9D 16 04                           sta SprObject_YMF_Dummy,x
09FEA A0 00                              ldy #$00                     ;set Y to zero by default
09FEC B5 9F                              lda SprObject_Y_Speed,x      ;get current vertical speed
09FEE 10 01                              bpl AlterYP                  ;if currently moving downwards, do not decrement Y
09FF0 88                                 dey                          ;otherwise decrement Y
09FF1 84 07                     AlterYP: sty $07                      ;store Y here
09FF3 75 CE                              adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
09FF5 95 CE                              sta SprObject_Y_Position,x   ;store as new vertical position
09FF7 B5 B5                              lda SprObject_Y_HighPos,x
09FF9 65 07                              adc $07                      ;add carry plus contents of $07 to vertical high byte
09FFB 95 B5                              sta SprObject_Y_HighPos,x    ;store as new vertical high byte
09FFD BD 33 04                           lda SprObject_Y_MoveForce,x
0A000 18                                 clc
0A001 65 00                              adc $00                      ;add downward movement amount to contents of $0433
0A003 9D 33 04                           sta SprObject_Y_MoveForce,x
0A006 B5 9F                              lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
0A008 69 00                              adc #$00
0A00A 95 9F                              sta SprObject_Y_Speed,x
0A00C C5 02                              cmp $02                      ;compare to maximum speed
0A00E 30 10                              bmi ChkUpM                   ;if less than preset value, skip this part
0A010 BD 33 04                           lda SprObject_Y_MoveForce,x
0A013 C9 80                              cmp #$80                     ;if less positively than preset maximum, skip this part
0A015 90 09                              bcc ChkUpM
0A017 A5 02                              lda $02
0A019 95 9F                              sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
0A01B A9 00                              lda #$00
0A01D 9D 33 04                           sta SprObject_Y_MoveForce,x  ;clear fractional
0A020 68                        ChkUpM:  pla                          ;get value from stack
0A021 F0 2B                              beq ExVMove                  ;if set to zero, branch to leave
0A023 A5 02                              lda $02
0A025 49 FF                              eor #%11111111               ;otherwise get two's compliment of maximum speed
0A027 A8                                 tay
0A028 C8                                 iny
0A029 84 07                              sty $07                      ;store two's compliment here
0A02B BD 33 04                           lda SprObject_Y_MoveForce,x
0A02E 38                                 sec                          ;subtract upward movement amount from contents
0A02F E5 01                              sbc $01                      ;of movement force, note that $01 is twice as large as $00,
0A031 9D 33 04                           sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
0A034 B5 9F                              lda SprObject_Y_Speed,x
0A036 E9 00                              sbc #$00                     ;subtract borrow from vertical speed and store
0A038 95 9F                              sta SprObject_Y_Speed,x
0A03A C5 07                              cmp $07                      ;compare vertical speed to two's compliment
0A03C 10 10                              bpl ExVMove                  ;if less negatively than preset maximum, skip this part
0A03E BD 33 04                           lda SprObject_Y_MoveForce,x
0A041 C9 80                              cmp #$80                     ;check if fractional part is above certain amount,
0A043 B0 09                              bcs ExVMove                  ;and if so, branch to leave
0A045 A5 07                              lda $07
0A047 95 9F                              sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
0A049 A9 FF                              lda #$ff
0A04B 9D 33 04                           sta SprObject_Y_MoveForce,x  ;clear fractional
0A04E 60                        ExVMove: rts                          ;leave!
0A04F                           
0A04F                           ;-------------------------------------------------------------------------------------
0A04F                           
0A04F                           EnemiesAndLoopsCore:
0A04F B5 0F                                 lda Enemy_Flag,x         ;check data here for MSB set
0A051 48                                    pha                      ;save in stack
0A052 0A                                    asl
0A053 B0 12                                 bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
0A055 68                                    pla                      ;get from stack
0A056 F0 03                                 beq ChkAreaTsk           ;if data zero, branch
0A058 4C 8A A8                              jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
0A05B AD 1F 07                  ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
0A05E 29 07                                 and #$07
0A060 C9 07                                 cmp #$07                 ;if at a specific task, jump and leave
0A062 F0 0E                                 beq ExitELCore
0A064 4C D4 A0                              jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
0A067 68                        ChkBowserF: pla                      ;get data from stack
0A068 29 0F                                 and #%00001111           ;mask out high nybble
0A06A A8                                    tay
0A06B B9 0F 00                              lda Enemy_Flag,y         ;use as pointer and load same place with different offset
0A06E D0 02                                 bne ExitELCore
0A070 95 0F                                 sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
0A072 60                        ExitELCore: rts
0A073                           
0A073                           ;--------------------------------
0A073                           
0A073                           ;loop command data
0A073                           LoopCmdWorldNumber:
0A073 03 03 06 06 06 06 06 06..       .db $03, $03, $06, $06, $06, $06, $06, $06, $07, $07, $07
0A07E                           
0A07E                           LoopCmdPageNumber:
0A07E 05 09 04 05 06 08 09 0A..       .db $05, $09, $04, $05, $06, $08, $09, $0a, $06, $0b, $10
0A089                           
0A089                           LoopCmdYPosition:
0A089 40 B0 B0 80 40 40 80 40..       .db $40, $b0, $b0, $80, $40, $40, $80, $40, $f0, $f0, $f0
0A094                           
0A094                           ExecGameLoopback:
0A094 A5 6D                           lda Player_PageLoc        ;send player back four pages
0A096 38                              sec
0A097 E9 04                           sbc #$04
0A099 85 6D                           sta Player_PageLoc
0A09B AD 25 07                        lda CurrentPageLoc        ;send current page back four pages
0A09E 38                              sec
0A09F E9 04                           sbc #$04
0A0A1 8D 25 07                        sta CurrentPageLoc
0A0A4 AD 1A 07                        lda ScreenLeft_PageLoc    ;subtract four from page location
0A0A7 38                              sec                       ;of screen's left border
0A0A8 E9 04                           sbc #$04
0A0AA 8D 1A 07                        sta ScreenLeft_PageLoc
0A0AD AD 1B 07                        lda ScreenRight_PageLoc   ;do the same for the page location
0A0B0 38                              sec                       ;of screen's right border
0A0B1 E9 04                           sbc #$04
0A0B3 8D 1B 07                        sta ScreenRight_PageLoc
0A0B6 AD 2A 07                        lda AreaObjectPageLoc     ;subtract four from page control
0A0B9 38                              sec                       ;for area objects
0A0BA E9 04                           sbc #$04
0A0BC 8D 2A 07                        sta AreaObjectPageLoc
0A0BF A9 00                           lda #$00                  ;initialize page select for both
0A0C1 8D 3B 07                        sta EnemyObjectPageSel    ;area and enemy objects
0A0C4 8D 2B 07                        sta AreaObjectPageSel
0A0C7 8D 39 07                        sta EnemyDataOffset       ;initialize enemy object data offset
0A0CA 8D 3A 07                        sta EnemyObjectPageLoc    ;and enemy object page control
0A0CD B9 00 7C                        lda AreaDataOfsLoopback,y ;adjust area object offset based on
0A0D0 8D 2C 07                        sta AreaDataOffset        ;which loop command we encountered
0A0D3 60                              rts
0A0D4                           
0A0D4                           ProcLoopCommand:
0A0D4 AD 45 07                            lda LoopCommand           ;check if loop command was found
0A0D7 F0 5E                               beq ChkEnemyFrenzy
0A0D9 AD 26 07                            lda CurrentColumnPos      ;check to see if we're still on the first page
0A0DC D0 59                               bne ChkEnemyFrenzy        ;if not, do not loop yet
0A0DE A0 0B                               ldy #$0b                  ;start at the end of each set of loop data
0A0E0 88                        FindLoop: dey
0A0E1 30 54                               bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
0A0E3 AD 5F 07                            lda WorldNumber           ;check to see if one of the world numbers
0A0E6 D9 73 A0                            cmp LoopCmdWorldNumber,y  ;matches our current world number
0A0E9 D0 F5                               bne FindLoop
0A0EB AD 25 07                            lda CurrentPageLoc        ;check to see if one of the page numbers
0A0EE D9 7E A0                            cmp LoopCmdPageNumber,y   ;matches the page we're currently on
0A0F1 D0 ED                               bne FindLoop
0A0F3 A5 CE                               lda Player_Y_Position     ;check to see if the player is at the correct position
0A0F5 D9 89 A0                            cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
0A0F8 D0 23                               bne WrongChk
0A0FA A5 1D                               lda Player_State          ;check to see if the player is
0A0FC C9 00                               cmp #$00                  ;on solid ground (i.e. not jumping or falling)
0A0FE D0 1D                               bne WrongChk              ;if not, player fails to pass loop, and loopback
0A100 AD 5F 07                            lda WorldNumber           ;are we in world 7? (check performed on correct
0A103 C9 06                               cmp #World7               ;vertical position and on solid ground)
0A105 D0 23                               bne InitMLp               ;if not, initialize flags used there, otherwise
0A107 EE D9 06                            inc MultiLoopCorrectCntr  ;increment counter for correct progression
0A10A EE DA 06                  IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
0A10D AD DA 06                            lda MultiLoopPassCntr     ;have we done all three parts?
0A110 C9 03                               cmp #$03
0A112 D0 1E                               bne InitLCmd              ;if not, skip this part
0A114 AD D9 06                            lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
0A117 C9 03                               cmp #$03
0A119 F0 0F                               beq InitMLp               ;if so, branch past unnecessary check here
0A11B D0 07                               bne DoLpBack              ;unconditional branch if previous branch fails
0A11D AD 5F 07                  WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
0A120 C9 06                               cmp #World7               ;incorrect vertical position or not on solid ground)
0A122 F0 E6                               beq IncMLoop
0A124 20 94 A0                  DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
0A127 20 79 B0                            jsr KillAllEnemies
0A12A A9 00                     InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
0A12C 8D DA 06                            sta MultiLoopPassCntr
0A12F 8D D9 06                            sta MultiLoopCorrectCntr
0A132 A9 00                     InitLCmd: lda #$00                  ;initialize loop command flag
0A134 8D 45 07                            sta LoopCommand
0A137                           
0A137                           ;--------------------------------
0A137                           
0A137                           ChkEnemyFrenzy:
0A137 AD CD 06                        lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
0A13A F0 10                           beq ProcessEnemyData  ;if not, skip this part
0A13C 95 16                           sta Enemy_ID,x        ;store as enemy object identifier here
0A13E A9 01                           lda #$01
0A140 95 0F                           sta Enemy_Flag,x      ;activate enemy object flag
0A142 A9 00                           lda #$00
0A144 95 1E                           sta Enemy_State,x     ;initialize state and frenzy queue
0A146 8D CD 06                        sta EnemyFrenzyQueue
0A149 4C 2E A2                        jmp InitEnemyObject   ;and then jump to deal with this enemy
0A14C                           
0A14C                           ;--------------------------------
0A14C                           ;$06 - used to hold page location of extended right boundary
0A14C                           ;$07 - used to hold high nybble of position of extended right boundary
0A14C                           
0A14C                           ProcessEnemyData:
0A14C AC 39 07                          ldy EnemyDataOffset      ;get offset of enemy object data
0A14F B1 E9                             lda (EnemyData),y        ;load first byte
0A151 C9 FF                             cmp #$ff                 ;check for EOD terminator
0A153 D0 03                             bne CheckEndofBuffer
0A155 4C 1E A2                          jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
0A158                           
0A158                           CheckEndofBuffer:
0A158 29 0F                             and #%00001111           ;check for special row $0e
0A15A C9 0E                             cmp #$0e
0A15C F0 0E                             beq CheckRightBounds     ;if found, branch, otherwise
0A15E E0 05                             cpx #$05                 ;check for end of buffer
0A160 90 0A                             bcc CheckRightBounds     ;if not at end of buffer, branch
0A162 C8                                iny
0A163 B1 E9                             lda (EnemyData),y        ;check for specific value here
0A165 29 3F                             and #%00111111           ;not sure what this was intended for, exactly
0A167 C9 2E                             cmp #$2e                 ;this part is quite possibly residual code
0A169 F0 01                             beq CheckRightBounds     ;but it has the effect of keeping enemies out of
0A16B 60                                rts                      ;the sixth slot
0A16C                           
0A16C                           CheckRightBounds:
0A16C AD 1D 07                          lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
0A16F 18                                clc
0A170 69 30                             adc #$30
0A172 29 F0                             and #%11110000           ;store high nybble
0A174 85 07                             sta $07
0A176 AD 1B 07                          lda ScreenRight_PageLoc  ;add carry to page location of right boundary
0A179 69 00                             adc #$00
0A17B 85 06                             sta $06                  ;store page location + carry
0A17D AC 39 07                          ldy EnemyDataOffset
0A180 C8                                iny
0A181 B1 E9                             lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
0A183 0A                                asl
0A184 90 0B                             bcc CheckPageCtrlRow
0A186 AD 3B 07                          lda EnemyObjectPageSel   ;if page select already set, do not set again
0A189 D0 06                             bne CheckPageCtrlRow
0A18B EE 3B 07                          inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select 
0A18E EE 3A 07                          inc EnemyObjectPageLoc   ;and increment page control
0A191                           
0A191                           CheckPageCtrlRow:
0A191 88                                dey
0A192 B1 E9                             lda (EnemyData),y        ;reread first byte
0A194 29 0F                             and #$0f
0A196 C9 0F                             cmp #$0f                 ;check for special row $0f
0A198 D0 19                             bne PositionEnemyObj     ;if not found, branch to position enemy object
0A19A AD 3B 07                          lda EnemyObjectPageSel   ;if page select set,
0A19D D0 14                             bne PositionEnemyObj     ;branch without reading second byte
0A19F C8                                iny
0A1A0 B1 E9                             lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
0A1A2 29 3F                             and #%00111111
0A1A4 8D 3A 07                          sta EnemyObjectPageLoc   ;store as page control for enemy object data
0A1A7 EE 39 07                          inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
0A1AA EE 39 07                          inc EnemyDataOffset
0A1AD EE 3B 07                          inc EnemyObjectPageSel   ;set page select for enemy object data and 
0A1B0 4C D4 A0                          jmp ProcLoopCommand      ;jump back to process loop commands again
0A1B3                           
0A1B3                           PositionEnemyObj:
0A1B3 AD 3A 07                          lda EnemyObjectPageLoc   ;store page control as page location
0A1B6 95 6E                             sta Enemy_PageLoc,x      ;for enemy object
0A1B8 B1 E9                             lda (EnemyData),y        ;get first byte of enemy object
0A1BA 29 F0                             and #%11110000
0A1BC 95 87                             sta Enemy_X_Position,x   ;store column position
0A1BE CD 1D 07                          cmp ScreenRight_X_Pos    ;check column position against right boundary
0A1C1 B5 6E                             lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
0A1C3 ED 1B 07                          sbc ScreenRight_PageLoc  ;from page location
0A1C6 B0 0B                             bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
0A1C8 B1 E9                             lda (EnemyData),y
0A1CA 29 0F                             and #%00001111           ;check for special row $0e
0A1CC C9 0E                             cmp #$0e                 ;if found, jump elsewhere
0A1CE F0 69                             beq ParseRow0e
0A1D0 4C 58 A2                          jmp CheckThreeBytes      ;if not found, unconditional jump
0A1D3                           
0A1D3                           CheckRightExtBounds:
0A1D3 A5 07                             lda $07                  ;check right boundary + 48 against
0A1D5 D5 87                             cmp Enemy_X_Position,x   ;column position without subtracting,
0A1D7 A5 06                             lda $06                  ;then subtract borrow from page control temp
0A1D9 F5 6E                             sbc Enemy_PageLoc,x      ;plus carry
0A1DB 90 41                             bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
0A1DD A9 01                             lda #$01                 ;store value in vertical high byte
0A1DF 95 B6                             sta Enemy_Y_HighPos,x
0A1E1 B1 E9                             lda (EnemyData),y        ;get first byte again
0A1E3 0A                                asl                      ;multiply by four to get the vertical
0A1E4 0A                                asl                      ;coordinate
0A1E5 0A                                asl
0A1E6 0A                                asl
0A1E7 95 CF                             sta Enemy_Y_Position,x
0A1E9 C9 E0                             cmp #$e0                 ;do one last check for special row $0e
0A1EB F0 4C                             beq ParseRow0e           ;(necessary if branched to $c1cb)
0A1ED C8                                iny
0A1EE B1 E9                             lda (EnemyData),y        ;get second byte of object
0A1F0 29 40                             and #%01000000           ;check to see if hard mode bit is set
0A1F2 F0 05                             beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
0A1F4 AD CC 06                          lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
0A1F7 F0 6D                             beq Inc2B                ;is on, and if not, branch to skip this object completely
0A1F9                           
0A1F9                           CheckForEnemyGroup:
0A1F9 B1 E9                             lda (EnemyData),y      ;get second byte and mask out 2 MSB
0A1FB 29 3F                             and #%00111111
0A1FD C9 37                             cmp #$37               ;check for value below $37
0A1FF 90 04                             bcc BuzzyBeetleMutate
0A201 C9 3F                             cmp #$3f               ;if $37 or greater, check for value
0A203 90 31                             bcc DoGroup            ;below $3f, branch if below $3f
0A205                           
0A205                           BuzzyBeetleMutate:
0A205 C9 06                             cmp #Goomba          ;if below $37, check for goomba
0A207 D0 07                             bne StrID            ;value ($3f or more always fails)
0A209 AC 6A 07                          ldy PrimaryHardMode  ;check if primary hard mode flag is set
0A20C F0 02                             beq StrID            ;and if so, change goomba to buzzy beetle
0A20E A9 02                             lda #BuzzyBeetle
0A210 95 16                     StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
0A212 A9 01                             lda #$01
0A214 95 0F                             sta Enemy_Flag,x     ;set flag for enemy in buffer
0A216 20 2E A2                          jsr InitEnemyObject
0A219 B5 0F                             lda Enemy_Flag,x     ;check to see if flag is set
0A21B D0 49                             bne Inc2B            ;if not, leave, otherwise branch
0A21D 60                                rts
0A21E                           
0A21E                           CheckFrenzyBuffer:
0A21E AD CB 06                          lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
0A221 D0 09                             bne StrFre               ;then branch ahead to store in enemy object buffer
0A223 AD 98 03                          lda VineFlagOffset       ;otherwise check vine flag offset
0A226 C9 01                             cmp #$01
0A228 D0 0B                             bne ExEPar               ;if other value <> 1, leave
0A22A A9 2F                             lda #VineObject          ;otherwise put vine in enemy identifier
0A22C 95 16                     StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
0A22E                           
0A22E                           InitEnemyObject:
0A22E A9 00                             lda #$00                 ;initialize enemy state
0A230 95 1E                             sta Enemy_State,x
0A232 20 74 A2                          jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
0A235 60                        ExEPar: rts                      ;then leave
0A236                           
0A236                           DoGroup:
0A236 4C 23 A7                          jmp HandleGroupEnemies   ;handle enemy group objects
0A239                           
0A239                           ParseRow0e:
0A239 C8                                iny                      ;increment Y to load third byte of object
0A23A C8                                iny
0A23B B1 E9                             lda (EnemyData),y
0A23D 4A                                lsr                      ;move 3 MSB to the bottom, effectively
0A23E 4A                                lsr                      ;making %xxx00000 into %00000xxx
0A23F 4A                                lsr
0A240 4A                                lsr
0A241 4A                                lsr
0A242 CD 5F 07                          cmp WorldNumber          ;is it the same world number as we're on?
0A245 D0 0E                             bne NotUse               ;if not, do not use (this allows multiple uses
0A247 88                                dey                      ;of the same area, like the underground bonus areas)
0A248 B1 E9                             lda (EnemyData),y        ;otherwise, get second byte and use as offset
0A24A 8D 50 07                          sta AreaPointer          ;to addresses for level and enemy object data
0A24D C8                                iny
0A24E B1 E9                             lda (EnemyData),y        ;get third byte again, and this time mask out
0A250 29 1F                             and #%00011111           ;the 3 MSB from before, save as page number to be
0A252 8D 51 07                          sta EntrancePage         ;used upon entry to area, if area is entered
0A255 4C 63 A2                  NotUse: jmp Inc3B
0A258                           
0A258                           CheckThreeBytes:
0A258 AC 39 07                          ldy EnemyDataOffset      ;load current offset for enemy object data
0A25B B1 E9                             lda (EnemyData),y        ;get first byte
0A25D 29 0F                             and #%00001111           ;check for special row $0e
0A25F C9 0E                             cmp #$0e
0A261 D0 03                             bne Inc2B
0A263 EE 39 07                  Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
0A266 EE 39 07                  Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
0A269 EE 39 07                          inc EnemyDataOffset
0A26C A9 00                             lda #$00                 ;init page select for enemy objects
0A26E 8D 3B 07                          sta EnemyObjectPageSel
0A271 A6 08                             ldx ObjectOffset         ;reload current offset in enemy buffers
0A273 60                                rts                      ;and leave
0A274                           
0A274                           CheckpointEnemyID:
0A274 B5 16                             lda Enemy_ID,x
0A276 C9 15                             cmp #$15                     ;check enemy object identifier for $15 or greater
0A278 B0 0D                             bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
0A27A A8                                tay                          ;save identifier in Y register for now
0A27B B5 CF                             lda Enemy_Y_Position,x
0A27D 69 08                             adc #$08                     ;add eight pixels to what will eventually be the
0A27F 95 CF                             sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
0A281 A9 01                             lda #$01
0A283 9D D8 03                          sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
0A286 98                                tya                          ;get identifier back and use as offset for jump engine
0A287                           
0A287                           InitEnemyRoutines:
0A287 20 0A 6E                          jsr JumpEngine
0A28A                                 
0A28A                           ;jump engine table for newly loaded enemy objects
0A28A                           
0A28A 16 A3                           .dw InitNormalEnemy  ;for objects $00-$0f
0A28C 16 A3                           .dw InitNormalEnemy
0A28E 16 A3                           .dw InitNormalEnemy
0A290 26 A3                           .dw InitRedKoopa
0A292 F8 A2                           .dw NoInitCode
0A294 30 A3                           .dw InitHammerBro
0A296 F9 A2                           .dw InitGoomba
0A298 4A A3                           .dw InitBloober
0A29A 73 A3                           .dw InitBulletBill
0A29C F8 A2                           .dw NoInitCode
0A29E 7D A3                           .dw InitCheepCheep
0A2A0 7D A3                           .dw InitCheepCheep
0A2A2 FF A2                           .dw InitPodoboo
0A2A4 8F A7                           .dw InitPiranhaPlant
0A2A6 D9 A7                           .dw InitJumpGPTroopa
0A2A8 52 A3                           .dw InitRedPTroopa
0A2AA                           
0A2AA 45 A3                           .dw InitHorizFlySwimEnemy  ;for objects $10-$1f
0A2AC 8D A3                           .dw InitLakitu
0A2AE A8 A7                           .dw InitEnemyFrenzy
0A2B0 F8 A2                           .dw NoInitCode
0A2B2 A8 A7                           .dw InitEnemyFrenzy
0A2B4 A8 A7                           .dw InitEnemyFrenzy
0A2B6 A8 A7                           .dw InitEnemyFrenzy
0A2B8 A8 A7                           .dw InitEnemyFrenzy
0A2BA C0 A7                           .dw EndFrenzy
0A2BC F8 A2                           .dw NoInitCode
0A2BE F8 A2                           .dw NoInitCode
0A2C0 64 A4                           .dw InitShortFirebar
0A2C2 64 A4                           .dw InitShortFirebar
0A2C4 64 A4                           .dw InitShortFirebar
0A2C6 64 A4                           .dw InitShortFirebar
0A2C8 61 A4                           .dw InitLongFirebar
0A2CA                           
0A2CA F8 A2                           .dw NoInitCode ;for objects $20-$2f
0A2CC F8 A2                           .dw NoInitCode
0A2CE F8 A2                           .dw NoInitCode
0A2D0 F8 A2                           .dw NoInitCode
0A2D2 E7 A7                           .dw InitBalPlatform
0A2D4 1A A8                           .dw InitVertPlatform
0A2D6 47 A8                           .dw LargeLiftUp
0A2D8 4D A8                           .dw LargeLiftDown
0A2DA 13 A8                           .dw InitHoriPlatform
0A2DC 0B A8                           .dw InitDropPlatform
0A2DE 13 A8                           .dw InitHoriPlatform
0A2E0 53 A8                           .dw PlatLiftUp
0A2E2 5F A8                           .dw PlatLiftDown
0A2E4 51 A5                           .dw InitBowser
0A2E6 68 9C                           .dw PwrUpJmp   ;possibly dummy value
0A2E8 26 99                           .dw Setup_Vine
0A2EA                           
0A2EA F8 A2                           .dw NoInitCode ;for objects $30-$36
0A2EC F8 A2                           .dw NoInitCode
0A2EE F8 A2                           .dw NoInitCode
0A2F0 F8 A2                           .dw NoInitCode
0A2F2 F8 A2                           .dw NoInitCode
0A2F4 0F A3                           .dw InitRetainerObj
0A2F6 89 A8                           .dw EndOfEnemyInitCode
0A2F8                           
0A2F8                           ;-------------------------------------------------------------------------------------
0A2F8                           
0A2F8                           NoInitCode:
0A2F8 60                              rts               ;this executed when enemy object has no init code
0A2F9                           
0A2F9                           ;--------------------------------
0A2F9                           
0A2F9                           InitGoomba:
0A2F9 20 16 A3                        jsr InitNormalEnemy  ;set appropriate horizontal speed
0A2FC 4C 4E A3                        jmp SmallBBox        ;set $09 as bounding box control, set other values
0A2FF                           
0A2FF                           ;--------------------------------
0A2FF                           
0A2FF                           InitPodoboo:
0A2FF A9 02                           lda #$02                  ;set enemy position to below
0A301 95 B6                           sta Enemy_Y_HighPos,x     ;the bottom of the screen
0A303 95 CF                           sta Enemy_Y_Position,x
0A305 4A                              lsr
0A306 9D 96 07                        sta EnemyIntervalTimer,x  ;set timer for enemy
0A309 4A                              lsr
0A30A 95 1E                           sta Enemy_State,x         ;initialize enemy state, then jump to use
0A30C 4C 4E A3                        jmp SmallBBox             ;$09 as bounding box size and set other things
0A30F                           
0A30F                           ;--------------------------------
0A30F                           
0A30F                           InitRetainerObj:
0A30F A9 B8                           lda #$b8                ;set fixed vertical position for
0A311 95 CF                           sta Enemy_Y_Position,x  ;princess/mushroom retainer object
0A313 60                              rts
0A314                           
0A314                           ;--------------------------------
0A314                           
0A314                           NormalXSpdData:
0A314 F8 F4                           .db $f8, $f4
0A316                           
0A316                           InitNormalEnemy:
0A316 A0 01                              ldy #$01              ;load offset of 1 by default
0A318 AD 6A 07                           lda PrimaryHardMode   ;check for primary hard mode flag set
0A31B D0 01                              bne GetESpd
0A31D 88                                 dey                   ;if not set, decrement offset
0A31E B9 14 A3                  GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
0A321 95 58                     SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
0A323 4C 62 A3                           jmp TallBBox          ;branch to set bounding box control and other data
0A326                           
0A326                           ;--------------------------------
0A326                           
0A326                           InitRedKoopa:
0A326 20 16 A3                        jsr InitNormalEnemy   ;load appropriate horizontal speed
0A329 A9 01                           lda #$01              ;set enemy state for red koopa troopa $03
0A32B 95 1E                           sta Enemy_State,x
0A32D 60                              rts
0A32E                           
0A32E                           ;--------------------------------
0A32E                           
0A32E                           HBroWalkingTimerData:
0A32E 80 50                           .db $80, $50
0A330                           
0A330                           InitHammerBro:
0A330 A9 00                           lda #$00                    ;init horizontal speed and timer used by hammer bro
0A332 9D A2 03                        sta HammerThrowingTimer,x   ;apparently to time hammer throwing
0A335 95 58                           sta Enemy_X_Speed,x
0A337 AC CC 06                        ldy SecondaryHardMode       ;get secondary hard mode flag
0A33A B9 2E A3                        lda HBroWalkingTimerData,y
0A33D 9D 96 07                        sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
0A340 A9 0B                           lda #$0b                    ;set specific value for bounding box size control
0A342 4C 64 A3                        jmp SetBBox
0A345                           
0A345                           ;--------------------------------
0A345                           
0A345                           InitHorizFlySwimEnemy:
0A345 A9 00                           lda #$00        ;initialize horizontal speed
0A347 4C 21 A3                        jmp SetESpd
0A34A                           
0A34A                           ;--------------------------------
0A34A                           
0A34A                           InitBloober:
0A34A A9 00                                lda #$00               ;initialize horizontal speed
0A34C 95 58                                sta BlooperMoveSpeed,x
0A34E A9 09                     SmallBBox: lda #$09               ;set specific bounding box size control
0A350 D0 12                                bne SetBBox            ;unconditional branch
0A352                           
0A352                           ;--------------------------------
0A352                           
0A352                           InitRedPTroopa:
0A352 A0 30                               ldy #$30                    ;load central position adder for 48 pixels down
0A354 B5 CF                               lda Enemy_Y_Position,x      ;set vertical coordinate into location to
0A356 9D 01 04                            sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
0A359 10 02                               bpl GetCent                 ;if vertical coordinate < $80
0A35B A0 E0                               ldy #$e0                    ;if => $80, load position adder for 32 pixels up
0A35D 98                        GetCent:  tya                         ;send central position adder to A
0A35E 75 CF                               adc Enemy_Y_Position,x      ;add to current vertical coordinate
0A360 95 58                               sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
0A362 A9 03                     TallBBox: lda #$03                    ;set specific bounding box size control
0A364 9D 9A 04                  SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
0A367 A9 02                               lda #$02                    ;set moving direction for left
0A369 95 46                               sta Enemy_MovingDir,x
0A36B A9 00                     InitVStf: lda #$00                    ;initialize vertical speed
0A36D 95 A0                               sta Enemy_Y_Speed,x         ;and movement force
0A36F 9D 34 04                            sta Enemy_Y_MoveForce,x
0A372 60                                  rts
0A373                           
0A373                           ;--------------------------------
0A373                           
0A373                           InitBulletBill:
0A373 A9 02                           lda #$02                  ;set moving direction for left
0A375 95 46                           sta Enemy_MovingDir,x
0A377 A9 09                           lda #$09                  ;set bounding box control for $09
0A379 9D 9A 04                        sta Enemy_BoundBoxCtrl,x
0A37C 60                              rts
0A37D                           
0A37D                           ;--------------------------------
0A37D                           
0A37D                           InitCheepCheep:
0A37D 20 4E A3                        jsr SmallBBox              ;set vertical bounding box, speed, init others
0A380 BD A7 07                        lda PseudoRandomBitReg,x   ;check one portion of LSFR
0A383 29 10                           and #%00010000             ;get d4 from it
0A385 95 58                           sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
0A387 B5 CF                           lda Enemy_Y_Position,x
0A389 9D 34 04                        sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
0A38C 60                              rts
0A38D                           
0A38D                           ;--------------------------------
0A38D                           
0A38D                           InitLakitu:
0A38D AD CB 06                        lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
0A390 D0 0B                           bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
0A392                           
0A392                           SetupLakitu:
0A392 A9 00                           lda #$00                   ;erase counter for lakitu's reappearance
0A394 8D D1 06                        sta LakituReappearTimer
0A397 20 45 A3                        jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
0A39A 4C E1 A7                        jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
0A39D                           
0A39D                           KillLakitu:
0A39D 4C A0 A9                        jmp EraseEnemyObject
0A3A0                           
0A3A0                           ;--------------------------------
0A3A0                           ;$01-$03 - used to hold pseudorandom difference adjusters
0A3A0                           
0A3A0                           PRDiffAdjustData:
0A3A0 26 2C 32 38                     .db $26, $2c, $32, $38
0A3A4 20 22 24 26                     .db $20, $22, $24, $26
0A3A8 13 14 15 16                     .db $13, $14, $15, $16
0A3AC                           
0A3AC                           LakituAndSpinyHandler:
0A3AC AD 8F 07                            lda FrenzyEnemyTimer    ;if timer here not expired, leave
0A3AF D0 3C                               bne ExLSHand
0A3B1 E0 05                               cpx #$05                ;if we are on the special use slot, leave
0A3B3 B0 38                               bcs ExLSHand
0A3B5 A9 80                               lda #$80                ;set timer
0A3B7 8D 8F 07                            sta FrenzyEnemyTimer
0A3BA A0 04                               ldy #$04                ;start with the last enemy slot
0A3BC B9 16 00                  ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
0A3BF C9 11                               cmp #Lakitu             ;if lakitu is on one of them
0A3C1 F0 2B                               beq CreateSpiny         ;if so, branch out of this loop
0A3C3 88                                  dey                     ;otherwise check another slot
0A3C4 10 F6                               bpl ChkLak              ;loop until all slots are checked
0A3C6 EE D1 06                            inc LakituReappearTimer ;increment reappearance timer
0A3C9 AD D1 06                            lda LakituReappearTimer
0A3CC C9 07                               cmp #$07                ;check to see if we're up to a certain value yet
0A3CE 90 1D                               bcc ExLSHand            ;if not, leave
0A3D0 A2 04                               ldx #$04                ;start with the last enemy slot again
0A3D2 B5 0F                     ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
0A3D4 F0 05                               beq CreateL             ;branch out of loop if found
0A3D6 CA                                  dex                     ;otherwise check next slot
0A3D7 10 F9                               bpl ChkNoEn             ;branch until all slots are checked
0A3D9 30 10                               bmi RetEOfs             ;if no empty slots were found, branch to leave
0A3DB A9 00                     CreateL:  lda #$00                ;initialize enemy state
0A3DD 95 1E                               sta Enemy_State,x
0A3DF A9 11                               lda #Lakitu             ;create lakitu enemy object
0A3E1 95 16                               sta Enemy_ID,x
0A3E3 20 92 A3                            jsr SetupLakitu         ;do a sub to set up lakitu
0A3E6 A9 20                               lda #$20
0A3E8 20 E0 A5                            jsr PutAtRightExtent    ;finish setting up lakitu
0A3EB A6 08                     RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
0A3ED 60                        ExLSHand: rts
0A3EE                           
0A3EE                           ;--------------------------------
0A3EE                           
0A3EE                           CreateSpiny:
0A3EE A5 CE                               lda Player_Y_Position      ;if player above a certain point, branch to leave
0A3F0 C9 2C                               cmp #$2c
0A3F2 90 F9                               bcc ExLSHand
0A3F4 B9 1E 00                            lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
0A3F7 D0 F4                               bne ExLSHand
0A3F9 B9 6E 00                            lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
0A3FC 95 6E                               sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
0A3FE B9 87 00                            lda Enemy_X_Position,y
0A401 95 87                               sta Enemy_X_Position,x
0A403 A9 01                               lda #$01                   ;put spiny within vertical screen unit
0A405 95 B6                               sta Enemy_Y_HighPos,x
0A407 B9 CF 00                            lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
0A40A 38                                  sec
0A40B E9 08                               sbc #$08
0A40D 95 CF                               sta Enemy_Y_Position,x
0A40F BD A7 07                            lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
0A412 29 03                               and #%00000011
0A414 A8                                  tay
0A415 A2 02                               ldx #$02
0A417 B9 A0 A3                  DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
0A41A 95 01                               sta $01,x                  ;to $01-$03
0A41C C8                                  iny
0A41D C8                                  iny                        ;increment Y four bytes for each value
0A41E C8                                  iny
0A41F C8                                  iny
0A420 CA                                  dex                        ;decrement X for each one
0A421 10 F4                               bpl DifLoop                ;loop until all three are written
0A423 A6 08                               ldx ObjectOffset           ;get enemy object buffer offset
0A425 20 74 AF                            jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
0A428 A4 57                               ldy Player_X_Speed         ;check player's horizontal speed
0A42A C0 08                               cpy #$08
0A42C B0 0E                               bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
0A42E A8                                  tay                        ;otherwise save value in A to Y for now
0A42F BD A8 07                            lda PseudoRandomBitReg+1,x
0A432 29 03                               and #%00000011             ;get one of the LSFR parts and save the 2 LSB
0A434 F0 05                               beq UsePosv                ;branch if neither bits are set
0A436 98                                  tya
0A437 49 FF                               eor #%11111111             ;otherwise get two's compliment of Y
0A439 A8                                  tay
0A43A C8                                  iny
0A43B 98                        UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
0A43C 20 4E A3                  SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
0A43F A0 02                               ldy #$02
0A441 95 58                               sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
0A443 C9 00                               cmp #$00                   ;of A were lost...branch here will never be taken for
0A445 30 01                               bmi SpinyRte               ;the same reason
0A447 88                                  dey
0A448 94 46                     SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
0A44A A9 FD                               lda #$fd
0A44C 95 A0                               sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
0A44E A9 01                               lda #$01
0A450 95 0F                               sta Enemy_Flag,x           ;enable enemy object by setting flag
0A452 A9 05                               lda #$05
0A454 95 1E                               sta Enemy_State,x          ;put spiny in egg state and leave
0A456 60                        ChpChpEx: rts
0A457                           
0A457                           ;--------------------------------
0A457                           
0A457                           FirebarSpinSpdData:
0A457 28 38 28 38 28                  .db $28, $38, $28, $38, $28
0A45C                           
0A45C                           FirebarSpinDirData:
0A45C 00 00 10 10 00                  .db $00, $00, $10, $10, $00
0A461                           
0A461                           InitLongFirebar:
0A461 20 7D A5                        jsr DuplicateEnemyObj       ;create enemy object for long firebar
0A464                           
0A464                           InitShortFirebar:
0A464 A9 00                           lda #$00                    ;initialize low byte of spin state
0A466 95 58                           sta FirebarSpinState_Low,x
0A468 B5 16                           lda Enemy_ID,x              ;subtract $1b from enemy identifier
0A46A 38                              sec                         ;to get proper offset for firebar data
0A46B E9 1B                           sbc #$1b
0A46D A8                              tay
0A46E B9 57 A4                        lda FirebarSpinSpdData,y    ;get spinning speed of firebar
0A471 9D 88 03                        sta FirebarSpinSpeed,x
0A474 B9 5C A4                        lda FirebarSpinDirData,y    ;get spinning direction of firebar
0A477 95 34                           sta FirebarSpinDirection,x
0A479 B5 CF                           lda Enemy_Y_Position,x
0A47B 18                              clc                         ;add four pixels to vertical coordinate
0A47C 69 04                           adc #$04
0A47E 95 CF                           sta Enemy_Y_Position,x
0A480 B5 87                           lda Enemy_X_Position,x
0A482 18                              clc                         ;add four pixels to horizontal coordinate
0A483 69 04                           adc #$04
0A485 95 87                           sta Enemy_X_Position,x
0A487 B5 6E                           lda Enemy_PageLoc,x
0A489 69 00                           adc #$00                    ;add carry to page location
0A48B 95 6E                           sta Enemy_PageLoc,x
0A48D 4C E1 A7                        jmp TallBBox2               ;set bounding box control (not used) and leave
0A490                           
0A490                           ;--------------------------------
0A490                           ;$00-$01 - used to hold pseudorandom bits
0A490                           
0A490                           FlyCCXPositionData:
0A490 80 30 40 80                     .db $80, $30, $40, $80
0A494 30 50 50 70                     .db $30, $50, $50, $70
0A498 20 40 80 A0                     .db $20, $40, $80, $a0
0A49C 70 40 90 68                     .db $70, $40, $90, $68
0A4A0                           
0A4A0                           FlyCCXSpeedData:
0A4A0 0E 05 06 0E                     .db $0e, $05, $06, $0e
0A4A4 1C 20 10 0C                     .db $1c, $20, $10, $0c
0A4A8 1E 22 18 14                     .db $1e, $22, $18, $14
0A4AC                           
0A4AC                           FlyCCTimerData:
0A4AC 10 60 20 48                     .db $10, $60, $20, $48
0A4B0                           
0A4B0                           InitFlyingCheepCheep:
0A4B0 AD 8F 07                           lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
0A4B3 D0 A1                              bne ChpChpEx
0A4B5 20 4E A3                           jsr SmallBBox              ;jump to set bounding box size $09 and init other values
0A4B8 BD A8 07                           lda PseudoRandomBitReg+1,x
0A4BB 29 03                              and #%00000011             ;set pseudorandom offset here
0A4BD A8                                 tay
0A4BE B9 AC A4                           lda FlyCCTimerData,y       ;load timer with pseudorandom offset
0A4C1 8D 8F 07                           sta FrenzyEnemyTimer
0A4C4 A0 03                              ldy #$03                   ;load Y with default value
0A4C6 AD CC 06                           lda SecondaryHardMode
0A4C9 F0 01                              beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
0A4CB C8                                 iny                        ;otherwise, increment Y to allow as many as four onscreen
0A4CC 84 00                     MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
0A4CE E4 00                              cpx $00                    ;compare enemy object buffer offset with Y
0A4D0 B0 84                              bcs ChpChpEx               ;if X => Y, branch to leave
0A4D2 BD A7 07                           lda PseudoRandomBitReg,x
0A4D5 29 03                              and #%00000011             ;get last two bits of LSFR, first part
0A4D7 85 00                              sta $00                    ;and store in two places
0A4D9 85 01                              sta $01
0A4DB A9 FB                              lda #$fb                   ;set vertical speed for cheep-cheep
0A4DD 95 A0                              sta Enemy_Y_Speed,x
0A4DF A9 00                              lda #$00                   ;load default value
0A4E1 A4 57                              ldy Player_X_Speed         ;check player's horizontal speed
0A4E3 F0 07                              beq GSeed                  ;if player not moving left or right, skip this part
0A4E5 A9 04                              lda #$04
0A4E7 C0 19                              cpy #$19                   ;if moving to the right but not very quickly,
0A4E9 90 01                              bcc GSeed                  ;do not change A
0A4EB 0A                                 asl                        ;otherwise, multiply A by 2
0A4EC 48                        GSeed:   pha                        ;save to stack
0A4ED 18                                 clc
0A4EE 65 00                              adc $00                    ;add to last two bits of LSFR we saved earlier
0A4F0 85 00                              sta $00                    ;save it there
0A4F2 BD A8 07                           lda PseudoRandomBitReg+1,x
0A4F5 29 03                              and #%00000011             ;if neither of the last two bits of second LSFR set,
0A4F7 F0 07                              beq RSeed                  ;skip this part and save contents of $00
0A4F9 BD A9 07                           lda PseudoRandomBitReg+2,x
0A4FC 29 0F                              and #%00001111             ;otherwise overwrite with lower nybble of
0A4FE 85 00                              sta $00                    ;third LSFR part
0A500 68                        RSeed:   pla                        ;get value from stack we saved earlier
0A501 18                                 clc
0A502 65 01                              adc $01                    ;add to last two bits of LSFR we saved in other place
0A504 A8                                 tay                        ;use as pseudorandom offset here
0A505 B9 A0 A4                           lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
0A508 95 58                              sta Enemy_X_Speed,x
0A50A A9 01                              lda #$01                   ;set to move towards the right
0A50C 95 46                              sta Enemy_MovingDir,x
0A50E A5 57                              lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
0A510 D0 12                              bne D2XPos1
0A512 A4 00                              ldy $00                    ;get first LSFR or third LSFR lower nybble
0A514 98                                 tya                        ;and check for d1 set
0A515 29 02                              and #%00000010
0A517 F0 0B                              beq D2XPos1                ;if d1 not set, branch
0A519 B5 58                              lda Enemy_X_Speed,x
0A51B 49 FF                              eor #$ff                   ;if d1 set, change horizontal speed
0A51D 18                                 clc                        ;into two's compliment, thus moving in the opposite
0A51E 69 01                              adc #$01                   ;direction
0A520 95 58                              sta Enemy_X_Speed,x
0A522 F6 46                              inc Enemy_MovingDir,x      ;increment to move towards the left
0A524 98                        D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
0A525 29 02                              and #%00000010
0A527 F0 0F                              beq D2XPos2                ;check for d1 set again, branch again if not set
0A529 A5 86                              lda Player_X_Position      ;get player's horizontal position
0A52B 18                                 clc
0A52C 79 90 A4                           adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
0A52F 95 87                              sta Enemy_X_Position,x     ;and save as enemy's horizontal position
0A531 A5 6D                              lda Player_PageLoc         ;get player's page location
0A533 69 00                              adc #$00                   ;add carry and jump past this part
0A535 4C 44 A5                           jmp FinCCSt
0A538 A5 86                     D2XPos2: lda Player_X_Position      ;get player's horizontal position
0A53A 38                                 sec
0A53B F9 90 A4                           sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
0A53E 95 87                              sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
0A540 A5 6D                              lda Player_PageLoc         ;get player's page location
0A542 E9 00                              sbc #$00                   ;subtract borrow
0A544 95 6E                     FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
0A546 A9 01                              lda #$01
0A548 95 0F                              sta Enemy_Flag,x           ;set enemy's buffer flag
0A54A 95 B6                              sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
0A54C A9 F8                              lda #$f8
0A54E 95 CF                              sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
0A550 60                                 rts
0A551                           
0A551                           ;--------------------------------
0A551                           
0A551                           InitBowser:
0A551 20 7D A5                        jsr DuplicateEnemyObj     ;jump to create another bowser object
0A554 8E 68 03                        stx BowserFront_Offset    ;save offset of first here
0A557 A9 00                           lda #$00
0A559 8D 63 03                        sta BowserBodyControls    ;initialize bowser's body controls
0A55C 8D 69 03                        sta BridgeCollapseOffset  ;and bridge collapse offset
0A55F B5 87                           lda Enemy_X_Position,x
0A561 8D 66 03                        sta BowserOrigXPos        ;store original horizontal position here
0A564 A9 DF                           lda #$df
0A566 8D 90 07                        sta BowserFireBreathTimer ;store something here
0A569 95 46                           sta Enemy_MovingDir,x     ;and in moving direction
0A56B A9 20                           lda #$20
0A56D 8D 64 03                        sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
0A570 9D 8A 07                        sta EnemyFrameTimer,x
0A573 A9 05                           lda #$05
0A575 8D 83 04                        sta BowserHitPoints       ;give bowser 5 hit points
0A578 4A                              lsr
0A579 8D 65 03                        sta BowserMovementSpeed   ;set default movement speed here
0A57C 60                              rts
0A57D                           
0A57D                           ;--------------------------------
0A57D                           
0A57D                           DuplicateEnemyObj:
0A57D A0 FF                             ldy #$ff                ;start at beginning of enemy slots
0A57F C8                        FSLoop: iny                     ;increment one slot
0A580 B9 0F 00                          lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
0A583 D0 FA                             bne FSLoop              ;if set, branch and keep checking
0A585 8C CF 06                          sty DuplicateObj_Offset ;otherwise set offset here
0A588 8A                                txa                     ;transfer original enemy buffer offset
0A589 09 80                             ora #%10000000          ;store with d7 set as flag in new enemy
0A58B 99 0F 00                          sta Enemy_Flag,y        ;slot as well as enemy offset
0A58E B5 6E                             lda Enemy_PageLoc,x
0A590 99 6E 00                          sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
0A593 B5 87                             lda Enemy_X_Position,x  ;from original enemy to new enemy
0A595 99 87 00                          sta Enemy_X_Position,y
0A598 A9 01                             lda #$01
0A59A 95 0F                             sta Enemy_Flag,x        ;set flag as normal for original enemy
0A59C 99 B6 00                          sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
0A59F B5 CF                             lda Enemy_Y_Position,x
0A5A1 99 CF 00                          sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
0A5A4 60                        FlmEx:  rts                     ;and then leave
0A5A5                           
0A5A5                           ;--------------------------------
0A5A5                           
0A5A5                           FlameYPosData:
0A5A5 90 80 70 90                     .db $90, $80, $70, $90
0A5A9                           
0A5A9                           FlameYMFAdderData:
0A5A9 FF 01                           .db $ff, $01
0A5AB                           
0A5AB                           InitBowserFlame:
0A5AB AD 8F 07                          lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
0A5AE D0 F4                             bne FlmEx
0A5B0 9D 34 04                          sta Enemy_Y_MoveForce,x     ;reset something here
0A5B3 A5 FD                             lda NoiseSoundQueue
0A5B5 09 02                             ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
0A5B7 85 FD                             sta NoiseSoundQueue
0A5B9 AC 68 03                          ldy BowserFront_Offset      ;get bowser's buffer offset
0A5BC B9 16 00                          lda Enemy_ID,y              ;check for bowser
0A5BF C9 2D                             cmp #Bowser
0A5C1 F0 31                             beq SpawnFromMouth          ;branch if found
0A5C3 20 E1 B1                          jsr SetFlameTimer           ;get timer data based on flame counter
0A5C6 18                                clc
0A5C7 69 20                             adc #$20                    ;add 32 frames by default
0A5C9 AC CC 06                          ldy SecondaryHardMode
0A5CC F0 03                             beq SetFrT                  ;if secondary mode flag not set, use as timer setting
0A5CE 38                                sec
0A5CF E9 10                             sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
0A5D1 8D 8F 07                  SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
0A5D4 BD A7 07                          lda PseudoRandomBitReg,x
0A5D7 29 03                             and #%00000011              ;get 2 LSB from first part of LSFR
0A5D9 9D 17 04                          sta BowserFlamePRandomOfs,x ;set here
0A5DC A8                                tay                         ;use as offset
0A5DD B9 A5 A5                          lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
0A5E0                           
0A5E0                           PutAtRightExtent:
0A5E0 95 CF                           sta Enemy_Y_Position,x    ;set vertical position
0A5E2 AD 1D 07                        lda ScreenRight_X_Pos
0A5E5 18                              clc
0A5E6 69 20                           adc #$20                  ;place enemy 32 pixels beyond right side of screen
0A5E8 95 87                           sta Enemy_X_Position,x
0A5EA AD 1B 07                        lda ScreenRight_PageLoc
0A5ED 69 00                           adc #$00                  ;add carry
0A5EF 95 6E                           sta Enemy_PageLoc,x
0A5F1 4C 27 A6                        jmp FinishFlame           ;skip this part to finish setting values
0A5F4                           
0A5F4                           SpawnFromMouth:
0A5F4 B9 87 00                         lda Enemy_X_Position,y    ;get bowser's horizontal position
0A5F7 38                               sec
0A5F8 E9 0E                            sbc #$0e                  ;subtract 14 pixels
0A5FA 95 87                            sta Enemy_X_Position,x    ;save as flame's horizontal position
0A5FC B9 6E 00                         lda Enemy_PageLoc,y
0A5FF 95 6E                            sta Enemy_PageLoc,x       ;copy page location from bowser to flame
0A601 B9 CF 00                         lda Enemy_Y_Position,y
0A604 18                               clc                       ;add 8 pixels to bowser's vertical position
0A605 69 08                            adc #$08
0A607 95 CF                            sta Enemy_Y_Position,x    ;save as flame's vertical position
0A609 BD A7 07                         lda PseudoRandomBitReg,x
0A60C 29 03                            and #%00000011            ;get 2 LSB from first part of LSFR
0A60E 9D 17 04                         sta Enemy_YMF_Dummy,x     ;save here
0A611 A8                               tay                       ;use as offset
0A612 B9 A5 A5                         lda FlameYPosData,y       ;get value here using bits as offset
0A615 A0 00                            ldy #$00                  ;load default offset
0A617 D5 CF                            cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
0A619 90 01                            bcc SetMF                 ;if less, do not increment offset
0A61B C8                               iny                       ;otherwise increment now
0A61C B9 A9 A5                  SetMF: lda FlameYMFAdderData,y   ;get value here and save
0A61F 9D 34 04                         sta Enemy_Y_MoveForce,x   ;to vertical movement force
0A622 A9 00                            lda #$00
0A624 8D CB 06                         sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
0A627                           
0A627                           FinishFlame:
0A627 A9 08                           lda #$08                 ;set $08 for bounding box control
0A629 9D 9A 04                        sta Enemy_BoundBoxCtrl,x
0A62C A9 01                           lda #$01                 ;set high byte of vertical and
0A62E 95 B6                           sta Enemy_Y_HighPos,x    ;enemy buffer flag
0A630 95 0F                           sta Enemy_Flag,x
0A632 4A                              lsr
0A633 9D 01 04                        sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
0A636 95 1E                           sta Enemy_State,x        ;enemy state
0A638 60                              rts
0A639                           
0A639                           ;--------------------------------
0A639                           
0A639                           FireworksXPosData:
0A639 00 30 60 60 00 20               .db $00, $30, $60, $60, $00, $20
0A63F                           
0A63F                           FireworksYPosData:
0A63F 60 40 70 40 60 30               .db $60, $40, $70, $40, $60, $30
0A645                           
0A645                           InitFireworks:
0A645 AD 8F 07                            lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
0A648 D0 47                               bne ExitFWk
0A64A A9 20                               lda #$20                     ;otherwise reset timer
0A64C 8D 8F 07                            sta FrenzyEnemyTimer
0A64F CE D7 06                            dec FireworksCounter         ;decrement for each explosion
0A652 A0 06                               ldy #$06                     ;start at last slot
0A654 88                        StarFChk: dey
0A655 B9 16 00                            lda Enemy_ID,y               ;check for presence of star flag object
0A658 C9 31                               cmp #StarFlagObject          ;if there isn't a star flag object,
0A65A D0 F8                               bne StarFChk                 ;routine goes into infinite loop = crash
0A65C B9 87 00                            lda Enemy_X_Position,y
0A65F 38                                  sec                          ;get horizontal coordinate of star flag object, then
0A660 E9 30                               sbc #$30                     ;subtract 48 pixels from it and save to
0A662 48                                  pha                          ;the stack
0A663 B9 6E 00                            lda Enemy_PageLoc,y
0A666 E9 00                               sbc #$00                     ;subtract the carry from the page location
0A668 85 00                               sta $00                      ;of the star flag object
0A66A AD D7 06                            lda FireworksCounter         ;get fireworks counter
0A66D 18                                  clc
0A66E 79 1E 00                            adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
0A671 A8                                  tay                          ;use as offset
0A672 68                                  pla                          ;get saved horizontal coordinate of star flag - 48 pixels
0A673 18                                  clc
0A674 79 39 A6                            adc FireworksXPosData,y      ;add number based on offset of fireworks counter
0A677 95 87                               sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
0A679 A5 00                               lda $00
0A67B 69 00                               adc #$00                     ;add carry and store as page location for
0A67D 95 6E                               sta Enemy_PageLoc,x          ;the fireworks object
0A67F B9 3F A6                            lda FireworksYPosData,y      ;get vertical position using same offset
0A682 95 CF                               sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
0A684 A9 01                               lda #$01
0A686 95 B6                               sta Enemy_Y_HighPos,x        ;store in vertical high byte
0A688 95 0F                               sta Enemy_Flag,x             ;and activate enemy buffer flag
0A68A 4A                                  lsr
0A68B 95 58                               sta ExplosionGfxCounter,x    ;initialize explosion counter
0A68D A9 08                               lda #$08
0A68F 95 A0                               sta ExplosionTimerCounter,x  ;set explosion timing counter
0A691 60                        ExitFWk:  rts
0A692                           
0A692                           ;--------------------------------
0A692                           
0A692                           Bitmasks:
0A692 01 02 04 08 10 20 40 80         .db %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
0A69A                           
0A69A                           Enemy17YPosData:
0A69A 40 30 90 50 20 60 A0 70         .db $40, $30, $90, $50, $20, $60, $a0, $70
0A6A2                           
0A6A2                           SwimCC_IDData:
0A6A2 0A 0B                           .db $0a, $0b
0A6A4                           
0A6A4                           BulletBillCheepCheep:
0A6A4 AD 8F 07                           lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
0A6A7 D0 6F                              bne ExF17
0A6A9 AD 4E 07                           lda AreaType              ;are we in a water-type level?
0A6AC D0 57                              bne DoBulletBills         ;if not, branch elsewhere
0A6AE E0 03                              cpx #$03                  ;are we past third enemy slot?
0A6B0 B0 66                              bcs ExF17                 ;if so, branch to leave
0A6B2 A0 00                              ldy #$00                  ;load default offset
0A6B4 BD A7 07                           lda PseudoRandomBitReg,x
0A6B7 C9 AA                              cmp #$aa                  ;check first part of LSFR against preset value
0A6B9 90 01                              bcc ChkW2                 ;if less than preset, do not increment offset
0A6BB C8                                 iny                       ;otherwise increment
0A6BC AD 5F 07                  ChkW2:   lda WorldNumber           ;check world number
0A6BF C9 01                              cmp #World2
0A6C1 F0 01                              beq Get17ID               ;if we're on world 2, do not increment offset
0A6C3 C8                                 iny                       ;otherwise increment
0A6C4 98                        Get17ID: tya
0A6C5 29 01                              and #%00000001            ;mask out all but last bit of offset
0A6C7 A8                                 tay
0A6C8 B9 A2 A6                           lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
0A6CB 95 16                     Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
0A6CD AD DD 06                           lda BitMFilter
0A6D0 C9 FF                              cmp #$ff                  ;if not all bits set, skip init part and compare bits
0A6D2 D0 05                              bne GetRBit
0A6D4 A9 00                              lda #$00                  ;initialize vertical position filter
0A6D6 8D DD 06                           sta BitMFilter
0A6D9 BD A7 07                  GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
0A6DC 29 07                              and #%00000111            ;mask out all but 3 LSB
0A6DE A8                        ChkRBit: tay                       ;use as offset
0A6DF B9 92 A6                           lda Bitmasks,y            ;load bitmask
0A6E2 2C DD 06                           bit BitMFilter            ;perform AND on filter without changing it
0A6E5 F0 07                              beq AddFBit
0A6E7 C8                                 iny                       ;increment offset
0A6E8 98                                 tya
0A6E9 29 07                              and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
0A6EB 4C DE A6                           jmp ChkRBit               ;do another check
0A6EE 0D DD 06                  AddFBit: ora BitMFilter            ;add bit to already set bits in filter
0A6F1 8D DD 06                           sta BitMFilter            ;and store
0A6F4 B9 9A A6                           lda Enemy17YPosData,y     ;load vertical position using offset
0A6F7 20 E0 A5                           jsr PutAtRightExtent      ;set vertical position and other values
0A6FA 9D 17 04                           sta Enemy_YMF_Dummy,x     ;initialize dummy variable
0A6FD A9 20                              lda #$20                  ;set timer
0A6FF 8D 8F 07                           sta FrenzyEnemyTimer
0A702 4C 74 A2                           jmp CheckpointEnemyID     ;process our new enemy object
0A705                           
0A705                           DoBulletBills:
0A705 A0 FF                               ldy #$ff                   ;start at beginning of enemy slots
0A707 C8                        BB_SLoop: iny                        ;move onto the next slot
0A708 C0 05                               cpy #$05                   ;branch to play sound if we've done all slots
0A70A B0 0D                               bcs FireBulletBill
0A70C B9 0F 00                            lda Enemy_Flag,y           ;if enemy buffer flag not set,
0A70F F0 F6                               beq BB_SLoop               ;loop back and check another slot
0A711 B9 16 00                            lda Enemy_ID,y
0A714 C9 08                               cmp #BulletBill_FrenzyVar  ;check enemy identifier for
0A716 D0 EF                               bne BB_SLoop               ;bullet bill object (frenzy variant)
0A718 60                        ExF17:    rts                        ;if found, leave
0A719                           
0A719                           FireBulletBill:
0A719 A5 FE                           lda Square2SoundQueue
0A71B 09 08                           ora #Sfx_Blast            ;play fireworks/gunfire sound
0A71D 85 FE                           sta Square2SoundQueue
0A71F A9 08                           lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
0A721 D0 A8                           bne Set17ID               ;unconditional branch
0A723                           
0A723                           ;--------------------------------
0A723                           ;$00 - used to store Y position of group enemies
0A723                           ;$01 - used to store enemy ID
0A723                           ;$02 - used to store page location of right side of screen
0A723                           ;$03 - used to store X position of right side of screen
0A723                           
0A723                           HandleGroupEnemies:
0A723 A0 00                             ldy #$00                  ;load value for green koopa troopa
0A725 38                                sec
0A726 E9 37                             sbc #$37                  ;subtract $37 from second byte read
0A728 48                                pha                       ;save result in stack for now
0A729 C9 04                             cmp #$04                  ;was byte in $3b-$3e range?
0A72B B0 0B                             bcs SnglID                ;if so, branch
0A72D 48                                pha                       ;save another copy to stack
0A72E A0 06                             ldy #Goomba               ;load value for goomba enemy
0A730 AD 6A 07                          lda PrimaryHardMode       ;if primary hard mode flag not set,
0A733 F0 02                             beq PullID                ;branch, otherwise change to value
0A735 A0 02                             ldy #BuzzyBeetle          ;for buzzy beetle
0A737 68                        PullID: pla                       ;get second copy from stack
0A738 84 01                     SnglID: sty $01                   ;save enemy id here
0A73A A0 B0                             ldy #$b0                  ;load default y coordinate
0A73C 29 02                             and #$02                  ;check to see if d1 was set
0A73E F0 02                             beq SetYGp                ;if so, move y coordinate up,
0A740 A0 70                             ldy #$70                  ;otherwise branch and use default
0A742 84 00                     SetYGp: sty $00                   ;save y coordinate here
0A744 AD 1B 07                          lda ScreenRight_PageLoc   ;get page number of right edge of screen
0A747 85 02                             sta $02                   ;save here
0A749 AD 1D 07                          lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
0A74C 85 03                             sta $03                   ;save here
0A74E A0 02                             ldy #$02                  ;load two enemies by default
0A750 68                                pla                       ;get first copy from stack
0A751 4A                                lsr                       ;check to see if d0 was set
0A752 90 01                             bcc CntGrp                ;if not, use default value
0A754 C8                                iny                       ;otherwise increment to three enemies
0A755 8C D3 06                  CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
0A758 A2 FF                     GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
0A75A E8                        GSltLp: inx                       ;increment and branch if past
0A75B E0 05                             cpx #$05                  ;end of buffers
0A75D B0 2D                             bcs NextED
0A75F B5 0F                             lda Enemy_Flag,x          ;check to see if enemy is already
0A761 D0 F7                             bne GSltLp                ;stored in buffer, and branch if so
0A763 A5 01                             lda $01
0A765 95 16                             sta Enemy_ID,x            ;store enemy object identifier
0A767 A5 02                             lda $02
0A769 95 6E                             sta Enemy_PageLoc,x       ;store page location for enemy object
0A76B A5 03                             lda $03
0A76D 95 87                             sta Enemy_X_Position,x    ;store x coordinate for enemy object
0A76F 18                                clc
0A770 69 18                             adc #$18                  ;add 24 pixels for next enemy
0A772 85 03                             sta $03
0A774 A5 02                             lda $02                   ;add carry to page location for
0A776 69 00                             adc #$00                  ;next enemy
0A778 85 02                             sta $02
0A77A A5 00                             lda $00                   ;store y coordinate for enemy object
0A77C 95 CF                             sta Enemy_Y_Position,x
0A77E A9 01                             lda #$01                  ;activate flag for buffer, and
0A780 95 B6                             sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
0A782 95 0F                             sta Enemy_Flag,x
0A784 20 74 A2                          jsr CheckpointEnemyID     ;process each enemy object separately
0A787 CE D3 06                          dec NumberofGroupEnemies  ;do this until we run out of enemy objects
0A78A D0 CC                             bne GrLoop
0A78C 4C 66 A2                  NextED: jmp Inc2B                 ;jump to increment data offset and leave
0A78F                           
0A78F                           ;--------------------------------
0A78F                           
0A78F                           InitPiranhaPlant:
0A78F A9 01                           lda #$01                     ;set initial speed
0A791 95 58                           sta PiranhaPlant_Y_Speed,x
0A793 4A                              lsr
0A794 95 1E                           sta Enemy_State,x            ;initialize enemy state and what would normally
0A796 95 A0                           sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
0A798 B5 CF                           lda Enemy_Y_Position,x
0A79A 9D 34 04                        sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
0A79D 38                              sec
0A79E E9 18                           sbc #$18
0A7A0 9D 17 04                        sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
0A7A3 A9 09                           lda #$09
0A7A5 4C E3 A7                        jmp SetBBox2                 ;set specific value for bounding box control
0A7A8                           
0A7A8                           ;--------------------------------
0A7A8                           
0A7A8                           InitEnemyFrenzy:
0A7A8 B5 16                           lda Enemy_ID,x        ;load enemy identifier
0A7AA 8D CB 06                        sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
0A7AD 38                              sec
0A7AE E9 12                           sbc #$12              ;subtract 12 and use as offset for jump engine
0A7B0 20 0A 6E                        jsr JumpEngine
0A7B3                           
0A7B3                           ;frenzy object jump table
0A7B3 AC A3                           .dw LakituAndSpinyHandler
0A7B5 BF A7                           .dw NoFrenzyCode
0A7B7 B0 A4                           .dw InitFlyingCheepCheep
0A7B9 AB A5                           .dw InitBowserFlame
0A7BB 45 A6                           .dw InitFireworks
0A7BD A4 A6                           .dw BulletBillCheepCheep
0A7BF                           
0A7BF                           ;--------------------------------
0A7BF                           
0A7BF                           NoFrenzyCode:
0A7BF 60                              rts
0A7C0                           
0A7C0                           ;--------------------------------
0A7C0                           
0A7C0                           EndFrenzy:
0A7C0 A0 05                                ldy #$05               ;start at last slot
0A7C2 B9 16 00                  LakituChk: lda Enemy_ID,y         ;check enemy identifiers
0A7C5 C9 11                                cmp #Lakitu            ;for lakitu
0A7C7 D0 05                                bne NextFSlot
0A7C9 A9 01                                lda #$01               ;if found, set state
0A7CB 99 1E 00                             sta Enemy_State,y
0A7CE 88                        NextFSlot: dey                    ;move onto the next slot
0A7CF 10 F1                                bpl LakituChk          ;do this until all slots are checked
0A7D1 A9 00                                lda #$00
0A7D3 8D CB 06                             sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
0A7D6 95 0F                                sta Enemy_Flag,x       ;disable enemy buffer flag for this object
0A7D8 60                                   rts
0A7D9                           
0A7D9                           ;--------------------------------
0A7D9                           
0A7D9                           InitJumpGPTroopa:
0A7D9 A9 02                                lda #$02                  ;set for movement to the left
0A7DB 95 46                                sta Enemy_MovingDir,x
0A7DD A9 F8                                lda #$f8                  ;set horizontal speed
0A7DF 95 58                                sta Enemy_X_Speed,x
0A7E1 A9 03                     TallBBox2: lda #$03                  ;set specific value for bounding box control
0A7E3 9D 9A 04                  SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
0A7E6 60                                   rts
0A7E7                           
0A7E7                           ;--------------------------------
0A7E7                           
0A7E7                           InitBalPlatform:
0A7E7 D6 CF                             dec Enemy_Y_Position,x    ;raise vertical position by two pixels
0A7E9 D6 CF                             dec Enemy_Y_Position,x
0A7EB AC CC 06                          ldy SecondaryHardMode     ;if secondary hard mode flag not set,
0A7EE D0 05                             bne AlignP                ;branch ahead
0A7F0 A0 02                             ldy #$02                  ;otherwise set value here
0A7F2 20 79 A8                          jsr PosPlatform           ;do a sub to add or subtract pixels
0A7F5 A0 FF                     AlignP: ldy #$ff                  ;set default value here for now
0A7F7 AD A0 03                          lda BalPlatformAlignment  ;get current balance platform alignment
0A7FA 95 1E                             sta Enemy_State,x         ;set platform alignment to object state here
0A7FC 10 02                             bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
0A7FE 8A                                txa                       ;if old contents already $ff, put
0A7FF A8                                tay                       ;object offset as alignment to make next positive
0A800 8C A0 03                  SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
0A803 A9 00                             lda #$00
0A805 95 46                             sta Enemy_MovingDir,x     ;init moving direction
0A807 A8                                tay                       ;init Y
0A808 20 79 A8                          jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
0A80B                           
0A80B                           ;--------------------------------
0A80B                           
0A80B                           InitDropPlatform:
0A80B A9 FF                           lda #$ff
0A80D 9D A2 03                        sta PlatformCollisionFlag,x  ;set some value here
0A810 4C 30 A8                        jmp CommonPlatCode           ;then jump ahead to execute more code
0A813                           
0A813                           ;--------------------------------
0A813                           
0A813                           InitHoriPlatform:
0A813 A9 00                           lda #$00
0A815 95 58                           sta XMoveSecondaryCounter,x  ;init one of the moving counters
0A817 4C 30 A8                        jmp CommonPlatCode           ;jump ahead to execute more code
0A81A                           
0A81A                           ;--------------------------------
0A81A                           
0A81A                           InitVertPlatform:
0A81A A0 40                            ldy #$40                    ;set default value here
0A81C B5 CF                            lda Enemy_Y_Position,x      ;check vertical position
0A81E 10 07                            bpl SetYO                   ;if above a certain point, skip this part
0A820 49 FF                            eor #$ff
0A822 18                               clc                         ;otherwise get two's compliment
0A823 69 01                            adc #$01
0A825 A0 C0                            ldy #$c0                    ;get alternate value to add to vertical position
0A827 9D 01 04                  SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
0A82A 98                               tya
0A82B 18                               clc                         ;load value from earlier, add number of pixels 
0A82C 75 CF                            adc Enemy_Y_Position,x      ;to vertical position
0A82E 95 58                            sta YPlatformCenterYPos,x   ;save result as central vertical position
0A830                           
0A830                           ;--------------------------------
0A830                           
0A830                           CommonPlatCode: 
0A830 20 6B A3                          jsr InitVStf              ;do a sub to init certain other values 
0A833 A9 05                     SPBBox: lda #$05                  ;set default bounding box size control
0A835 AC 4E 07                          ldy AreaType
0A838 C0 03                             cpy #$03                  ;check for castle-type level
0A83A F0 07                             beq CasPBB                ;use default value if found
0A83C AC CC 06                          ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
0A83F D0 02                             bne CasPBB                ;if set, use default value
0A841 A9 06                             lda #$06                  ;use alternate value if not castle or secondary not set
0A843 9D 9A 04                  CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
0A846 60                                rts
0A847                           
0A847                           ;--------------------------------
0A847                           
0A847                           LargeLiftUp:
0A847 20 53 A8                        jsr PlatLiftUp       ;execute code for platforms going up
0A84A 4C 50 A8                        jmp LargeLiftBBox    ;overwrite bounding box for large platforms
0A84D                           
0A84D                           LargeLiftDown:
0A84D 20 5F A8                        jsr PlatLiftDown     ;execute code for platforms going down
0A850                           
0A850                           LargeLiftBBox:
0A850 4C 33 A8                        jmp SPBBox           ;jump to overwrite bounding box size control
0A853                           
0A853                           ;--------------------------------
0A853                           
0A853                           PlatLiftUp:
0A853 A9 10                           lda #$10                 ;set movement amount here
0A855 9D 34 04                        sta Enemy_Y_MoveForce,x
0A858 A9 FF                           lda #$ff                 ;set moving speed for platforms going up
0A85A 95 A0                           sta Enemy_Y_Speed,x
0A85C 4C 68 A8                        jmp CommonSmallLift      ;skip ahead to part we should be executing
0A85F                           
0A85F                           ;--------------------------------
0A85F                           
0A85F                           PlatLiftDown:
0A85F A9 F0                           lda #$f0                 ;set movement amount here
0A861 9D 34 04                        sta Enemy_Y_MoveForce,x
0A864 A9 00                           lda #$00                 ;set moving speed for platforms going down
0A866 95 A0                           sta Enemy_Y_Speed,x
0A868                           
0A868                           ;--------------------------------
0A868                           
0A868                           CommonSmallLift:
0A868 A0 01                           ldy #$01
0A86A 20 79 A8                        jsr PosPlatform           ;do a sub to add 12 pixels due to preset value  
0A86D A9 04                           lda #$04
0A86F 9D 9A 04                        sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
0A872 60                              rts
0A873                           
0A873                           ;--------------------------------
0A873                           
0A873                           PlatPosDataLow:
0A873 08 0C F8                        .db $08,$0c,$f8
0A876                           
0A876                           PlatPosDataHigh:
0A876 00 00 FF                        .db $00,$00,$ff
0A879                           
0A879                           PosPlatform:
0A879 B5 87                           lda Enemy_X_Position,x  ;get horizontal coordinate
0A87B 18                              clc
0A87C 79 73 A8                        adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
0A87F 95 87                           sta Enemy_X_Position,x  ;store as new horizontal coordinate
0A881 B5 6E                           lda Enemy_PageLoc,x
0A883 79 76 A8                        adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
0A886 95 6E                           sta Enemy_PageLoc,x     ;store as new page location
0A888 60                              rts                     ;and go back
0A889                           
0A889                           ;--------------------------------
0A889                           
0A889                           EndOfEnemyInitCode:
0A889 60                              rts
0A88A                           
0A88A                           ;-------------------------------------------------------------------------------------
0A88A                           
0A88A                           RunEnemyObjectsCore:
0A88A A6 08                            ldx ObjectOffset  ;get offset for enemy object buffer
0A88C A9 00                            lda #$00          ;load value 0 for jump engine by default
0A88E B4 16                            ldy Enemy_ID,x
0A890 C0 15                            cpy #$15          ;if enemy object < $15, use default value
0A892 90 03                            bcc JmpEO
0A894 98                               tya               ;otherwise subtract $14 from the value and use
0A895 E9 14                            sbc #$14          ;as value for jump engine
0A897 20 0A 6E                  JmpEO: jsr JumpEngine
0A89A                                 
0A89A E8 A8                           .dw RunNormalEnemies  ;for objects $00-$14
0A89C                           
0A89C 3D A9                           .dw RunBowserFlame    ;for objects $15-$1f
0A89E 9D B2                           .dw RunFireworks
0A8A0 DE A8                           .dw NoRunCode
0A8A2 DE A8                           .dw NoRunCode
0A8A4 DE A8                           .dw NoRunCode
0A8A6 DE A8                           .dw NoRunCode
0A8A8 4F A9                           .dw RunFirebarObj
0A8AA 4F A9                           .dw RunFirebarObj
0A8AC 4F A9                           .dw RunFirebarObj
0A8AE 4F A9                           .dw RunFirebarObj
0A8B0 4F A9                           .dw RunFirebarObj
0A8B2                           
0A8B2 4F A9                           .dw RunFirebarObj     ;for objects $20-$2f
0A8B4 4F A9                           .dw RunFirebarObj
0A8B6 4F A9                           .dw RunFirebarObj
0A8B8 DE A8                           .dw NoRunCode
0A8BA 6D A9                           .dw RunLargePlatform
0A8BC 6D A9                           .dw RunLargePlatform
0A8BE 6D A9                           .dw RunLargePlatform
0A8C0 6D A9                           .dw RunLargePlatform
0A8C2 6D A9                           .dw RunLargePlatform
0A8C4 6D A9                           .dw RunLargePlatform
0A8C6 6D A9                           .dw RunLargePlatform
0A8C8 55 A9                           .dw RunSmallPlatform
0A8CA 55 A9                           .dw RunSmallPlatform
0A8CC 6D B0                           .dw RunBowser
0A8CE 8D 9C                           .dw PowerUpObjHandler
0A8D0 53 99                           .dw VineObjectHandler
0A8D2                           
0A8D2 DE A8                           .dw NoRunCode         ;for objects $30-$35
0A8D4 E1 B2                           .dw RunStarFlagObj
0A8D6 C2 98                           .dw JumpspringHandler
0A8D8 DE A8                           .dw NoRunCode
0A8DA AC 97                           .dw WarpZoneObject
0A8DC DF A8                           .dw RunRetainerObj
0A8DE                           
0A8DE                           ;--------------------------------
0A8DE                           
0A8DE                           NoRunCode:
0A8DE 60                              rts
0A8DF                           
0A8DF                           ;--------------------------------
0A8DF                           
0A8DF                           RunRetainerObj:
0A8DF 20 B3 D1                        jsr GetEnemyOffscreenBits
0A8E2 20 56 D1                        jsr RelativeEnemyPosition
0A8E5 4C 81 C8                        jmp EnemyGfxHandler
0A8E8                           
0A8E8                           ;--------------------------------
0A8E8                           
0A8E8                           RunNormalEnemies:
0A8E8 A9 00                               lda #$00                  ;init sprite attributes
0A8EA 9D C5 03                            sta Enemy_SprAttrib,x
0A8ED 20 B3 D1                            jsr GetEnemyOffscreenBits
0A8F0 20 56 D1                            jsr RelativeEnemyPosition
0A8F3 20 81 C8                            jsr EnemyGfxHandler
0A8F6 20 48 C2                            jsr GetEnemyBoundBox
0A8F9 20 C6 BF                            jsr EnemyToBGCollisionDet
0A8FC 20 38 BA                            jsr EnemiesCollision
0A8FF 20 58 B8                            jsr PlayerEnemyCollision
0A902 AC 47 07                            ldy TimerControl          ;if master timer control set, skip to last routine
0A905 D0 03                               bne SkipMove
0A907 20 0D A9                            jsr EnemyMovementSubs
0A90A 4C 82 B6                  SkipMove: jmp OffscreenBoundsCheck
0A90D                           
0A90D                           EnemyMovementSubs:
0A90D B5 16                           lda Enemy_ID,x
0A90F 20 0A 6E                        jsr JumpEngine
0A912                           
0A912 7F AA                           .dw MoveNormalEnemy      ;only objects $00-$14 use this table
0A914 7F AA                           .dw MoveNormalEnemy
0A916 7F AA                           .dw MoveNormalEnemy
0A918 7F AA                           .dw MoveNormalEnemy
0A91A 7F AA                           .dw MoveNormalEnemy
0A91C E0 A9                           .dw ProcHammerBro
0A91E 7F AA                           .dw MoveNormalEnemy
0A920 91 AB                           .dw MoveBloober
0A922 3E AC                           .dw MoveBulletBill
0A924 3C A9                           .dw NoMoveCode
0A926 52 AC                           .dw MoveSwimmingCheepCheep
0A928 52 AC                           .dw MoveSwimmingCheepCheep
0A92A B8 A9                           .dw MovePodoboo
0A92C B8 B3                           .dw MovePiranhaPlant
0A92E 01 AB                           .dw MoveJumpingEnemy
0A930 07 AB                           .dw ProcMoveRedPTroopa
0A932 2D AB                           .dw MoveFlyGreenPTroopa
0A934 30 AF                           .dw MoveLakitu
0A936 7F AA                           .dw MoveNormalEnemy
0A938 3C A9                           .dw NoMoveCode   ;dummy
0A93A E7 AE                           .dw MoveFlyingCheepCheep
0A93C                           
0A93C                           ;--------------------------------
0A93C                           
0A93C                           NoMoveCode:
0A93C 60                              rts
0A93D                           
0A93D                           ;--------------------------------
0A93D                           
0A93D                           RunBowserFlame:
0A93D 20 F3 B1                        jsr ProcBowserFlame
0A940 20 B3 D1                        jsr GetEnemyOffscreenBits
0A943 20 56 D1                        jsr RelativeEnemyPosition
0A946 20 48 C2                        jsr GetEnemyBoundBox
0A949 20 58 B8                        jsr PlayerEnemyCollision
0A94C 4C 82 B6                        jmp OffscreenBoundsCheck
0A94F                           
0A94F                           ;--------------------------------
0A94F                           
0A94F                           RunFirebarObj:
0A94F 20 44 AD                        jsr ProcFirebar
0A952 4C 82 B6                        jmp OffscreenBoundsCheck
0A955                           
0A955                           ;--------------------------------
0A955                           
0A955                           RunSmallPlatform:
0A955 20 B3 D1                        jsr GetEnemyOffscreenBits
0A958 20 56 D1                        jsr RelativeEnemyPosition
0A95B 20 51 C2                        jsr SmallPlatformBoundBox
0A95E 20 80 BB                        jsr SmallPlatformCollision
0A961 20 56 D1                        jsr RelativeEnemyPosition
0A964 20 6A CD                        jsr DrawSmallPlatform
0A967 20 5D B6                        jsr MoveSmallPlatform
0A96A 4C 82 B6                        jmp OffscreenBoundsCheck
0A96D                           
0A96D                           ;--------------------------------
0A96D                           
0A96D                           RunLargePlatform:
0A96D 20 B3 D1                          jsr GetEnemyOffscreenBits
0A970 20 56 D1                          jsr RelativeEnemyPosition
0A973 20 78 C2                          jsr LargePlatformBoundBox
0A976 20 4A BB                          jsr LargePlatformCollision
0A979 AD 47 07                          lda TimerControl             ;if master timer control set,
0A97C D0 03                             bne SkipPT                   ;skip subroutine tree
0A97E 20 8A A9                          jsr LargePlatformSubroutines
0A981 20 56 D1                  SkipPT: jsr RelativeEnemyPosition
0A984 20 CC C5                          jsr DrawLargePlatform
0A987 4C 82 B6                          jmp OffscreenBoundsCheck
0A98A                           
0A98A                           ;--------------------------------
0A98A                           
0A98A                           LargePlatformSubroutines:
0A98A B5 16                           lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
0A98C 38                              sec
0A98D E9 24                           sbc #$24
0A98F 20 0A 6E                        jsr JumpEngine
0A992                           
0A992 3A B4                           .dw BalancePlatform   ;table used by objects $24-$2a
0A994 DB B5                           .dw YMovingPlatform
0A996 57 B6                           .dw MoveLargeLiftPlat
0A998 57 B6                           .dw MoveLargeLiftPlat
0A99A 0F B6                           .dw XMovingPlatform
0A99C 39 B6                           .dw DropPlatform
0A99E 45 B6                           .dw RightPlatform
0A9A0                           
0A9A0                           ;-------------------------------------------------------------------------------------
0A9A0                           
0A9A0                           EraseEnemyObject:
0A9A0 A9 00                           lda #$00                 ;clear all enemy object variables
0A9A2 95 0F                           sta Enemy_Flag,x
0A9A4 95 16                           sta Enemy_ID,x
0A9A6 95 1E                           sta Enemy_State,x
0A9A8 9D 10 01                        sta FloateyNum_Control,x
0A9AB 9D 96 07                        sta EnemyIntervalTimer,x
0A9AE 9D 25 01                        sta ShellChainCounter,x
0A9B1 9D C5 03                        sta Enemy_SprAttrib,x
0A9B4 9D 8A 07                        sta EnemyFrameTimer,x
0A9B7 60                              rts
0A9B8                           
0A9B8                           ;-------------------------------------------------------------------------------------
0A9B8                           
0A9B8                           MovePodoboo:
0A9B8 BD 96 07                        lda EnemyIntervalTimer,x   ;check enemy timer
0A9BB D0 16                           bne PdbM                   ;branch to move enemy if not expired
0A9BD 20 FF A2                        jsr InitPodoboo            ;otherwise set up podoboo again
0A9C0 BD A8 07                        lda PseudoRandomBitReg+1,x ;get part of LSFR
0A9C3 09 80                           ora #%10000000             ;set d7
0A9C5 9D 34 04                        sta Enemy_Y_MoveForce,x    ;store as movement force
0A9C8 29 0F                           and #%00001111             ;mask out high nybble
0A9CA 09 06                           ora #$06                   ;set for at least six intervals
0A9CC 9D 96 07                        sta EnemyIntervalTimer,x   ;store as new enemy timer
0A9CF A9 F9                           lda #$f9
0A9D1 95 A0                           sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
0A9D3 4C 9A 9F                  PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
0A9D6                           
0A9D6                           ;--------------------------------
0A9D6                           ;$00 - used in HammerBroJumpCode as bitmask
0A9D6                           
0A9D6                           HammerThrowTmrData:
0A9D6 30 1C                           .db $30, $1c
0A9D8                           
0A9D8                           XSpeedAdderData:
0A9D8 00 E8 00 18                     .db $00, $e8, $00, $18
0A9DC                           
0A9DC                           RevivedXSpeed:
0A9DC 08 F8 0C F4                     .db $08, $f8, $0c, $f4
0A9E0                           
0A9E0                           ProcHammerBro:
0A9E0 B5 1E                            lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
0A9E2 29 20                            and #%00100000
0A9E4 F0 03                            beq ChkJH                  ;if not set, go ahead with code
0A9E6 4C ED AA                         jmp MoveDefeatedEnemy      ;otherwise jump to something else
0A9E9 B5 3C                     ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
0A9EB F0 2D                            beq HammerBroJumpCode      ;if expired, branch to jump
0A9ED D6 3C                            dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
0A9EF AD D1 03                         lda Enemy_OffscreenBits
0A9F2 29 0C                            and #%00001100             ;check offscreen bits
0A9F4 D0 6A                            bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
0A9F6 BD A2 03                         lda HammerThrowingTimer,x  ;check hammer throwing timer
0A9F9 D0 17                            bne DecHT                  ;if not expired, skip ahead, do not throw hammer
0A9FB AC CC 06                         ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
0A9FE B9 D6 A9                         lda HammerThrowTmrData,y   ;get timer data using flag as offset
0AA01 9D A2 03                         sta HammerThrowingTimer,x  ;set as new timer
0AA04 20 9C 9A                         jsr SpawnHammerObj         ;do a sub here to spawn hammer object
0AA07 90 09                            bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
0AA09 B5 1E                            lda Enemy_State,x
0AA0B 09 08                            ora #%00001000             ;set d3 in enemy state for hammer throw
0AA0D 95 1E                            sta Enemy_State,x
0AA0F 4C 60 AA                         jmp MoveHammerBroXDir      ;jump to move hammer bro
0AA12 DE A2 03                  DecHT: dec HammerThrowingTimer,x  ;decrement timer
0AA15 4C 60 AA                         jmp MoveHammerBroXDir      ;jump to move hammer bro
0AA18                           
0AA18                           HammerBroJumpLData:
0AA18 20 37                           .db $20, $37
0AA1A                           
0AA1A                           HammerBroJumpCode:
0AA1A B5 1E                            lda Enemy_State,x           ;get hammer bro's enemy state
0AA1C 29 07                            and #%00000111              ;mask out all but 3 LSB
0AA1E C9 01                            cmp #$01                    ;check for d0 set (for jumping)
0AA20 F0 3E                            beq MoveHammerBroXDir       ;if set, branch ahead to moving code
0AA22 A9 00                            lda #$00                    ;load default value here
0AA24 85 00                            sta $00                     ;save into temp variable for now
0AA26 A0 FA                            ldy #$fa                    ;set default vertical speed
0AA28 B5 CF                            lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
0AA2A 30 13                            bmi SetHJ                   ;if on the bottom half of the screen, use current speed
0AA2C A0 FD                            ldy #$fd                    ;otherwise set alternate vertical speed
0AA2E C9 70                            cmp #$70                    ;check to see if hammer bro is above the middle of screen
0AA30 E6 00                            inc $00                     ;increment preset value to $01
0AA32 90 0B                            bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
0AA34 C6 00                            dec $00                     ;otherwise return value to $00
0AA36 BD A8 07                         lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
0AA39 29 01                            and #$01
0AA3B D0 02                            bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
0AA3D A0 FA                            ldy #$fa                    ;otherwise reset to default vertical speed
0AA3F 94 A0                     SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
0AA41 B5 1E                            lda Enemy_State,x           ;set d0 in enemy state for jumping
0AA43 09 01                            ora #$01
0AA45 95 1E                            sta Enemy_State,x
0AA47 A5 00                            lda $00                     ;load preset value here to use as bitmask
0AA49 3D A9 07                         and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
0AA4C A8                               tay                         ;then use as offset
0AA4D AD CC 06                         lda SecondaryHardMode       ;check secondary hard mode flag
0AA50 D0 01                            bne HJump
0AA52 A8                               tay                         ;if secondary hard mode flag clear, set offset to 0
0AA53 B9 18 AA                  HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
0AA56 9D 8A 07                         sta EnemyFrameTimer,x       ;save in enemy timer
0AA59 BD A8 07                         lda PseudoRandomBitReg+1,x
0AA5C 09 C0                            ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
0AA5E 95 3C                            sta HammerBroJumpTimer,x    ;store in jump timer
0AA60                           
0AA60                           MoveHammerBroXDir:
0AA60 A0 FC                              ldy #$fc                  ;move hammer bro a little to the left
0AA62 A5 09                              lda FrameCounter
0AA64 29 40                              and #%01000000            ;change hammer bro's direction every 64 frames
0AA66 D0 02                              bne Shimmy
0AA68 A0 04                              ldy #$04                  ;if d6 set in counter, move him a little to the right
0AA6A 94 58                     Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
0AA6C A0 01                              ldy #$01                  ;set to face right by default
0AA6E 20 48 C1                           jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
0AA71 30 0A                              bmi SetShim               ;if enemy to the left of player, skip this part
0AA73 C8                                 iny                       ;set to face left
0AA74 BD 96 07                           lda EnemyIntervalTimer,x  ;check walking timer
0AA77 D0 04                              bne SetShim               ;if not yet expired, skip to set moving direction
0AA79 A9 F8                              lda #$f8
0AA7B 95 58                              sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
0AA7D 94 46                     SetShim: sty Enemy_MovingDir,x     ;set moving direction
0AA7F                           
0AA7F                           MoveNormalEnemy:
0AA7F A0 00                            ldy #$00                   ;init Y to leave horizontal movement as-is 
0AA81 B5 1E                            lda Enemy_State,x
0AA83 29 40                            and #%01000000             ;check enemy state for d6 set, if set skip
0AA85 D0 19                            bne FallE                  ;to move enemy vertically, then horizontally if necessary
0AA87 B5 1E                            lda Enemy_State,x
0AA89 0A                               asl                        ;check enemy state for d7 set
0AA8A B0 30                            bcs SteadM                 ;if set, branch to move enemy horizontally
0AA8C B5 1E                            lda Enemy_State,x
0AA8E 29 20                            and #%00100000             ;check enemy state for d5 set
0AA90 D0 5B                            bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
0AA92 B5 1E                            lda Enemy_State,x
0AA94 29 07                            and #%00000111             ;check d2-d0 of enemy state for any set bits
0AA96 F0 24                            beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
0AA98 C9 05                            cmp #$05
0AA9A F0 04                            beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
0AA9C C9 03                            cmp #$03
0AA9E B0 30                            bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
0AAA0 20 6B 9F                  FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
0AAA3 A0 00                            ldy #$00
0AAA5 B5 1E                            lda Enemy_State,x          ;check for enemy state $02
0AAA7 C9 02                            cmp #$02
0AAA9 F0 0C                            beq MEHor                  ;if found, branch to move enemy horizontally
0AAAB 29 40                            and #%01000000             ;check for d6 set
0AAAD F0 0D                            beq SteadM                 ;if not set, branch to something else
0AAAF B5 16                            lda Enemy_ID,x
0AAB1 C9 2E                            cmp #PowerUpObject         ;check for power-up object
0AAB3 F0 07                            beq SteadM
0AAB5 D0 03                            bne SlowM                  ;if any other object where d6 set, jump to set Y
0AAB7 4C 0A 9F                  MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
0AABA                           
0AABA A0 01                     SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
0AABC B5 58                     SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
0AABE 48                                pha                       ;save to stack
0AABF 10 02                             bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
0AAC1 C8                                iny
0AAC2 C8                                iny                       ;otherwise increment Y to next data
0AAC3 18                        AddHS:  clc
0AAC4 79 D8 A9                          adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
0AAC7 95 58                             sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
0AAC9 20 0A 9F                          jsr MoveEnemyHorizontally ;then do a sub to move horizontally
0AACC 68                                pla
0AACD 95 58                             sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
0AACF 60                                rts                       ;original memory location, then leave
0AAD0                           
0AAD0                           ReviveStunned:
0AAD0 BD 96 07                           lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
0AAD3 D0 1E                              bne ChkKillGoomba         ;skip ahead to something else
0AAD5 95 1E                              sta Enemy_State,x         ;otherwise initialize enemy state to normal
0AAD7 A5 09                              lda FrameCounter
0AAD9 29 01                              and #$01                  ;get d0 of frame counter
0AADB A8                                 tay                       ;use as Y and increment for movement direction
0AADC C8                                 iny
0AADD 94 46                              sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
0AADF 88                                 dey                       ;decrement for use as pointer
0AAE0 AD 6A 07                           lda PrimaryHardMode       ;check primary hard mode flag
0AAE3 F0 02                              beq SetRSpd               ;if not set, use pointer as-is
0AAE5 C8                                 iny
0AAE6 C8                                 iny                       ;otherwise increment 2 bytes to next data
0AAE7 B9 DC A9                  SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
0AAEA 95 58                              sta Enemy_X_Speed,x       ;and leave
0AAEC 60                                 rts
0AAED                           
0AAED                           MoveDefeatedEnemy:
0AAED 20 6B 9F                        jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
0AAF0 4C 0A 9F                        jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
0AAF3                           
0AAF3                           ChkKillGoomba:
0AAF3 C9 0E                             cmp #$0e              ;check to see if enemy timer has reached
0AAF5 D0 09                             bne NKGmba            ;a certain point, and branch to leave if not
0AAF7 B5 16                             lda Enemy_ID,x
0AAF9 C9 06                             cmp #Goomba           ;check for goomba object
0AAFB D0 03                             bne NKGmba            ;branch if not found
0AAFD 20 A0 A9                          jsr EraseEnemyObject  ;otherwise, kill this goomba object
0AB00 60                        NKGmba: rts                   ;leave!
0AB01                           
0AB01                           ;--------------------------------
0AB01                           
0AB01                           MoveJumpingEnemy:
0AB01 20 9A 9F                        jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
0AB04 4C 0A 9F                        jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
0AB07                           
0AB07                           ;--------------------------------
0AB07                           
0AB07                           ProcMoveRedPTroopa:
0AB07 B5 A0                               lda Enemy_Y_Speed,x
0AB09 1D 34 04                            ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
0AB0C D0 13                               bne MoveRedPTUpOrDown       ;branch if any found
0AB0E 9D 17 04                            sta Enemy_YMF_Dummy,x       ;initialize something here
0AB11 B5 CF                               lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
0AB13 DD 01 04                            cmp RedPTroopaOrigXPos,x
0AB16 B0 09                               bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
0AB18 A5 09                               lda FrameCounter            ;get frame counter
0AB1A 29 07                               and #%00000111              ;mask out all but 3 LSB
0AB1C D0 02                               bne NoIncPT                 ;if any bits set, branch to leave
0AB1E F6 CF                               inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
0AB20 60                        NoIncPT:  rts                         ;leave
0AB21                           
0AB21                           MoveRedPTUpOrDown:
0AB21 B5 CF                               lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
0AB23 D5 58                               cmp RedPTroopaCenterYPos,x
0AB25 90 03                               bcc MovPTDwn                ;if current < central, jump to move downwards
0AB27 4C 7D 9F                            jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
0AB2A 4C 78 9F                  MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
0AB2D                           
0AB2D                           ;--------------------------------
0AB2D                           ;$00 - used to store adder for movement, also used as adder for platform
0AB2D                           ;$01 - used to store maximum value for secondary counter
0AB2D                           
0AB2D                           MoveFlyGreenPTroopa:
0AB2D 20 4D AB                          jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
0AB30 20 6E AB                          jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
0AB33 A0 01                             ldy #$01                   ;set Y to move green paratroopa down
0AB35 A5 09                             lda FrameCounter
0AB37 29 03                             and #%00000011             ;check frame counter 2 LSB for any bits set
0AB39 D0 11                             bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
0AB3B A5 09                             lda FrameCounter
0AB3D 29 40                             and #%01000000             ;check frame counter for d6 set
0AB3F D0 02                             bne YSway                  ;branch to move green paratroopa down if set
0AB41 A0 FF                             ldy #$ff                   ;otherwise set Y to move green paratroopa up
0AB43 84 00                     YSway:  sty $00                    ;store adder here
0AB45 B5 CF                             lda Enemy_Y_Position,x
0AB47 18                                clc                        ;add or subtract from vertical position
0AB48 65 00                             adc $00                    ;to give green paratroopa a wavy flight
0AB4A 95 CF                             sta Enemy_Y_Position,x
0AB4C 60                        NoMGPT: rts                        ;leave!
0AB4D                           
0AB4D                           XMoveCntr_GreenPTroopa:
0AB4D A9 13                              lda #$13                    ;load preset maximum value for secondary counter
0AB4F                           
0AB4F                           XMoveCntr_Platform:
0AB4F 85 01                              sta $01                     ;store value here
0AB51 A5 09                              lda FrameCounter
0AB53 29 03                              and #%00000011              ;branch to leave if not on
0AB55 D0 0D                              bne NoIncXM                 ;every fourth frame
0AB57 B4 58                              ldy XMoveSecondaryCounter,x ;get secondary counter
0AB59 B5 A0                              lda XMovePrimaryCounter,x   ;get primary counter
0AB5B 4A                                 lsr
0AB5C B0 0A                              bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
0AB5E C4 01                              cpy $01                     ;compare secondary counter to preset maximum value
0AB60 F0 03                              beq IncPXM                  ;if equal, branch ahead of this part
0AB62 F6 58                              inc XMoveSecondaryCounter,x ;increment secondary counter and leave
0AB64 60                        NoIncXM: rts
0AB65 F6 A0                     IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
0AB67 60                                 rts
0AB68 98                        DecSeXM: tya                         ;put secondary counter in A
0AB69 F0 FA                              beq IncPXM                  ;if secondary counter at zero, branch back
0AB6B D6 58                              dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
0AB6D 60                                 rts
0AB6E                           
0AB6E                           MoveWithXMCntrs:
0AB6E B5 58                              lda XMoveSecondaryCounter,x  ;save secondary counter to stack
0AB70 48                                 pha
0AB71 A0 01                              ldy #$01                     ;set value here by default
0AB73 B5 A0                              lda XMovePrimaryCounter,x
0AB75 29 02                              and #%00000010               ;if d1 of primary counter is
0AB77 D0 0B                              bne XMRight                  ;set, branch ahead of this part here
0AB79 B5 58                              lda XMoveSecondaryCounter,x
0AB7B 49 FF                              eor #$ff                     ;otherwise change secondary
0AB7D 18                                 clc                          ;counter to two's compliment
0AB7E 69 01                              adc #$01
0AB80 95 58                              sta XMoveSecondaryCounter,x
0AB82 A0 02                              ldy #$02                     ;load alternate value here
0AB84 94 46                     XMRight: sty Enemy_MovingDir,x        ;store as moving direction
0AB86 20 0A 9F                           jsr MoveEnemyHorizontally
0AB89 85 00                              sta $00                      ;save value obtained from sub here
0AB8B 68                                 pla                          ;get secondary counter from stack
0AB8C 95 58                              sta XMoveSecondaryCounter,x  ;and return to original place
0AB8E 60                                 rts
0AB8F                           
0AB8F                           ;--------------------------------
0AB8F                           
0AB8F                           BlooberBitmasks:
0AB8F 3F 03                           .db %00111111, %00000011
0AB91                           
0AB91                           MoveBloober:
0AB91 B5 1E                             lda Enemy_State,x
0AB93 29 20                             and #%00100000             ;check enemy state for d5 set
0AB95 D0 4D                             bne MoveDefeatedBloober    ;branch if set to move defeated bloober
0AB97 AC CC 06                          ldy SecondaryHardMode      ;use secondary hard mode flag as offset
0AB9A BD A8 07                          lda PseudoRandomBitReg+1,x ;get LSFR
0AB9D 39 8F AB                          and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
0ABA0 D0 12                             bne BlooberSwim            ;if any bits set, skip ahead to make swim
0ABA2 8A                                txa
0ABA3 4A                                lsr                        ;check to see if on second or fourth slot (1 or 3)
0ABA4 90 04                             bcc FBLeft                 ;if not, branch to figure out moving direction
0ABA6 A4 45                             ldy Player_MovingDir       ;otherwise, load player's moving direction and
0ABA8 B0 08                             bcs SBMDir                 ;do an unconditional branch to set
0ABAA A0 02                     FBLeft: ldy #$02                   ;set left moving direction by default
0ABAC 20 48 C1                          jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
0ABAF 10 01                             bpl SBMDir                 ;if enemy to the right of player, keep left
0ABB1 88                                dey                        ;otherwise decrement to set right moving direction
0ABB2 94 46                     SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
0ABB4                           
0ABB4                           BlooberSwim:
0ABB4 20 E7 AB                         jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
0ABB7 B5 CF                            lda Enemy_Y_Position,x   ;get vertical coordinate
0ABB9 38                               sec
0ABBA FD 34 04                         sbc Enemy_Y_MoveForce,x  ;subtract movement force
0ABBD C9 20                            cmp #$20                 ;check to see if position is above edge of status bar
0ABBF 90 02                            bcc SwimX                ;if so, don't do it
0ABC1 95 CF                            sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
0ABC3 B4 46                     SwimX: ldy Enemy_MovingDir,x    ;check moving direction
0ABC5 88                               dey
0ABC6 D0 0E                            bne LeftSwim             ;if moving to the left, branch to second part
0ABC8 B5 87                            lda Enemy_X_Position,x
0ABCA 18                               clc                      ;add movement speed to horizontal coordinate
0ABCB 75 58                            adc BlooperMoveSpeed,x
0ABCD 95 87                            sta Enemy_X_Position,x   ;store result as new horizontal coordinate
0ABCF B5 6E                            lda Enemy_PageLoc,x
0ABD1 69 00                            adc #$00                 ;add carry to page location
0ABD3 95 6E                            sta Enemy_PageLoc,x      ;store as new page location and leave
0ABD5 60                               rts
0ABD6                           
0ABD6                           LeftSwim:
0ABD6 B5 87                           lda Enemy_X_Position,x
0ABD8 38                              sec                      ;subtract movement speed from horizontal coordinate
0ABD9 F5 58                           sbc BlooperMoveSpeed,x
0ABDB 95 87                           sta Enemy_X_Position,x   ;store result as new horizontal coordinate
0ABDD B5 6E                           lda Enemy_PageLoc,x
0ABDF E9 00                           sbc #$00                 ;subtract borrow from page location
0ABE1 95 6E                           sta Enemy_PageLoc,x      ;store as new page location and leave
0ABE3 60                              rts
0ABE4                           
0ABE4                           MoveDefeatedBloober:
0ABE4 4C 94 9F                        jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
0ABE7                           
0ABE7                           ProcSwimmingB:
0ABE7 B5 A0                             lda BlooperMoveCounter,x  ;get enemy's movement counter
0ABE9 29 02                             and #%00000010            ;check for d1 set
0ABEB D0 37                             bne ChkForFloatdown       ;branch if set
0ABED A5 09                             lda FrameCounter
0ABEF 29 07                             and #%00000111            ;get 3 LSB of frame counter
0ABF1 48                                pha                       ;and save it to the stack
0ABF2 B5 A0                             lda BlooperMoveCounter,x  ;get enemy's movement counter
0ABF4 4A                                lsr                       ;check for d0 set
0ABF5 B0 15                             bcs SlowSwim              ;branch if set
0ABF7 68                                pla                       ;pull 3 LSB of frame counter from the stack
0ABF8 D0 11                             bne BSwimE                ;branch to leave, execute code only every eighth frame
0ABFA BD 34 04                          lda Enemy_Y_MoveForce,x
0ABFD 18                                clc                       ;add to movement force to speed up swim
0ABFE 69 01                             adc #$01
0AC00 9D 34 04                          sta Enemy_Y_MoveForce,x   ;set movement force
0AC03 95 58                             sta BlooperMoveSpeed,x    ;set as movement speed
0AC05 C9 02                             cmp #$02
0AC07 D0 02                             bne BSwimE                ;if certain horizontal speed, branch to leave
0AC09 F6 A0                             inc BlooperMoveCounter,x  ;otherwise increment movement counter
0AC0B 60                        BSwimE: rts
0AC0C                           
0AC0C                           SlowSwim:
0AC0C 68                               pla                      ;pull 3 LSB of frame counter from the stack
0AC0D D0 14                            bne NoSSw                ;branch to leave, execute code only every eighth frame
0AC0F BD 34 04                         lda Enemy_Y_MoveForce,x
0AC12 38                               sec                      ;subtract from movement force to slow swim
0AC13 E9 01                            sbc #$01
0AC15 9D 34 04                         sta Enemy_Y_MoveForce,x  ;set movement force
0AC18 95 58                            sta BlooperMoveSpeed,x   ;set as movement speed
0AC1A D0 07                            bne NoSSw                ;if any speed, branch to leave
0AC1C F6 A0                            inc BlooperMoveCounter,x ;otherwise increment movement counter
0AC1E A9 02                            lda #$02
0AC20 9D 96 07                         sta EnemyIntervalTimer,x ;set enemy's timer
0AC23 60                        NoSSw: rts                      ;leave
0AC24                           
0AC24                           ChkForFloatdown:
0AC24 BD 96 07                        lda EnemyIntervalTimer,x ;get enemy timer
0AC27 F0 08                           beq ChkNearPlayer        ;branch if expired
0AC29                           
0AC29                           Floatdown:
0AC29 A5 09                           lda FrameCounter        ;get frame counter
0AC2B 4A                              lsr                     ;check for d0 set
0AC2C B0 02                           bcs NoFD                ;branch to leave on every other frame
0AC2E F6 CF                           inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
0AC30 60                        NoFD: rts                     ;leave
0AC31                           
0AC31                           ChkNearPlayer:
0AC31 B5 CF                           lda Enemy_Y_Position,x    ;get vertical coordinate
0AC33 69 10                           adc #$10                  ;add sixteen pixels
0AC35 C5 CE                           cmp Player_Y_Position     ;compare result with player's vertical coordinate
0AC37 90 F0                           bcc Floatdown             ;if modified vertical less than player's, branch
0AC39 A9 00                           lda #$00
0AC3B 95 A0                           sta BlooperMoveCounter,x  ;otherwise nullify movement counter
0AC3D 60                              rts
0AC3E                           
0AC3E                           ;--------------------------------
0AC3E                           
0AC3E                           MoveBulletBill:
0AC3E B5 1E                              lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
0AC40 29 20                              and #%00100000
0AC42 F0 03                              beq NotDefB                ;if not set, continue with movement code
0AC44 4C 9A 9F                           jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
0AC47 A9 E8                     NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
0AC49 95 58                              sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
0AC4B 4C 0A 9F                           jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
0AC4E                           
0AC4E                           ;--------------------------------
0AC4E                           ;$02 - used to hold preset values
0AC4E                           ;$03 - used to hold enemy state
0AC4E                           
0AC4E                           SwimCCXMoveData:
0AC4E 40 80                           .db $40, $80
0AC50 04 04                           .db $04, $04 ;residual data, not used
0AC52                           
0AC52                           MoveSwimmingCheepCheep:
0AC52 B5 1E                             lda Enemy_State,x         ;check cheep-cheep's enemy object state
0AC54 29 20                             and #%00100000            ;for d5 set
0AC56 F0 03                             beq CCSwim                ;if not set, continue with movement code
0AC58 4C 94 9F                          jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
0AC5B 85 03                     CCSwim: sta $03                   ;save enemy state in $03
0AC5D B5 16                             lda Enemy_ID,x            ;get enemy identifier
0AC5F 38                                sec
0AC60 E9 0A                             sbc #$0a                  ;subtract ten for cheep-cheep identifiers
0AC62 A8                                tay                       ;use as offset
0AC63 B9 4E AC                          lda SwimCCXMoveData,y     ;load value here
0AC66 85 02                             sta $02
0AC68 BD 01 04                          lda Enemy_X_MoveForce,x   ;load horizontal force
0AC6B 38                                sec
0AC6C E5 02                             sbc $02                   ;subtract preset value from horizontal force
0AC6E 9D 01 04                          sta Enemy_X_MoveForce,x   ;store as new horizontal force
0AC71 B5 87                             lda Enemy_X_Position,x    ;get horizontal coordinate
0AC73 E9 00                             sbc #$00                  ;subtract borrow (thus moving it slowly)
0AC75 95 87                             sta Enemy_X_Position,x    ;and save as new horizontal coordinate
0AC77 B5 6E                             lda Enemy_PageLoc,x
0AC79 E9 00                             sbc #$00                  ;subtract borrow again, this time from the
0AC7B 95 6E                             sta Enemy_PageLoc,x       ;page location, then save
0AC7D A9 20                             lda #$20
0AC7F 85 02                             sta $02                   ;save new value here
0AC81 E0 02                             cpx #$02                  ;check enemy object offset
0AC83 90 49                             bcc ExSwCC                ;if in first or second slot, branch to leave
0AC85 B5 58                             lda CheepCheepMoveMFlag,x ;check movement flag
0AC87 C9 10                             cmp #$10                  ;if movement speed set to $00,
0AC89 90 16                             bcc CCSwimUpwards         ;branch to move upwards
0AC8B BD 17 04                          lda Enemy_YMF_Dummy,x
0AC8E 18                                clc
0AC8F 65 02                             adc $02                   ;add preset value to dummy variable to get carry
0AC91 9D 17 04                          sta Enemy_YMF_Dummy,x     ;and save dummy
0AC94 B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0AC96 65 03                             adc $03                   ;add carry to it plus enemy state to slowly move it downwards
0AC98 95 CF                             sta Enemy_Y_Position,x    ;save as new vertical coordinate
0AC9A B5 B6                             lda Enemy_Y_HighPos,x
0AC9C 69 00                             adc #$00                  ;add carry to page location and
0AC9E 4C B4 AC                          jmp ChkSwimYPos           ;jump to end of movement code
0ACA1                           
0ACA1                           CCSwimUpwards:
0ACA1 BD 17 04                          lda Enemy_YMF_Dummy,x
0ACA4 38                                sec
0ACA5 E5 02                             sbc $02                   ;subtract preset value to dummy variable to get borrow
0ACA7 9D 17 04                          sta Enemy_YMF_Dummy,x     ;and save dummy
0ACAA B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0ACAC E5 03                             sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
0ACAE 95 CF                             sta Enemy_Y_Position,x    ;save as new vertical coordinate
0ACB0 B5 B6                             lda Enemy_Y_HighPos,x
0ACB2 E9 00                             sbc #$00                  ;subtract borrow from page location
0ACB4                           
0ACB4                           ChkSwimYPos:
0ACB4 95 B6                             sta Enemy_Y_HighPos,x     ;save new page location here
0ACB6 A0 00                             ldy #$00                  ;load movement speed to upwards by default
0ACB8 B5 CF                             lda Enemy_Y_Position,x    ;get vertical coordinate
0ACBA 38                                sec
0ACBB FD 34 04                          sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
0ACBE 10 07                             bpl YPDiff                ;if result positive, skip to next part
0ACC0 A0 10                             ldy #$10                  ;otherwise load movement speed to downwards
0ACC2 49 FF                             eor #$ff
0ACC4 18                                clc                       ;get two's compliment of result
0ACC5 69 01                             adc #$01                  ;to obtain total difference of original vs. current
0ACC7 C9 0F                     YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
0ACC9 90 03                             bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
0ACCB 98                                tya
0ACCC 95 58                             sta CheepCheepMoveMFlag,x ;otherwise change movement speed
0ACCE 60                        ExSwCC: rts                       ;leave
0ACCF                           
0ACCF                           ;--------------------------------
0ACCF                           ;$00 - used as counter for firebar parts
0ACCF                           ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
0ACCF                           ;$02 - used for oscillated high byte of spin state or to hold vertical adder
0ACCF                           ;$03 - used for mirror data
0ACCF                           ;$04 - used to store player's sprite 1 X coordinate
0ACCF                           ;$05 - used to evaluate mirror data
0ACCF                           ;$06 - used to store either screen X coordinate or sprite data offset
0ACCF                           ;$07 - used to store screen Y coordinate
0ACCF                           ;$ed - used to hold maximum length of firebar
0ACCF                           ;$ef - used to hold high byte of spinstate
0ACCF                           
0ACCF                           ;horizontal adder is at first byte + high byte of spinstate,
0ACCF                           ;vertical adder is same + 8 bytes, two's compliment
0ACCF                           ;if greater than $08 for proper oscillation
0ACCF                           FirebarPosLookupTbl:
0ACCF 00 01 03 04 05 06 07 07..       .db $00, $01, $03, $04, $05, $06, $07, $07, $08
0ACD8 00 03 06 09 0B 0D 0E 0F..       .db $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
0ACE1 00 04 09 0D 10 13 16 17..       .db $00, $04, $09, $0d, $10, $13, $16, $17, $18
0ACEA 00 06 0C 12 16 1A 1D 1F..       .db $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
0ACF3 00 07 0F 16 1C 21 25 27..       .db $00, $07, $0f, $16, $1c, $21, $25, $27, $28
0ACFC 00 09 12 1B 21 27 2C 2F..       .db $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
0AD05 00 0B 15 1F 27 2E 33 37..       .db $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
0AD0E 00 0C 18 24 2D 35 3B 3E..       .db $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
0AD17 00 0E 1B 28 32 3B 42 46..       .db $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
0AD20 00 0F 1F 2D 38 42 4A 4E..       .db $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
0AD29 00 11 22 31 3E 49 51 56..       .db $00, $11, $22, $31, $3e, $49, $51, $56, $58
0AD32                           
0AD32                           FirebarMirrorData:
0AD32 01 03 02 00                     .db $01, $03, $02, $00
0AD36                           
0AD36                           FirebarTblOffsets:
0AD36 00 09 12 1B 24 2D               .db $00, $09, $12, $1b, $24, $2d
0AD3C 36 3F 48 51 5A 63               .db $36, $3f, $48, $51, $5a, $63
0AD42                           
0AD42                           FirebarYPos:
0AD42 0C 18                           .db $0c, $18
0AD44                           
0AD44                           ProcFirebar:
0AD44 20 B3 D1                            jsr GetEnemyOffscreenBits   ;get offscreen information
0AD47 AD D1 03                            lda Enemy_OffscreenBits     ;check for d3 set
0AD4A 29 08                               and #%00001000              ;if so, branch to leave
0AD4C D0 74                               bne SkipFBar
0AD4E AD 47 07                            lda TimerControl            ;if master timer control set, branch
0AD51 D0 0A                               bne SusFbar                 ;ahead of this part
0AD53 BD 88 03                            lda FirebarSpinSpeed,x      ;load spinning speed of firebar
0AD56 20 18 B4                            jsr FirebarSpin             ;modify current spinstate
0AD59 29 1F                               and #%00011111              ;mask out all but 5 LSB
0AD5B 95 A0                               sta FirebarSpinState_High,x ;and store as new high byte of spinstate
0AD5D B5 A0                     SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
0AD5F B4 16                               ldy Enemy_ID,x              ;check enemy identifier
0AD61 C0 1F                               cpy #$1f
0AD63 90 0D                               bcc SetupGFB                ;if < $1f (long firebar), branch
0AD65 C9 08                               cmp #$08                    ;check high byte of spinstate
0AD67 F0 04                               beq SkpFSte                 ;if eight, branch to change
0AD69 C9 18                               cmp #$18
0AD6B D0 05                               bne SetupGFB                ;if not at twenty-four branch to not change
0AD6D 18                        SkpFSte:  clc
0AD6E 69 01                               adc #$01                    ;add one to spinning thing to avoid horizontal state
0AD70 95 A0                               sta FirebarSpinState_High,x
0AD72 85 EF                     SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
0AD74 20 56 D1                            jsr RelativeEnemyPosition   ;get relative coordinates to screen
0AD77 20 96 AE                            jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
0AD7A BC E5 06                            ldy Enemy_SprDataOffset,x   ;get OAM data offset
0AD7D AD B9 03                            lda Enemy_Rel_YPos          ;get relative vertical coordinate
0AD80 99 00 02                            sta Sprite_Y_Position,y     ;store as Y in OAM data
0AD83 85 07                               sta $07                     ;also save here
0AD85 AD AE 03                            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0AD88 99 03 02                            sta Sprite_X_Position,y     ;store as X in OAM data
0AD8B 85 06                               sta $06                     ;also save here
0AD8D A9 01                               lda #$01
0AD8F 85 00                               sta $00                     ;set $01 value here (not necessary)
0AD91 20 10 AE                            jsr FirebarCollision        ;draw fireball part and do collision detection
0AD94 A0 05                               ldy #$05                    ;load value for short firebars by default
0AD96 B5 16                               lda Enemy_ID,x
0AD98 C9 1F                               cmp #$1f                    ;are we doing a long firebar?
0AD9A 90 02                               bcc SetMFbar                ;no, branch then
0AD9C A0 0B                               ldy #$0b                    ;otherwise load value for long firebars
0AD9E 84 ED                     SetMFbar: sty $ed                     ;store maximum value for length of firebars
0ADA0 A9 00                               lda #$00
0ADA2 85 00                               sta $00                     ;initialize counter here
0ADA4 A5 EF                     DrawFbar: lda $ef                     ;load high byte of spinstate
0ADA6 20 96 AE                            jsr GetFirebarPosition      ;get fireball position data depending on firebar part
0ADA9 20 C3 AD                            jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
0ADAC A5 00                               lda $00                     ;check which firebar part
0ADAE C9 04                               cmp #$04
0ADB0 D0 08                               bne NextFbar
0ADB2 AC CF 06                            ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
0ADB5 B9 E5 06                            lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
0ADB8 85 06                               sta $06                     ;using long firebar offset, then store as new one here
0ADBA E6 00                     NextFbar: inc $00                     ;move onto the next firebar part
0ADBC A5 00                               lda $00
0ADBE C5 ED                               cmp $ed                     ;if we end up at the maximum part, go on and leave
0ADC0 90 E2                               bcc DrawFbar                ;otherwise go back and do another
0ADC2 60                        SkipFBar: rts
0ADC3                           
0ADC3                           DrawFirebar_Collision:
0ADC3 A5 03                              lda $03                  ;store mirror data elsewhere
0ADC5 85 05                              sta $05          
0ADC7 A4 06                              ldy $06                  ;load OAM data offset for firebar
0ADC9 A5 01                              lda $01                  ;load horizontal adder we got from position loader
0ADCB 46 05                              lsr $05                  ;shift LSB of mirror data
0ADCD B0 04                              bcs AddHA                ;if carry was set, skip this part
0ADCF 49 FF                              eor #$ff
0ADD1 69 01                              adc #$01                 ;otherwise get two's compliment of horizontal adder
0ADD3 18                        AddHA:   clc                      ;add horizontal coordinate relative to screen to
0ADD4 6D AE 03                           adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
0ADD7 99 03 02                           sta Sprite_X_Position,y  ;store as X coordinate here
0ADDA 85 06                              sta $06                  ;store here for now, note offset is saved in Y still
0ADDC CD AE 03                           cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
0ADDF B0 09                              bcs SubtR1               ;if sprite coordinate => original coordinate, branch
0ADE1 AD AE 03                           lda Enemy_Rel_XPos
0ADE4 38                                 sec                      ;otherwise subtract sprite X from the
0ADE5 E5 06                              sbc $06                  ;original one and skip this part
0ADE7 4C EE AD                           jmp ChkFOfs
0ADEA 38                        SubtR1:  sec                      ;subtract original X from the
0ADEB ED AE 03                           sbc Enemy_Rel_XPos       ;current sprite X
0ADEE C9 59                     ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
0ADF0 90 04                              bcc VAHandl              ;continue by handling vertical adder
0ADF2 A9 F8                              lda #$f8                 ;otherwise, load offscreen Y coordinate
0ADF4 D0 15                              bne SetVFbr              ;and unconditionally branch to move sprite offscreen
0ADF6 AD B9 03                  VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
0ADF9 C9 F8                              cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
0ADFB F0 0E                              beq SetVFbr
0ADFD A5 02                              lda $02                  ;load vertical adder we got from position loader
0ADFF 46 05                              lsr $05                  ;shift LSB of mirror data one more time
0AE01 B0 04                              bcs AddVA                ;if carry was set, skip this part
0AE03 49 FF                              eor #$ff
0AE05 69 01                              adc #$01                 ;otherwise get two's compliment of second part
0AE07 18                        AddVA:   clc                      ;add vertical coordinate relative to screen to 
0AE08 6D B9 03                           adc Enemy_Rel_YPos       ;the second data, modified or otherwise
0AE0B 99 00 02                  SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
0AE0E 85 07                              sta $07                  ;also store here for now
0AE10                           
0AE10                           FirebarCollision:
0AE10 20 F1 CC                           jsr DrawFirebar          ;run sub here to draw current tile of firebar
0AE13 98                                 tya                      ;return OAM data offset and save
0AE14 48                                 pha                      ;to the stack for now
0AE15 AD 9F 07                           lda StarInvincibleTimer  ;if star mario invincibility timer
0AE18 0D 47 07                           ora TimerControl         ;or master timer controls set
0AE1B D0 70                              bne NoColFB              ;then skip all of this
0AE1D 85 05                              sta $05                  ;otherwise initialize counter
0AE1F A4 B5                              ldy Player_Y_HighPos
0AE21 88                                 dey                      ;if player's vertical high byte offscreen,
0AE22 D0 69                              bne NoColFB              ;skip all of this
0AE24 A4 CE                              ldy Player_Y_Position    ;get player's vertical position
0AE26 AD 54 07                           lda PlayerSize           ;get player's size
0AE29 D0 05                              bne AdjSm                ;if player small, branch to alter variables
0AE2B AD 14 07                           lda CrouchingFlag
0AE2E F0 09                              beq BigJp                ;if player big and not crouching, jump ahead
0AE30 E6 05                     AdjSm:   inc $05                  ;if small or big but crouching, execute this part
0AE32 E6 05                              inc $05                  ;first increment our counter twice (setting $02 as flag)
0AE34 98                                 tya
0AE35 18                                 clc                      ;then add 24 pixels to the player's
0AE36 69 18                              adc #$18                 ;vertical coordinate
0AE38 A8                                 tay
0AE39 98                        BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
0AE3A 38                        FBCLoop: sec                      ;subtract vertical position of firebar
0AE3B E5 07                              sbc $07                  ;from the vertical coordinate of the player
0AE3D 10 05                              bpl ChkVFBD              ;if player lower on the screen than firebar, 
0AE3F 49 FF                              eor #$ff                 ;skip two's compliment part
0AE41 18                                 clc                      ;otherwise get two's compliment
0AE42 69 01                              adc #$01
0AE44 C9 08                     ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
0AE46 B0 1C                              bcs Chk2Ofs
0AE48 A5 06                              lda $06                  ;if firebar on far right on the screen, skip this,
0AE4A C9 F0                              cmp #$f0                 ;because, really, what's the point?
0AE4C B0 16                              bcs Chk2Ofs
0AE4E AD 07 02                           lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
0AE51 18                                 clc
0AE52 69 04                              adc #$04                 ;add four pixels
0AE54 85 04                              sta $04                  ;store here
0AE56 38                                 sec                      ;subtract horizontal coordinate of firebar
0AE57 E5 06                              sbc $06                  ;from the X coordinate of player's sprite 1
0AE59 10 05                              bpl ChkFBCl              ;if modded X coordinate to the right of firebar
0AE5B 49 FF                              eor #$ff                 ;skip two's compliment part
0AE5D 18                                 clc                      ;otherwise get two's compliment
0AE5E 69 01                              adc #$01
0AE60 C9 08                     ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
0AE62 90 13                              bcc ChgSDir              ;to process
0AE64 A5 05                     Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
0AE66 C9 02                              cmp #$02                 ;branch to increment OAM offset and leave, no collision
0AE68 F0 23                              beq NoColFB
0AE6A A4 05                              ldy $05                  ;otherwise get temp here and use as offset
0AE6C A5 CE                              lda Player_Y_Position
0AE6E 18                                 clc
0AE6F 79 42 AD                           adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
0AE72 E6 05                              inc $05                  ;then increment temp and jump back
0AE74 4C 3A AE                           jmp FBCLoop
0AE77 A2 01                     ChgSDir: ldx #$01                 ;set movement direction by default
0AE79 A5 04                              lda $04                  ;if OAM X coordinate of player's sprite 1
0AE7B C5 06                              cmp $06                  ;is greater than horizontal coordinate of firebar
0AE7D B0 01                              bcs SetSDir              ;then do not alter movement direction
0AE7F E8                                 inx                      ;otherwise increment it
0AE80 86 46                     SetSDir: stx Enemy_MovingDir      ;store movement direction here
0AE82 A2 00                              ldx #$00
0AE84 A5 00                              lda $00                  ;save value written to $00 to stack
0AE86 48                                 pha
0AE87 20 31 B9                           jsr InjurePlayer         ;perform sub to hurt or kill player
0AE8A 68                                 pla
0AE8B 85 00                              sta $00                  ;get value of $00 from stack
0AE8D 68                        NoColFB: pla                      ;get OAM data offset
0AE8E 18                                 clc                      ;add four to it and save
0AE8F 69 04                              adc #$04
0AE91 85 06                              sta $06
0AE93 A6 08                              ldx ObjectOffset         ;get enemy object buffer offset and leave
0AE95 60                                 rts
0AE96                           
0AE96                           GetFirebarPosition:
0AE96 48                                   pha                        ;save high byte of spinstate to the stack
0AE97 29 0F                                and #%00001111             ;mask out low nybble
0AE99 C9 09                                cmp #$09
0AE9B 90 05                                bcc GetHAdder              ;if lower than $09, branch ahead
0AE9D 49 0F                                eor #%00001111             ;otherwise get two's compliment to oscillate
0AE9F 18                                   clc
0AEA0 69 01                                adc #$01
0AEA2 85 01                     GetHAdder: sta $01                    ;store result, modified or not, here
0AEA4 A4 00                                ldy $00                    ;load number of firebar ball where we're at
0AEA6 B9 36 AD                             lda FirebarTblOffsets,y    ;load offset to firebar position data
0AEA9 18                                   clc
0AEAA 65 01                                adc $01                    ;add oscillated high byte of spinstate
0AEAC A8                                   tay                        ;to offset here and use as new offset
0AEAD B9 CF AC                             lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
0AEB0 85 01                                sta $01
0AEB2 68                                   pla                        ;pull whatever was in A from the stack
0AEB3 48                                   pha                        ;save it again because we still need it
0AEB4 18                                   clc
0AEB5 69 08                                adc #$08                   ;add eight this time, to get vertical adder
0AEB7 29 0F                                and #%00001111             ;mask out high nybble
0AEB9 C9 09                                cmp #$09                   ;if lower than $09, branch ahead
0AEBB 90 05                                bcc GetVAdder
0AEBD 49 0F                                eor #%00001111             ;otherwise get two's compliment
0AEBF 18                                   clc
0AEC0 69 01                                adc #$01
0AEC2 85 02                     GetVAdder: sta $02                    ;store result here
0AEC4 A4 00                                ldy $00
0AEC6 B9 36 AD                             lda FirebarTblOffsets,y    ;load offset to firebar position data again
0AEC9 18                                   clc
0AECA 65 02                                adc $02                    ;this time add value in $02 to offset here and use as offset
0AECC A8                                   tay
0AECD B9 CF AC                             lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
0AED0 85 02                                sta $02
0AED2 68                                   pla                        ;pull out whatever was in A one last time
0AED3 4A                                   lsr                        ;divide by eight or shift three to the right
0AED4 4A                                   lsr
0AED5 4A                                   lsr
0AED6 A8                                   tay                        ;use as offset
0AED7 B9 32 AD                             lda FirebarMirrorData,y    ;load mirroring data here
0AEDA 85 03                                sta $03                    ;store
0AEDC 60                                   rts
0AEDD                           
0AEDD                           ;--------------------------------
0AEDD                           
0AEDD                           PRandomSubtracter:
0AEDD F8 A0 70 BD 00                  .db $f8, $a0, $70, $bd, $00
0AEE2                           
0AEE2                           FlyCCBPriority:
0AEE2 20 20 20 00 00                  .db $20, $20, $20, $00, $00
0AEE7                           
0AEE7                           MoveFlyingCheepCheep:
0AEE7 B5 1E                             lda Enemy_State,x          ;check cheep-cheep's enemy state
0AEE9 29 20                             and #%00100000             ;for d5 set
0AEEB F0 08                             beq FlyCC                  ;branch to continue code if not set
0AEED A9 00                             lda #$00
0AEEF 9D C5 03                          sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
0AEF2 4C 9A 9F                          jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
0AEF5 20 0A 9F                  FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
0AEF8 A0 0D                             ldy #$0d                   ;set vertical movement amount
0AEFA A9 05                             lda #$05                   ;set maximum speed
0AEFC 20 9E 9F                          jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
0AEFF BD 34 04                          lda Enemy_Y_MoveForce,x
0AF02 4A                                lsr                        ;get vertical movement force and
0AF03 4A                                lsr                        ;move high nybble to low
0AF04 4A                                lsr
0AF05 4A                                lsr
0AF06 A8                                tay                        ;save as offset (note this tends to go into reach of code)
0AF07 B5 CF                             lda Enemy_Y_Position,x     ;get vertical position
0AF09 38                                sec                        ;subtract pseudorandom value based on offset from position
0AF0A F9 DD AE                          sbc PRandomSubtracter,y
0AF0D 10 05                             bpl AddCCF                  ;if result within top half of screen, skip this part
0AF0F 49 FF                             eor #$ff
0AF11 18                                clc                        ;otherwise get two's compliment
0AF12 69 01                             adc #$01
0AF14 C9 08                     AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
0AF16 B0 0E                             bcs BPGet                  ;skip to the end without changing movement force
0AF18 BD 34 04                          lda Enemy_Y_MoveForce,x
0AF1B 18                                clc
0AF1C 69 10                             adc #$10                   ;otherwise add to it
0AF1E 9D 34 04                          sta Enemy_Y_MoveForce,x
0AF21 4A                                lsr                        ;move high nybble to low again
0AF22 4A                                lsr
0AF23 4A                                lsr
0AF24 4A                                lsr
0AF25 A8                                tay
0AF26 B9 E2 AE                  BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
0AF29 9D C5 03                          sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
0AF2C 60                                rts                        ;drawing it next frame), then leave
0AF2D                           
0AF2D                           ;--------------------------------
0AF2D                           ;$00 - used to hold horizontal difference
0AF2D                           ;$01-$03 - used to hold difference adjusters
0AF2D                           
0AF2D                           LakituDiffAdj:
0AF2D 15 30 40                        .db $15, $30, $40
0AF30                           
0AF30                           MoveLakitu:
0AF30 B5 1E                              lda Enemy_State,x          ;check lakitu's enemy state
0AF32 29 20                              and #%00100000             ;for d5 set
0AF34 F0 03                              beq ChkLS                  ;if not set, continue with code
0AF36 4C 6B 9F                           jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
0AF39 B5 1E                     ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
0AF3B F0 0B                              beq Fr12S                  ;go ahead and continue with code
0AF3D A9 00                              lda #$00
0AF3F 95 A0                              sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
0AF41 8D CB 06                           sta EnemyFrenzyBuffer      ;initialize frenzy buffer
0AF44 A9 10                              lda #$10
0AF46 D0 13                              bne SetLSpd                ;load horizontal speed and do unconditional branch
0AF48 A9 12                     Fr12S:   lda #Spiny
0AF4A 8D CB 06                           sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
0AF4D A0 02                              ldy #$02
0AF4F B9 2D AF                  LdLDa:   lda LakituDiffAdj,y        ;load values
0AF52 99 01 00                           sta $0001,y                ;store in zero page
0AF55 88                                 dey
0AF56 10 F7                              bpl LdLDa                  ;do this until all values are stired
0AF58 20 74 AF                           jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
0AF5B 95 58                     SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
0AF5D A0 01                              ldy #$01                   ;set moving direction to right by default
0AF5F B5 A0                              lda LakituMoveDirection,x
0AF61 29 01                              and #$01                   ;get LSB of moving direction
0AF63 D0 0A                              bne SetLMov                ;if set, branch to the end to use moving direction
0AF65 B5 58                              lda LakituMoveSpeed,x
0AF67 49 FF                              eor #$ff                   ;get two's compliment of moving speed
0AF69 18                                 clc
0AF6A 69 01                              adc #$01
0AF6C 95 58                              sta LakituMoveSpeed,x      ;store as new moving speed
0AF6E C8                                 iny                        ;increment moving direction to left
0AF6F 94 46                     SetLMov: sty Enemy_MovingDir,x      ;store moving direction
0AF71 4C 0A 9F                           jmp MoveEnemyHorizontally  ;move lakitu horizontally
0AF74                           
0AF74                           PlayerLakituDiff:
0AF74 A0 00                                ldy #$00                   ;set Y for default value
0AF76 20 48 C1                             jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
0AF79 10 0A                                bpl ChkLakDif              ;branch if enemy is to the right of the player
0AF7B C8                                   iny                        ;increment Y for left of player
0AF7C A5 00                                lda $00
0AF7E 49 FF                                eor #$ff                   ;get two's compliment of low byte of horizontal difference
0AF80 18                                   clc
0AF81 69 01                                adc #$01                   ;store two's compliment as horizontal difference
0AF83 85 00                                sta $00
0AF85 A5 00                     ChkLakDif: lda $00                    ;get low byte of horizontal difference
0AF87 C9 3C                                cmp #$3c                   ;if within a certain distance of player, branch
0AF89 90 1C                                bcc ChkPSpeed
0AF8B A9 3C                                lda #$3c                   ;otherwise set maximum distance
0AF8D 85 00                                sta $00
0AF8F B5 16                                lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
0AF91 C9 11                                cmp #Lakitu
0AF93 D0 12                                bne ChkPSpeed              ;if not, branch elsewhere
0AF95 98                                   tya                        ;compare contents of Y, now in A
0AF96 D5 A0                                cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
0AF98 F0 0D                                beq ChkPSpeed              ;if moving toward the player, branch, do not alter
0AF9A B5 A0                                lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
0AF9C F0 06                                beq SetLMovD               ;branch and alter without delay
0AF9E D6 58                                dec LakituMoveSpeed,x      ;decrement horizontal speed
0AFA0 B5 58                                lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
0AFA2 D0 40                                bne ExMoveLak
0AFA4 98                        SetLMovD:  tya                        ;set horizontal direction depending on horizontal
0AFA5 95 A0                                sta LakituMoveDirection,x  ;difference between enemy and player if necessary
0AFA7 A5 00                     ChkPSpeed: lda $00
0AFA9 29 3C                                and #%00111100             ;mask out all but four bits in the middle
0AFAB 4A                                   lsr                        ;divide masked difference by four
0AFAC 4A                                   lsr
0AFAD 85 00                                sta $00                    ;store as new value
0AFAF A0 00                                ldy #$00                   ;init offset
0AFB1 A5 57                                lda Player_X_Speed
0AFB3 F0 24                                beq SubDifAdj              ;if player not moving horizontally, branch
0AFB5 AD 75 07                             lda ScrollAmount
0AFB8 F0 1F                                beq SubDifAdj              ;if scroll speed not set, branch to same place
0AFBA C8                                   iny                        ;otherwise increment offset
0AFBB A5 57                                lda Player_X_Speed
0AFBD C9 19                                cmp #$19                   ;if player not running, branch
0AFBF 90 08                                bcc ChkSpinyO
0AFC1 AD 75 07                             lda ScrollAmount
0AFC4 C9 02                                cmp #$02                   ;if scroll speed below a certain amount, branch
0AFC6 90 01                                bcc ChkSpinyO              ;to same place
0AFC8 C8                                   iny                        ;otherwise increment once more
0AFC9 B5 16                     ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
0AFCB C9 12                                cmp #Spiny
0AFCD D0 04                                bne ChkEmySpd              ;branch if not found
0AFCF A5 57                                lda Player_X_Speed         ;if player not moving, skip this part
0AFD1 D0 06                                bne SubDifAdj
0AFD3 B5 A0                     ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
0AFD5 D0 02                                bne SubDifAdj              ;branch if nonzero
0AFD7 A0 00                                ldy #$00                   ;otherwise reinit offset
0AFD9 B9 01 00                  SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
0AFDC A4 00                                ldy $00                    ;get saved horizontal difference
0AFDE 38                        SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
0AFDF E9 01                                sbc #$01                   ;from one of three saved values
0AFE1 88                                   dey
0AFE2 10 FA                                bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
0AFE4 60                        ExMoveLak: rts                        ;leave!!!
0AFE5                           
0AFE5                           ;-------------------------------------------------------------------------------------
0AFE5                           ;$04-$05 - used to store name table address in little endian order
0AFE5                           
0AFE5                           BridgeCollapseData:
0AFE5 1A                              .db $1a ;axe
0AFE6 58                              .db $58 ;chain
0AFE7 98 96 94 92 90 8E 8C            .db $98, $96, $94, $92, $90, $8e, $8c ;bridge
0AFEE 8A 88 86 84 82 80               .db $8a, $88, $86, $84, $82, $80
0AFF4                           
0AFF4                           BridgeCollapse:
0AFF4 AE 68 03                         ldx BowserFront_Offset    ;get enemy offset for bowser
0AFF7 B5 16                            lda Enemy_ID,x            ;check enemy object identifier for bowser
0AFF9 C9 2D                            cmp #Bowser               ;if not found, branch ahead,
0AFFB D0 10                            bne SetM2                 ;metatile removal not necessary
0AFFD 86 08                            stx ObjectOffset          ;store as enemy offset here
0AFFF B5 1E                            lda Enemy_State,x         ;if bowser in normal state, skip all of this
0B001 F0 1A                            beq RemoveBridge
0B003 29 40                            and #%01000000            ;if bowser's state has d6 clear, skip to silence music
0B005 F0 06                            beq SetM2
0B007 B5 CF                            lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
0B009 C9 E0                            cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
0B00B 90 0A                            bcc MoveD_Bowser
0B00D A9 80                     SetM2: lda #Silence              ;silence music
0B00F 85 FC                            sta EventMusicQueue
0B011 EE 72 07                         inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
0B014 4C 79 B0                         jmp KillAllEnemies        ;jump to empty all enemy slots and then leave  
0B017                           
0B017                           MoveD_Bowser:
0B017 20 94 9F                         jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
0B01A 4C 83 B1                         jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
0B01D                           
0B01D                           RemoveBridge:
0B01D CE 64 03                           dec BowserFeetCounter     ;decrement timer to control bowser's feet
0B020 D0 44                              bne NoBFall               ;if not expired, skip all of this
0B022 A9 04                              lda #$04
0B024 8D 64 03                           sta BowserFeetCounter     ;otherwise, set timer now
0B027 AD 63 03                           lda BowserBodyControls
0B02A 49 01                              eor #$01                  ;invert bit to control bowser's feet
0B02C 8D 63 03                           sta BowserBodyControls
0B02F A9 22                              lda #$22                  ;put high byte of name table address here for now
0B031 85 05                              sta $05
0B033 AC 69 03                           ldy BridgeCollapseOffset  ;get bridge collapse offset here
0B036 B9 E5 AF                           lda BridgeCollapseData,y  ;load low byte of name table address and store here
0B039 85 04                              sta $04
0B03B AC 00 03                           ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
0B03E C8                                 iny
0B03F A2 0C                              ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
0B041 20 D3 6A                           jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
0B044 A6 08                              ldx ObjectOffset          ;get enemy offset
0B046 20 95 6A                           jsr MoveVOffset           ;set new vram buffer offset
0B049 A9 08                              lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
0B04B 85 FE                              sta Square2SoundQueue     ;queue while at the same time loading the brick
0B04D A9 01                              lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
0B04F 85 FD                              sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing 
0B051 EE 69 03                           inc BridgeCollapseOffset  ;increment bridge collapse offset
0B054 AD 69 03                           lda BridgeCollapseOffset
0B057 C9 0F                              cmp #$0f                  ;if bridge collapse offset has not yet reached
0B059 D0 0B                              bne NoBFall               ;the end, go ahead and skip this part
0B05B 20 6B A3                           jsr InitVStf              ;initialize whatever vertical speed bowser has
0B05E A9 40                              lda #%01000000
0B060 95 1E                              sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
0B062 A9 80                              lda #Sfx_BowserFall
0B064 85 FE                              sta Square2SoundQueue     ;play bowser defeat sound
0B066 4C 83 B1                  NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
0B069                           
0B069                           ;--------------------------------
0B069                           
0B069                           PRandomRange:
0B069 21 41 11 31                     .db $21, $41, $11, $31
0B06D                           
0B06D                           RunBowser:
0B06D B5 1E                           lda Enemy_State,x       ;if d5 in enemy state is not set
0B06F 29 20                           and #%00100000          ;then branch elsewhere to run bowser
0B071 F0 14                           beq BowserControl
0B073 B5 CF                           lda Enemy_Y_Position,x  ;otherwise check vertical position
0B075 C9 E0                           cmp #$e0                ;if above a certain point, branch to move defeated bowser
0B077 90 9E                           bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
0B079                           
0B079                           KillAllEnemies:
0B079 A2 04                               ldx #$04              ;start with last enemy slot
0B07B 20 A0 A9                  KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
0B07E CA                                  dex                   ;move onto next enemy slot
0B07F 10 FA                               bpl KillLoop          ;do this until all slots are emptied
0B081 8D CB 06                            sta EnemyFrenzyBuffer ;empty frenzy buffer
0B084 A6 08                               ldx ObjectOffset      ;get enemy object offset and leave
0B086 60                                  rts
0B087                           
0B087                           BowserControl:
0B087 A9 00                                lda #$00
0B089 8D CB 06                             sta EnemyFrenzyBuffer      ;empty frenzy buffer
0B08C AD 47 07                             lda TimerControl           ;if master timer control not set,
0B08F F0 03                                beq ChkMouth               ;skip jump and execute code here
0B091 4C 41 B1                             jmp SkipToFB               ;otherwise, jump over a bunch of code
0B094 AD 63 03                  ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
0B097 10 03                                bpl FeetTmr                ;if bit clear, go ahead with code here
0B099 4C 17 B1                             jmp HammerChk              ;otherwise skip a whole section starting here
0B09C CE 64 03                  FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
0B09F D0 0D                                bne ResetMDr               ;if not expired, skip this part
0B0A1 A9 20                                lda #$20                   ;otherwise, reset timer
0B0A3 8D 64 03                             sta BowserFeetCounter        
0B0A6 AD 63 03                             lda BowserBodyControls     ;and invert bit used
0B0A9 49 01                                eor #%00000001             ;to control bowser's feet
0B0AB 8D 63 03                             sta BowserBodyControls
0B0AE A5 09                     ResetMDr:  lda FrameCounter           ;check frame counter
0B0B0 29 0F                                and #%00001111             ;if not on every sixteenth frame, skip
0B0B2 D0 04                                bne B_FaceP                ;ahead to continue code
0B0B4 A9 02                                lda #$02                   ;otherwise reset moving/facing direction every
0B0B6 95 46                                sta Enemy_MovingDir,x      ;sixteen frames
0B0B8 BD 8A 07                  B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
0B0BB F0 1C                                beq GetPRCmp               ;branch to next section
0B0BD 20 48 C1                             jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
0B0C0 10 17                                bpl GetPRCmp               ;and branch if bowser to the right of the player
0B0C2 A9 01                                lda #$01
0B0C4 95 46                                sta Enemy_MovingDir,x      ;set bowser to move and face to the right
0B0C6 A9 02                                lda #$02
0B0C8 8D 65 03                             sta BowserMovementSpeed    ;set movement speed
0B0CB A9 20                                lda #$20
0B0CD 9D 8A 07                             sta EnemyFrameTimer,x      ;set timer here
0B0D0 8D 90 07                             sta BowserFireBreathTimer  ;set timer used for bowser's flame
0B0D3 B5 87                                lda Enemy_X_Position,x        
0B0D5 C9 C8                                cmp #$c8                   ;if bowser to the right past a certain point,
0B0D7 B0 3E                                bcs HammerChk              ;skip ahead to some other section
0B0D9 A5 09                     GetPRCmp:  lda FrameCounter           ;get frame counter
0B0DB 29 03                                and #%00000011
0B0DD D0 38                                bne HammerChk              ;execute this code every fourth frame, otherwise branch
0B0DF B5 87                                lda Enemy_X_Position,x
0B0E1 CD 66 03                             cmp BowserOrigXPos         ;if bowser not at original horizontal position,
0B0E4 D0 0C                                bne GetDToO                ;branch to skip this part
0B0E6 BD A7 07                             lda PseudoRandomBitReg,x
0B0E9 29 03                                and #%00000011             ;get pseudorandom offset
0B0EB A8                                   tay
0B0EC B9 69 B0                             lda PRandomRange,y         ;load value using pseudorandom offset
0B0EF 8D DC 06                             sta MaxRangeFromOrigin     ;and store here
0B0F2 B5 87                     GetDToO:   lda Enemy_X_Position,x
0B0F4 18                                   clc                        ;add movement speed to bowser's horizontal
0B0F5 6D 65 03                             adc BowserMovementSpeed    ;coordinate and save as new horizontal position
0B0F8 95 87                                sta Enemy_X_Position,x
0B0FA B4 46                                ldy Enemy_MovingDir,x
0B0FC C0 01                                cpy #$01                   ;if bowser moving and facing to the right, skip ahead
0B0FE F0 17                                beq HammerChk
0B100 A0 FF                                ldy #$ff                   ;set default movement speed here (move left)
0B102 38                                   sec                        ;get difference of current vs. original
0B103 ED 66 03                             sbc BowserOrigXPos         ;horizontal position
0B106 10 07                                bpl CompDToO               ;if current position to the right of original, skip ahead
0B108 49 FF                                eor #$ff
0B10A 18                                   clc                        ;get two's compliment
0B10B 69 01                                adc #$01
0B10D A0 01                                ldy #$01                   ;set alternate movement speed here (move right)
0B10F CD DC 06                  CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
0B112 90 03                                bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
0B114 8C 65 03                             sty BowserMovementSpeed    ;otherwise change bowser's movement speed
0B117 BD 8A 07                  HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
0B11A D0 28                                bne MakeBJump              ;some other section of code
0B11C 20 94 9F                             jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
0B11F AD 5F 07                             lda WorldNumber            ;check world number
0B122 C9 05                                cmp #World6
0B124 90 09                                bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
0B126 A5 09                                lda FrameCounter
0B128 29 03                                and #%00000011             ;check to see if it's time to execute sub
0B12A D0 03                                bne SetHmrTmr              ;if not, skip sub, otherwise
0B12C 20 9C 9A                             jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
0B12F B5 CF                     SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
0B131 C9 80                                cmp #$80                   ;if still above a certain point
0B133 90 1C                                bcc ChkFireB               ;then skip to world number check for flames
0B135 BD A7 07                             lda PseudoRandomBitReg,x
0B138 29 03                                and #%00000011             ;get pseudorandom offset
0B13A A8                                   tay
0B13B B9 69 B0                             lda PRandomRange,y         ;get value using pseudorandom offset
0B13E 9D 8A 07                             sta EnemyFrameTimer,x      ;set for timer here
0B141 4C 51 B1                  SkipToFB:  jmp ChkFireB               ;jump to execute flames code
0B144 C9 01                     MakeBJump: cmp #$01                   ;if timer not yet about to expire,
0B146 D0 09                                bne ChkFireB               ;skip ahead to next part
0B148 D6 CF                                dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
0B14A 20 6B A3                             jsr InitVStf               ;initialize movement amount
0B14D A9 FE                                lda #$fe
0B14F 95 A0                                sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
0B151 AD 5F 07                  ChkFireB:  lda WorldNumber            ;check world number here
0B154 C9 07                                cmp #World8                ;world 8?
0B156 F0 04                                beq SpawnFBr               ;if so, execute this part here
0B158 C9 05                                cmp #World6                ;world 6-7?
0B15A B0 27                                bcs BowserGfxHandler       ;if so, skip this part here
0B15C AD 90 07                  SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
0B15F D0 22                                bne BowserGfxHandler       ;if not expired yet, skip all of this
0B161 A9 20                                lda #$20
0B163 8D 90 07                             sta BowserFireBreathTimer  ;set timer here
0B166 AD 63 03                             lda BowserBodyControls
0B169 49 80                                eor #%10000000             ;invert bowser's mouth bit to open
0B16B 8D 63 03                             sta BowserBodyControls     ;and close bowser's mouth
0B16E 30 E1                                bmi ChkFireB               ;if bowser's mouth open, loop back
0B170 20 E1 B1                             jsr SetFlameTimer          ;get timing for bowser's flame
0B173 AC CC 06                             ldy SecondaryHardMode
0B176 F0 03                                beq SetFBTmr               ;if secondary hard mode flag not set, skip this
0B178 38                                   sec
0B179 E9 10                                sbc #$10                   ;otherwise subtract from value in A
0B17B 8D 90 07                  SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
0B17E A9 15                                lda #BowserFlame           ;put bowser's flame identifier
0B180 8D CB 06                             sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
0B183                           
0B183                           ;--------------------------------
0B183                           
0B183                           BowserGfxHandler:
0B183 20 C4 B1                            jsr ProcessBowserHalf    ;do a sub here to process bowser's front
0B186 A0 10                               ldy #$10                 ;load default value here to position bowser's rear
0B188 B5 46                               lda Enemy_MovingDir,x    ;check moving direction
0B18A 4A                                  lsr
0B18B 90 02                               bcc CopyFToR             ;if moving left, use default
0B18D A0 F0                               ldy #$f0                 ;otherwise load alternate positioning value here
0B18F 98                        CopyFToR: tya                      ;move bowser's rear object position value to A
0B190 18                                  clc
0B191 75 87                               adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
0B193 AC CF 06                            ldy DuplicateObj_Offset  ;get bowser's rear object offset
0B196 99 87 00                            sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
0B199 B5 CF                               lda Enemy_Y_Position,x
0B19B 18                                  clc                      ;add eight pixels to bowser's front object
0B19C 69 08                               adc #$08                 ;vertical coordinate and store as vertical coordinate
0B19E 99 CF 00                            sta Enemy_Y_Position,y   ;for bowser's rear
0B1A1 B5 1E                               lda Enemy_State,x
0B1A3 99 1E 00                            sta Enemy_State,y        ;copy enemy state directly from front to rear
0B1A6 B5 46                               lda Enemy_MovingDir,x
0B1A8 99 46 00                            sta Enemy_MovingDir,y    ;copy moving direction also
0B1AB A5 08                               lda ObjectOffset         ;save enemy object offset of front to stack
0B1AD 48                                  pha
0B1AE AE CF 06                            ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
0B1B1 86 08                               stx ObjectOffset
0B1B3 A9 2D                               lda #Bowser              ;set bowser's enemy identifier
0B1B5 95 16                               sta Enemy_ID,x           ;store in bowser's rear object
0B1B7 20 C4 B1                            jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
0B1BA 68                                  pla
0B1BB 85 08                               sta ObjectOffset         ;get original enemy object offset
0B1BD AA                                  tax
0B1BE A9 00                               lda #$00                 ;nullify bowser's front/rear graphics flag
0B1C0 8D 6A 03                            sta BowserGfxFlag
0B1C3 60                        ExBGfxH:  rts                      ;leave!
0B1C4                           
0B1C4                           ProcessBowserHalf:
0B1C4 EE 6A 03                        inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
0B1C7 20 DF A8                        jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
0B1CA B5 1E                           lda Enemy_State,x
0B1CC D0 F5                           bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
0B1CE A9 0A                           lda #$0a
0B1D0 9D 9A 04                        sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
0B1D3 20 48 C2                        jsr GetEnemyBoundBox      ;get bounding box coordinates
0B1D6 4C 58 B8                        jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
0B1D9                           
0B1D9                           ;-------------------------------------------------------------------------------------
0B1D9                           ;$00 - used to hold movement force and tile number
0B1D9                           ;$01 - used to hold sprite attribute data
0B1D9                           
0B1D9                           FlameTimerData:
0B1D9 BF 40 BF BF BF 40 40 BF         .db $bf, $40, $bf, $bf, $bf, $40, $40, $bf
0B1E1                           
0B1E1                           SetFlameTimer:
0B1E1 AC 67 03                        ldy BowserFlameTimerCtrl  ;load counter as offset
0B1E4 EE 67 03                        inc BowserFlameTimerCtrl  ;increment
0B1E7 AD 67 03                        lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
0B1EA 29 07                           and #%00000111            ;to keep in range of 0-7
0B1EC 8D 67 03                        sta BowserFlameTimerCtrl
0B1EF B9 D9 B1                        lda FlameTimerData,y      ;load value to be used then leave
0B1F2 60                        ExFl: rts
0B1F3                           
0B1F3                           ProcBowserFlame:
0B1F3 AD 47 07                           lda TimerControl            ;if master timer control flag set,
0B1F6 D0 30                              bne SetGfxF                 ;skip all of this
0B1F8 A9 40                              lda #$40                    ;load default movement force
0B1FA AC CC 06                           ldy SecondaryHardMode
0B1FD F0 02                              beq SFlmX                   ;if secondary hard mode flag not set, use default
0B1FF A9 60                              lda #$60                    ;otherwise load alternate movement force to go faster
0B201 85 00                     SFlmX:   sta $00                     ;store value here
0B203 BD 01 04                           lda Enemy_X_MoveForce,x
0B206 38                                 sec                         ;subtract value from movement force
0B207 E5 00                              sbc $00
0B209 9D 01 04                           sta Enemy_X_MoveForce,x     ;save new value
0B20C B5 87                              lda Enemy_X_Position,x
0B20E E9 01                              sbc #$01                    ;subtract one from horizontal position to move
0B210 95 87                              sta Enemy_X_Position,x      ;to the left
0B212 B5 6E                              lda Enemy_PageLoc,x
0B214 E9 00                              sbc #$00                    ;subtract borrow from page location
0B216 95 6E                              sta Enemy_PageLoc,x
0B218 BC 17 04                           ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
0B21B B5 CF                              lda Enemy_Y_Position,x      ;load vertical coordinate
0B21D D9 A5 A5                           cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
0B220 F0 06                              beq SetGfxF                 ;if equal, branch and do not modify coordinate
0B222 18                                 clc
0B223 7D 34 04                           adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
0B226 95 CF                              sta Enemy_Y_Position,x      ;as new vertical coordinate
0B228 20 56 D1                  SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
0B22B B5 1E                              lda Enemy_State,x           ;if bowser's flame not in normal state,
0B22D D0 C3                              bne ExFl                    ;branch to leave
0B22F A9 51                              lda #$51                    ;otherwise, continue
0B231 85 00                              sta $00                     ;write first tile number
0B233 A0 02                              ldy #$02                    ;load attributes without vertical flip by default
0B235 A5 09                              lda FrameCounter
0B237 29 02                              and #%00000010              ;invert vertical flip bit every 2 frames
0B239 F0 02                              beq FlmeAt                  ;if d1 not set, write default value
0B23B A0 82                              ldy #$82                    ;otherwise write value with vertical flip bit set
0B23D 84 01                     FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
0B23F BC E5 06                           ldy Enemy_SprDataOffset,x   ;get OAM data offset
0B242 A2 00                              ldx #$00
0B244                           
0B244                           DrawFlameLoop:
0B244 AD B9 03                           lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
0B247 99 00 02                           sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
0B24A A5 00                              lda $00
0B24C 99 01 02                           sta Sprite_Tilenumber,y    ;write current tile number into OAM data
0B24F E6 00                              inc $00                    ;increment tile number to draw more bowser's flame
0B251 A5 01                              lda $01
0B253 99 02 02                           sta Sprite_Attributes,y    ;write saved attributes into OAM data
0B256 AD AE 03                           lda Enemy_Rel_XPos
0B259 99 03 02                           sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
0B25C 18                                 clc
0B25D 69 08                              adc #$08
0B25F 8D AE 03                           sta Enemy_Rel_XPos         ;then add eight to it and store
0B262 C8                                 iny
0B263 C8                                 iny
0B264 C8                                 iny
0B265 C8                                 iny                        ;increment Y four times to move onto the next OAM
0B266 E8                                 inx                        ;move onto the next OAM, and branch if three
0B267 E0 03                              cpx #$03                   ;have not yet been done
0B269 90 D9                              bcc DrawFlameLoop
0B26B A6 08                              ldx ObjectOffset           ;reload original enemy offset
0B26D 20 B3 D1                           jsr GetEnemyOffscreenBits  ;get offscreen information
0B270 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get OAM data offset
0B273 AD D1 03                           lda Enemy_OffscreenBits    ;get enemy object offscreen bits
0B276 4A                                 lsr                        ;move d0 to carry and result to stack
0B277 48                                 pha
0B278 90 05                              bcc M3FOfs                 ;branch if carry not set
0B27A A9 F8                              lda #$f8                   ;otherwise move sprite offscreen, this part likely
0B27C 99 0C 02                           sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
0B27F 68                        M3FOfs:  pla                        ;get bits from stack
0B280 4A                                 lsr                        ;move d1 to carry and move bits back to stack
0B281 48                                 pha
0B282 90 05                              bcc M2FOfs                 ;branch if carry not set again
0B284 A9 F8                              lda #$f8                   ;otherwise move third sprite offscreen
0B286 99 08 02                           sta Sprite_Y_Position+8,y
0B289 68                        M2FOfs:  pla                        ;get bits from stack again
0B28A 4A                                 lsr                        ;move d2 to carry and move bits back to stack again
0B28B 48                                 pha
0B28C 90 05                              bcc M1FOfs                 ;branch if carry not set yet again
0B28E A9 F8                              lda #$f8                   ;otherwise move second sprite offscreen
0B290 99 04 02                           sta Sprite_Y_Position+4,y
0B293 68                        M1FOfs:  pla                        ;get bits from stack one last time
0B294 4A                                 lsr                        ;move d3 to carry
0B295 90 05                              bcc ExFlmeD                ;branch if carry not set one last time
0B297 A9 F8                              lda #$f8
0B299 99 00 02                           sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
0B29C 60                        ExFlmeD: rts                        ;leave
0B29D                           
0B29D                           ;--------------------------------
0B29D                           
0B29D                           RunFireworks:
0B29D D6 A0                                dec ExplosionTimerCounter,x ;decrement explosion timing counter here
0B29F D0 0C                                bne SetupExpl               ;if not expired, skip this part
0B2A1 A9 08                                lda #$08
0B2A3 95 A0                                sta ExplosionTimerCounter,x ;reset counter
0B2A5 F6 58                                inc ExplosionGfxCounter,x   ;increment explosion graphics counter
0B2A7 B5 58                                lda ExplosionGfxCounter,x
0B2A9 C9 03                                cmp #$03                    ;check explosion graphics counter
0B2AB B0 18                                bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
0B2AD 20 56 D1                  SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
0B2B0 AD B9 03                             lda Enemy_Rel_YPos          ;copy relative coordinates
0B2B3 8D BA 03                             sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
0B2B6 AD AE 03                             lda Enemy_Rel_XPos          ;first vertical, then horizontal
0B2B9 8D AF 03                             sta Fireball_Rel_XPos
0B2BC BC E5 06                             ldy Enemy_SprDataOffset,x   ;get OAM data offset
0B2BF B5 58                                lda ExplosionGfxCounter,x   ;get explosion graphics counter
0B2C1 20 1B CD                             jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
0B2C4 60                                   rts
0B2C5                           
0B2C5                           FireworksSoundScore:
0B2C5 A9 00                           lda #$00               ;disable enemy buffer flag
0B2C7 95 0F                           sta Enemy_Flag,x
0B2C9 A9 08                           lda #Sfx_Blast         ;play fireworks/gunfire sound
0B2CB 85 FE                           sta Square2SoundQueue
0B2CD A9 05                           lda #$05               ;set part of score modifier for 500 points
0B2CF 8D 38 01                        sta DigitModifier+4
0B2D2 4C 3E B3                        jmp EndAreaPoints     ;jump to award points accordingly then leave
0B2D5                           
0B2D5                           ;--------------------------------
0B2D5                           
0B2D5                           StarFlagYPosAdder:
0B2D5 00 00 08 08                     .db $00, $00, $08, $08
0B2D9                           
0B2D9                           StarFlagXPosAdder:
0B2D9 00 08 00 08                     .db $00, $08, $00, $08
0B2DD                           
0B2DD                           StarFlagTileData:
0B2DD 54 55 56 57                     .db $54, $55, $56, $57
0B2E1                           
0B2E1                           RunStarFlagObj:
0B2E1 A9 00                           lda #$00                 ;initialize enemy frenzy buffer
0B2E3 8D CB 06                        sta EnemyFrenzyBuffer
0B2E6 AD 46 07                        lda StarFlagTaskControl  ;check star flag object task number here
0B2E9 C9 05                           cmp #$05                 ;if greater than 5, branch to exit
0B2EB B0 2C                           bcs StarFlagExit
0B2ED 20 0A 6E                        jsr JumpEngine           ;otherwise jump to appropriate sub
0B2F0                                 
0B2F0 19 B3                           .dw StarFlagExit
0B2F2 FA B2                           .dw GameTimerFireworks
0B2F4 1A B3                           .dw AwardGameTimerPoints
0B2F6 56 B3                           .dw RaiseFlagSetoffFWorks
0B2F8 AA B3                           .dw DelayToAreaEnd
0B2FA                           
0B2FA                           GameTimerFireworks:
0B2FA A0 05                             ldy #$05               ;set default state for star flag object
0B2FC AD FA 07                          lda GameTimerDisplay+2 ;get game timer's last digit
0B2FF C9 01                             cmp #$01
0B301 F0 0E                             beq SetFWC             ;if last digit of game timer set to 1, skip ahead
0B303 A0 03                             ldy #$03               ;otherwise load new value for state
0B305 C9 03                             cmp #$03
0B307 F0 08                             beq SetFWC             ;if last digit of game timer set to 3, skip ahead
0B309 A0 00                             ldy #$00               ;otherwise load one more potential value for state
0B30B C9 06                             cmp #$06
0B30D F0 02                             beq SetFWC             ;if last digit of game timer set to 6, skip ahead
0B30F A9 FF                             lda #$ff               ;otherwise set value for no fireworks
0B311 8D D7 06                  SetFWC: sta FireworksCounter   ;set fireworks counter here
0B314 94 1E                             sty Enemy_State,x      ;set whatever state we have in star flag object
0B316                           
0B316                           IncrementSFTask1:
0B316 EE 46 07                        inc StarFlagTaskControl  ;increment star flag object task number
0B319                           
0B319                           StarFlagExit:
0B319 60                              rts                      ;leave
0B31A                           
0B31A                           AwardGameTimerPoints:
0B31A AD F8 07                           lda GameTimerDisplay   ;check all game timer digits for any intervals left
0B31D 0D F9 07                           ora GameTimerDisplay+1
0B320 0D FA 07                           ora GameTimerDisplay+2
0B323 F0 F1                              beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
0B325 A5 09                              lda FrameCounter
0B327 29 04                              and #%00000100         ;check frame counter for d2 set (skip ahead
0B329 F0 04                              beq NoTTick            ;for four frames every four frames) branch if not set
0B32B A9 10                              lda #Sfx_TimerTick
0B32D 85 FE                              sta Square2SoundQueue  ;load timer tick sound
0B32F A0 23                     NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
0B331 A9 FF                              lda #$ff               ;set adder here to $ff, or -1, to subtract one
0B333 8D 39 01                           sta DigitModifier+5    ;from the last digit of the game timer
0B336 20 65 6F                           jsr DigitsMathRoutine  ;subtract digit
0B339 A9 05                              lda #$05               ;set now to add 50 points
0B33B 8D 39 01                           sta DigitModifier+5    ;per game timer interval subtracted
0B33E                           
0B33E                           EndAreaPoints:
0B33E A0 0B                              ldy #$0b               ;load offset for mario's score by default
0B340 AD 53 07                           lda CurrentPlayer      ;check player on the screen
0B343 F0 02                              beq ELPGive            ;if mario, do not change
0B345 A0 11                              ldy #$11               ;otherwise load offset for luigi's score
0B347 20 65 6F                  ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
0B34A AD 53 07                           lda CurrentPlayer      ;get player on the screen (or 500 points per
0B34D 0A                                 asl                    ;fireworks explosion if branched here from there)
0B34E 0A                                 asl                    ;shift to high nybble
0B34F 0A                                 asl
0B350 0A                                 asl
0B351 09 04                              ora #%00000100         ;add four to set nybble for game timer
0B353 4C 3E 9C                           jmp UpdateNumber       ;jump to print the new score and game timer
0B356                           
0B356                           RaiseFlagSetoffFWorks:
0B356 B5 CF                              lda Enemy_Y_Position,x  ;check star flag's vertical position
0B358 C9 72                              cmp #$72                ;against preset value
0B35A 90 05                              bcc SetoffF             ;if star flag higher vertically, branch to other code
0B35C D6 CF                              dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
0B35E 4C 6D B3                           jmp DrawStarFlag        ;and skip this part here
0B361 AD D7 06                  SetoffF: lda FireworksCounter    ;check fireworks counter
0B364 F0 38                              beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
0B366 30 36                              bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
0B368 A9 16                              lda #Fireworks
0B36A 8D CB 06                           sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
0B36D                           
0B36D                           DrawStarFlag:
0B36D 20 56 D1                           jsr RelativeEnemyPosition  ;get relative coordinates of star flag
0B370 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get OAM data offset
0B373 A2 03                              ldx #$03                   ;do four sprites
0B375 AD B9 03                  DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
0B378 18                                 clc
0B379 7D D5 B2                           adc StarFlagYPosAdder,x    ;add Y coordinate adder data
0B37C 99 00 02                           sta Sprite_Y_Position,y    ;store as Y coordinate
0B37F BD DD B2                           lda StarFlagTileData,x     ;get tile number
0B382 99 01 02                           sta Sprite_Tilenumber,y    ;store as tile number
0B385 A9 22                              lda #$22                   ;set palette and background priority bits
0B387 99 02 02                           sta Sprite_Attributes,y    ;store as attributes
0B38A AD AE 03                           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0B38D 18                                 clc
0B38E 7D D9 B2                           adc StarFlagXPosAdder,x    ;add X coordinate adder data
0B391 99 03 02                           sta Sprite_X_Position,y    ;store as X coordinate
0B394 C8                                 iny
0B395 C8                                 iny                        ;increment OAM data offset four bytes
0B396 C8                                 iny                        ;for next sprite
0B397 C8                                 iny
0B398 CA                                 dex                        ;move onto next sprite
0B399 10 DA                              bpl DSFLoop                ;do this until all sprites are done
0B39B A6 08                              ldx ObjectOffset           ;get enemy object offset and leave
0B39D 60                                 rts
0B39E                           
0B39E                           DrawFlagSetTimer:
0B39E 20 6D B3                        jsr DrawStarFlag          ;do sub to draw star flag
0B3A1 A9 06                           lda #$06
0B3A3 9D 96 07                        sta EnemyIntervalTimer,x  ;set interval timer here
0B3A6                           
0B3A6                           IncrementSFTask2:
0B3A6 EE 46 07                        inc StarFlagTaskControl   ;move onto next task
0B3A9 60                              rts
0B3AA                           
0B3AA                           DelayToAreaEnd:
0B3AA 20 6D B3                        jsr DrawStarFlag          ;do sub to draw star flag
0B3AD BD 96 07                        lda EnemyIntervalTimer,x  ;if interval timer set in previous task
0B3B0 D0 05                           bne StarFlagExit2         ;not yet expired, branch to leave
0B3B2 AD B1 07                        lda EventMusicBuffer      ;if event music buffer empty,
0B3B5 F0 EF                           beq IncrementSFTask2      ;branch to increment task
0B3B7                           
0B3B7                           StarFlagExit2:
0B3B7 60                              rts                       ;otherwise leave
0B3B8                           
0B3B8                           ;--------------------------------
0B3B8                           ;$00 - used to store horizontal difference between player and piranha plant
0B3B8                           
0B3B8                           MovePiranhaPlant:
0B3B8 B5 1E                           lda Enemy_State,x           ;check enemy state
0B3BA D0 56                           bne PutinPipe               ;if set at all, branch to leave
0B3BC BD 8A 07                        lda EnemyFrameTimer,x       ;check enemy's timer here
0B3BF D0 51                           bne PutinPipe               ;branch to end if not yet expired
0B3C1 B5 A0                           lda PiranhaPlant_MoveFlag,x ;check movement flag
0B3C3 D0 23                           bne SetupToMovePPlant       ;if moving, skip to part ahead
0B3C5 B5 58                           lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch 
0B3C7 30 14                           bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
0B3C9 20 48 C1                        jsr PlayerEnemyDiff         ;get horizontal difference between player and
0B3CC 10 09                           bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
0B3CE A5 00                           lda $00                     ;otherwise get saved horizontal difference
0B3D0 49 FF                           eor #$ff
0B3D2 18                              clc                         ;and change to two's compliment
0B3D3 69 01                           adc #$01
0B3D5 85 00                           sta $00                     ;save as new horizontal difference
0B3D7                           
0B3D7                           ChkPlayerNearPipe:
0B3D7 A5 00                           lda $00                     ;get saved horizontal difference
0B3D9 C9 21                           cmp #$21
0B3DB 90 35                           bcc PutinPipe               ;if player within a certain distance, branch to leave
0B3DD                           
0B3DD                           ReversePlantSpeed:
0B3DD B5 58                           lda PiranhaPlant_Y_Speed,x  ;get vertical speed
0B3DF 49 FF                           eor #$ff
0B3E1 18                              clc                         ;change to two's compliment
0B3E2 69 01                           adc #$01
0B3E4 95 58                           sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
0B3E6 F6 A0                           inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
0B3E8                           
0B3E8                           SetupToMovePPlant:
0B3E8 BD 34 04                        lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
0B3EB B4 58                           ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
0B3ED 10 03                           bpl RiseFallPiranhaPlant    ;branch if moving downwards
0B3EF BD 17 04                        lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
0B3F2                           
0B3F2                           RiseFallPiranhaPlant:
0B3F2 85 00                           sta $00                     ;save vertical coordinate here
0B3F4 A5 09                           lda FrameCounter            ;get frame counter
0B3F6 4A                              lsr
0B3F7 90 19                           bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
0B3F9 AD 47 07                        lda TimerControl            ;get master timer control
0B3FC D0 14                           bne PutinPipe               ;branch to leave if set (likely not necessary)
0B3FE B5 CF                           lda Enemy_Y_Position,x      ;get current vertical coordinate
0B400 18                              clc
0B401 75 58                           adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
0B403 95 CF                           sta Enemy_Y_Position,x      ;save as new vertical coordinate
0B405 C5 00                           cmp $00                     ;compare against low or high coordinate
0B407 D0 09                           bne PutinPipe               ;branch to leave if not yet reached
0B409 A9 00                           lda #$00
0B40B 95 A0                           sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
0B40D A9 40                           lda #$40
0B40F 9D 8A 07                        sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
0B412                           
0B412                           PutinPipe:
0B412 A9 20                           lda #%00100000              ;set background priority bit in sprite
0B414 9D C5 03                        sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
0B417 60                              rts                         ;then leave
0B418                           
0B418                           ;-------------------------------------------------------------------------------------
0B418                           ;$07 - spinning speed
0B418                           
0B418                           FirebarSpin:
0B418 85 07                           sta $07                     ;save spinning speed here
0B41A B5 34                           lda FirebarSpinDirection,x  ;check spinning direction
0B41C D0 0E                           bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
0B41E A0 18                           ldy #$18                    ;possibly residual ldy
0B420 B5 58                           lda FirebarSpinState_Low,x
0B422 18                              clc                         ;add spinning speed to what would normally be
0B423 65 07                           adc $07                     ;the horizontal speed
0B425 95 58                           sta FirebarSpinState_Low,x
0B427 B5 A0                           lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
0B429 69 00                           adc #$00
0B42B 60                              rts
0B42C                           
0B42C                           SpinCounterClockwise:
0B42C A0 08                           ldy #$08                    ;possibly residual ldy
0B42E B5 58                           lda FirebarSpinState_Low,x
0B430 38                              sec                         ;subtract spinning speed to what would normally be
0B431 E5 07                           sbc $07                     ;the horizontal speed
0B433 95 58                           sta FirebarSpinState_Low,x
0B435 B5 A0                           lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
0B437 E9 00                           sbc #$00
0B439 60                              rts
0B43A                           
0B43A                           ;-------------------------------------------------------------------------------------
0B43A                           ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
0B43A                           ;$01 - used to hold high byte of name table for rope
0B43A                           ;$02 - used to hold page location of rope
0B43A                           
0B43A                           BalancePlatform:
0B43A B5 B6                            lda Enemy_Y_HighPos,x       ;check high byte of vertical position
0B43C C9 03                            cmp #$03
0B43E D0 03                            bne DoBPl
0B440 4C A0 A9                         jmp EraseEnemyObject        ;if far below screen, kill the object
0B443 B5 1E                     DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
0B445 10 01                            bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
0B447 60                               rts
0B448                           
0B448                           CheckBalPlatform:
0B448 A8                               tay                         ;save offset from state as Y
0B449 BD A2 03                         lda PlatformCollisionFlag,x ;get collision flag of platform
0B44C 85 00                            sta $00                     ;store here
0B44E B5 46                            lda Enemy_MovingDir,x       ;get moving direction
0B450 F0 03                            beq ChkForFall
0B452 4C C3 B5                         jmp PlatformFall            ;if set, jump here
0B455                           
0B455                           ChkForFall:
0B455 A9 2D                            lda #$2d                    ;check if platform is above a certain point
0B457 D5 CF                            cmp Enemy_Y_Position,x
0B459 90 0F                            bcc ChkOtherForFall         ;if not, branch elsewhere
0B45B C4 00                            cpy $00                     ;if collision flag is set to same value as
0B45D F0 08                            beq MakePlatformFall        ;enemy state, branch to make platforms fall
0B45F 18                               clc
0B460 69 02                            adc #$02                    ;otherwise add 2 pixels to vertical position
0B462 95 CF                            sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
0B464 4C B9 B5                         jmp StopPlatforms           ;to make platforms stop
0B467                           
0B467                           MakePlatformFall:
0B467 4C A0 B5                         jmp InitPlatformFall        ;make platforms fall
0B46A                           
0B46A                           ChkOtherForFall:
0B46A D9 CF 00                         cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
0B46D 90 0D                            bcc ChkToMoveBalPlat        ;if not, branch elsewhere
0B46F E4 00                            cpx $00                     ;if collision flag is set to same value as
0B471 F0 F4                            beq MakePlatformFall        ;enemy state, branch to make platforms fall
0B473 18                               clc
0B474 69 02                            adc #$02                    ;otherwise add 2 pixels to vertical position
0B476 99 CF 00                         sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
0B479 4C B9 B5                         jmp StopPlatforms           ;jump to stop movement and do not return
0B47C                           
0B47C                           ChkToMoveBalPlat:
0B47C B5 CF                             lda Enemy_Y_Position,x      ;save vertical position to stack
0B47E 48                                pha
0B47F BD A2 03                          lda PlatformCollisionFlag,x ;get collision flag
0B482 10 18                             bpl ColFlg                  ;branch if collision
0B484 BD 34 04                          lda Enemy_Y_MoveForce,x
0B487 18                                clc                         ;add $05 to contents of moveforce, whatever they be
0B488 69 05                             adc #$05
0B48A 85 00                             sta $00                     ;store here
0B48C B5 A0                             lda Enemy_Y_Speed,x
0B48E 69 00                             adc #$00                    ;add carry to vertical speed
0B490 30 1A                             bmi PlatDn                  ;branch if moving downwards
0B492 D0 0C                             bne PlatUp                  ;branch elsewhere if moving upwards
0B494 A5 00                             lda $00
0B496 C9 0B                             cmp #$0b                    ;check if there's still a little force left
0B498 90 0C                             bcc PlatSt                  ;if not enough, branch to stop movement
0B49A B0 04                             bcs PlatUp                  ;otherwise keep branch to move upwards
0B49C C5 08                     ColFlg: cmp ObjectOffset            ;if collision flag matches
0B49E F0 0C                             beq PlatDn                  ;current enemy object offset, branch
0B4A0 20 BF 9F                  PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
0B4A3 4C AF B4                          jmp DoOtherPlatform         ;jump ahead to remaining code
0B4A6 20 B9 B5                  PlatSt: jsr StopPlatforms           ;do a sub to stop movement
0B4A9 4C AF B4                          jmp DoOtherPlatform         ;jump ahead to remaining code
0B4AC 20 BC 9F                  PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
0B4AF                           
0B4AF                           DoOtherPlatform:
0B4AF B4 1E                            ldy Enemy_State,x           ;get offset of other platform
0B4B1 68                               pla                         ;get old vertical coordinate from stack
0B4B2 38                               sec
0B4B3 F5 CF                            sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
0B4B5 18                               clc
0B4B6 79 CF 00                         adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
0B4B9 99 CF 00                         sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
0B4BC BD A2 03                         lda PlatformCollisionFlag,x ;if no collision, skip this part here
0B4BF 30 04                            bmi DrawEraseRope
0B4C1 AA                               tax                         ;put offset which collision occurred here
0B4C2 20 26 BC                         jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
0B4C5                           
0B4C5                           DrawEraseRope:
0B4C5 A4 08                              ldy ObjectOffset            ;get enemy object offset
0B4C7 B9 A0 00                           lda Enemy_Y_Speed,y         ;check to see if current platform is
0B4CA 19 34 04                           ora Enemy_Y_MoveForce,y     ;moving at all
0B4CD F0 77                              beq ExitRp                  ;if not, skip all of this and branch to leave
0B4CF AE 00 03                           ldx VRAM_Buffer1_Offset     ;get vram buffer offset
0B4D2 E0 20                              cpx #$20                    ;if offset beyond a certain point, go ahead
0B4D4 B0 70                              bcs ExitRp                  ;and skip this, branch to leave
0B4D6 B9 A0 00                           lda Enemy_Y_Speed,y
0B4D9 48                                 pha                         ;save two copies of vertical speed to stack
0B4DA 48                                 pha
0B4DB 20 49 B5                           jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
0B4DE A5 01                              lda $01                     ;write name table address to vram buffer
0B4E0 9D 01 03                           sta VRAM_Buffer1,x          ;first the high byte, then the low
0B4E3 A5 00                              lda $00
0B4E5 9D 02 03                           sta VRAM_Buffer1+1,x
0B4E8 A9 02                              lda #$02                    ;set length for 2 bytes
0B4EA 9D 03 03                           sta VRAM_Buffer1+2,x
0B4ED B9 A0 00                           lda Enemy_Y_Speed,y         ;if platform moving upwards, branch 
0B4F0 30 0D                              bmi EraseR1                 ;to do something else
0B4F2 A9 A2                              lda #$a2
0B4F4 9D 04 03                           sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
0B4F7 A9 A3                              lda #$a3                    ;and right sides of rope in vram buffer
0B4F9 9D 05 03                           sta VRAM_Buffer1+4,x
0B4FC 4C 07 B5                           jmp OtherRope               ;jump to skip this part
0B4FF A9 24                     EraseR1: lda #$24                    ;put blank tiles in vram buffer
0B501 9D 04 03                           sta VRAM_Buffer1+3,x        ;to erase rope
0B504 9D 05 03                           sta VRAM_Buffer1+4,x
0B507                           
0B507                           OtherRope:
0B507 B9 1E 00                           lda Enemy_State,y           ;get offset of other platform from state
0B50A A8                                 tay                         ;use as Y here
0B50B 68                                 pla                         ;pull second copy of vertical speed from stack
0B50C 49 FF                              eor #$ff                    ;invert bits to reverse speed
0B50E 20 49 B5                           jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles  
0B511 A5 01                              lda $01                     ;write name table address to vram buffer
0B513 9D 06 03                           sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
0B516 A5 00                              lda $00                     ;the other platform
0B518 9D 07 03                           sta VRAM_Buffer1+6,x
0B51B A9 02                              lda #$02
0B51D 9D 08 03                           sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
0B520 68                                 pla                         ;pull first copy of vertical speed from stack
0B521 10 0D                              bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
0B523 A9 A2                              lda #$a2
0B525 9D 09 03                           sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
0B528 A9 A3                              lda #$a3                    ;and right sides of rope in vram
0B52A 9D 0A 03                           sta VRAM_Buffer1+9,x        ;transfer buffer
0B52D 4C 38 B5                           jmp EndRp                   ;jump to skip this part
0B530 A9 24                     EraseR2: lda #$24                    ;put blank tiles in vram buffer
0B532 9D 09 03                           sta VRAM_Buffer1+8,x        ;to erase rope
0B535 9D 0A 03                           sta VRAM_Buffer1+9,x
0B538 A9 00                     EndRp:   lda #$00                    ;put null terminator at the end
0B53A 9D 0B 03                           sta VRAM_Buffer1+10,x
0B53D AD 00 03                           lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
0B540 18                                 clc                         ;and store
0B541 69 0A                              adc #10
0B543 8D 00 03                           sta VRAM_Buffer1_Offset
0B546 A6 08                     ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
0B548 60                                 rts
0B549                           
0B549                           SetupPlatformRope:
0B549 48                                pha                     ;save second/third copy to stack
0B54A B9 87 00                          lda Enemy_X_Position,y  ;get horizontal coordinate
0B54D 18                                clc
0B54E 69 08                             adc #$08                ;add eight pixels
0B550 AE CC 06                          ldx SecondaryHardMode   ;if secondary hard mode flag set,
0B553 D0 03                             bne GetLRp              ;use coordinate as-is
0B555 18                                clc
0B556 69 10                             adc #$10                ;otherwise add sixteen more pixels
0B558 48                        GetLRp: pha                     ;save modified horizontal coordinate to stack
0B559 B9 6E 00                          lda Enemy_PageLoc,y
0B55C 69 00                             adc #$00                ;add carry to page location
0B55E 85 02                             sta $02                 ;and save here
0B560 68                                pla                     ;pull modified horizontal coordinate
0B561 29 F0                             and #%11110000          ;from the stack, mask out low nybble
0B563 4A                                lsr                     ;and shift three bits to the right
0B564 4A                                lsr
0B565 4A                                lsr
0B566 85 00                             sta $00                 ;store result here as part of name table low byte
0B568 B6 CF                             ldx Enemy_Y_Position,y  ;get vertical coordinate
0B56A 68                                pla                     ;get second/third copy of vertical speed from stack
0B56B 10 05                             bpl GetHRp              ;skip this part if moving downwards or not at all
0B56D 8A                                txa
0B56E 18                                clc
0B56F 69 08                             adc #$08                ;add eight to vertical coordinate and
0B571 AA                                tax                     ;save as X
0B572 8A                        GetHRp: txa                     ;move vertical coordinate to A
0B573 AE 00 03                          ldx VRAM_Buffer1_Offset ;get vram buffer offset
0B576 0A                                asl
0B577 2A                                rol                     ;rotate d7 to d0 and d6 into carry
0B578 48                                pha                     ;save modified vertical coordinate to stack
0B579 2A                                rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
0B57A 29 03                             and #%00000011          ;mask out all bits but d7 and d6, then set
0B57C 09 20                             ora #%00100000          ;d5 to get appropriate high byte of name table
0B57E 85 01                             sta $01                 ;address, then store
0B580 A5 02                             lda $02                 ;get saved page location from earlier
0B582 29 01                             and #$01                ;mask out all but LSB
0B584 0A                                asl
0B585 0A                                asl                     ;shift twice to the left and save with the
0B586 05 01                             ora $01                 ;rest of the bits of the high byte, to get
0B588 85 01                             sta $01                 ;the proper name table and the right place on it
0B58A 68                                pla                     ;get modified vertical coordinate from stack
0B58B 29 E0                             and #%11100000          ;mask out low nybble and LSB of high nybble
0B58D 18                                clc
0B58E 65 00                             adc $00                 ;add to horizontal part saved here
0B590 85 00                             sta $00                 ;save as name table low byte
0B592 B9 CF 00                          lda Enemy_Y_Position,y
0B595 C9 E8                             cmp #$e8                ;if vertical position not below the
0B597 90 06                             bcc ExPRp               ;bottom of the screen, we're done, branch to leave
0B599 A5 00                             lda $00
0B59B 29 BF                             and #%10111111          ;mask out d6 of low byte of name table address
0B59D 85 00                             sta $00
0B59F 60                        ExPRp:  rts                     ;leave!
0B5A0                           
0B5A0                           InitPlatformFall:
0B5A0 98                              tya                        ;move offset of other platform from Y to X
0B5A1 AA                              tax
0B5A2 20 B3 D1                        jsr GetEnemyOffscreenBits  ;get offscreen bits
0B5A5 A9 06                           lda #$06
0B5A7 20 16 BA                        jsr SetupFloateyNumber     ;award 1000 points to player
0B5AA AD AD 03                        lda Player_Rel_XPos
0B5AD 9D 17 01                        sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
0B5B0 A5 CE                           lda Player_Y_Position
0B5B2 9D 1E 01                        sta FloateyNum_Y_Pos,x
0B5B5 A9 01                           lda #$01                   ;set moving direction as flag for
0B5B7 95 46                           sta Enemy_MovingDir,x      ;falling platforms
0B5B9                           
0B5B9                           StopPlatforms:
0B5B9 20 6B A3                        jsr InitVStf             ;initialize vertical speed and low byte
0B5BC 99 A0 00                        sta Enemy_Y_Speed,y      ;for both platforms and leave
0B5BF 99 34 04                        sta Enemy_Y_MoveForce,y
0B5C2 60                              rts
0B5C3                           
0B5C3                           PlatformFall:
0B5C3 98                              tya                         ;save offset for other platform to stack
0B5C4 48                              pha
0B5C5 20 73 9F                        jsr MoveFallingPlatform     ;make current platform fall
0B5C8 68                              pla
0B5C9 AA                              tax                         ;pull offset from stack and save to X
0B5CA 20 73 9F                        jsr MoveFallingPlatform     ;make other platform fall
0B5CD A6 08                           ldx ObjectOffset
0B5CF BD A2 03                        lda PlatformCollisionFlag,x ;if player not standing on either platform,
0B5D2 30 04                           bmi ExPF                    ;skip this part
0B5D4 AA                              tax                         ;transfer collision flag offset as offset to X
0B5D5 20 26 BC                        jsr PositionPlayerOnVPlat   ;and position player appropriately
0B5D8 A6 08                     ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
0B5DA 60                              rts
0B5DB                           
0B5DB                           ;--------------------------------
0B5DB                           
0B5DB                           YMovingPlatform:
0B5DB B5 A0                             lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
0B5DD 1D 34 04                          ora Enemy_Y_MoveForce,x      ;check on other position
0B5E0 D0 15                             bne ChkYCenterPos
0B5E2 9D 17 04                          sta Enemy_YMF_Dummy,x        ;initialize dummy variable
0B5E5 B5 CF                             lda Enemy_Y_Position,x
0B5E7 DD 01 04                          cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
0B5EA B0 0B                             bcs ChkYCenterPos            ;ahead of all this
0B5EC A5 09                             lda FrameCounter
0B5EE 29 07                             and #%00000111               ;check for every eighth frame
0B5F0 D0 02                             bne SkipIY
0B5F2 F6 CF                             inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
0B5F4 4C 06 B6                  SkipIY: jmp ChkYPCollision           ;skip ahead to last part
0B5F7                           
0B5F7                           ChkYCenterPos:
0B5F7 B5 CF                             lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
0B5F9 D5 58                             cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
0B5FB 90 06                             bcc YMDown
0B5FD 20 BF 9F                          jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
0B600 4C 06 B6                          jmp ChkYPCollision
0B603 20 BC 9F                  YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
0B606                           
0B606                           ChkYPCollision:
0B606 BD A2 03                         lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
0B609 30 03                            bmi ExYPl                    ;to leave
0B60B 20 26 BC                         jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
0B60E 60                        ExYPl: rts                          ;leave
0B60F                           
0B60F                           ;--------------------------------
0B60F                           ;$00 - used as adder to position player hotizontally
0B60F                           
0B60F                           XMovingPlatform:
0B60F A9 0E                           lda #$0e                     ;load preset maximum value for secondary counter
0B611 20 4F AB                        jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
0B614 20 6E AB                        jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
0B617 BD A2 03                        lda PlatformCollisionFlag,x  ;if no collision with player,
0B61A 30 1C                           bmi ExXMP                    ;branch ahead to leave
0B61C                           
0B61C                           PositionPlayerOnHPlat:
0B61C A5 86                              lda Player_X_Position
0B61E 18                                 clc                       ;add saved value from second subroutine to
0B61F 65 00                              adc $00                   ;current player's position to position
0B621 85 86                              sta Player_X_Position     ;player accordingly in horizontal position
0B623 A5 6D                              lda Player_PageLoc        ;get player's page location
0B625 A4 00                              ldy $00                   ;check to see if saved value here is positive or negative
0B627 30 05                              bmi PPHSubt               ;if negative, branch to subtract
0B629 69 00                              adc #$00                  ;otherwise add carry to page location
0B62B 4C 30 B6                           jmp SetPVar               ;jump to skip subtraction
0B62E E9 00                     PPHSubt: sbc #$00                  ;subtract borrow from page location
0B630 85 6D                     SetPVar: sta Player_PageLoc        ;save result to player's page location
0B632 8C A1 03                           sty Platform_X_Scroll     ;put saved value from second sub here to be used later
0B635 20 26 BC                           jsr PositionPlayerOnVPlat ;position player vertically and appropriately
0B638 60                        ExXMP:   rts                       ;and we are done here
0B639                           
0B639                           ;--------------------------------
0B639                           
0B639                           DropPlatform:
0B639 BD A2 03                         lda PlatformCollisionFlag,x  ;if no collision between platform and player
0B63C 30 06                            bmi ExDPl                    ;occurred, just leave without moving anything
0B63E 20 90 9F                         jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
0B641 20 26 BC                         jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
0B644 60                        ExDPl: rts                          ;leave
0B645                           
0B645                           ;--------------------------------
0B645                           ;$00 - residual value from sub
0B645                           
0B645                           RightPlatform:
0B645 20 0A 9F                         jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
0B648 85 00                            sta $00                       ;store saved value here (residual code)
0B64A BD A2 03                         lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
0B64D 30 07                            bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
0B64F A9 10                            lda #$10
0B651 95 58                            sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
0B653 20 1C B6                         jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
0B656 60                        ExRPl: rts                           ;then leave
0B657                           
0B657                           ;--------------------------------
0B657                           
0B657                           MoveLargeLiftPlat:
0B657 20 63 B6                        jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
0B65A 4C 06 B6                        jmp ChkYPCollision     ;branch to position player correctly
0B65D                           
0B65D                           MoveSmallPlatform:
0B65D 20 63 B6                        jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
0B660 4C 79 B6                        jmp ChkSmallPlatCollision  ;branch to position player correctly
0B663                           
0B663                           MoveLiftPlatforms:
0B663 AD 47 07                        lda TimerControl         ;if master timer control set, skip all of this
0B666 D0 19                           bne ExLiftP              ;and branch to leave
0B668 BD 17 04                        lda Enemy_YMF_Dummy,x
0B66B 18                              clc                      ;add contents of movement amount to whatever's here
0B66C 7D 34 04                        adc Enemy_Y_MoveForce,x
0B66F 9D 17 04                        sta Enemy_YMF_Dummy,x
0B672 B5 CF                           lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
0B674 75 A0                           adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
0B676 95 CF                           sta Enemy_Y_Position,x   ;and then leave
0B678 60                              rts
0B679                           
0B679                           ChkSmallPlatCollision:
0B679 BD A2 03                           lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
0B67C F0 03                              beq ExLiftP                 ;if none found, leave player position alone
0B67E 20 1E BC                           jsr PositionPlayerOnS_Plat  ;use to position player correctly
0B681 60                        ExLiftP: rts                         ;then leave
0B682                           
0B682                           ;-------------------------------------------------------------------------------------
0B682                           ;$00 - page location of extended left boundary
0B682                           ;$01 - extended left boundary position
0B682                           ;$02 - page location of extended right boundary
0B682                           ;$03 - extended right boundary position
0B682                           
0B682                           OffscreenBoundsCheck:
0B682 B5 16                               lda Enemy_ID,x          ;check for cheep-cheep object
0B684 C9 14                               cmp #FlyingCheepCheep   ;branch to leave if found
0B686 F0 55                               beq ExScrnBd
0B688 AD 1C 07                            lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
0B68B B4 16                               ldy Enemy_ID,x
0B68D C0 05                               cpy #HammerBro          ;check for hammer bro object
0B68F F0 04                               beq LimitB
0B691 C0 0D                               cpy #PiranhaPlant       ;check for piranha plant object
0B693 D0 02                               bne ExtendLB            ;these two will be erased sooner than others if too far left
0B695 69 38                     LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
0B697 E9 48                     ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
0B699 85 01                               sta $01                 ;store result here
0B69B AD 1A 07                            lda ScreenLeft_PageLoc
0B69E E9 00                               sbc #$00                ;subtract borrow from page location of left side
0B6A0 85 00                               sta $00                 ;store result here
0B6A2 AD 1D 07                            lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
0B6A5 69 48                               adc #$48
0B6A7 85 03                               sta $03                 ;store result here
0B6A9 AD 1B 07                            lda ScreenRight_PageLoc     
0B6AC 69 00                               adc #$00                ;then add the carry to the page location
0B6AE 85 02                               sta $02                 ;and store result here
0B6B0 B5 87                               lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
0B6B2 C5 01                               cmp $01                 ;to modified horizontal left edge coordinate to get carry
0B6B4 B5 6E                               lda Enemy_PageLoc,x
0B6B6 E5 00                               sbc $00                 ;then subtract it from the page coordinate of the enemy object
0B6B8 30 20                               bmi TooFar              ;if enemy object is too far left, branch to erase it
0B6BA B5 87                               lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
0B6BC C5 03                               cmp $03                 ;to modified horizontal right edge coordinate to get carry
0B6BE B5 6E                               lda Enemy_PageLoc,x
0B6C0 E5 02                               sbc $02                 ;then subtract it from the page coordinate of the enemy object
0B6C2 30 19                               bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
0B6C4 B5 1E                               lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
0B6C6 C9 05                               cmp #HammerBro          ;if in state used by spiny's egg, do not erase
0B6C8 F0 13                               beq ExScrnBd
0B6CA C0 0D                               cpy #PiranhaPlant       ;if piranha plant, do not erase
0B6CC F0 0F                               beq ExScrnBd
0B6CE C0 30                               cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
0B6D0 F0 0B                               beq ExScrnBd
0B6D2 C0 31                               cpy #StarFlagObject     ;if star flag, do not erase
0B6D4 F0 07                               beq ExScrnBd
0B6D6 C0 32                               cpy #JumpspringObject   ;if jumpspring, do not erase
0B6D8 F0 03                               beq ExScrnBd            ;erase all others too far to the right
0B6DA 20 A0 A9                  TooFar:   jsr EraseEnemyObject    ;erase object if necessary
0B6DD 60                        ExScrnBd: rts                     ;leave
0B6DE                           
0B6DE                           ;-------------------------------------------------------------------------------------
0B6DE                           ;$01 - enemy buffer offset
0B6DE                           
0B6DE                           FireballEnemyCollision:
0B6DE B5 24                           lda Fireball_State,x  ;check to see if fireball state is set at all
0B6E0 F0 56                           beq ExitFBallEnemy    ;branch to leave if not
0B6E2 0A                              asl
0B6E3 B0 53                           bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
0B6E5 A5 09                           lda FrameCounter
0B6E7 4A                              lsr                   ;get LSB of frame counter
0B6E8 B0 4E                           bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
0B6EA 8A                              txa
0B6EB 0A                              asl                   ;multiply fireball offset by four
0B6EC 0A                              asl
0B6ED 18                              clc
0B6EE 69 1C                           adc #$1c              ;then add $1c or 28 bytes to it
0B6F0 A8                              tay                   ;to use fireball's bounding box coordinates 
0B6F1 A2 04                           ldx #$04
0B6F3                           
0B6F3                           FireballEnemyCDLoop:
0B6F3 86 01                                stx $01                     ;store enemy object offset here
0B6F5 98                                   tya
0B6F6 48                                   pha                         ;push fireball offset to the stack
0B6F7 B5 1E                                lda Enemy_State,x
0B6F9 29 20                                and #%00100000              ;check to see if d5 is set in enemy state
0B6FB D0 34                                bne NoFToECol               ;if so, skip to next enemy slot
0B6FD B5 0F                                lda Enemy_Flag,x            ;check to see if buffer flag is set
0B6FF F0 30                                beq NoFToECol               ;if not, skip to next enemy slot
0B701 B5 16                                lda Enemy_ID,x              ;check enemy identifier
0B703 C9 24                                cmp #$24
0B705 90 04                                bcc GoombaDie               ;if < $24, branch to check further
0B707 C9 2B                                cmp #$2b
0B709 90 26                                bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
0B70B C9 06                     GoombaDie: cmp #Goomba                 ;check for goomba identifier
0B70D D0 06                                bne NotGoomba               ;if not found, continue with code
0B70F B5 1E                                lda Enemy_State,x           ;otherwise check for defeated state
0B711 C9 02                                cmp #$02                    ;if stomped or otherwise defeated,
0B713 B0 1C                                bcs NoFToECol               ;skip to next enemy slot
0B715 BD D8 03                  NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
0B718 D0 17                                bne NoFToECol               ;skip to next enemy slot
0B71A 8A                                   txa
0B71B 0A                                   asl                         ;otherwise multiply enemy offset by four
0B71C 0A                                   asl
0B71D 18                                   clc
0B71E 69 04                                adc #$04                    ;add 4 bytes to it
0B720 AA                                   tax                         ;to use enemy's bounding box coordinates
0B721 20 2C C3                             jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
0B724 A6 08                                ldx ObjectOffset            ;return fireball's original offset
0B726 90 09                                bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
0B728 A9 80                                lda #%10000000
0B72A 95 24                                sta Fireball_State,x        ;set d7 in enemy state
0B72C A6 01                                ldx $01                     ;get enemy offset
0B72E 20 43 B7                             jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
0B731 68                        NoFToECol: pla                         ;pull fireball offset from stack
0B732 A8                                   tay                         ;put it in Y
0B733 A6 01                                ldx $01                     ;get enemy object offset
0B735 CA                                   dex                         ;decrement it
0B736 10 BB                                bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
0B738                           
0B738                           ExitFBallEnemy:
0B738 A6 08                           ldx ObjectOffset                 ;get original fireball offset and leave
0B73A 60                              rts
0B73B                           
0B73B                           BowserIdentities:
0B73B 06 00 02 12 11 07 05 2D         .db Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser
0B743                           
0B743                           HandleEnemyFBallCol:
0B743 20 56 D1                        jsr RelativeEnemyPosition  ;get relative coordinate of enemy
0B746 A6 01                           ldx $01                    ;get current enemy object offset
0B748 B5 0F                           lda Enemy_Flag,x           ;check buffer flag for d7 set
0B74A 10 0B                           bpl ChkBuzzyBeetle         ;branch if not set to continue
0B74C 29 0F                           and #%00001111             ;otherwise mask out high nybble and
0B74E AA                              tax                        ;use low nybble as enemy offset
0B74F B5 16                           lda Enemy_ID,x
0B751 C9 2D                           cmp #Bowser                ;check enemy identifier for bowser
0B753 F0 0C                           beq HurtBowser             ;branch if found
0B755 A6 01                           ldx $01                    ;otherwise retrieve current enemy offset
0B757                           
0B757                           ChkBuzzyBeetle:
0B757 B5 16                           lda Enemy_ID,x
0B759 C9 02                           cmp #BuzzyBeetle           ;check for buzzy beetle
0B75B F0 6B                           beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
0B75D C9 2D                           cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
0B75F D0 2D                           bne ChkOtherEnemies        ;if not found, branch to check other enemies
0B761                           
0B761                           HurtBowser:
0B761 CE 83 04                            dec BowserHitPoints        ;decrement bowser's hit points
0B764 D0 62                               bne ExHCF                  ;if bowser still has hit points, branch to leave
0B766 20 6B A3                            jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
0B769 95 58                               sta Enemy_X_Speed,x        ;initialize horizontal speed
0B76B 8D CB 06                            sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
0B76E A9 FE                               lda #$fe
0B770 95 A0                               sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
0B772 AC 5F 07                            ldy WorldNumber            ;use world number as offset
0B775 B9 3B B7                            lda BowserIdentities,y     ;get enemy identifier to replace bowser with
0B778 95 16                               sta Enemy_ID,x             ;set as new enemy identifier
0B77A A9 20                               lda #$20                   ;set A to use starting value for state
0B77C C0 03                               cpy #$03                   ;check to see if using offset of 3 or more
0B77E B0 02                               bcs SetDBSte               ;branch if so
0B780 09 03                               ora #$03                   ;otherwise add 3 to enemy state
0B782 95 1E                     SetDBSte: sta Enemy_State,x          ;set defeated enemy state
0B784 A9 80                               lda #Sfx_BowserFall
0B786 85 FE                               sta Square2SoundQueue      ;load bowser defeat sound
0B788 A6 01                               ldx $01                    ;get enemy offset
0B78A A9 09                               lda #$09                   ;award 5000 points to player for defeating bowser
0B78C D0 33                               bne EnemySmackScore        ;unconditional branch to award points
0B78E                           
0B78E                           ChkOtherEnemies:
0B78E C9 08                           cmp #BulletBill_FrenzyVar
0B790 F0 36                           beq ExHCF                 ;branch to leave if bullet bill (frenzy variant) 
0B792 C9 0C                           cmp #Podoboo       
0B794 F0 32                           beq ExHCF                 ;branch to leave if podoboo
0B796 C9 15                           cmp #$15       
0B798 B0 2E                           bcs ExHCF                 ;branch to leave if identifier => $15
0B79A                           
0B79A                           ShellOrBlockDefeat:
0B79A B5 16                           lda Enemy_ID,x            ;check for piranha plant
0B79C C9 0D                           cmp #PiranhaPlant
0B79E D0 06                           bne StnE                  ;branch if not found
0B7A0 B5 CF                           lda Enemy_Y_Position,x
0B7A2 69 18                           adc #$18                  ;add 24 pixels to enemy object's vertical position
0B7A4 95 CF                           sta Enemy_Y_Position,x
0B7A6 20 20 C0                  StnE: jsr ChkToStunEnemies      ;do yet another sub
0B7A9 B5 1E                           lda Enemy_State,x
0B7AB 29 1F                           and #%00011111            ;mask out 2 MSB of enemy object's state
0B7AD 09 20                           ora #%00100000            ;set d5 to defeat enemy and save as new state
0B7AF 95 1E                           sta Enemy_State,x
0B7B1 A9 02                           lda #$02                  ;award 200 points by default
0B7B3 B4 16                           ldy Enemy_ID,x            ;check for hammer bro
0B7B5 C0 05                           cpy #HammerBro
0B7B7 D0 02                           bne GoombaPoints          ;branch if not found
0B7B9 A9 06                           lda #$06                  ;award 1000 points for hammer bro
0B7BB                           
0B7BB                           GoombaPoints:
0B7BB C0 06                           cpy #Goomba               ;check for goomba
0B7BD D0 02                           bne EnemySmackScore       ;branch if not found
0B7BF A9 01                           lda #$01                  ;award 100 points for goomba
0B7C1                           
0B7C1                           EnemySmackScore:
0B7C1 20 16 BA                         jsr SetupFloateyNumber   ;update necessary score variables
0B7C4 A9 08                            lda #Sfx_EnemySmack      ;play smack enemy sound
0B7C6 85 FF                            sta Square1SoundQueue
0B7C8 60                        ExHCF: rts                      ;and now let's leave
0B7C9                           
0B7C9                           ;-------------------------------------------------------------------------------------
0B7C9                           
0B7C9                           PlayerHammerCollision:
0B7C9 A5 09                             lda FrameCounter          ;get frame counter
0B7CB 4A                                lsr                       ;shift d0 into carry
0B7CC 90 36                             bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
0B7CE AD 47 07                          lda TimerControl          ;if either master timer control
0B7D1 0D D6 03                          ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
0B7D4 D0 2E                             bne ExPHC                 ;branch to leave
0B7D6 8A                                txa
0B7D7 0A                                asl                       ;multiply misc object offset by four
0B7D8 0A                                asl
0B7D9 18                                clc
0B7DA 69 24                             adc #$24                  ;add 36 or $24 bytes to get proper offset
0B7DC A8                                tay                       ;for misc object bounding box coordinates
0B7DD 20 2A C3                          jsr PlayerCollisionCore   ;do player-to-hammer collision detection
0B7E0 A6 08                             ldx ObjectOffset          ;get misc object offset
0B7E2 90 1B                             bcc ClHCol                ;if no collision, then branch
0B7E4 BD BE 06                          lda Misc_Collision_Flag,x ;otherwise read collision flag
0B7E7 D0 1B                             bne ExPHC                 ;if collision flag already set, branch to leave
0B7E9 A9 01                             lda #$01
0B7EB 9D BE 06                          sta Misc_Collision_Flag,x ;otherwise set collision flag now
0B7EE B5 64                             lda Misc_X_Speed,x
0B7F0 49 FF                             eor #$ff                  ;get two's compliment of
0B7F2 18                                clc                       ;hammer's horizontal speed
0B7F3 69 01                             adc #$01
0B7F5 95 64                             sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
0B7F7 AD 9F 07                          lda StarInvincibleTimer   ;if star mario invincibility timer set,
0B7FA D0 08                             bne ExPHC                 ;branch to leave
0B7FC 4C 31 B9                          jmp InjurePlayer          ;otherwise jump to hurt player, do not return
0B7FF A9 00                     ClHCol: lda #$00                  ;clear collision flag
0B801 9D BE 06                          sta Misc_Collision_Flag,x
0B804 60                        ExPHC:  rts
0B805                           
0B805                           ;-------------------------------------------------------------------------------------
0B805                           
0B805                           HandlePowerUpCollision:
0B805 20 A0 A9                        jsr EraseEnemyObject    ;erase the power-up object
0B808 A9 06                           lda #$06
0B80A 20 16 BA                        jsr SetupFloateyNumber  ;award 1000 points to player by default
0B80D A9 20                           lda #Sfx_PowerUpGrab
0B80F 85 FE                           sta Square2SoundQueue   ;play the power-up sound
0B811 A5 39                           lda PowerUpType         ;check power-up type
0B813 C9 02                           cmp #$02
0B815 90 0E                           bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
0B817 C9 03                           cmp #$03
0B819 F0 24                           beq SetFor1Up           ;if 1-up mushroom, branch
0B81B A9 23                           lda #$23                ;otherwise set star mario invincibility
0B81D 8D 9F 07                        sta StarInvincibleTimer ;timer, and load the star mario music
0B820 A9 40                           lda #StarPowerMusic     ;into the area music queue, then leave
0B822 85 FB                           sta AreaMusicQueue
0B824 60                              rts
0B825                           
0B825                           Shroom_Flower_PUp:
0B825 AD 56 07                        lda PlayerStatus    ;if player status = small, branch
0B828 F0 1B                           beq UpToSuper
0B82A C9 01                           cmp #$01            ;if player status not super, leave
0B82C D0 23                           bne NoPUp
0B82E A6 08                           ldx ObjectOffset    ;get enemy offset, not necessary
0B830 A9 02                           lda #$02            ;set player status to fiery
0B832 8D 56 07                        sta PlayerStatus
0B835 20 F7 65                        jsr GetPlayerColors ;run sub to change colors of player
0B838 A6 08                           ldx ObjectOffset    ;get enemy offset again, and again not necessary
0B83A A9 0C                           lda #$0c            ;set value to be used by subroutine tree (fiery)
0B83C 4C 4C B8                        jmp UpToFiery       ;jump to set values accordingly
0B83F                           
0B83F                           SetFor1Up:
0B83F A9 0B                           lda #$0b                 ;change 1000 points into 1-up instead
0B841 9D 10 01                        sta FloateyNum_Control,x ;and then leave
0B844 60                              rts
0B845                           
0B845                           UpToSuper:
0B845 A9 01                            lda #$01         ;set player status to super
0B847 8D 56 07                         sta PlayerStatus
0B84A A9 09                            lda #$09         ;set value to be used by subroutine tree (super)
0B84C                           
0B84C                           UpToFiery:
0B84C A0 00                            ldy #$00         ;set value to be used as new player state
0B84E 20 4D B9                         jsr SetPRout     ;set values to stop certain things in motion
0B851 60                        NoPUp: rts
0B852                           
0B852                           ;--------------------------------
0B852                           
0B852                           ResidualXSpdData:
0B852 18 E8                           .db $18, $e8
0B854                           
0B854                           KickedShellXSpdData:
0B854 30 D0                           .db $30, $d0
0B856                           
0B856                           DemotedKoopaXSpdData:
0B856 08 F8                           .db $08, $f8
0B858                           
0B858                           PlayerEnemyCollision:
0B858 A5 09                              lda FrameCounter            ;check counter for d0 set
0B85A 4A                                 lsr
0B85B B0 F4                              bcs NoPUp                   ;if set, branch to leave
0B85D 20 46 BC                           jsr CheckPlayerVertical     ;if player object is completely offscreen or
0B860 B0 23                              bcs NoPECol                 ;if down past 224th pixel row, branch to leave
0B862 BD D8 03                           lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
0B865 D0 1E                              bne NoPECol                 ;go ahead and branch to leave
0B867 A5 0E                              lda GameEngineSubroutine
0B869 C9 08                              cmp #$08                    ;if not set to run player control routine
0B86B D0 18                              bne NoPECol                 ;on next frame, branch to leave
0B86D B5 1E                              lda Enemy_State,x
0B86F 29 20                              and #%00100000              ;if enemy state has d5 set, branch to leave
0B871 D0 12                              bne NoPECol
0B873 20 57 BC                           jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
0B876 20 2A C3                           jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
0B879 A6 08                              ldx ObjectOffset            ;get enemy object buffer offset
0B87B B0 09                              bcs CheckForPUpCollision    ;if collision, branch past this part here
0B87D BD 91 04                           lda Enemy_CollisionBits,x
0B880 29 FE                              and #%11111110              ;otherwise, clear d0 of current enemy object's
0B882 9D 91 04                           sta Enemy_CollisionBits,x   ;collision bit
0B885 60                        NoPECol: rts
0B886                           
0B886                           CheckForPUpCollision:
0B886 B4 16                            ldy Enemy_ID,x
0B888 C0 2E                            cpy #PowerUpObject            ;check for power-up object
0B88A D0 03                            bne EColl                     ;if not found, branch to next part
0B88C 4C 05 B8                         jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
0B88F AD 9F 07                  EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
0B892 F0 06                            beq HandlePECollisions        ;perform task here, otherwise kill enemy like
0B894 4C 9A B7                         jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
0B897                           
0B897                           KickedShellPtsData:
0B897 0A 06 04                        .db $0a, $06, $04
0B89A                           
0B89A                           HandlePECollisions:
0B89A BD 91 04                         lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
0B89D 29 01                            and #%00000001               ;or for being offscreen at all
0B89F 1D D8 03                         ora EnemyOffscrBitsMasked,x
0B8A2 D0 59                            bne ExPEC                    ;branch to leave if either is true
0B8A4 A9 01                            lda #$01
0B8A6 1D 91 04                         ora Enemy_CollisionBits,x    ;otherwise set d0 now
0B8A9 9D 91 04                         sta Enemy_CollisionBits,x
0B8AC C0 12                            cpy #Spiny                   ;branch if spiny
0B8AE F0 4E                            beq ChkForPlayerInjury
0B8B0 C0 0D                            cpy #PiranhaPlant            ;branch if piranha plant
0B8B2 F0 7D                            beq InjurePlayer
0B8B4 C0 0C                            cpy #Podoboo                 ;branch if podoboo
0B8B6 F0 79                            beq InjurePlayer
0B8B8 C0 33                            cpy #BulletBill_CannonVar    ;branch if bullet bill
0B8BA F0 42                            beq ChkForPlayerInjury
0B8BC C0 15                            cpy #$15                     ;branch if object => $15
0B8BE B0 71                            bcs InjurePlayer
0B8C0 AD 4E 07                         lda AreaType                 ;branch if water type level
0B8C3 F0 6C                            beq InjurePlayer
0B8C5 B5 1E                            lda Enemy_State,x            ;branch if d7 of enemy state was set
0B8C7 0A                               asl
0B8C8 B0 34                            bcs ChkForPlayerInjury
0B8CA B5 1E                            lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
0B8CC 29 07                            and #%00000111
0B8CE C9 02                            cmp #$02                     ;branch if enemy is in normal or falling state
0B8D0 90 2C                            bcc ChkForPlayerInjury
0B8D2 B5 16                            lda Enemy_ID,x               ;branch to leave if goomba in defeated state
0B8D4 C9 06                            cmp #Goomba
0B8D6 F0 25                            beq ExPEC
0B8D8 A9 08                            lda #Sfx_EnemySmack          ;play smack enemy sound
0B8DA 85 FF                            sta Square1SoundQueue
0B8DC B5 1E                            lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
0B8DE 09 80                            ora #%10000000
0B8E0 95 1E                            sta Enemy_State,x
0B8E2 20 0A BA                         jsr EnemyFacePlayer          ;set moving direction and get offset
0B8E5 B9 54 B8                         lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
0B8E8 95 58                            sta Enemy_X_Speed,x
0B8EA A9 03                            lda #$03                     ;add three to whatever the stomp counter contains
0B8EC 18                               clc                          ;to give points for kicking the shell
0B8ED 6D 84 04                         adc StompChainCounter
0B8F0 BC 96 07                         ldy EnemyIntervalTimer,x     ;check shell enemy's timer
0B8F3 C0 03                            cpy #$03                     ;if above a certain point, branch using the points
0B8F5 B0 03                            bcs KSPts                    ;data obtained from the stomp counter + 3
0B8F7 B9 97 B8                         lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
0B8FA 20 16 BA                  KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
0B8FD 60                        ExPEC: rts                          ;leave!!!
0B8FE                           
0B8FE                           ChkForPlayerInjury:
0B8FE A5 9F                               lda Player_Y_Speed     ;check player's vertical speed
0B900 30 02                               bmi ChkInj             ;perform procedure below if player moving upwards
0B902 D0 6A                               bne EnemyStomped       ;or not at all, and branch elsewhere if moving downwards
0B904 B5 16                     ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
0B906 C9 07                               cmp #Bloober
0B908 90 09                               bcc ChkETmrs
0B90A A5 CE                               lda Player_Y_Position  ;add 12 pixels to player's vertical position
0B90C 18                                  clc
0B90D 69 0C                               adc #$0c
0B90F D5 CF                               cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
0B911 90 5B                               bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
0B913 AD 91 07                  ChkETmrs: lda StompTimer         ;check stomp timer
0B916 D0 56                               bne EnemyStomped       ;branch if set
0B918 AD 9E 07                            lda InjuryTimer        ;check to see if injured invincibility timer still
0B91B D0 3D                               bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
0B91D AD AD 03                            lda Player_Rel_XPos
0B920 CD AE 03                            cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
0B923 90 03                               bcc TInjE              ;relative position, branch here
0B925 4C FB B9                            jmp ChkEnemyFaceRight  ;otherwise do a jump here
0B928 B5 46                     TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
0B92A C9 01                               cmp #$01               ;branch, otherwise do a jump here
0B92C D0 03                               bne InjurePlayer       ;to turn the enemy around
0B92E 4C 04 BA                            jmp LInj
0B931                           
0B931                           InjurePlayer:
0B931 AD 9E 07                        lda InjuryTimer          ;check again to see if injured invincibility timer is
0B934 D0 24                           bne ExInjColRoutines     ;at zero, and branch to leave if so
0B936                           
0B936                           ForceInjury:
0B936 AE 56 07                            ldx PlayerStatus          ;check player's status
0B939 F0 22                               beq KillPlayer            ;branch if small
0B93B 8D 56 07                            sta PlayerStatus          ;otherwise set player's status to small
0B93E A9 08                               lda #$08
0B940 8D 9E 07                            sta InjuryTimer           ;set injured invincibility timer
0B943 0A                                  asl
0B944 85 FF                               sta Square1SoundQueue     ;play pipedown/injury sound
0B946 20 F7 65                            jsr GetPlayerColors       ;change player's palette if necessary
0B949 A9 0A                               lda #$0a                  ;set subroutine to run on next frame
0B94B A0 01                     SetKRout: ldy #$01                  ;set new player state
0B94D 85 0E                     SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
0B94F 84 1D                               sty Player_State          ;store new player state
0B951 A0 FF                               ldy #$ff
0B953 8C 47 07                            sty TimerControl          ;set master timer control flag to halt timers
0B956 C8                                  iny
0B957 8C 75 07                            sty ScrollAmount          ;initialize scroll speed
0B95A                           
0B95A                           ExInjColRoutines:
0B95A A6 08                           ldx ObjectOffset              ;get enemy offset and leave
0B95C 60                              rts
0B95D                           
0B95D                           KillPlayer:
0B95D 86 57                           stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
0B95F E8                              inx
0B960 86 FC                           stx EventMusicQueue  ;set event music queue to death music
0B962 A9 FC                           lda #$fc
0B964 85 9F                           sta Player_Y_Speed   ;set new vertical speed
0B966 A9 0B                           lda #$0b             ;set subroutine to run on next frame
0B968 D0 E1                           bne SetKRout         ;branch to set player's state and other things
0B96A                           
0B96A                           StompedEnemyPtsData:
0B96A 02 06 05 06                     .db $02, $06, $05, $06
0B96E                           
0B96E                           EnemyStomped:
0B96E B5 16                           lda Enemy_ID,x             ;check for spiny, branch to hurt player
0B970 C9 12                           cmp #Spiny                 ;if found
0B972 F0 BD                           beq InjurePlayer
0B974 A9 04                           lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
0B976 85 FF                           sta Square1SoundQueue
0B978 B5 16                           lda Enemy_ID,x
0B97A A0 00                           ldy #$00                   ;initialize points data offset for stomped enemies
0B97C C9 14                           cmp #FlyingCheepCheep      ;branch for cheep-cheep
0B97E F0 1B                           beq EnemyStompedPts
0B980 C9 08                           cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
0B982 F0 17                           beq EnemyStompedPts
0B984 C9 33                           cmp #BulletBill_CannonVar
0B986 F0 13                           beq EnemyStompedPts
0B988 C9 0C                           cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
0B98A F0 0F                           beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
0B98C C8                              iny                        ;increment points data offset
0B98D C9 05                           cmp #HammerBro             ;branch for hammer bro
0B98F F0 0A                           beq EnemyStompedPts
0B991 C8                              iny                        ;increment points data offset
0B992 C9 11                           cmp #Lakitu                ;branch for lakitu
0B994 F0 05                           beq EnemyStompedPts
0B996 C8                              iny                        ;increment points data offset
0B997 C9 07                           cmp #Bloober               ;branch if NOT bloober
0B999 D0 1D                           bne ChkForDemoteKoopa
0B99B                           
0B99B                           EnemyStompedPts:
0B99B B9 6A B9                        lda StompedEnemyPtsData,y  ;load points data using offset in Y
0B99E 20 16 BA                        jsr SetupFloateyNumber     ;run sub to set floatey number controls
0B9A1 B5 46                           lda Enemy_MovingDir,x
0B9A3 48                              pha                        ;save enemy movement direction to stack
0B9A4 20 34 C0                        jsr SetStun                ;run sub to kill enemy
0B9A7 68                              pla
0B9A8 95 46                           sta Enemy_MovingDir,x      ;return enemy movement direction from stack
0B9AA A9 20                           lda #%00100000
0B9AC 95 1E                           sta Enemy_State,x          ;set d5 in enemy state
0B9AE 20 6B A3                        jsr InitVStf               ;nullify vertical speed, physics-related thing,
0B9B1 95 58                           sta Enemy_X_Speed,x        ;and horizontal speed
0B9B3 A9 FD                           lda #$fd                   ;set player's vertical speed, to give bounce
0B9B5 85 9F                           sta Player_Y_Speed
0B9B7 60                              rts
0B9B8                           
0B9B8                           ChkForDemoteKoopa:
0B9B8 C9 09                           cmp #$09                   ;branch elsewhere if enemy object < $09
0B9BA 90 1D                           bcc HandleStompedShellE
0B9BC 29 01                           and #%00000001             ;demote koopa paratroopas to ordinary troopas
0B9BE 95 16                           sta Enemy_ID,x
0B9C0 A0 00                           ldy #$00                   ;return enemy to normal state
0B9C2 94 1E                           sty Enemy_State,x
0B9C4 A9 03                           lda #$03                   ;award 400 points to the player
0B9C6 20 16 BA                        jsr SetupFloateyNumber
0B9C9 20 6B A3                        jsr InitVStf               ;nullify physics-related thing and vertical speed
0B9CC 20 0A BA                        jsr EnemyFacePlayer        ;turn enemy around if necessary
0B9CF B9 56 B8                        lda DemotedKoopaXSpdData,y
0B9D2 95 58                           sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
0B9D4 4C F6 B9                        jmp SBnce                  ;then move onto something else
0B9D7                           
0B9D7                           RevivalRateData:
0B9D7 10 0B                           .db $10, $0b
0B9D9                           
0B9D9                           HandleStompedShellE:
0B9D9 A9 04                            lda #$04                   ;set defeated state for enemy
0B9DB 95 1E                            sta Enemy_State,x
0B9DD EE 84 04                         inc StompChainCounter      ;increment the stomp counter
0B9E0 AD 84 04                         lda StompChainCounter      ;add whatever is in the stomp counter
0B9E3 18                               clc                        ;to whatever is in the stomp timer
0B9E4 6D 91 07                         adc StompTimer
0B9E7 20 16 BA                         jsr SetupFloateyNumber     ;award points accordingly
0B9EA EE 91 07                         inc StompTimer             ;increment stomp timer of some sort
0B9ED AC 6A 07                         ldy PrimaryHardMode        ;check primary hard mode flag
0B9F0 B9 D7 B9                         lda RevivalRateData,y      ;load timer setting according to flag
0B9F3 9D 96 07                         sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
0B9F6 A9 FC                     SBnce: lda #$fc                   ;set player's vertical speed for bounce
0B9F8 85 9F                            sta Player_Y_Speed         ;and then leave!!!
0B9FA 60                               rts
0B9FB                           
0B9FB                           ChkEnemyFaceRight:
0B9FB B5 46                            lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
0B9FD C9 01                            cmp #$01
0B9FF D0 03                            bne LInj              ;if not, branch
0BA01 4C 31 B9                         jmp InjurePlayer      ;otherwise go back to hurt player
0BA04 20 21 BB                  LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
0BA07 4C 31 B9                         jmp InjurePlayer      ;go back to hurt player
0BA0A                           
0BA0A                           
0BA0A                           EnemyFacePlayer:
0BA0A A0 01                            ldy #$01               ;set to move right by default
0BA0C 20 48 C1                         jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
0BA0F 10 01                            bpl SFcRt              ;if enemy is to the right of player, do not increment
0BA11 C8                               iny                    ;otherwise, increment to set to move to the left
0BA12 94 46                     SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
0BA14 88                               dey                    ;then decrement to use as a proper offset
0BA15 60                               rts
0BA16                           
0BA16                           SetupFloateyNumber:
0BA16 9D 10 01                         sta FloateyNum_Control,x ;set number of points control for floatey numbers
0BA19 A9 30                            lda #$30
0BA1B 9D 2C 01                         sta FloateyNum_Timer,x   ;set timer for floatey numbers
0BA1E B5 CF                            lda Enemy_Y_Position,x
0BA20 9D 1E 01                         sta FloateyNum_Y_Pos,x   ;set vertical coordinate
0BA23 AD AE 03                         lda Enemy_Rel_XPos
0BA26 9D 17 01                         sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
0BA29 60                        ExSFN: rts
0BA2A                           
0BA2A                           ;-------------------------------------------------------------------------------------
0BA2A                           ;$01 - used to hold enemy offset for second enemy
0BA2A                           
0BA2A                           SetBitsMask:
0BA2A 80 40 20 10 08 04 02            .db %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
0BA31                           
0BA31                           ClearBitsMask:
0BA31 7F BF DF EF F7 FB FD            .db %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
0BA38                           
0BA38                           EnemiesCollision:
0BA38 A5 09                             lda FrameCounter            ;check counter for d0 set
0BA3A 4A                                lsr
0BA3B 90 EC                             bcc ExSFN                   ;if d0 not set, leave
0BA3D AD 4E 07                          lda AreaType
0BA40 F0 E7                             beq ExSFN                   ;if water area type, leave
0BA42 B5 16                             lda Enemy_ID,x
0BA44 C9 15                             cmp #$15                    ;if enemy object => $15, branch to leave
0BA46 B0 6E                             bcs ExitECRoutine
0BA48 C9 11                             cmp #Lakitu                 ;if lakitu, branch to leave
0BA4A F0 6A                             beq ExitECRoutine
0BA4C C9 0D                             cmp #PiranhaPlant           ;if piranha plant, branch to leave
0BA4E F0 66                             beq ExitECRoutine
0BA50 BD D8 03                          lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
0BA53 D0 61                             bne ExitECRoutine
0BA55 20 57 BC                          jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
0BA58 CA                                dex                         ;first enemy we're going to compare, then decrement for second
0BA59 30 5B                             bmi ExitECRoutine           ;branch to leave if there are no other enemies
0BA5B 86 01                     ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
0BA5D 98                                tya                         ;save first enemy's bounding box offset to stack
0BA5E 48                                pha
0BA5F B5 0F                             lda Enemy_Flag,x            ;check enemy object enable flag
0BA61 F0 4C                             beq ReadyNextEnemy          ;branch if flag not set
0BA63 B5 16                             lda Enemy_ID,x
0BA65 C9 15                             cmp #$15                    ;check for enemy object => $15
0BA67 B0 46                             bcs ReadyNextEnemy          ;branch if true
0BA69 C9 11                             cmp #Lakitu
0BA6B F0 42                             beq ReadyNextEnemy          ;branch if enemy object is lakitu
0BA6D C9 0D                             cmp #PiranhaPlant
0BA6F F0 3E                             beq ReadyNextEnemy          ;branch if enemy object is piranha plant
0BA71 BD D8 03                          lda EnemyOffscrBitsMasked,x
0BA74 D0 39                             bne ReadyNextEnemy          ;branch if masked offscreen bits set
0BA76 8A                                txa                         ;get second enemy object's bounding box offset
0BA77 0A                                asl                         ;multiply by four, then add four
0BA78 0A                                asl
0BA79 18                                clc
0BA7A 69 04                             adc #$04
0BA7C AA                                tax                         ;use as new contents of X
0BA7D 20 2C C3                          jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
0BA80 A6 08                             ldx ObjectOffset            ;use first enemy offset for X
0BA82 A4 01                             ldy $01                     ;use second enemy offset for Y
0BA84 90 20                             bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
0BA86 B5 1E                             lda Enemy_State,x
0BA88 19 1E 00                          ora Enemy_State,y           ;check both enemy states for d7 set
0BA8B 29 80                             and #%10000000
0BA8D D0 11                             bne YesEC                   ;branch if at least one of them is set
0BA8F B9 91 04                          lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
0BA92 3D 2A BA                          and SetBitsMask,x           ;check to see if bit connected to second enemy is
0BA95 D0 18                             bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
0BA97 B9 91 04                          lda Enemy_CollisionBits,y
0BA9A 1D 2A BA                          ora SetBitsMask,x           ;if the bit is not set, set it now
0BA9D 99 91 04                          sta Enemy_CollisionBits,y
0BAA0 20 B9 BA                  YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
0BAA3 4C AF BA                          jmp ReadyNextEnemy          ;move onto next enemy slot
0BAA6                           
0BAA6                           NoEnemyCollision:
0BAA6 B9 91 04                        lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
0BAA9 3D 31 BA                        and ClearBitsMask,x           ;clear bit connected to second enemy
0BAAC 99 91 04                        sta Enemy_CollisionBits,y     ;then move onto next enemy slot
0BAAF                           
0BAAF                           ReadyNextEnemy:
0BAAF 68                              pla              ;get first enemy's bounding box offset from the stack
0BAB0 A8                              tay              ;use as Y again
0BAB1 A6 01                           ldx $01          ;get and decrement second enemy's object buffer offset
0BAB3 CA                              dex
0BAB4 10 A5                           bpl ECLoop       ;loop until all enemy slots have been checked
0BAB6                           
0BAB6                           ExitECRoutine:
0BAB6 A6 08                           ldx ObjectOffset ;get enemy object buffer offset
0BAB8 60                              rts              ;leave
0BAB9                           
0BAB9                           ProcEnemyCollisions:
0BAB9 B9 1E 00                        lda Enemy_State,y        ;check both enemy states for d5 set
0BABC 15 1E                           ora Enemy_State,x
0BABE 29 20                           and #%00100000           ;if d5 is set in either state, or both, branch
0BAC0 D0 33                           bne ExitProcessEColl     ;to leave and do nothing else at this point
0BAC2 B5 1E                           lda Enemy_State,x
0BAC4 C9 06                           cmp #$06                 ;if second enemy state < $06, branch elsewhere
0BAC6 90 2E                           bcc ProcSecondEnemyColl
0BAC8 B5 16                           lda Enemy_ID,x           ;check second enemy identifier for hammer bro
0BACA C9 05                           cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
0BACC F0 27                           beq ExitProcessEColl
0BACE B9 1E 00                        lda Enemy_State,y        ;check first enemy state for d7 set
0BAD1 0A                              asl
0BAD2 90 0A                           bcc ShellCollisions      ;branch if d7 is clear
0BAD4 A9 06                           lda #$06
0BAD6 20 16 BA                        jsr SetupFloateyNumber   ;award 1000 points for killing enemy
0BAD9 20 9A B7                        jsr ShellOrBlockDefeat   ;then kill enemy, then load
0BADC A4 01                           ldy $01                  ;original offset of second enemy
0BADE                           
0BADE                           ShellCollisions:
0BADE 98                              tya                      ;move Y to X
0BADF AA                              tax
0BAE0 20 9A B7                        jsr ShellOrBlockDefeat   ;kill second enemy
0BAE3 A6 08                           ldx ObjectOffset
0BAE5 BD 25 01                        lda ShellChainCounter,x  ;get chain counter for shell
0BAE8 18                              clc
0BAE9 69 04                           adc #$04                 ;add four to get appropriate point offset
0BAEB A6 01                           ldx $01
0BAED 20 16 BA                        jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
0BAF0 A6 08                           ldx ObjectOffset         ;load original offset of first enemy
0BAF2 FE 25 01                        inc ShellChainCounter,x  ;increment chain counter for additional enemies
0BAF5                           
0BAF5                           ExitProcessEColl:
0BAF5 60                              rts                      ;leave!!!
0BAF6                           
0BAF6                           ProcSecondEnemyColl:
0BAF6 B9 1E 00                        lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
0BAF9 C9 06                           cmp #$06
0BAFB 90 1D                           bcc MoveEOfs
0BAFD B9 16 00                        lda Enemy_ID,y           ;check first enemy identifier for hammer bro
0BB00 C9 05                           cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
0BB02 F0 F1                           beq ExitProcessEColl
0BB04 20 9A B7                        jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
0BB07 A4 01                           ldy $01
0BB09 B9 25 01                        lda ShellChainCounter,y  ;get chain counter for shell
0BB0C 18                              clc
0BB0D 69 04                           adc #$04                 ;add four to get appropriate point offset
0BB0F A6 08                           ldx ObjectOffset
0BB11 20 16 BA                        jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
0BB14 A6 01                           ldx $01                  ;load original offset of second enemy
0BB16 FE 25 01                        inc ShellChainCounter,x  ;increment chain counter for additional enemies
0BB19 60                              rts                      ;leave!!!
0BB1A                           
0BB1A                           MoveEOfs:
0BB1A 98                              tya                      ;move Y ($01) to X
0BB1B AA                              tax
0BB1C 20 21 BB                        jsr EnemyTurnAround      ;do the sub here using value from $01
0BB1F A6 08                           ldx ObjectOffset         ;then do it again using value from $08
0BB21                           
0BB21                           EnemyTurnAround:
0BB21 B5 16                            lda Enemy_ID,x           ;check for specific enemies
0BB23 C9 0D                            cmp #PiranhaPlant
0BB25 F0 22                            beq ExTA                 ;if piranha plant, leave
0BB27 C9 11                            cmp #Lakitu
0BB29 F0 1E                            beq ExTA                 ;if lakitu, leave
0BB2B C9 05                            cmp #HammerBro
0BB2D F0 1A                            beq ExTA                 ;if hammer bro, leave
0BB2F C9 12                            cmp #Spiny
0BB31 F0 08                            beq RXSpd                ;if spiny, turn it around
0BB33 C9 0E                            cmp #GreenParatroopaJump
0BB35 F0 04                            beq RXSpd                ;if green paratroopa, turn it around
0BB37 C9 07                            cmp #$07
0BB39 B0 0E                            bcs ExTA                 ;if any OTHER enemy object => $07, leave
0BB3B B5 58                     RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
0BB3D 49 FF                            eor #$ff                 ;get two's compliment for horizontal speed
0BB3F A8                               tay
0BB40 C8                               iny
0BB41 94 58                            sty Enemy_X_Speed,x      ;store as new horizontal speed
0BB43 B5 46                            lda Enemy_MovingDir,x
0BB45 49 03                            eor #%00000011           ;invert moving direction and store, then leave
0BB47 95 46                            sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
0BB49 60                        ExTA:  rts                      ;leave!!!
0BB4A                           
0BB4A                           ;-------------------------------------------------------------------------------------
0BB4A                           ;$00 - vertical position of platform
0BB4A                           
0BB4A                           LargePlatformCollision:
0BB4A A9 FF                            lda #$ff                     ;save value here
0BB4C 9D A2 03                         sta PlatformCollisionFlag,x
0BB4F AD 47 07                         lda TimerControl             ;check master timer control
0BB52 D0 29                            bne ExLPC                    ;if set, branch to leave
0BB54 B5 1E                            lda Enemy_State,x            ;if d7 set in object state,
0BB56 30 25                            bmi ExLPC                    ;branch to leave
0BB58 B5 16                            lda Enemy_ID,x
0BB5A C9 24                            cmp #$24                     ;check enemy object identifier for
0BB5C D0 06                            bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
0BB5E B5 1E                            lda Enemy_State,x
0BB60 AA                               tax                          ;set state as enemy offset here
0BB61 20 64 BB                         jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
0BB64                           
0BB64                           ChkForPlayerC_LargeP:
0BB64 20 46 BC                         jsr CheckPlayerVertical      ;figure out if player is below a certain point
0BB67 B0 14                            bcs ExLPC                    ;or offscreen, branch to leave if true
0BB69 8A                               txa
0BB6A 20 59 BC                         jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
0BB6D B5 CF                            lda Enemy_Y_Position,x       ;store vertical coordinate in
0BB6F 85 00                            sta $00                      ;temp variable for now
0BB71 8A                               txa                          ;send offset we're on to the stack
0BB72 48                               pha
0BB73 20 2A C3                         jsr PlayerCollisionCore      ;do player-to-platform collision detection
0BB76 68                               pla                          ;retrieve offset from the stack
0BB77 AA                               tax
0BB78 90 03                            bcc ExLPC                    ;if no collision, branch to leave
0BB7A 20 C1 BB                         jsr ProcLPlatCollisions      ;otherwise collision, perform sub
0BB7D A6 08                     ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
0BB7F 60                               rts
0BB80                           
0BB80                           ;--------------------------------
0BB80                           ;$00 - counter for bounding boxes
0BB80                           
0BB80                           SmallPlatformCollision:
0BB80 AD 47 07                        lda TimerControl             ;if master timer control set,
0BB83 D0 37                           bne ExSPC                    ;branch to leave
0BB85 9D A2 03                        sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
0BB88 20 46 BC                        jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
0BB8B B0 2F                           bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
0BB8D A9 02                           lda #$02
0BB8F 85 00                           sta $00                      ;load counter here for 2 bounding boxes
0BB91                           
0BB91                           ChkSmallPlatLoop:
0BB91 A6 08                           ldx ObjectOffset           ;get enemy object offset
0BB93 20 57 BC                        jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
0BB96 29 02                           and #%00000010             ;if d1 of offscreen lower nybble bits was set
0BB98 D0 22                           bne ExSPC                  ;then branch to leave
0BB9A B9 AD 04                        lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
0BB9D C9 20                           cmp #$20                   ;above a specific point
0BB9F 90 05                           bcc MoveBoundBox           ;if so, branch, don't do collision detection
0BBA1 20 2A C3                        jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
0BBA4 B0 19                           bcs ProcSPlatCollisions    ;skip ahead if collision
0BBA6                           
0BBA6                           MoveBoundBox:
0BBA6 B9 AD 04                         lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
0BBA9 18                               clc                        ;128 pixels downwards
0BBAA 69 80                            adc #$80
0BBAC 99 AD 04                         sta BoundingBox_UL_YPos,y
0BBAF B9 AF 04                         lda BoundingBox_DR_YPos,y
0BBB2 18                               clc
0BBB3 69 80                            adc #$80
0BBB5 99 AF 04                         sta BoundingBox_DR_YPos,y
0BBB8 C6 00                            dec $00                    ;decrement counter we set earlier
0BBBA D0 D5                            bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
0BBBC A6 08                     ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
0BBBE 60                               rts
0BBBF                           
0BBBF                           ;--------------------------------
0BBBF                           
0BBBF                           ProcSPlatCollisions:
0BBBF A6 08                           ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
0BBC1                           
0BBC1                           ProcLPlatCollisions:
0BBC1 B9 AF 04                        lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
0BBC4 38                              sec                          ;of the player's bounding box from the bottom
0BBC5 ED AD 04                        sbc BoundingBox_UL_YPos      ;of the platform's bounding box
0BBC8 C9 04                           cmp #$04                     ;if difference too large or negative,
0BBCA B0 08                           bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
0BBCC A5 9F                           lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
0BBCE 10 04                           bpl ChkForTopCollision       ;if so, don't mess with it
0BBD0 A9 01                           lda #$01                     ;otherwise, set vertical
0BBD2 85 9F                           sta Player_Y_Speed           ;speed of player to kill jump
0BBD4                           
0BBD4                           ChkForTopCollision:
0BBD4 AD AF 04                        lda BoundingBox_DR_YPos      ;get difference by subtracting the top
0BBD7 38                              sec                          ;of the platform's bounding box from the bottom
0BBD8 F9 AD 04                        sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
0BBDB C9 06                           cmp #$06
0BBDD B0 1B                           bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
0BBDF A5 9F                           lda Player_Y_Speed
0BBE1 30 17                           bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
0BBE3 A5 00                           lda $00                      ;get saved bounding box counter from earlier
0BBE5 B4 16                           ldy Enemy_ID,x
0BBE7 C0 2B                           cpy #$2b                     ;if either of the two small platform objects are found,
0BBE9 F0 05                           beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
0BBEB C0 2C                           cpy #$2c                     ;as contents of collision flag
0BBED F0 01                           beq SetCollisionFlag
0BBEF 8A                              txa                          ;otherwise use enemy object buffer offset
0BBF0                           
0BBF0                           SetCollisionFlag:
0BBF0 A6 08                           ldx ObjectOffset             ;get enemy object buffer offset
0BBF2 9D A2 03                        sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
0BBF5 A9 00                           lda #$00
0BBF7 85 1D                           sta Player_State             ;set player state to normal then leave
0BBF9 60                              rts
0BBFA                           
0BBFA                           PlatformSideCollisions:
0BBFA A9 01                              lda #$01                   ;set value here to indicate possible horizontal
0BBFC 85 00                              sta $00                    ;collision on left side of platform
0BBFE AD AE 04                           lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
0BC01 38                                 sec                        ;from player's right edge
0BC02 F9 AC 04                           sbc BoundingBox_UL_XPos,y
0BC05 C9 08                              cmp #$08                   ;if difference close enough, skip all of this
0BC07 90 0D                              bcc SideC
0BC09 E6 00                              inc $00                    ;otherwise increment value set here for right side collision
0BC0B B9 AE 04                           lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
0BC0E 18                                 clc                        ;from platform's right edge
0BC0F ED AC 04                           sbc BoundingBox_UL_XPos
0BC12 C9 09                              cmp #$09                   ;if difference not close enough, skip subroutine
0BC14 B0 03                              bcs NoSideC                ;and instead branch to leave (no collision)
0BC16 20 50 BF                  SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
0BC19 A6 08                     NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
0BC1B 60                                 rts
0BC1C                           
0BC1C                           ;-------------------------------------------------------------------------------------
0BC1C                           
0BC1C                           PlayerPosSPlatData:
0BC1C 80 00                           .db $80, $00
0BC1E                           
0BC1E                           PositionPlayerOnS_Plat:
0BC1E A8                              tay                        ;use bounding box counter saved in collision flag
0BC1F B5 CF                           lda Enemy_Y_Position,x     ;for offset
0BC21 18                              clc                        ;add positioning data using offset to the vertical
0BC22 79 1B BC                        adc PlayerPosSPlatData-1,y ;coordinate
0BC25 2C                              .db $2c                    ;BIT instruction opcode
0BC26                           
0BC26                           PositionPlayerOnVPlat:
0BC26 B5 CF                              lda Enemy_Y_Position,x    ;get vertical coordinate
0BC28 A4 0E                              ldy GameEngineSubroutine
0BC2A C0 0B                              cpy #$0b                  ;if certain routine being executed on this frame,
0BC2C F0 17                              beq ExPlPos               ;skip all of this
0BC2E B4 B6                              ldy Enemy_Y_HighPos,x
0BC30 C0 01                              cpy #$01                  ;if vertical high byte offscreen, skip this
0BC32 D0 11                              bne ExPlPos
0BC34 38                                 sec                       ;subtract 32 pixels from vertical coordinate
0BC35 E9 20                              sbc #$20                  ;for the player object's height
0BC37 85 CE                              sta Player_Y_Position     ;save as player's new vertical coordinate
0BC39 98                                 tya
0BC3A E9 00                              sbc #$00                  ;subtract borrow and store as player's
0BC3C 85 B5                              sta Player_Y_HighPos      ;new vertical high byte
0BC3E A9 00                              lda #$00
0BC40 85 9F                              sta Player_Y_Speed        ;initialize vertical speed and low byte of force
0BC42 8D 33 04                           sta Player_Y_MoveForce    ;and then leave
0BC45 60                        ExPlPos: rts
0BC46                           
0BC46                           ;-------------------------------------------------------------------------------------
0BC46                           
0BC46                           CheckPlayerVertical:
0BC46 AD D0 03                         lda Player_OffscreenBits  ;if player object is completely offscreen
0BC49 C9 F0                            cmp #$f0                  ;vertically, leave this routine
0BC4B B0 09                            bcs ExCPV
0BC4D A4 B5                            ldy Player_Y_HighPos      ;if player high vertical byte is not
0BC4F 88                               dey                       ;within the screen, leave this routine
0BC50 D0 04                            bne ExCPV
0BC52 A5 CE                            lda Player_Y_Position     ;if on the screen, check to see how far down
0BC54 C9 D0                            cmp #$d0                  ;the player is vertically
0BC56 60                        ExCPV: rts
0BC57                           
0BC57                           ;-------------------------------------------------------------------------------------
0BC57                           
0BC57                           GetEnemyBoundBoxOfs:
0BC57 A5 08                           lda ObjectOffset         ;get enemy object buffer offset
0BC59                           
0BC59                           GetEnemyBoundBoxOfsArg:
0BC59 0A                              asl                      ;multiply A by four, then add four
0BC5A 0A                              asl                      ;to skip player's bounding box
0BC5B 18                              clc
0BC5C 69 04                           adc #$04
0BC5E A8                              tay                      ;send to Y
0BC5F AD D1 03                        lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
0BC62 29 0F                           and #%00001111           ;save low nybble
0BC64 C9 0F                           cmp #%00001111           ;check for all bits set
0BC66 60                              rts
0BC67                           
0BC67                           ;-------------------------------------------------------------------------------------
0BC67                           ;$00-$01 - used to hold many values, essentially temp variables
0BC67                           ;$04 - holds lower nybble of vertical coordinate from block buffer routine
0BC67                           ;$eb - used to hold block buffer adder
0BC67                           
0BC67                           PlayerBGUpperExtent:
0BC67 20 10                           .db $20, $10
0BC69                           
0BC69                           PlayerBGCollision:
0BC69 AD 16 07                            lda DisableCollisionDet   ;if collision detection disabled flag set,
0BC6C D0 2E                               bne ExPBGCol              ;branch to leave
0BC6E A5 0E                               lda GameEngineSubroutine
0BC70 C9 0B                               cmp #$0b                  ;if running routine #11 or $0b
0BC72 F0 28                               beq ExPBGCol              ;branch to leave
0BC74 C9 04                               cmp #$04
0BC76 90 24                               bcc ExPBGCol              ;if running routines $00-$03 branch to leave
0BC78 A9 01                               lda #$01                  ;load default player state for swimming
0BC7A AC 04 07                            ldy SwimmingFlag          ;if swimming flag set,
0BC7D D0 0A                               bne SetPSte               ;branch ahead to set default state
0BC7F A5 1D                               lda Player_State          ;if player in normal state,
0BC81 F0 04                               beq SetFallS              ;branch to set default state for falling
0BC83 C9 03                               cmp #$03
0BC85 D0 04                               bne ChkOnScr              ;if in any other state besides climbing, skip to next part
0BC87 A9 02                     SetFallS: lda #$02                  ;load default player state for falling
0BC89 85 1D                     SetPSte:  sta Player_State          ;set whatever player state is appropriate
0BC8B A5 B5                     ChkOnScr: lda Player_Y_HighPos
0BC8D C9 01                               cmp #$01                  ;check player's vertical high byte for still on the screen
0BC8F D0 0B                               bne ExPBGCol              ;branch to leave if not
0BC91 A9 FF                               lda #$ff
0BC93 8D 90 04                            sta Player_CollisionBits  ;initialize player's collision flag
0BC96 A5 CE                               lda Player_Y_Position
0BC98 C9 CF                               cmp #$cf                  ;check player's vertical coordinate
0BC9A 90 01                               bcc ChkCollSize           ;if not too close to the bottom of screen, continue
0BC9C 60                        ExPBGCol: rts                       ;otherwise leave
0BC9D                           
0BC9D                           ChkCollSize:
0BC9D A0 02                              ldy #$02                    ;load default offset
0BC9F AD 14 07                           lda CrouchingFlag
0BCA2 D0 0C                              bne GBBAdr                  ;if player crouching, skip ahead
0BCA4 AD 54 07                           lda PlayerSize
0BCA7 D0 07                              bne GBBAdr                  ;if player small, skip ahead
0BCA9 88                                 dey                         ;otherwise decrement offset for big player not crouching
0BCAA AD 04 07                           lda SwimmingFlag
0BCAD D0 01                              bne GBBAdr                  ;if swimming flag set, skip ahead
0BCAF 88                                 dey                         ;otherwise decrement offset
0BCB0 B9 B2 C3                  GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
0BCB3 85 EB                              sta $eb                     ;store value here
0BCB5 A8                                 tay                         ;put value into Y, as offset for block buffer routine
0BCB6 AE 54 07                           ldx PlayerSize              ;get player's size as offset
0BCB9 AD 14 07                           lda CrouchingFlag
0BCBC F0 01                              beq HeadChk                 ;if player not crouching, branch ahead
0BCBE E8                                 inx                         ;otherwise increment size as offset
0BCBF A5 CE                     HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
0BCC1 DD 67 BC                           cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
0BCC4 90 35                              bcc DoFootCheck             ;if player is too high, skip this part
0BCC6 20 EE C3                           jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
0BCC9 F0 30                              beq DoFootCheck             ;player, and branch if nothing above player's head
0BCCB 20 A6 BF                           jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
0BCCE B0 4F                              bcs AwardTouchedCoin        ;if so, branch to some other part of code
0BCD0 A4 9F                              ldy Player_Y_Speed          ;check player's vertical speed
0BCD2 10 27                              bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
0BCD4 A4 04                              ldy $04                     ;check lower nybble of vertical coordinate returned
0BCD6 C0 04                              cpy #$04                    ;from collision detection routine
0BCD8 90 21                              bcc DoFootCheck             ;if low nybble < 4, branch
0BCDA 20 94 BF                           jsr CheckForSolidMTiles     ;check to see what player's head bumped on
0BCDD B0 10                              bcs SolidOrClimb            ;if player collided with solid metatile, branch
0BCDF AC 4E 07                           ldy AreaType                ;otherwise check area type
0BCE2 F0 13                              beq NYSpd                   ;if water level, branch ahead
0BCE4 AC 84 07                           ldy BlockBounceTimer        ;if block bounce timer not expired,
0BCE7 D0 0E                              bne NYSpd                   ;branch ahead, do not process collision
0BCE9 20 F5 9C                           jsr PlayerHeadCollision     ;otherwise do a sub to process collision
0BCEC 4C FB BC                           jmp DoFootCheck             ;jump ahead to skip these other parts here
0BCEF                           
0BCEF                           SolidOrClimb:
0BCEF C9 26                            cmp #$26               ;if climbing metatile,
0BCF1 F0 04                            beq NYSpd              ;branch ahead and do not play sound
0BCF3 A9 02                            lda #Sfx_Bump
0BCF5 85 FF                            sta Square1SoundQueue  ;otherwise load bump sound
0BCF7 A9 01                     NYSpd: lda #$01               ;set player's vertical speed to nullify
0BCF9 85 9F                            sta Player_Y_Speed     ;jump or swim
0BCFB                           
0BCFB                           DoFootCheck:
0BCFB A4 EB                           ldy $eb                    ;get block buffer adder offset
0BCFD A5 CE                           lda Player_Y_Position
0BCFF C9 CF                           cmp #$cf                   ;check to see how low player is
0BD01 B0 60                           bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
0BD03 20 ED C3                        jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
0BD06 20 A6 BF                        jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
0BD09 B0 14                           bcs AwardTouchedCoin       ;if so, branch to some other part of code
0BD0B 48                              pha                        ;save bottom left metatile to stack
0BD0C 20 ED C3                        jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
0BD0F 85 00                           sta $00                    ;save bottom right metatile here
0BD11 68                              pla
0BD12 85 01                           sta $01                    ;pull bottom left metatile and save here
0BD14 D0 0C                           bne ChkFootMTile           ;if anything here, skip this part
0BD16 A5 00                           lda $00                    ;otherwise check for anything in bottom right metatile
0BD18 F0 49                           beq DoPlayerSideCheck      ;and skip ahead if not
0BD1A 20 A6 BF                        jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
0BD1D 90 03                           bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
0BD1F                           
0BD1F                           AwardTouchedCoin:
0BD1F 4C 0A BE                        jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
0BD22                           
0BD22                           ChkFootMTile:
0BD22 20 9F BF                            jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
0BD25 B0 3C                               bcs DoPlayerSideCheck      ;if so, branch
0BD27 A4 9F                               ldy Player_Y_Speed         ;check player's vertical speed
0BD29 30 38                               bmi DoPlayerSideCheck      ;if player moving upwards, branch
0BD2B C9 C5                               cmp #$c5
0BD2D D0 03                               bne ContChk                ;if player did not touch axe, skip ahead
0BD2F 4C 13 BE                            jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
0BD32 20 C2 BE                  ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
0BD35 F0 2C                               beq DoPlayerSideCheck      ;if either found, branch
0BD37 AC 0E 07                            ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
0BD3A D0 23                               bne InitSteP               ;branch ahead
0BD3C A4 04                               ldy $04                    ;check lower nybble of vertical coordinate returned
0BD3E C0 05                               cpy #$05                   ;from collision detection routine
0BD40 90 07                               bcc LandPlyr               ;if lower nybble < 5, branch
0BD42 A5 45                               lda Player_MovingDir
0BD44 85 00                               sta $00                    ;use player's moving direction as temp variable
0BD46 4C 50 BF                            jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
0BD49 20 C9 BE                  LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
0BD4C A9 F0                               lda #$f0
0BD4E 25 CE                               and Player_Y_Position      ;mask out lower nybble of player's vertical position
0BD50 85 CE                               sta Player_Y_Position      ;and store as new vertical position to land player properly
0BD52 20 ED BE                            jsr HandlePipeEntry        ;do sub to process potential pipe entry
0BD55 A9 00                               lda #$00
0BD57 85 9F                               sta Player_Y_Speed         ;initialize vertical speed and fractional
0BD59 8D 33 04                            sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
0BD5C 8D 84 04                            sta StompChainCounter      ;initialize enemy stomp counter
0BD5F A9 00                     InitSteP: lda #$00
0BD61 85 1D                               sta Player_State           ;set player's state to normal
0BD63                           
0BD63                           DoPlayerSideCheck:
0BD63 A4 EB                           ldy $eb       ;get block buffer adder offset
0BD65 C8                              iny
0BD66 C8                              iny           ;increment offset 2 bytes to use adders for side collisions
0BD67 A9 02                           lda #$02      ;set value here to be used as counter
0BD69 85 00                           sta $00
0BD6B                           
0BD6B                           SideCheckLoop:
0BD6B C8                               iny                       ;move onto the next one
0BD6C 84 EB                            sty $eb                   ;store it
0BD6E A5 CE                            lda Player_Y_Position
0BD70 C9 20                            cmp #$20                  ;check player's vertical position
0BD72 90 16                            bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
0BD74 C9 E4                            cmp #$e4
0BD76 B0 28                            bcs ExSCH                 ;branch to leave if player is too far down
0BD78 20 F1 C3                         jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
0BD7B F0 0D                            beq BHalf                 ;branch ahead if nothing found
0BD7D C9 1C                            cmp #$1c                  ;otherwise check for pipe metatiles
0BD7F F0 09                            beq BHalf                 ;if collided with sideways pipe (top), branch ahead
0BD81 C9 6B                            cmp #$6b
0BD83 F0 05                            beq BHalf                 ;if collided with water pipe (top), branch ahead
0BD85 20 9F BF                         jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
0BD88 90 17                            bcc CheckSideMTiles       ;if not, branch to alternate section of code
0BD8A A4 EB                     BHalf: ldy $eb                   ;load block adder offset
0BD8C C8                               iny                       ;increment it
0BD8D A5 CE                            lda Player_Y_Position     ;get player's vertical position
0BD8F C9 08                            cmp #$08
0BD91 90 0D                            bcc ExSCH                 ;if too high, branch to leave
0BD93 C9 D0                            cmp #$d0
0BD95 B0 09                            bcs ExSCH                 ;if too low, branch to leave
0BD97 20 F1 C3                         jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
0BD9A D0 05                            bne CheckSideMTiles       ;if something found, branch
0BD9C C6 00                            dec $00                   ;otherwise decrement counter
0BD9E D0 CB                            bne SideCheckLoop         ;run code until both sides of player are checked
0BDA0 60                        ExSCH: rts                       ;leave
0BDA1                           
0BDA1                           CheckSideMTiles:
0BDA1 20 C2 BE                            jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
0BDA4 F0 61                               beq ExCSM                  ;branch to leave if either found
0BDA6 20 9F BF                            jsr CheckForClimbMTiles    ;check for climbable metatiles
0BDA9 90 03                               bcc ContSChk               ;if not found, skip and continue with code
0BDAB 4C 33 BE                            jmp HandleClimbing         ;otherwise jump to handle climbing
0BDAE 20 A6 BF                  ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
0BDB1 B0 57                               bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
0BDB3 20 E2 BE                            jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
0BDB6 90 08                               bcc ChkPBtm                ;if not found, branch ahead to continue cude
0BDB8 AD 0E 07                            lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
0BDBB D0 4A                               bne ExCSM                  ;branch to leave if set
0BDBD 4C 04 BE                            jmp StopPlayerMove         ;otherwise jump to impede player's movement
0BDC0 A4 1D                     ChkPBtm:  ldy Player_State           ;get player's state
0BDC2 C0 00                               cpy #$00                   ;check for player's state set to normal
0BDC4 D0 3E                               bne StopPlayerMove         ;if not, branch to impede player's movement
0BDC6 A4 33                               ldy PlayerFacingDir        ;get player's facing direction
0BDC8 88                                  dey
0BDC9 D0 39                               bne StopPlayerMove         ;if facing left, branch to impede movement
0BDCB C9 6C                               cmp #$6c                   ;otherwise check for pipe metatiles
0BDCD F0 04                               beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
0BDCF C9 1F                               cmp #$1f                   ;if collided with water pipe (bottom), continue
0BDD1 D0 31                               bne StopPlayerMove         ;otherwise branch to impede player's movement
0BDD3 AD C4 03                  PipeDwnS: lda Player_SprAttrib       ;check player's attributes
0BDD6 D0 04                               bne PlyrPipe               ;if already set, branch, do not play sound again
0BDD8 A0 10                               ldy #Sfx_PipeDown_Injury
0BDDA 84 FF                               sty Square1SoundQueue      ;otherwise load pipedown/injury sound
0BDDC 09 20                     PlyrPipe: ora #%00100000
0BDDE 8D C4 03                            sta Player_SprAttrib       ;set background priority bit in player attributes
0BDE1 A5 86                               lda Player_X_Position
0BDE3 29 0F                               and #%00001111             ;get lower nybble of player's horizontal coordinate
0BDE5 F0 0E                               beq ChkGERtn               ;if at zero, branch ahead to skip this part
0BDE7 A0 00                               ldy #$00                   ;set default offset for timer setting data
0BDE9 AD 1A 07                            lda ScreenLeft_PageLoc     ;load page location for left side of screen
0BDEC F0 01                               beq SetCATmr               ;if at page zero, use default offset
0BDEE C8                                  iny                        ;otherwise increment offset
0BDEF B9 08 BE                  SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
0BDF2 8D DE 06                            sta ChangeAreaTimer
0BDF5 A5 0E                     ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
0BDF7 C9 07                               cmp #$07
0BDF9 F0 0C                               beq ExCSM                  ;if running player entrance routine or
0BDFB C9 08                               cmp #$08                   ;player control routine, go ahead and branch to leave
0BDFD D0 08                               bne ExCSM
0BDFF A9 02                               lda #$02
0BE01 85 0E                               sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
0BE03 60                                  rts                        ;and leave
0BE04                           
0BE04                           ;--------------------------------
0BE04                           ;$02 - high nybble of vertical coordinate from block buffer
0BE04                           ;$04 - low nybble of horizontal coordinate from block buffer
0BE04                           ;$06-$07 - block buffer address
0BE04                           
0BE04                           StopPlayerMove:
0BE04 20 50 BF                         jsr ImpedePlayerMove      ;stop player's movement
0BE07 60                        ExCSM: rts                       ;leave
0BE08                                 
0BE08                           AreaChangeTimerData:
0BE08 A0 34                           .db $a0, $34
0BE0A                           
0BE0A                           HandleCoinMetatile:
0BE0A 20 21 BE                        jsr ErACM             ;do sub to erase coin metatile from block buffer
0BE0D EE 48 07                        inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
0BE10 4C 06 9C                        jmp GiveOneCoin       ;update coin amount and tally on the screen
0BE13                           
0BE13                           HandleAxeMetatile:
0BE13 A9 00                            lda #$00
0BE15 8D 72 07                         sta OperMode_Task   ;reset secondary mode
0BE18 A9 02                            lda #$02
0BE1A 8D 70 07                         sta OperMode        ;set primary mode to autoctrl mode
0BE1D A9 18                            lda #$18
0BE1F 85 57                            sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
0BE21 A4 02                     ErACM: ldy $02             ;load vertical high nybble offset for block buffer
0BE23 A9 00                            lda #$00            ;load blank metatile
0BE25 91 06                            sta ($06),y         ;store to remove old contents from block buffer
0BE27 4C 53 6A                         jmp RemoveCoin_Axe  ;update the screen accordingly
0BE2A                           
0BE2A                           ;--------------------------------
0BE2A                           ;$02 - high nybble of vertical coordinate from block buffer
0BE2A                           ;$04 - low nybble of horizontal coordinate from block buffer
0BE2A                           ;$06-$07 - block buffer address
0BE2A                           
0BE2A                           ClimbXPosAdder:
0BE2A F9 07                           .db $f9, $07
0BE2C                           
0BE2C                           ClimbPLocAdder:
0BE2C FF 00                           .db $ff, $00
0BE2E                           
0BE2E                           FlagpoleYPosData:
0BE2E 18 22 50 68 90                  .db $18, $22, $50, $68, $90
0BE33                           
0BE33                           HandleClimbing:
0BE33 A4 04                           ldy $04            ;check low nybble of horizontal coordinate returned from
0BE35 C0 06                           cpy #$06           ;collision detection routine against certain values, this
0BE37 90 04                           bcc ExHC           ;makes actual physical part of vine or flagpole thinner
0BE39 C0 0A                           cpy #$0a           ;than 16 pixels
0BE3B 90 01                           bcc ChkForFlagpole
0BE3D 60                        ExHC: rts                ;leave if too far left or too far right
0BE3E                           
0BE3E                           ChkForFlagpole:
0BE3E C9 24                           cmp #$24               ;check climbing metatiles
0BE40 F0 04                           beq FlagpoleCollision  ;branch if flagpole ball found
0BE42 C9 25                           cmp #$25
0BE44 D0 39                           bne VineCollision      ;branch to alternate code if flagpole shaft not found
0BE46                           
0BE46                           FlagpoleCollision:
0BE46 A5 0E                           lda GameEngineSubroutine
0BE48 C9 05                           cmp #$05                  ;check for end-of-level routine running
0BE4A F0 41                           beq PutPlayerOnVine       ;if running, branch to end of climbing code
0BE4C A9 01                           lda #$01
0BE4E 85 33                           sta PlayerFacingDir       ;set player's facing direction to right
0BE50 EE 23 07                        inc ScrollLock            ;set scroll lock flag
0BE53 A5 0E                           lda GameEngineSubroutine
0BE55 C9 04                           cmp #$04                  ;check for flagpole slide routine running
0BE57 F0 1F                           beq RunFR                 ;if running, branch to end of flagpole code here
0BE59 A9 33                           lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
0BE5B 20 20 77                        jsr KillEnemies           ;get rid of them
0BE5E A9 80                           lda #Silence
0BE60 85 FC                           sta EventMusicQueue       ;silence music
0BE62 4A                              lsr
0BE63 8D 13 07                        sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
0BE66 A2 04                           ldx #$04                  ;start at end of vertical coordinate data
0BE68 A5 CE                           lda Player_Y_Position
0BE6A 8D 0F 07                        sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
0BE6D                           
0BE6D                           ChkFlagpoleYPosLoop:
0BE6D DD 2E BE                         cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
0BE70 B0 03                            bcs MtchF                 ;if player's => current, branch to use current offset
0BE72 CA                               dex                       ;otherwise decrement offset to use 
0BE73 D0 F8                            bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
0BE75 8E 0F 01                  MtchF: stx FlagpoleScore         ;store offset here to be used later
0BE78 A9 04                     RunFR: lda #$04
0BE7A 85 0E                            sta GameEngineSubroutine  ;set value to run flagpole slide routine
0BE7C 4C 8D BE                         jmp PutPlayerOnVine       ;jump to end of climbing code
0BE7F                           
0BE7F                           VineCollision:
0BE7F C9 26                           cmp #$26                  ;check for climbing metatile used on vines
0BE81 D0 0A                           bne PutPlayerOnVine
0BE83 A5 CE                           lda Player_Y_Position     ;check player's vertical coordinate
0BE85 C9 20                           cmp #$20                  ;for being in status bar area
0BE87 B0 04                           bcs PutPlayerOnVine       ;branch if not that far up
0BE89 A9 01                           lda #$01
0BE8B 85 0E                           sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
0BE8D                           
0BE8D                           PutPlayerOnVine:
0BE8D A9 03                              lda #$03                ;set player state to climbing
0BE8F 85 1D                              sta Player_State
0BE91 A9 00                              lda #$00                ;nullify player's horizontal speed
0BE93 85 57                              sta Player_X_Speed      ;and fractional horizontal movement force
0BE95 8D 05 07                           sta Player_X_MoveForce
0BE98 A5 86                              lda Player_X_Position   ;get player's horizontal coordinate
0BE9A 38                                 sec
0BE9B ED 1C 07                           sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
0BE9E C9 10                              cmp #$10
0BEA0 B0 04                              bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
0BEA2 A9 02                              lda #$02
0BEA4 85 33                              sta PlayerFacingDir     ;otherwise force player to face left
0BEA6 A4 33                     SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
0BEA8 A5 06                              lda $06                 ;get low byte of block buffer address
0BEAA 0A                                 asl
0BEAB 0A                                 asl                     ;move low nybble to high
0BEAC 0A                                 asl
0BEAD 0A                                 asl
0BEAE 18                                 clc
0BEAF 79 29 BE                           adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
0BEB2 85 86                              sta Player_X_Position   ;store as player's horizontal coordinate
0BEB4 A5 06                              lda $06                 ;get low byte of block buffer address again
0BEB6 D0 09                              bne ExPVne              ;if not zero, branch
0BEB8 AD 1B 07                           lda ScreenRight_PageLoc ;load page location of right side of screen
0BEBB 18                                 clc
0BEBC 79 2B BE                           adc ClimbPLocAdder-1,y  ;add depending on facing location
0BEBF 85 6D                              sta Player_PageLoc      ;store as player's page location
0BEC1 60                        ExPVne:  rts                     ;finally, we're done!
0BEC2                           
0BEC2                           ;--------------------------------
0BEC2                           
0BEC2                           ChkInvisibleMTiles:
0BEC2 C9 5F                              cmp #$5f       ;check for hidden coin block
0BEC4 F0 02                              beq ExCInvT    ;branch to leave if found
0BEC6 C9 60                              cmp #$60       ;check for hidden 1-up block
0BEC8 60                        ExCInvT: rts            ;leave with zero flag set if either found
0BEC9                           
0BEC9                           ;--------------------------------
0BEC9                           ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
0BEC9                           ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
0BEC9                           
0BEC9                           ChkForLandJumpSpring:
0BEC9 20 E2 BE                          jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
0BECC 90 13                             bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
0BECE A9 70                             lda #$70
0BED0 8D 09 07                          sta VerticalForce           ;otherwise set vertical movement force for player
0BED3 A9 F9                             lda #$f9
0BED5 8D DB 06                          sta JumpspringForce         ;set default jumpspring force
0BED8 A9 03                             lda #$03
0BEDA 8D 86 07                          sta JumpspringTimer         ;set jumpspring timer to be used later
0BEDD 4A                                lsr
0BEDE 8D 0E 07                          sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
0BEE1 60                        ExCJSp: rts                         ;and leave
0BEE2                           
0BEE2                           ChkJumpspringMetatiles:
0BEE2 C9 67                              cmp #$67      ;check for top jumpspring metatile
0BEE4 F0 05                              beq JSFnd     ;branch to set carry if found
0BEE6 C9 68                              cmp #$68      ;check for bottom jumpspring metatile
0BEE8 18                                 clc           ;clear carry flag
0BEE9 D0 01                              bne NoJSFnd   ;branch to use cleared carry if not found
0BEEB 38                        JSFnd:   sec           ;set carry if found
0BEEC 60                        NoJSFnd: rts           ;leave
0BEED                           
0BEED                           HandlePipeEntry:
0BEED A5 0B                              lda Up_Down_Buttons       ;check saved controller bits from earlier
0BEEF 29 04                              and #%00000100            ;for pressing down
0BEF1 F0 5C                              beq ExPipeE               ;if not pressing down, branch to leave
0BEF3 A5 00                              lda $00
0BEF5 C9 11                              cmp #$11                  ;check right foot metatile for warp pipe right metatile
0BEF7 D0 56                              bne ExPipeE               ;branch to leave if not found
0BEF9 A5 01                              lda $01
0BEFB C9 10                              cmp #$10                  ;check left foot metatile for warp pipe left metatile
0BEFD D0 50                              bne ExPipeE               ;branch to leave if not found
0BEFF A9 30                              lda #$30
0BF01 8D DE 06                           sta ChangeAreaTimer       ;set timer for change of area
0BF04 A9 03                              lda #$03
0BF06 85 0E                              sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
0BF08 A9 10                              lda #Sfx_PipeDown_Injury
0BF0A 85 FF                              sta Square1SoundQueue     ;load pipedown/injury sound
0BF0C A9 20                              lda #%00100000
0BF0E 8D C4 03                           sta Player_SprAttrib      ;set background priority bit in player's attributes
0BF11 AD D6 06                           lda WarpZoneControl       ;check warp zone control
0BF14 F0 39                              beq ExPipeE               ;branch to leave if none found
0BF16 29 03                              and #%00000011            ;mask out all but 2 LSB
0BF18 0A                                 asl
0BF19 0A                                 asl                       ;multiply by four
0BF1A AA                                 tax                       ;save as offset to warp zone numbers (starts at left pipe)
0BF1B A5 86                              lda Player_X_Position     ;get player's horizontal position
0BF1D C9 60                              cmp #$60      
0BF1F 90 06                              bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
0BF21 E8                                 inx                       ;otherwise increment for middle pipe
0BF22 C9 A0                              cmp #$a0      
0BF24 90 01                              bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
0BF26 E8                                 inx                       ;otherwise increment for last pipe
0BF27 BC F8 67                  GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
0BF2A 88                                 dey                       ;decrement for use as world number
0BF2B 8C 5F 07                           sty WorldNumber           ;store as world number and offset
0BF2E BE BC 7C                           ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
0BF31 BD C4 7C                           lda AreaAddrOffsets,x     ;get area offset based on world offset
0BF34 8D 50 07                           sta AreaPointer           ;store area offset here to be used to change areas
0BF37 A9 80                              lda #Silence
0BF39 85 FC                              sta EventMusicQueue       ;silence music
0BF3B A9 00                              lda #$00
0BF3D 8D 51 07                           sta EntrancePage          ;initialize starting page number
0BF40 8D 60 07                           sta AreaNumber            ;initialize area number used for area address offset
0BF43 8D 5C 07                           sta LevelNumber           ;initialize level number used for world display
0BF46 8D 52 07                           sta AltEntranceControl    ;initialize mode of entry
0BF49 EE 5D 07                           inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
0BF4C EE 57 07                           inc FetchNewGameTimerFlag ;set flag to load new game timer
0BF4F 60                        ExPipeE: rts                       ;leave!!!
0BF50                           
0BF50                           ImpedePlayerMove:
0BF50 A9 00                            lda #$00                  ;initialize value here
0BF52 A4 57                            ldy Player_X_Speed        ;get player's horizontal speed
0BF54 A6 00                            ldx $00                   ;check value set earlier for
0BF56 CA                               dex                       ;left side collision
0BF57 D0 0A                            bne RImpd                 ;if right side collision, skip this part
0BF59 E8                               inx                       ;return value to X
0BF5A C0 00                            cpy #$00                  ;if player moving to the left,
0BF5C 30 28                            bmi ExIPM                 ;branch to invert bit and leave
0BF5E A9 FF                            lda #$ff                  ;otherwise load A with value to be used later
0BF60 4C 6B BF                         jmp NXSpd                 ;and jump to affect movement
0BF63 A2 02                     RImpd: ldx #$02                  ;return $02 to X
0BF65 C0 01                            cpy #$01                  ;if player moving to the right,
0BF67 10 1D                            bpl ExIPM                 ;branch to invert bit and leave
0BF69 A9 01                            lda #$01                  ;otherwise load A with value to be used here
0BF6B A0 10                     NXSpd: ldy #$10
0BF6D 8C 85 07                         sty SideCollisionTimer    ;set timer of some sort
0BF70 A0 00                            ldy #$00
0BF72 84 57                            sty Player_X_Speed        ;nullify player's horizontal speed
0BF74 C9 00                            cmp #$00                  ;if value set in A not set to $ff,
0BF76 10 01                            bpl PlatF                 ;branch ahead, do not decrement Y
0BF78 88                               dey                       ;otherwise decrement Y now
0BF79 84 00                     PlatF: sty $00                   ;store Y as high bits of horizontal adder
0BF7B 18                               clc
0BF7C 65 86                            adc Player_X_Position     ;add contents of A to player's horizontal
0BF7E 85 86                            sta Player_X_Position     ;position to move player left or right
0BF80 A5 6D                            lda Player_PageLoc
0BF82 65 00                            adc $00                   ;add high bits and carry to
0BF84 85 6D                            sta Player_PageLoc        ;page location if necessary
0BF86 8A                        ExIPM: txa                       ;invert contents of X
0BF87 49 FF                            eor #$ff
0BF89 2D 90 04                         and Player_CollisionBits  ;mask out bit that was set here
0BF8C 8D 90 04                         sta Player_CollisionBits  ;store to clear bit
0BF8F 60                               rts
0BF90                           
0BF90                           ;--------------------------------
0BF90                           
0BF90                           SolidMTileUpperExt:
0BF90 10 61 88 C4                     .db $10, $61, $88, $c4
0BF94                           
0BF94                           CheckForSolidMTiles:
0BF94 20 B5 BF                        jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
0BF97 DD 90 BF                        cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
0BF9A 60                              rts
0BF9B                           
0BF9B                           ClimbMTileUpperExt:
0BF9B 24 6D 8A C6                     .db $24, $6d, $8a, $c6
0BF9F                           
0BF9F                           CheckForClimbMTiles:
0BF9F 20 B5 BF                        jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
0BFA2 DD 9B BF                        cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
0BFA5 60                              rts
0BFA6                           
0BFA6                           CheckForCoinMTiles:
0BFA6 C9 C2                              cmp #$c2              ;check for regular coin
0BFA8 F0 06                              beq CoinSd            ;branch if found
0BFAA C9 C3                              cmp #$c3              ;check for underwater coin
0BFAC F0 02                              beq CoinSd            ;branch if found
0BFAE 18                                 clc                   ;otherwise clear carry and leave
0BFAF 60                                 rts
0BFB0 A9 01                     CoinSd:  lda #Sfx_CoinGrab
0BFB2 85 FE                              sta Square2SoundQueue ;load coin grab sound and leave
0BFB4 60                                 rts
0BFB5                           
0BFB5                           GetMTileAttrib:
0BFB5 A8                               tay            ;save metatile value into Y
0BFB6 29 C0                            and #%11000000 ;mask out all but 2 MSB
0BFB8 0A                               asl
0BFB9 2A                               rol            ;shift and rotate d7-d6 to d1-d0
0BFBA 2A                               rol
0BFBB AA                               tax            ;use as offset for metatile data
0BFBC 98                               tya            ;get original metatile value back
0BFBD 60                        ExEBG: rts            ;leave
0BFBE                           
0BFBE                           ;-------------------------------------------------------------------------------------
0BFBE                           ;$06-$07 - address from block buffer routine
0BFBE                           
0BFBE                           EnemyBGCStateData:
0BFBE 01 01 02 02 02 05               .db $01, $01, $02, $02, $02, $05
0BFC4                           
0BFC4                           EnemyBGCXSpdData:
0BFC4 10 F0                           .db $10, $f0
0BFC6                           
0BFC6                           EnemyToBGCollisionDet:
0BFC6 B5 1E                           lda Enemy_State,x        ;check enemy state for d6 set
0BFC8 29 20                           and #%00100000
0BFCA D0 F1                           bne ExEBG                ;if set, branch to leave
0BFCC 20 60 C1                        jsr SubtEnemyYPos        ;otherwise, do a subroutine here
0BFCF 90 EC                           bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
0BFD1 B4 16                           ldy Enemy_ID,x
0BFD3 C0 12                           cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
0BFD5 D0 06                           bne DoIDCheckBGColl
0BFD7 B5 CF                           lda Enemy_Y_Position,x
0BFD9 C9 25                           cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
0BFDB 90 E0                           bcc ExEBG
0BFDD                           
0BFDD                           DoIDCheckBGColl:
0BFDD C0 0E                            cpy #GreenParatroopaJump ;check for some other enemy object
0BFDF D0 03                            bne HBChk                ;branch if not found
0BFE1 4C 68 C1                         jmp EnemyJump            ;otherwise jump elsewhere
0BFE4 C0 05                     HBChk: cpy #HammerBro           ;check for hammer bro
0BFE6 D0 03                            bne CInvu                ;branch if not found
0BFE8 4C 8A C1                         jmp HammerBroBGColl      ;otherwise jump elsewhere
0BFEB C0 12                     CInvu: cpy #Spiny               ;if enemy object is spiny, branch
0BFED F0 08                            beq YesIn
0BFEF C0 2E                            cpy #PowerUpObject       ;if special power-up object, branch
0BFF1 F0 04                            beq YesIn
0BFF3 C0 07                            cpy #$07                 ;if enemy object =>$07, branch to leave
0BFF5 B0 74                            bcs ExEBGChk
0BFF7 20 B3 C1                  YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
0BFFA D0 03                            bne HandleEToBGCollision ;if block underneath enemy, branch
0BFFC                           
0BFFC                           NoEToBGCollision:
0BFFC 4C E7 C0                         jmp ChkForRedKoopa       ;otherwise skip and do something else
0BFFF                           
0BFFF                           ;--------------------------------
0BFFF                           ;$02 - vertical coordinate from block buffer routine
0BFFF                           
0BFFF                           HandleEToBGCollision:
0BFFF 20 BA C1                        jsr ChkForNonSolids       ;if something is underneath enemy, find out what
0C002 F0 F8                           beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
0C004 C9 23                           cmp #$23
0C006 D0 64                           bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
0C008 A4 02                           ldy $02                   ;get vertical coordinate used to find block
0C00A A9 00                           lda #$00                  ;store default blank metatile in that spot so we won't
0C00C 91 06                           sta ($06),y               ;trigger this routine accidentally again
0C00E B5 16                           lda Enemy_ID,x
0C010 C9 15                           cmp #$15                  ;if enemy object => $15, branch ahead
0C012 B0 0C                           bcs ChkToStunEnemies
0C014 C9 06                           cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
0C016 D0 03                           bne GiveOEPoints
0C018 20 93 C1                        jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
0C01B                           
0C01B                           GiveOEPoints:
0C01B A9 01                           lda #$01                  ;award 100 points for hitting block beneath enemy
0C01D 20 16 BA                        jsr SetupFloateyNumber
0C020                           
0C020                           ChkToStunEnemies:
0C020 C9 09                               cmp #$09                   ;perform many comparisons on enemy object identifier
0C022 90 10                               bcc SetStun      
0C024 C9 11                               cmp #$11                   ;if the enemy object identifier is equal to the values
0C026 B0 0C                               bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
0C028 C9 0A                               cmp #$0a                   ;modified if not any of those values, note that piranha plant will
0C02A 90 04                               bcc Demote                 ;always fail this test because A will still have vertical
0C02C C9 0D                               cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
0C02E 90 04                               bcc SetStun                ;are only necessary if branching from $d7a1
0C030 29 01                     Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
0C032 95 16                               sta Enemy_ID,x             ;into green or red koopa troopa to demote them
0C034 B5 1E                     SetStun:  lda Enemy_State,x          ;load enemy state
0C036 29 F0                               and #%11110000             ;save high nybble
0C038 09 02                               ora #%00000010
0C03A 95 1E                               sta Enemy_State,x          ;set d1 of enemy state
0C03C D6 CF                               dec Enemy_Y_Position,x
0C03E D6 CF                               dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
0C040 B5 16                               lda Enemy_ID,x
0C042 C9 07                               cmp #Bloober               ;check for bloober object
0C044 F0 07                               beq SetWYSpd
0C046 A9 FD                               lda #$fd                   ;set default vertical speed
0C048 AC 4E 07                            ldy AreaType
0C04B D0 02                               bne SetNotW                ;if area type not water, set as speed, otherwise
0C04D A9 FF                     SetWYSpd: lda #$ff                   ;change the vertical speed
0C04F 95 A0                     SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
0C051 A0 01                               ldy #$01
0C053 20 48 C1                            jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
0C056 10 01                               bpl ChkBBill               ;branch if enemy is to the right of player
0C058 C8                                  iny                        ;increment Y if not
0C059 B5 16                     ChkBBill: lda Enemy_ID,x      
0C05B C9 33                               cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
0C05D F0 06                               beq NoCDirF
0C05F C9 08                               cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
0C061 F0 02                               beq NoCDirF                ;branch if either found, direction does not change
0C063 94 46                               sty Enemy_MovingDir,x      ;store as moving direction
0C065 88                        NoCDirF:  dey                        ;decrement and use as offset
0C066 B9 C4 BF                            lda EnemyBGCXSpdData,y     ;get proper horizontal speed
0C069 95 58                               sta Enemy_X_Speed,x        ;and store, then leave
0C06B 60                        ExEBGChk: rts
0C06C                           
0C06C                           ;--------------------------------
0C06C                           ;$04 - low nybble of vertical coordinate from block buffer routine
0C06C                           
0C06C                           LandEnemyProperly:
0C06C A5 04                            lda $04                 ;check lower nybble of vertical coordinate saved earlier
0C06E 38                               sec
0C06F E9 08                            sbc #$08                ;subtract eight pixels
0C071 C9 05                            cmp #$05                ;used to determine whether enemy landed from falling
0C073 B0 72                            bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
0C075 B5 1E                            lda Enemy_State,x      
0C077 29 40                            and #%01000000          ;branch if d6 in enemy state is set
0C079 D0 57                            bne LandEnemyInitState
0C07B B5 1E                            lda Enemy_State,x
0C07D 0A                               asl                     ;branch if d7 in enemy state is not set
0C07E 90 03                            bcc ChkLandedEnemyState
0C080 4C 03 C1                  SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
0C083                           
0C083                           ChkLandedEnemyState:
0C083 B5 1E                                lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
0C085 F0 F9                                beq SChkA
0C087 C9 05                                cmp #$05                  ;if in state used by spiny's egg
0C089 F0 1F                                beq ProcEnemyDirection    ;then branch elsewhere
0C08B C9 03                                cmp #$03                  ;if already in state used by koopas and buzzy beetles
0C08D B0 1A                                bcs ExSteChk              ;or in higher numbered state, branch to leave
0C08F B5 1E                                lda Enemy_State,x         ;load enemy state again (why?)
0C091 C9 02                                cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
0C093 D0 15                                bne ProcEnemyDirection    ;then branch elsewhere
0C095 A9 10                                lda #$10                  ;load default timer here
0C097 B4 16                                ldy Enemy_ID,x            ;check enemy identifier for spiny
0C099 C0 12                                cpy #Spiny
0C09B D0 02                                bne SetForStn             ;branch if not found
0C09D A9 00                                lda #$00                  ;set timer for $00 if spiny
0C09F 9D 96 07                  SetForStn: sta EnemyIntervalTimer,x  ;set timer here
0C0A2 A9 03                                lda #$03                  ;set state here, apparently used to render
0C0A4 95 1E                                sta Enemy_State,x         ;upside-down koopas and buzzy beetles
0C0A6 20 54 C1                             jsr EnemyLanding          ;then land it properly
0C0A9 60                        ExSteChk:  rts                       ;then leave
0C0AA                           
0C0AA                           ProcEnemyDirection:
0C0AA B5 16                              lda Enemy_ID,x            ;check enemy identifier for goomba
0C0AC C9 06                              cmp #Goomba               ;branch if found
0C0AE F0 22                              beq LandEnemyInitState
0C0B0 C9 12                              cmp #Spiny                ;check for spiny
0C0B2 D0 0E                              bne InvtD                 ;branch if not found
0C0B4 A9 01                              lda #$01
0C0B6 95 46                              sta Enemy_MovingDir,x     ;send enemy moving to the right by default
0C0B8 A9 08                              lda #$08
0C0BA 95 58                              sta Enemy_X_Speed,x       ;set horizontal speed accordingly
0C0BC A5 09                              lda FrameCounter
0C0BE 29 07                              and #%00000111            ;if timed appropriately, spiny will skip over
0C0C0 F0 10                              beq LandEnemyInitState    ;trying to face the player
0C0C2 A0 01                     InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
0C0C4 20 48 C1                           jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
0C0C7 10 01                              bpl CNwCDir               ;if enemy to the right of player, branch
0C0C9 C8                                 iny                       ;if to the left, increment by one for enemy to face right (inverted)
0C0CA 98                        CNwCDir: tya
0C0CB D5 46                              cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
0C0CD D0 03                              bne LandEnemyInitState
0C0CF 20 29 C1                           jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
0C0D2                           
0C0D2                           LandEnemyInitState:
0C0D2 20 54 C1                        jsr EnemyLanding       ;land enemy properly
0C0D5 B5 1E                           lda Enemy_State,x
0C0D7 29 80                           and #%10000000         ;if d7 of enemy state is set, branch
0C0D9 D0 05                           bne NMovShellFallBit
0C0DB A9 00                           lda #$00               ;otherwise initialize enemy state and leave
0C0DD 95 1E                           sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
0C0DF 60                              rts
0C0E0                           
0C0E0                           NMovShellFallBit:
0C0E0 B5 1E                           lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
0C0E2 29 BF                           and #%10111111      ;and store, then leave
0C0E4 95 1E                           sta Enemy_State,x
0C0E6 60                              rts
0C0E7                           
0C0E7                           ;--------------------------------
0C0E7                           
0C0E7                           ChkForRedKoopa:
0C0E7 B5 16                                  lda Enemy_ID,x            ;check for red koopa troopa $03
0C0E9 C9 03                                  cmp #RedKoopa
0C0EB D0 04                                  bne Chk2MSBSt             ;branch if not found
0C0ED B5 1E                                  lda Enemy_State,x
0C0EF F0 38                                  beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
0C0F1 B5 1E                     Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
0C0F3 A8                                     tay
0C0F4 0A                                     asl                       ;check for d7 set
0C0F5 90 07                                  bcc GetSteFromD           ;branch if not set
0C0F7 B5 1E                                  lda Enemy_State,x
0C0F9 09 40                                  ora #%01000000            ;set d6
0C0FB 4C 01 C1                               jmp SetD6Ste              ;jump ahead of this part
0C0FE B9 BE BF                  GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
0C101 95 1E                     SetD6Ste:    sta Enemy_State,x         ;set as new state
0C103                           
0C103                           ;--------------------------------
0C103                           ;$00 - used to store bitmask (not used but initialized here)
0C103                           ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
0C103                           
0C103                           DoEnemySideCheck:
0C103 B5 CF                               lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
0C105 C9 20                               cmp #$20                   ;because there's nothing there that impedes movement
0C107 90 1F                               bcc ExESdeC
0C109 A0 16                               ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
0C10B A9 02                               lda #$02                   ;set value here in what is also used as
0C10D 85 EB                               sta $eb                    ;OAM data offset
0C10F A5 EB                     SdeCLoop: lda $eb                    ;check value
0C111 D5 46                               cmp Enemy_MovingDir,x      ;compare value against moving direction
0C113 D0 0C                               bne NextSdeC               ;branch if different and do not seek block there
0C115 A9 01                               lda #$01                   ;set flag in A for save horizontal coordinate 
0C117 20 8D C3                            jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
0C11A F0 05                               beq NextSdeC               ;if nothing found, branch
0C11C 20 BA C1                            jsr ChkForNonSolids        ;check for non-solid blocks
0C11F D0 08                               bne ChkForBump_HammerBroJ  ;branch if not found
0C121 C6 EB                     NextSdeC: dec $eb                    ;move to the next direction
0C123 C8                                  iny
0C124 C0 18                               cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
0C126 90 E7                               bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
0C128 60                        ExESdeC:  rts
0C129                           
0C129                           ChkForBump_HammerBroJ: 
0C129 E0 05                             cpx #$05               ;check if we're on the special use slot
0C12B F0 09                             beq NoBump             ;and if so, branch ahead and do not play sound
0C12D B5 1E                             lda Enemy_State,x      ;if enemy state d7 not set, branch
0C12F 0A                                asl                    ;ahead and do not play sound
0C130 90 04                             bcc NoBump
0C132 A9 02                             lda #Sfx_Bump          ;otherwise, play bump sound
0C134 85 FF                             sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
0C136 B5 16                     NoBump: lda Enemy_ID,x         ;check for hammer bro
0C138 C9 05                             cmp #$05
0C13A D0 09                             bne InvEnemyDir        ;branch if not found
0C13C A9 00                             lda #$00
0C13E 85 00                             sta $00                ;initialize value here for bitmask  
0C140 A0 FA                             ldy #$fa               ;load default vertical speed for jumping
0C142 4C 3F AA                          jmp SetHJ              ;jump to code that makes hammer bro jump
0C145                           
0C145                           InvEnemyDir:
0C145 4C 3B BB                        jmp RXSpd     ;jump to turn the enemy around
0C148                           
0C148                           ;--------------------------------
0C148                           ;$00 - used to hold horizontal difference between player and enemy
0C148                           
0C148                           PlayerEnemyDiff:
0C148 B5 87                           lda Enemy_X_Position,x  ;get distance between enemy object's
0C14A 38                              sec                     ;horizontal coordinate and the player's
0C14B E5 86                           sbc Player_X_Position   ;horizontal coordinate
0C14D 85 00                           sta $00                 ;and store here
0C14F B5 6E                           lda Enemy_PageLoc,x
0C151 E5 6D                           sbc Player_PageLoc      ;subtract borrow, then leave
0C153 60                              rts
0C154                           
0C154                           ;--------------------------------
0C154                           
0C154                           EnemyLanding:
0C154 20 6B A3                        jsr InitVStf            ;do something here to vertical speed and something else
0C157 B5 CF                           lda Enemy_Y_Position,x
0C159 29 F0                           and #%11110000          ;save high nybble of vertical coordinate, and
0C15B 09 08                           ora #%00001000          ;set d3, then store, probably used to set enemy object
0C15D 95 CF                           sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
0C15F 60                              rts
0C160                           
0C160                           SubtEnemyYPos:
0C160 B5 CF                           lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
0C162 18                              clc                     ;vertical coordinate
0C163 69 3E                           adc #$3e
0C165 C9 44                           cmp #$44                ;compare against a certain range
0C167 60                              rts                     ;and leave with flags set for conditional branch
0C168                           
0C168                           EnemyJump:
0C168 20 60 C1                          jsr SubtEnemyYPos     ;do a sub here
0C16B 90 1A                             bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
0C16D B5 A0                             lda Enemy_Y_Speed,x
0C16F 18                                clc                   ;add two to vertical speed
0C170 69 02                             adc #$02
0C172 C9 03                             cmp #$03              ;if green paratroopa not falling, branch ahead
0C174 90 11                             bcc DoSide
0C176 20 B3 C1                          jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is 
0C179 F0 0C                             beq DoSide            ;standing on anything, then branch to same place if not
0C17B 20 BA C1                          jsr ChkForNonSolids   ;check for non-solid blocks
0C17E F0 07                             beq DoSide            ;branch if found
0C180 20 54 C1                          jsr EnemyLanding      ;change vertical coordinate and speed
0C183 A9 FD                             lda #$fd
0C185 95 A0                             sta Enemy_Y_Speed,x   ;make the paratroopa jump again
0C187 4C 03 C1                  DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
0C18A                           
0C18A                           ;--------------------------------
0C18A                           
0C18A                           HammerBroBGColl:
0C18A 20 B3 C1                        jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
0C18D F0 1D                           beq NoUnderHammerBro      
0C18F C9 23                           cmp #$23             ;check for blank metatile $23 and branch if not found
0C191 D0 08                           bne UnderHammerBro
0C193                           
0C193                           KillEnemyAboveBlock:
0C193 20 9A B7                        jsr ShellOrBlockDefeat  ;do this sub to kill enemy
0C196 A9 FC                           lda #$fc                ;alter vertical speed of enemy and leave
0C198 95 A0                           sta Enemy_Y_Speed,x
0C19A 60                              rts
0C19B                           
0C19B                           UnderHammerBro:
0C19B BD 8A 07                        lda EnemyFrameTimer,x ;check timer used by hammer bro
0C19E D0 0C                           bne NoUnderHammerBro  ;branch if not expired
0C1A0 B5 1E                           lda Enemy_State,x
0C1A2 29 88                           and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
0C1A4 95 1E                           sta Enemy_State,x     ;and store
0C1A6 20 54 C1                        jsr EnemyLanding      ;modify vertical coordinate, speed and something else
0C1A9 4C 03 C1                        jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
0C1AC                           
0C1AC                           NoUnderHammerBro:
0C1AC B5 1E                           lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
0C1AE 09 01                           ora #$01           ;in the enemy state to indicate jumping or falling, then leave
0C1B0 95 1E                           sta Enemy_State,x
0C1B2 60                              rts
0C1B3                           
0C1B3                           ChkUnderEnemy:
0C1B3 A9 00                           lda #$00                  ;set flag in A for save vertical coordinate
0C1B5 A0 15                           ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
0C1B7 4C 8D C3                        jmp BlockBufferChk_Enemy  ;hop to it!
0C1BA                           
0C1BA                           ChkForNonSolids:
0C1BA C9 26                            cmp #$26       ;blank metatile used for vines?
0C1BC F0 0E                            beq NSFnd
0C1BE C9 C2                            cmp #$c2       ;regular coin?
0C1C0 F0 0A                            beq NSFnd
0C1C2 C9 C3                            cmp #$c3       ;underwater coin?
0C1C4 F0 06                            beq NSFnd
0C1C6 C9 5F                            cmp #$5f       ;hidden coin block?
0C1C8 F0 02                            beq NSFnd
0C1CA C9 60                            cmp #$60       ;hidden 1-up block?
0C1CC 60                        NSFnd: rts
0C1CD                           
0C1CD                           ;-------------------------------------------------------------------------------------
0C1CD                           
0C1CD                           FireballBGCollision:
0C1CD B5 D5                           lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
0C1CF C9 18                           cmp #$18
0C1D1 90 21                           bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
0C1D3 20 A1 C3                        jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
0C1D6 F0 1C                           beq ClearBounceFlag         ;if nothing underneath fireball, branch
0C1D8 20 BA C1                        jsr ChkForNonSolids         ;check for non-solid metatiles
0C1DB F0 17                           beq ClearBounceFlag         ;branch if any found
0C1DD B5 A6                           lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
0C1DF 30 18                           bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
0C1E1 B5 3A                           lda FireballBouncingFlag,x  ;if bouncing flag already set,
0C1E3 D0 14                           bne InitFireballExplode     ;branch to set exploding bit in fireball's state
0C1E5 A9 FD                           lda #$fd
0C1E7 95 A6                           sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
0C1E9 A9 01                           lda #$01
0C1EB 95 3A                           sta FireballBouncingFlag,x  ;set bouncing flag
0C1ED B5 D5                           lda Fireball_Y_Position,x
0C1EF 29 F8                           and #$f8                    ;modify vertical coordinate to land it properly
0C1F1 95 D5                           sta Fireball_Y_Position,x   ;store as new vertical coordinate
0C1F3 60                              rts                         ;leave
0C1F4                           
0C1F4                           ClearBounceFlag:
0C1F4 A9 00                           lda #$00
0C1F6 95 3A                           sta FireballBouncingFlag,x  ;clear bouncing flag by default
0C1F8 60                              rts                         ;leave
0C1F9                           
0C1F9                           InitFireballExplode:
0C1F9 A9 80                           lda #$80
0C1FB 95 24                           sta Fireball_State,x        ;set exploding flag in fireball's state
0C1FD A9 02                           lda #Sfx_Bump
0C1FF 85 FF                           sta Square1SoundQueue       ;load bump sound
0C201 60                              rts                         ;leave
0C202                           
0C202                           ;-------------------------------------------------------------------------------------
0C202                           ;$00 - used to hold one of bitmasks, or offset
0C202                           ;$01 - used for relative X coordinate, also used to store middle screen page location
0C202                           ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
0C202                           
0C202                           ;this data added to relative coordinates of sprite objects
0C202                           ;stored in order: left edge, top edge, right edge, bottom edge
0C202                           BoundBoxCtrlData:
0C202 02 08 0E 20                     .db $02, $08, $0e, $20 
0C206 03 14 0D 20                     .db $03, $14, $0d, $20
0C20A 02 14 0E 20                     .db $02, $14, $0e, $20
0C20E 02 09 0E 15                     .db $02, $09, $0e, $15
0C212 00 00 18 06                     .db $00, $00, $18, $06
0C216 00 00 20 0D                     .db $00, $00, $20, $0d
0C21A 00 00 30 0D                     .db $00, $00, $30, $0d
0C21E 00 00 08 08                     .db $00, $00, $08, $08
0C222 06 04 0A 08                     .db $06, $04, $0a, $08
0C226 03 0E 0D 14                     .db $03, $0e, $0d, $14
0C22A 00 02 10 15                     .db $00, $02, $10, $15
0C22E 04 04 0C 1C                     .db $04, $04, $0c, $1c
0C232                           
0C232                           GetFireballBoundBox:
0C232 8A                              txa         ;add seven bytes to offset
0C233 18                              clc         ;to use in routines as offset for fireball
0C234 69 07                           adc #$07
0C236 AA                              tax
0C237 A0 02                           ldy #$02    ;set offset for relative coordinates
0C239 D0 07                           bne FBallB  ;unconditional branch
0C23B                           
0C23B                           GetMiscBoundBox:
0C23B 8A                                txa                       ;add nine bytes to offset
0C23C 18                                clc                       ;to use in routines as offset for misc object
0C23D 69 09                             adc #$09
0C23F AA                                tax
0C240 A0 06                             ldy #$06                  ;set offset for relative coordinates
0C242 20 A1 C2                  FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
0C245 4C E3 C2                          jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
0C248                           
0C248                           GetEnemyBoundBox:
0C248 A0 48                           ldy #$48                 ;store bitmask here for now
0C24A 84 00                           sty $00
0C24C A0 44                           ldy #$44                 ;store another bitmask here for now and jump
0C24E 4C 57 C2                        jmp GetMaskedOffScrBits
0C251                           
0C251                           SmallPlatformBoundBox:
0C251 A0 08                           ldy #$08                 ;store bitmask here for now
0C253 84 00                           sty $00
0C255 A0 04                           ldy #$04                 ;store another bitmask here for now
0C257                           
0C257                           GetMaskedOffScrBits:
0C257 B5 87                             lda Enemy_X_Position,x      ;get enemy object position relative
0C259 38                                sec                         ;to the left side of the screen
0C25A ED 1C 07                          sbc ScreenLeft_X_Pos
0C25D 85 01                             sta $01                     ;store here
0C25F B5 6E                             lda Enemy_PageLoc,x         ;subtract borrow from current page location
0C261 ED 1A 07                          sbc ScreenLeft_PageLoc      ;of left side
0C264 30 06                             bmi CMBits                  ;if enemy object is beyond left edge, branch
0C266 05 01                             ora $01
0C268 F0 02                             beq CMBits                  ;if precisely at the left edge, branch
0C26A A4 00                             ldy $00                     ;if to the right of left edge, use value in $00 for A
0C26C 98                        CMBits: tya                         ;otherwise use contents of Y
0C26D 2D D1 03                          and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
0C270 9D D8 03                          sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
0C273 D0 19                             bne MoveBoundBoxOffscreen   ;if anything set here, branch
0C275 4C 81 C2                          jmp SetupEOffsetFBBox       ;otherwise, do something else
0C278                           
0C278                           LargePlatformBoundBox:
0C278 E8                              inx                        ;increment X to get the proper offset
0C279 20 FA D1                        jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
0C27C CA                              dex                        ;decrement to return to original offset
0C27D C9 FE                           cmp #$fe                   ;if completely offscreen, branch to put entire bounding
0C27F B0 0D                           bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
0C281                           
0C281                           SetupEOffsetFBBox:
0C281 8A                              txa                        ;add 1 to offset to properly address
0C282 18                              clc                        ;the enemy object memory locations
0C283 69 01                           adc #$01
0C285 AA                              tax
0C286 A0 01                           ldy #$01                   ;load 1 as offset here, same reason
0C288 20 A1 C2                        jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
0C28B 4C E3 C2                        jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
0C28E                           
0C28E                           MoveBoundBoxOffscreen:
0C28E 8A                              txa                            ;multiply offset by 4
0C28F 0A                              asl
0C290 0A                              asl
0C291 A8                              tay                            ;use as offset here
0C292 A9 FF                           lda #$ff
0C294 99 B0 04                        sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
0C297 99 B1 04                        sta EnemyBoundingBoxCoord+1,y
0C29A 99 B2 04                        sta EnemyBoundingBoxCoord+2,y
0C29D 99 B3 04                        sta EnemyBoundingBoxCoord+3,y
0C2A0 60                              rts
0C2A1                           
0C2A1                           BoundingBoxCore:
0C2A1 86 00                           stx $00                     ;save offset here
0C2A3 B9 B8 03                        lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
0C2A6 85 02                           sta $02                     ;vertically and horizontally, respectively
0C2A8 B9 AD 03                        lda SprObject_Rel_XPos,y
0C2AB 85 01                           sta $01
0C2AD 8A                              txa                         ;multiply offset by four and save to stack
0C2AE 0A                              asl
0C2AF 0A                              asl
0C2B0 48                              pha
0C2B1 A8                              tay                         ;use as offset for Y, X is left alone
0C2B2 BD 99 04                        lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
0C2B5 0A                              asl                         ;multiply that by four and use as X
0C2B6 0A                              asl
0C2B7 AA                              tax
0C2B8 A5 01                           lda $01                     ;add the first number in the bounding box data to the
0C2BA 18                              clc                         ;relative horizontal coordinate using enemy object offset
0C2BB 7D 02 C2                        adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
0C2BE 99 AC 04                        sta BoundingBox_UL_Corner,y ;store here
0C2C1 A5 01                           lda $01
0C2C3 18                              clc
0C2C4 7D 04 C2                        adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
0C2C7 99 AE 04                        sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
0C2CA E8                              inx                         ;increment both offsets
0C2CB C8                              iny
0C2CC A5 02                           lda $02                     ;add the second number to the relative vertical coordinate
0C2CE 18                              clc                         ;using incremented offset and store using the other
0C2CF 7D 02 C2                        adc BoundBoxCtrlData,x      ;incremented offset
0C2D2 99 AC 04                        sta BoundingBox_UL_Corner,y
0C2D5 A5 02                           lda $02
0C2D7 18                              clc
0C2D8 7D 04 C2                        adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
0C2DB 99 AE 04                        sta BoundingBox_LR_Corner,y ;and store
0C2DE 68                              pla                         ;get original offset loaded into $00 * y from stack
0C2DF A8                              tay                         ;use as Y
0C2E0 A6 00                           ldx $00                     ;get original offset and use as X again
0C2E2 60                              rts
0C2E3                           
0C2E3                           CheckRightScreenBBox:
0C2E3 AD 1C 07                         lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
0C2E6 18                               clc                        ;and store as horizontal coordinate of middle
0C2E7 69 80                            adc #$80
0C2E9 85 02                            sta $02
0C2EB AD 1A 07                         lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
0C2EE 69 00                            adc #$00                   ;and store as page location of middle
0C2F0 85 01                            sta $01
0C2F2 B5 86                            lda SprObject_X_Position,x ;get horizontal coordinate
0C2F4 C5 02                            cmp $02                    ;compare against middle horizontal coordinate
0C2F6 B5 6D                            lda SprObject_PageLoc,x    ;get page location
0C2F8 E5 01                            sbc $01                    ;subtract from middle page location
0C2FA 90 15                            bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
0C2FC B9 AE 04                         lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
0C2FF 30 0D                            bmi NoOfs                  ;coordinates, branch if still on the screen
0C301 A9 FF                            lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
0C303 BE AC 04                         ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
0C306 30 03                            bmi SORte                  ;coordinates, and branch if still on the screen
0C308 99 AC 04                         sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
0C30B 99 AE 04                  SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
0C30E A6 08                     NoOfs: ldx ObjectOffset           ;get object offset and leave
0C310 60                               rts
0C311                           
0C311                           CheckLeftScreenBBox:
0C311 B9 AC 04                          lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
0C314 10 11                             bpl NoOfs2                 ;coordinates, and branch if still on the screen
0C316 C9 A0                             cmp #$a0                   ;check to see if left-side edge is in the middle of the
0C318 90 0D                             bcc NoOfs2                 ;screen or really offscreen, and branch if still on
0C31A A9 00                             lda #$00
0C31C BE AE 04                          ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
0C31F 10 03                             bpl SOLft                  ;coordinates, branch if still onscreen
0C321 99 AE 04                          sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
0C324 99 AC 04                  SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
0C327 A6 08                     NoOfs2: ldx ObjectOffset           ;get object offset and leave
0C329 60                                rts
0C32A                           
0C32A                           ;-------------------------------------------------------------------------------------
0C32A                           ;$06 - second object's offset
0C32A                           ;$07 - counter
0C32A                           
0C32A                           PlayerCollisionCore:
0C32A A2 00                           ldx #$00     ;initialize X to use player's bounding box for comparison
0C32C                           
0C32C                           SprObjectCollisionCore:
0C32C 84 06                           sty $06      ;save contents of Y here
0C32E A9 01                           lda #$01
0C330 85 07                           sta $07      ;save value 1 here as counter, compare horizontal coordinates first
0C332                           
0C332                           CollisionCoreLoop:
0C332 B9 AC 04                        lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
0C335 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
0C338 B0 2A                           bcs FirstBoxGreater          ;if first left/top => second, branch
0C33A DD AE 04                        cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
0C33D 90 12                           bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
0C33F F0 42                           beq CollisionFound           ;if somehow equal, collision, thus branch
0C341 B9 AE 04                        lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
0C344 D9 AC 04                        cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
0C347 90 3A                           bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
0C349 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
0C34C B0 35                           bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
0C34E A4 06                           ldy $06                      ;otherwise return with carry clear and Y = $0006
0C350 60                              rts                          ;note horizontal wrapping never occurs
0C351                           
0C351                           SecondBoxVerticalChk:
0C351 BD AE 04                        lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
0C354 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
0C357 90 2A                           bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
0C359 B9 AE 04                        lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
0C35C DD AC 04                        cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
0C35F B0 22                           bcs CollisionFound           ;if equal or greater, collision, thus branch
0C361 A4 06                           ldy $06                      ;otherwise return with carry clear and Y = $0006
0C363 60                              rts
0C364                           
0C364                           FirstBoxGreater:
0C364 DD AC 04                        cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
0C367 F0 1A                           beq CollisionFound           ;if first coordinate = second, collision, thus branch
0C369 DD AE 04                        cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
0C36C 90 15                           bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
0C36E F0 13                           beq CollisionFound           ;then collision, thus branch
0C370 D9 AE 04                        cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
0C373 90 0A                           bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
0C375 F0 08                           beq NoCollisionFound
0C377 B9 AE 04                        lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
0C37A DD AC 04                        cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
0C37D B0 04                           bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
0C37F                           
0C37F                           NoCollisionFound:
0C37F 18                              clc          ;clear carry, then load value set earlier, then leave
0C380 A4 06                           ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
0C382 60                              rts          ;not bother checking vertical ones, because what's the point?
0C383                           
0C383                           CollisionFound:
0C383 E8                              inx                    ;increment offsets on both objects to check
0C384 C8                              iny                    ;the vertical coordinates
0C385 C6 07                           dec $07                ;decrement counter to reflect this
0C387 10 A9                           bpl CollisionCoreLoop  ;if counter not expired, branch to loop
0C389 38                              sec                    ;otherwise we already did both sets, therefore collision, so set carry
0C38A A4 06                           ldy $06                ;load original value set here earlier, then leave
0C38C 60                              rts
0C38D                           
0C38D                           ;-------------------------------------------------------------------------------------
0C38D                           ;$02 - modified y coordinate
0C38D                           ;$03 - stores metatile involved in block buffer collisions
0C38D                           ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
0C38D                           ;$05 - modified x coordinate
0C38D                           ;$06-$07 - block buffer address
0C38D                           
0C38D                           BlockBufferChk_Enemy:
0C38D 48                              pha        ;save contents of A to stack
0C38E 8A                              txa
0C38F 18                              clc        ;add 1 to X to run sub with enemy offset in mind
0C390 69 01                           adc #$01
0C392 AA                              tax
0C393 68                              pla        ;pull A from stack and jump elsewhere
0C394 4C AA C3                        jmp BBChk_E
0C397                           
0C397                           ResidualMiscObjectCode:
0C397 8A                              txa
0C398 18                              clc           ;supposedly used once to set offset for
0C399 69 0D                           adc #$0d      ;miscellaneous objects
0C39B AA                              tax
0C39C A0 1B                           ldy #$1b      ;supposedly used once to set offset for block buffer data
0C39E 4C A8 C3                        jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
0C3A1                           
0C3A1                           BlockBufferChk_FBall:
0C3A1 A0 1A                              ldy #$1a                  ;set offset for block buffer adder data
0C3A3 8A                                 txa
0C3A4 18                                 clc
0C3A5 69 07                              adc #$07                  ;add seven bytes to use
0C3A7 AA                                 tax
0C3A8 A9 00                     ResJmpM: lda #$00                  ;set A to return vertical coordinate
0C3AA 20 F5 C3                  BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
0C3AD A6 08                              ldx ObjectOffset          ;get object offset
0C3AF C9 00                              cmp #$00                  ;check to see if object bumped into anything
0C3B1 60                                 rts
0C3B2                           
0C3B2                           BlockBufferAdderData:
0C3B2 00 07 0E                        .db $00, $07, $0e
0C3B5                           
0C3B5                           BlockBuffer_X_Adder:
0C3B5 08 03 0C 02 02 0D 0D 08         .db $08, $03, $0c, $02, $02, $0d, $0d, $08
0C3BD 03 0C 02 02 0D 0D 08 03         .db $03, $0c, $02, $02, $0d, $0d, $08, $03
0C3C5 0C 02 02 0D 0D 08 00 10         .db $0c, $02, $02, $0d, $0d, $08, $00, $10
0C3CD 04 14 04 04                     .db $04, $14, $04, $04
0C3D1                           
0C3D1                           BlockBuffer_Y_Adder:
0C3D1 04 20 20 08 18 08 18 02         .db $04, $20, $20, $08, $18, $08, $18, $02
0C3D9 20 20 08 18 08 18 12 20         .db $20, $20, $08, $18, $08, $18, $12, $20
0C3E1 20 18 18 18 18 18 14 14         .db $20, $18, $18, $18, $18, $18, $14, $14
0C3E9 06 06 08 10                     .db $06, $06, $08, $10
0C3ED                           
0C3ED                           BlockBufferColli_Feet:
0C3ED C8                               iny            ;if branched here, increment to next set of adders
0C3EE                           
0C3EE                           BlockBufferColli_Head:
0C3EE A9 00                            lda #$00       ;set flag to return vertical coordinate
0C3F0 2C                               .db $2c        ;BIT instruction opcode
0C3F1                           
0C3F1                           BlockBufferColli_Side:
0C3F1 A9 01                            lda #$01       ;set flag to return horizontal coordinate
0C3F3 A2 00                            ldx #$00       ;set offset for player object
0C3F5                           
0C3F5                           BlockBufferCollision:
0C3F5 48                               pha                         ;save contents of A to stack
0C3F6 84 04                            sty $04                     ;save contents of Y here
0C3F8 B9 B5 C3                         lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
0C3FB 18                               clc                         ;of object to value obtained using Y as offset
0C3FC 75 86                            adc SprObject_X_Position,x
0C3FE 85 05                            sta $05                     ;store here
0C400 B5 6D                            lda SprObject_PageLoc,x
0C402 69 00                            adc #$00                    ;add carry to page location
0C404 29 01                            and #$01                    ;get LSB, mask out all other bits
0C406 4A                               lsr                         ;move to carry
0C407 05 05                            ora $05                     ;get stored value
0C409 6A                               ror                         ;rotate carry to MSB of A
0C40A 4A                               lsr                         ;and effectively move high nybble to
0C40B 4A                               lsr                         ;lower, LSB which became MSB will be
0C40C 4A                               lsr                         ;d4 at this point
0C40D 20 EB 7B                         jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
0C410 A4 04                            ldy $04                     ;get old contents of Y
0C412 B5 CE                            lda SprObject_Y_Position,x  ;get vertical coordinate of object
0C414 18                               clc
0C415 79 D1 C3                         adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
0C418 29 F0                            and #%11110000              ;mask out low nybble
0C41A 38                               sec
0C41B E9 20                            sbc #$20                    ;subtract 32 pixels for the status bar
0C41D 85 02                            sta $02                     ;store result here
0C41F A8                               tay                         ;use as offset for block buffer
0C420 B1 06                            lda ($06),y                 ;check current content of block buffer
0C422 85 03                            sta $03                     ;and store here
0C424 A4 04                            ldy $04                     ;get old contents of Y again
0C426 68                               pla                         ;pull A from stack
0C427 D0 05                            bne RetXC                   ;if A = 1, branch
0C429 B5 CE                            lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
0C42B 4C 30 C4                         jmp RetYC                   ;and jump
0C42E B5 86                     RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
0C430 29 0F                     RetYC: and #%00001111              ;and mask out high nybble
0C432 85 04                            sta $04                     ;store masked out result here
0C434 A5 03                            lda $03                     ;get saved content of block buffer
0C436 60                               rts                         ;and leave
0C437                           
0C437                           ;-------------------------------------------------------------------------------------
0C437                           ;$00 - offset to vine Y coordinate adder
0C437                           ;$02 - offset to sprite data
0C437                           
0C437                           VineYPosAdder:
0C437 00 30                           .db $00, $30
0C439                           
0C439                           DrawVine:
0C439 84 00                              sty $00                    ;save offset here
0C43B AD B9 03                           lda Enemy_Rel_YPos         ;get relative vertical coordinate
0C43E 18                                 clc
0C43F 79 37 C4                           adc VineYPosAdder,y        ;add value using offset in Y to get value
0C442 BE 9A 03                           ldx VineObjOffset,y        ;get offset to vine
0C445 BC E5 06                           ldy Enemy_SprDataOffset,x  ;get sprite data offset
0C448 84 02                              sty $02                    ;store sprite data offset here
0C44A 20 B2 C4                           jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
0C44D AD AE 03                           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0C450 99 03 02                           sta Sprite_X_Position,y    ;store in first, third and fifth sprites
0C453 99 0B 02                           sta Sprite_X_Position+8,y
0C456 99 13 02                           sta Sprite_X_Position+16,y
0C459 18                                 clc
0C45A 69 06                              adc #$06                   ;add six pixels to second, fourth and sixth sprites
0C45C 99 07 02                           sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
0C45F 99 0F 02                           sta Sprite_X_Position+12,y ;our vertical stack of sprites
0C462 99 17 02                           sta Sprite_X_Position+20,y
0C465 A9 21                              lda #%00100001             ;set bg priority and palette attribute bits
0C467 99 02 02                           sta Sprite_Attributes,y    ;set in first, third and fifth sprites
0C46A 99 0A 02                           sta Sprite_Attributes+8,y
0C46D 99 12 02                           sta Sprite_Attributes+16,y
0C470 09 40                              ora #%01000000             ;additionally, set horizontal flip bit
0C472 99 06 02                           sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
0C475 99 0E 02                           sta Sprite_Attributes+12,y
0C478 99 16 02                           sta Sprite_Attributes+20,y
0C47B A2 05                              ldx #$05                   ;set tiles for six sprites
0C47D A9 E1                     VineTL:  lda #$e1                   ;set tile number for sprite
0C47F 99 01 02                           sta Sprite_Tilenumber,y
0C482 C8                                 iny                        ;move offset to next sprite data
0C483 C8                                 iny
0C484 C8                                 iny
0C485 C8                                 iny
0C486 CA                                 dex                        ;move onto next sprite
0C487 10 F4                              bpl VineTL                 ;loop until all sprites are done
0C489 A4 02                              ldy $02                    ;get original offset
0C48B A5 00                              lda $00                    ;get offset to vine adding data
0C48D D0 05                              bne SkpVTop                ;if offset not zero, skip this part
0C48F A9 E0                              lda #$e0
0C491 99 01 02                           sta Sprite_Tilenumber,y    ;set other tile number for top of vine
0C494 A2 00                     SkpVTop: ldx #$00                   ;start with the first sprite again
0C496 AD 9D 03                  ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
0C499 38                                 sec
0C49A F9 00 02                           sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
0C49D C9 64                              cmp #$64                   ;if two coordinates are less than 100/$64 pixels
0C49F 90 05                              bcc NextVSp                ;apart, skip this to leave sprite alone
0C4A1 A9 F8                              lda #$f8
0C4A3 99 00 02                           sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
0C4A6 C8                        NextVSp: iny                        ;move offset to next OAM data
0C4A7 C8                                 iny
0C4A8 C8                                 iny
0C4A9 C8                                 iny
0C4AA E8                                 inx                        ;move onto next sprite
0C4AB E0 06                              cpx #$06                   ;do this until all sprites are checked
0C4AD D0 E7                              bne ChkFTop
0C4AF A4 00                              ldy $00                    ;return offset set earlier
0C4B1 60                                 rts
0C4B2                           
0C4B2                           SixSpriteStacker:
0C4B2 A2 06                            ldx #$06           ;do six sprites
0C4B4 99 00 02                  StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
0C4B7 18                               clc
0C4B8 69 08                            adc #$08           ;add eight pixels
0C4BA C8                               iny
0C4BB C8                               iny                ;move offset four bytes forward
0C4BC C8                               iny
0C4BD C8                               iny
0C4BE CA                               dex                ;do another sprite
0C4BF D0 F3                            bne StkLp          ;do this until all sprites are done
0C4C1 A4 02                            ldy $02            ;get saved OAM data offset and leave
0C4C3 60                               rts
0C4C4                           
0C4C4                           ;-------------------------------------------------------------------------------------
0C4C4                           
0C4C4                           FirstSprXPos:
0C4C4 04 00 04 00                     .db $04, $00, $04, $00
0C4C8                           
0C4C8                           FirstSprYPos:
0C4C8 00 04 00 04                     .db $00, $04, $00, $04
0C4CC                           
0C4CC                           SecondSprXPos:
0C4CC 00 08 00 08                     .db $00, $08, $00, $08
0C4D0                           
0C4D0                           SecondSprYPos:
0C4D0 08 00 08 00                     .db $08, $00, $08, $00
0C4D4                           
0C4D4                           FirstSprTilenum:
0C4D4 80 82 81 83                     .db $80, $82, $81, $83
0C4D8                           
0C4D8                           SecondSprTilenum:
0C4D8 81 83 80 82                     .db $81, $83, $80, $82
0C4DC                           
0C4DC                           HammerSprAttrib:
0C4DC 03 03 C3 C3                     .db $03, $03, $c3, $c3
0C4E0                           
0C4E0                           DrawHammer:
0C4E0 BC F3 06                              ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
0C4E3 AD 47 07                              lda TimerControl
0C4E6 D0 08                                 bne ForceHPose              ;if master timer control set, skip this part
0C4E8 B5 2A                                 lda Misc_State,x            ;otherwise get hammer's state
0C4EA 29 7F                                 and #%01111111              ;mask out d7
0C4EC C9 01                                 cmp #$01                    ;check to see if set to 1 yet
0C4EE F0 04                                 beq GetHPose                ;if so, branch
0C4F0 A2 00                     ForceHPose: ldx #$00                    ;reset offset here
0C4F2 F0 07                                 beq RenderH                 ;do unconditional branch to rendering part
0C4F4 A5 09                     GetHPose:   lda FrameCounter            ;get frame counter
0C4F6 4A                                    lsr                         ;move d3-d2 to d1-d0
0C4F7 4A                                    lsr
0C4F8 29 03                                 and #%00000011              ;mask out all but d1-d0 (changes every four frames)
0C4FA AA                                    tax                         ;use as timing offset
0C4FB AD BE 03                  RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
0C4FE 18                                    clc
0C4FF 7D C8 C4                              adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
0C502 99 00 02                              sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
0C505 18                                    clc
0C506 7D D0 C4                              adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
0C509 99 04 02                              sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
0C50C AD B3 03                              lda Misc_Rel_XPos           ;get relative horizontal coordinate
0C50F 18                                    clc
0C510 7D C4 C4                              adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
0C513 99 03 02                              sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
0C516 18                                    clc
0C517 7D CC C4                              adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
0C51A 99 07 02                              sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
0C51D BD D4 C4                              lda FirstSprTilenum,x
0C520 99 01 02                              sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
0C523 BD D8 C4                              lda SecondSprTilenum,x
0C526 99 05 02                              sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
0C529 BD DC C4                              lda HammerSprAttrib,x
0C52C 99 02 02                              sta Sprite_Attributes,y     ;get and store attribute bytes for both
0C52F 99 06 02                              sta Sprite_Attributes+4,y   ;note in this case they use the same data
0C532 A6 08                                 ldx ObjectOffset            ;get misc object offset
0C534 AD D6 03                              lda Misc_OffscreenBits
0C537 29 FC                                 and #%11111100              ;check offscreen bits
0C539 F0 09                                 beq NoHOffscr               ;if all bits clear, leave object alone
0C53B A9 00                                 lda #$00
0C53D 95 2A                                 sta Misc_State,x            ;otherwise nullify misc object state
0C53F A9 F8                                 lda #$f8
0C541 20 C5 C5                              jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
0C544 60                        NoHOffscr:  rts                         ;leave
0C545                           
0C545                           ;-------------------------------------------------------------------------------------
0C545                           ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
0C545                           ;$02 - used to hold Y coordinate for floatey number
0C545                           ;$03 - residual byte used for flip (but value set here affects nothing)
0C545                           ;$04 - attribute byte for floatey number
0C545                           ;$05 - used as X coordinate for floatey number
0C545                           
0C545                           FlagpoleScoreNumTiles:
0C545 F9 50                           .db $f9, $50
0C547 F7 50                           .db $f7, $50
0C549 FA FB                           .db $fa, $fb
0C54B F8 FB                           .db $f8, $fb
0C54D F6 FB                           .db $f6, $fb
0C54F                           
0C54F                           FlagpoleGfxHandler:
0C54F BC E5 06                        ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
0C552 AD AE 03                        lda Enemy_Rel_XPos             ;get relative horizontal coordinate
0C555 99 03 02                        sta Sprite_X_Position,y        ;store as X coordinate for first sprite
0C558 18                              clc
0C559 69 08                           adc #$08                       ;add eight pixels and store
0C55B 99 07 02                        sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
0C55E 99 0B 02                        sta Sprite_X_Position+8,y
0C561 18                              clc
0C562 69 0C                           adc #$0c                       ;add twelve more pixels and
0C564 85 05                           sta $05                        ;store here to be used later by floatey number
0C566 B5 CF                           lda Enemy_Y_Position,x         ;get vertical coordinate
0C568 20 C5 C5                        jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
0C56B 69 08                           adc #$08                       ;add eight pixels
0C56D 99 08 02                        sta Sprite_Y_Position+8,y      ;and store into third sprite
0C570 AD 0D 01                        lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
0C573 85 02                           sta $02                        ;store it here
0C575 A9 01                           lda #$01
0C577 85 03                           sta $03                        ;set value for flip which will not be used, and
0C579 85 04                           sta $04                        ;attribute byte for floatey number
0C57B 99 02 02                        sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
0C57E 99 06 02                        sta Sprite_Attributes+4,y
0C581 99 0A 02                        sta Sprite_Attributes+8,y
0C584 A9 7E                           lda #$7e
0C586 99 01 02                        sta Sprite_Tilenumber,y        ;put triangle shaped tile
0C589 99 09 02                        sta Sprite_Tilenumber+8,y      ;into first and third sprites
0C58C A9 7F                           lda #$7f
0C58E 99 05 02                        sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
0C591 AD 0F 07                        lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
0C594 F0 15                           beq ChkFlagOffscreen           ;if zero, branch ahead
0C596 98                              tya
0C597 18                              clc                            ;add 12 bytes to sprite data offset
0C598 69 0C                           adc #$0c
0C59A A8                              tay                            ;put back in Y
0C59B AD 0F 01                        lda FlagpoleScore              ;get offset used to award points for touching flagpole
0C59E 0A                              asl                            ;multiply by 2 to get proper offset here
0C59F AA                              tax
0C5A0 BD 45 C5                        lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
0C5A3 85 00                           sta $00
0C5A5 BD 46 C5                        lda FlagpoleScoreNumTiles+1,x
0C5A8 20 B6 CB                        jsr DrawOneSpriteRow           ;use it to render floatey number
0C5AB                           
0C5AB                           ChkFlagOffscreen:
0C5AB A6 08                           ldx ObjectOffset               ;get object offset for flag
0C5AD BC E5 06                        ldy Enemy_SprDataOffset,x      ;get OAM data offset
0C5B0 AD D1 03                        lda Enemy_OffscreenBits        ;get offscreen bits
0C5B3 29 0E                           and #%00001110                 ;mask out all but d3-d1
0C5B5 F0 14                           beq ExitDumpSpr                ;if none of these bits set, branch to leave
0C5B7                           
0C5B7                           ;-------------------------------------------------------------------------------------
0C5B7                           
0C5B7                           MoveSixSpritesOffscreen:
0C5B7 A9 F8                           lda #$f8                  ;set offscreen coordinate if jumping here
0C5B9                           
0C5B9                           DumpSixSpr:
0C5B9 99 14 02                        sta Sprite_Data+20,y      ;dump A contents
0C5BC 99 10 02                        sta Sprite_Data+16,y      ;into third row sprites
0C5BF                           
0C5BF                           DumpFourSpr:
0C5BF 99 0C 02                        sta Sprite_Data+12,y      ;into second row sprites
0C5C2                           
0C5C2                           DumpThreeSpr:
0C5C2 99 08 02                        sta Sprite_Data+8,y
0C5C5                           
0C5C5                           DumpTwoSpr:
0C5C5 99 04 02                        sta Sprite_Data+4,y       ;and into first row sprites
0C5C8 99 00 02                        sta Sprite_Data,y
0C5CB                           
0C5CB                           ExitDumpSpr:
0C5CB 60                              rts
0C5CC                           
0C5CC                           ;-------------------------------------------------------------------------------------
0C5CC                           
0C5CC                           DrawLargePlatform:
0C5CC BC E5 06                        ldy Enemy_SprDataOffset,x   ;get OAM data offset
0C5CF 84 02                           sty $02                     ;store here
0C5D1 C8                              iny                         ;add 3 to it for offset
0C5D2 C8                              iny                         ;to X coordinate
0C5D3 C8                              iny
0C5D4 AD AE 03                        lda Enemy_Rel_XPos          ;get horizontal relative coordinate
0C5D7 20 B2 C4                        jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
0C5DA A6 08                           ldx ObjectOffset
0C5DC B5 CF                           lda Enemy_Y_Position,x      ;get vertical coordinate
0C5DE 20 BF C5                        jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
0C5E1 AC 4E 07                        ldy AreaType
0C5E4 C0 03                           cpy #$03                    ;check for castle-type level
0C5E6 F0 05                           beq ShrinkPlatform
0C5E8 AC CC 06                        ldy SecondaryHardMode       ;check for secondary hard mode flag set
0C5EB F0 02                           beq SetLast2Platform        ;branch if not set elsewhere
0C5ED                           
0C5ED                           ShrinkPlatform:
0C5ED A9 F8                           lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
0C5EF                           
0C5EF                           SetLast2Platform:
0C5EF BC E5 06                        ldy Enemy_SprDataOffset,x   ;get OAM data offset
0C5F2 99 10 02                        sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
0C5F5 99 14 02                        sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
0C5F8 A9 5B                           lda #$5b                    ;load default tile for platform (girder)
0C5FA AE 43 07                        ldx CloudTypeOverride
0C5FD F0 02                           beq SetPlatformTilenum      ;if cloud level override flag not set, use
0C5FF A9 75                           lda #$75                    ;otherwise load other tile for platform (puff)
0C601                           
0C601                           SetPlatformTilenum:
0C601 A6 08                             ldx ObjectOffset            ;get enemy object buffer offset
0C603 C8                                iny                         ;increment Y for tile offset
0C604 20 B9 C5                          jsr DumpSixSpr              ;dump tile number into all six sprites
0C607 A9 02                             lda #$02                    ;set palette controls
0C609 C8                                iny                         ;increment Y for sprite attributes
0C60A 20 B9 C5                          jsr DumpSixSpr              ;dump attributes into all six sprites
0C60D E8                                inx                         ;increment X for enemy objects
0C60E 20 FA D1                          jsr GetXOffscreenBits       ;get offscreen bits again
0C611 CA                                dex
0C612 BC E5 06                          ldy Enemy_SprDataOffset,x   ;get OAM data offset
0C615 0A                                asl                         ;rotate d7 into carry, save remaining
0C616 48                                pha                         ;bits to the stack
0C617 90 05                             bcc SChk2
0C619 A9 F8                             lda #$f8                    ;if d7 was set, move first sprite offscreen
0C61B 99 00 02                          sta Sprite_Y_Position,y
0C61E 68                        SChk2:  pla                         ;get bits from stack
0C61F 0A                                asl                         ;rotate d6 into carry
0C620 48                                pha                         ;save to stack
0C621 90 05                             bcc SChk3
0C623 A9 F8                             lda #$f8                    ;if d6 was set, move second sprite offscreen
0C625 99 04 02                          sta Sprite_Y_Position+4,y
0C628 68                        SChk3:  pla                         ;get bits from stack
0C629 0A                                asl                         ;rotate d5 into carry
0C62A 48                                pha                         ;save to stack
0C62B 90 05                             bcc SChk4
0C62D A9 F8                             lda #$f8                    ;if d5 was set, move third sprite offscreen
0C62F 99 08 02                          sta Sprite_Y_Position+8,y
0C632 68                        SChk4:  pla                         ;get bits from stack
0C633 0A                                asl                         ;rotate d4 into carry
0C634 48                                pha                         ;save to stack
0C635 90 05                             bcc SChk5
0C637 A9 F8                             lda #$f8                    ;if d4 was set, move fourth sprite offscreen
0C639 99 0C 02                          sta Sprite_Y_Position+12,y
0C63C 68                        SChk5:  pla                         ;get bits from stack
0C63D 0A                                asl                         ;rotate d3 into carry
0C63E 48                                pha                         ;save to stack
0C63F 90 05                             bcc SChk6
0C641 A9 F8                             lda #$f8                    ;if d3 was set, move fifth sprite offscreen
0C643 99 10 02                          sta Sprite_Y_Position+16,y
0C646 68                        SChk6:  pla                         ;get bits from stack
0C647 0A                                asl                         ;rotate d2 into carry
0C648 90 05                             bcc SLChk                   ;save to stack
0C64A A9 F8                             lda #$f8
0C64C 99 14 02                          sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
0C64F AD D1 03                  SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
0C652 0A                                asl                         ;and if d7 is not set, skip sub
0C653 90 03                             bcc ExDLPl
0C655 20 B7 C5                          jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
0C658 60                        ExDLPl: rts
0C659                           
0C659                           ;-------------------------------------------------------------------------------------
0C659                           
0C659                           DrawFloateyNumber_Coin:
0C659 A5 09                               lda FrameCounter          ;get frame counter
0C65B 4A                                  lsr                       ;divide by 2
0C65C B0 02                               bcs NotRsNum              ;branch if d0 not set to raise number every other frame
0C65E D6 DB                               dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
0C660 B5 DB                     NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
0C662 20 C5 C5                            jsr DumpTwoSpr            ;dump into both sprites
0C665 AD B3 03                            lda Misc_Rel_XPos         ;get relative horizontal coordinate
0C668 99 03 02                            sta Sprite_X_Position,y   ;store as X coordinate for first sprite
0C66B 18                                  clc
0C66C 69 08                               adc #$08                  ;add eight pixels
0C66E 99 07 02                            sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
0C671 A9 02                               lda #$02
0C673 99 02 02                            sta Sprite_Attributes,y   ;store attribute byte in both sprites
0C676 99 06 02                            sta Sprite_Attributes+4,y
0C679 A9 F7                               lda #$f7
0C67B 99 01 02                            sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
0C67E A9 FB                               lda #$fb                  ;that resemble "200"
0C680 99 05 02                            sta Sprite_Tilenumber+4,y
0C683 4C C1 C6                            jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
0C686                           
0C686                           JumpingCoinTiles:
0C686 60 61 62 63                     .db $60, $61, $62, $63
0C68A                           
0C68A                           JCoinGfxHandler:
0C68A BC F3 06                           ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
0C68D B5 2A                              lda Misc_State,x            ;get state of misc object
0C68F C9 02                              cmp #$02                    ;if 2 or greater, 
0C691 B0 C6                              bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
0C693 B5 DB                              lda Misc_Y_Position,x       ;store vertical coordinate as
0C695 99 00 02                           sta Sprite_Y_Position,y     ;Y coordinate for first sprite
0C698 18                                 clc
0C699 69 08                              adc #$08                    ;add eight pixels
0C69B 99 04 02                           sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
0C69E AD B3 03                           lda Misc_Rel_XPos           ;get relative horizontal coordinate
0C6A1 99 03 02                           sta Sprite_X_Position,y
0C6A4 99 07 02                           sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
0C6A7 A5 09                              lda FrameCounter            ;get frame counter
0C6A9 4A                                 lsr                         ;divide by 2 to alter every other frame
0C6AA 29 03                              and #%00000011              ;mask out d2-d1
0C6AC AA                                 tax                         ;use as graphical offset
0C6AD BD 86 C6                           lda JumpingCoinTiles,x      ;load tile number
0C6B0 C8                                 iny                         ;increment OAM data offset to write tile numbers
0C6B1 20 C5 C5                           jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
0C6B4 88                                 dey                         ;decrement to get old offset
0C6B5 A9 02                              lda #$02
0C6B7 99 02 02                           sta Sprite_Attributes,y     ;set attribute byte in first sprite
0C6BA A9 82                              lda #$82
0C6BC 99 06 02                           sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
0C6BF A6 08                              ldx ObjectOffset            ;get misc object offset
0C6C1 60                        ExJCGfx: rts                         ;leave
0C6C2                           
0C6C2                           ;-------------------------------------------------------------------------------------
0C6C2                           ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
0C6C2                           ;$02 - used to hold bottom row Y position
0C6C2                           ;$03 - used to hold flip control (not used here)
0C6C2                           ;$04 - used to hold sprite attributes
0C6C2                           ;$05 - used to hold X position
0C6C2                           ;$07 - counter
0C6C2                           
0C6C2                           ;tiles arranged in top left, right, bottom left, right order
0C6C2                           PowerUpGfxTable:
0C6C2 76 77 78 79                     .db $76, $77, $78, $79 ;regular mushroom
0C6C6 D6 D6 D9 D9                     .db $d6, $d6, $d9, $d9 ;fire flower
0C6CA 8D 8D E4 E4                     .db $8d, $8d, $e4, $e4 ;star
0C6CE 76 77 78 79                     .db $76, $77, $78, $79 ;1-up mushroom
0C6D2                           
0C6D2                           PowerUpAttributes:
0C6D2 02 01 02 01                     .db $02, $01, $02, $01
0C6D6                           
0C6D6                           DrawPowerUp:
0C6D6 AC EA 06                        ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
0C6D9 AD B9 03                        lda Enemy_Rel_YPos         ;get relative vertical coordinate
0C6DC 18                              clc
0C6DD 69 08                           adc #$08                   ;add eight pixels
0C6DF 85 02                           sta $02                    ;store result here
0C6E1 AD AE 03                        lda Enemy_Rel_XPos         ;get relative horizontal coordinate
0C6E4 85 05                           sta $05                    ;store here
0C6E6 A6 39                           ldx PowerUpType            ;get power-up type
0C6E8 BD D2 C6                        lda PowerUpAttributes,x    ;get attribute data for power-up type
0C6EB 0D CA 03                        ora Enemy_SprAttrib+5      ;add background priority bit if set
0C6EE 85 04                           sta $04                    ;store attributes here
0C6F0 8A                              txa
0C6F1 48                              pha                        ;save power-up type to the stack
0C6F2 0A                              asl
0C6F3 0A                              asl                        ;multiply by four to get proper offset
0C6F4 AA                              tax                        ;use as X
0C6F5 A9 01                           lda #$01
0C6F7 85 07                           sta $07                    ;set counter here to draw two rows of sprite object
0C6F9 85 03                           sta $03                    ;init d1 of flip control
0C6FB                           
0C6FB                           PUpDrawLoop:
0C6FB BD C2 C6                          lda PowerUpGfxTable,x      ;load left tile of power-up object
0C6FE 85 00                             sta $00
0C700 BD C3 C6                          lda PowerUpGfxTable+1,x    ;load right tile
0C703 20 B6 CB                          jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
0C706 C6 07                             dec $07                    ;decrement counter
0C708 10 F1                             bpl PUpDrawLoop            ;branch until two rows are drawn
0C70A AC EA 06                          ldy Enemy_SprDataOffset+5  ;get sprite data offset again
0C70D 68                                pla                        ;pull saved power-up type from the stack
0C70E F0 2F                             beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
0C710 C9 03                             cmp #$03
0C712 F0 2B                             beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
0C714 85 00                             sta $00                    ;store power-up type here now
0C716 A5 09                             lda FrameCounter           ;get frame counter
0C718 4A                                lsr                        ;divide by 2 to change colors every two frames
0C719 29 03                             and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
0C71B 0D CA 03                          ora Enemy_SprAttrib+5      ;add background priority bit if any set
0C71E 99 02 02                          sta Sprite_Attributes,y    ;set as new palette bits for top left and
0C721 99 06 02                          sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
0C724 A6 00                             ldx $00
0C726 CA                                dex                        ;check power-up type for fire flower
0C727 F0 06                             beq FlipPUpRightSide       ;if found, skip this part
0C729 99 0A 02                          sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
0C72C 99 0E 02                          sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
0C72F                           
0C72F                           FlipPUpRightSide:
0C72F B9 06 02                          lda Sprite_Attributes+4,y
0C732 09 40                             ora #%01000000             ;set horizontal flip bit for top right sprite
0C734 99 06 02                          sta Sprite_Attributes+4,y
0C737 B9 0E 02                          lda Sprite_Attributes+12,y
0C73A 09 40                             ora #%01000000             ;set horizontal flip bit for bottom right sprite
0C73C 99 0E 02                          sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
0C73F 4C 68 CB                  PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
0C742                           
0C742                           ;-------------------------------------------------------------------------------------
0C742                           ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
0C742                           ;$02 - used to store Y position
0C742                           ;$03 - used to store moving direction, used to flip enemies horizontally
0C742                           ;$04 - used to store enemy's sprite attributes
0C742                           ;$05 - used to store X position
0C742                           ;$eb - used to hold sprite data offset
0C742                           ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
0C742                           ;$ed - used to hold enemy state from buffer 
0C742                           ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
0C742                           
0C742                           ;tiles arranged in top left, right, middle left, right, bottom left, right order
0C742                           EnemyGraphicsTable:
0C742 FC FC AA AB AC AD               .db $fc, $fc, $aa, $ab, $ac, $ad  ;buzzy beetle frame 1
0C748 FC FC AE AF B0 B1               .db $fc, $fc, $ae, $af, $b0, $b1  ;             frame 2
0C74E FC A5 A6 A7 A8 A9               .db $fc, $a5, $a6, $a7, $a8, $a9  ;koopa troopa frame 1
0C754 FC A0 A1 A2 A3 A4               .db $fc, $a0, $a1, $a2, $a3, $a4  ;             frame 2
0C75A 69 A5 6A A7 A8 A9               .db $69, $a5, $6a, $a7, $a8, $a9  ;koopa paratroopa frame 1
0C760 6B A0 6C A2 A3 A4               .db $6b, $a0, $6c, $a2, $a3, $a4  ;                 frame 2
0C766 FC FC 96 97 98 99               .db $fc, $fc, $96, $97, $98, $99  ;spiny frame 1
0C76C FC FC 9A 9B 9C 9D               .db $fc, $fc, $9a, $9b, $9c, $9d  ;      frame 2
0C772 FC FC 8F 8E 8E 8F               .db $fc, $fc, $8f, $8e, $8e, $8f  ;spiny's egg frame 1
0C778 FC FC 95 94 94 95               .db $fc, $fc, $95, $94, $94, $95  ;            frame 2
0C77E FC FC DC DC DF DF               .db $fc, $fc, $dc, $dc, $df, $df  ;bloober frame 1
0C784 DC DC DD DD DE DE               .db $dc, $dc, $dd, $dd, $de, $de  ;        frame 2
0C78A FC FC B2 B3 B4 B5               .db $fc, $fc, $b2, $b3, $b4, $b5  ;cheep-cheep frame 1
0C790 FC FC B6 B3 B7 B5               .db $fc, $fc, $b6, $b3, $b7, $b5  ;            frame 2
0C796 FC FC 70 71 72 73               .db $fc, $fc, $70, $71, $72, $73  ;goomba
0C79C FC FC 6E 6E 6F 6F               .db $fc, $fc, $6e, $6e, $6f, $6f  ;koopa shell frame 1 (upside-down)
0C7A2 FC FC 6D 6D 6F 6F               .db $fc, $fc, $6d, $6d, $6f, $6f  ;            frame 2
0C7A8 FC FC 6F 6F 6E 6E               .db $fc, $fc, $6f, $6f, $6e, $6e  ;koopa shell frame 1 (rightsideup)
0C7AE FC FC 6F 6F 6D 6D               .db $fc, $fc, $6f, $6f, $6d, $6d  ;            frame 2
0C7B4 FC FC F4 F4 F5 F5               .db $fc, $fc, $f4, $f4, $f5, $f5  ;buzzy beetle shell frame 1 (rightsideup)
0C7BA FC FC F4 F4 F5 F5               .db $fc, $fc, $f4, $f4, $f5, $f5  ;                   frame 2
0C7C0 FC FC F5 F5 F4 F4               .db $fc, $fc, $f5, $f5, $f4, $f4  ;buzzy beetle shell frame 1 (upside-down)
0C7C6 FC FC F5 F5 F4 F4               .db $fc, $fc, $f5, $f5, $f4, $f4  ;                   frame 2
0C7CC FC FC FC FC EF EF               .db $fc, $fc, $fc, $fc, $ef, $ef  ;defeated goomba
0C7D2 B9 B8 BB BA BC BC               .db $b9, $b8, $bb, $ba, $bc, $bc  ;lakitu frame 1
0C7D8 FC FC BD BD BC BC               .db $fc, $fc, $bd, $bd, $bc, $bc  ;       frame 2
0C7DE 7A 7B DA DB D8 D8               .db $7a, $7b, $da, $db, $d8, $d8  ;princess
0C7E4 CD CD CE CE CF CF               .db $cd, $cd, $ce, $ce, $cf, $cf  ;mushroom retainer
0C7EA 7D 7C D1 8C D3 D2               .db $7d, $7c, $d1, $8c, $d3, $d2  ;hammer bro frame 1
0C7F0 7D 7C 89 88 8B 8A               .db $7d, $7c, $89, $88, $8b, $8a  ;           frame 2
0C7F6 D5 D4 E3 E2 D3 D2               .db $d5, $d4, $e3, $e2, $d3, $d2  ;           frame 3
0C7FC D5 D4 E3 E2 8B 8A               .db $d5, $d4, $e3, $e2, $8b, $8a  ;           frame 4
0C802 E5 E5 E6 E6 EB EB               .db $e5, $e5, $e6, $e6, $eb, $eb  ;piranha plant frame 1
0C808 EC EC ED ED EE EE               .db $ec, $ec, $ed, $ed, $ee, $ee  ;              frame 2
0C80E FC FC D0 D0 D7 D7               .db $fc, $fc, $d0, $d0, $d7, $d7  ;podoboo
0C814 BF BE C1 C0 C2 FC               .db $bf, $be, $c1, $c0, $c2, $fc  ;bowser front frame 1
0C81A C4 C3 C6 C5 C8 C7               .db $c4, $c3, $c6, $c5, $c8, $c7  ;bowser rear frame 1
0C820 BF BE CA C9 C2 FC               .db $bf, $be, $ca, $c9, $c2, $fc  ;       front frame 2
0C826 C4 C3 C6 C5 CC CB               .db $c4, $c3, $c6, $c5, $cc, $cb  ;       rear frame 2
0C82C FC FC E8 E7 EA E9               .db $fc, $fc, $e8, $e7, $ea, $e9  ;bullet bill
0C832 F2 F2 F3 F3 F2 F2               .db $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1
0C838 F1 F1 F1 F1 FC FC               .db $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2
0C83E F0 F0 FC FC FC FC               .db $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
0C844                           
0C844                           EnemyGfxTableOffsets:
0C844 0C 0C 00 0C 0C A8 54 3C         .db $0c, $0c, $00, $0c, $0c, $a8, $54, $3c
0C84C EA 18 48 48 CC C0 18 18         .db $ea, $18, $48, $48, $cc, $c0, $18, $18
0C854 18 90 24 FF 48 9C D2 D8         .db $18, $90, $24, $ff, $48, $9c, $d2, $d8
0C85C F0 F6 FC                        .db $f0, $f6, $fc
0C85F                           
0C85F                           EnemyAttributeData:
0C85F 01 02 03 02 01 01 03 03         .db $01, $02, $03, $02, $01, $01, $03, $03
0C867 03 01 01 02 02 21 01 02         .db $03, $01, $01, $02, $02, $21, $01, $02
0C86F 01 01 02 FF 02 02 01 01         .db $01, $01, $02, $ff, $02, $02, $01, $01
0C877 02 02 02                        .db $02, $02, $02
0C87A                           
0C87A                           EnemyAnimTimingBMask:
0C87A 08 18                           .db $08, $18
0C87C                           
0C87C                           JumpspringFrameOffsets:
0C87C 18 19 1A 19 18                  .db $18, $19, $1a, $19, $18
0C881                           
0C881                           EnemyGfxHandler:
0C881 B5 CF                           lda Enemy_Y_Position,x      ;get enemy object vertical position
0C883 85 02                           sta $02
0C885 AD AE 03                        lda Enemy_Rel_XPos          ;get enemy object horizontal position
0C888 85 05                           sta $05                     ;relative to screen
0C88A BC E5 06                        ldy Enemy_SprDataOffset,x
0C88D 84 EB                           sty $eb                     ;get sprite data offset
0C88F A9 00                           lda #$00
0C891 8D 09 01                        sta VerticalFlipFlag        ;initialize vertical flip flag by default
0C894 B5 46                           lda Enemy_MovingDir,x
0C896 85 03                           sta $03                     ;get enemy object moving direction
0C898 BD C5 03                        lda Enemy_SprAttrib,x
0C89B 85 04                           sta $04                     ;get enemy object sprite attributes
0C89D B5 16                           lda Enemy_ID,x
0C89F C9 0D                           cmp #PiranhaPlant           ;is enemy object piranha plant?
0C8A1 D0 0A                           bne CheckForRetainerObj     ;if not, branch
0C8A3 B4 58                           ldy PiranhaPlant_Y_Speed,x
0C8A5 30 06                           bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
0C8A7 BC 8A 07                        ldy EnemyFrameTimer,x
0C8AA F0 01                           beq CheckForRetainerObj     ;if timer for movement expired, branch
0C8AC 60                              rts                         ;if all conditions fail, leave
0C8AD                           
0C8AD                           CheckForRetainerObj:
0C8AD B5 1E                           lda Enemy_State,x           ;store enemy state
0C8AF 85 ED                           sta $ed
0C8B1 29 1F                           and #%00011111              ;nullify all but 5 LSB and use as Y
0C8B3 A8                              tay
0C8B4 B5 16                           lda Enemy_ID,x              ;check for mushroom retainer/princess object
0C8B6 C9 35                           cmp #RetainerObject
0C8B8 D0 08                           bne CheckForBulletBillCV    ;if not found, branch
0C8BA A0 00                           ldy #$00                    ;if found, nullify saved state in Y
0C8BC A9 01                           lda #$01                    ;set value that will not be used
0C8BE 85 03                           sta $03
0C8C0 A9 15                           lda #$15                    ;set value $15 as code for mushroom retainer/princess object
0C8C2                           
0C8C2                           CheckForBulletBillCV:
0C8C2 C9 33                            cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
0C8C4 D0 13                            bne CheckForJumpspring      ;if not found, branch again
0C8C6 C6 02                            dec $02                     ;decrement saved vertical position
0C8C8 A9 03                            lda #$03
0C8CA BC 8A 07                         ldy EnemyFrameTimer,x       ;get timer for enemy object
0C8CD F0 02                            beq SBBAt                   ;if expired, do not set priority bit
0C8CF 09 20                            ora #%00100000              ;otherwise do so
0C8D1 85 04                     SBBAt: sta $04                     ;set new sprite attributes
0C8D3 A0 00                            ldy #$00                    ;nullify saved enemy state both in Y and in
0C8D5 84 ED                            sty $ed                     ;memory location here
0C8D7 A9 08                            lda #$08                    ;set specific value to unconditionally branch once
0C8D9                           
0C8D9                           CheckForJumpspring:
0C8D9 C9 32                           cmp #JumpspringObject        ;check for jumpspring object
0C8DB D0 08                           bne CheckForPodoboo
0C8DD A0 03                           ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
0C8DF AE 0E 07                        ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
0C8E2 BD 7C C8                        lda JumpspringFrameOffsets,x ;load data using frame number as offset
0C8E5                           
0C8E5                           CheckForPodoboo:
0C8E5 85 EF                           sta $ef                 ;store saved enemy object value here
0C8E7 84 EC                           sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
0C8E9 A6 08                           ldx ObjectOffset        ;get enemy object offset
0C8EB C9 0C                           cmp #$0c                ;check for podoboo object
0C8ED D0 07                           bne CheckBowserGfxFlag  ;branch if not found
0C8EF B5 A0                           lda Enemy_Y_Speed,x     ;if moving upwards, branch
0C8F1 30 03                           bmi CheckBowserGfxFlag
0C8F3 EE 09 01                        inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
0C8F6                           
0C8F6                           CheckBowserGfxFlag:
0C8F6 AD 6A 03                               lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
0C8F9 F0 09                                  beq CheckForGoomba
0C8FB A0 16                                  ldy #$16            ;if set to 1, draw bowser's front
0C8FD C9 01                                  cmp #$01
0C8FF F0 01                                  beq SBwsrGfxOfs
0C901 C8                                     iny                 ;otherwise draw bowser's rear
0C902 84 EF                     SBwsrGfxOfs: sty $ef
0C904                           
0C904                           CheckForGoomba:
0C904 A4 EF                               ldy $ef               ;check value for goomba object
0C906 C0 06                               cpy #Goomba
0C908 D0 1D                               bne CheckBowserFront  ;branch if not found
0C90A B5 1E                               lda Enemy_State,x
0C90C C9 02                               cmp #$02              ;check for defeated state
0C90E 90 04                               bcc GmbaAnim          ;if not defeated, go ahead and animate
0C910 A2 04                               ldx #$04              ;if defeated, write new value here
0C912 86 EC                               stx $ec
0C914 29 20                     GmbaAnim: and #%00100000        ;check for d5 set in enemy object state 
0C916 0D 47 07                            ora TimerControl      ;or timer disable flag set
0C919 D0 0C                               bne CheckBowserFront  ;if either condition true, do not animate goomba
0C91B A5 09                               lda FrameCounter
0C91D 29 08                               and #%00001000        ;check for every eighth frame
0C91F D0 06                               bne CheckBowserFront
0C921 A5 03                               lda $03
0C923 49 03                               eor #%00000011        ;invert bits to flip horizontally every eight frames
0C925 85 03                               sta $03               ;leave alone otherwise
0C927                           
0C927                           CheckBowserFront:
0C927 B9 5F C8                               lda EnemyAttributeData,y    ;load sprite attribute using enemy object
0C92A 05 04                                  ora $04                     ;as offset, and add to bits already loaded
0C92C 85 04                                  sta $04
0C92E B9 44 C8                               lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
0C931 AA                                     tax                         ;save as X
0C932 A4 EC                                  ldy $ec                     ;get previously saved value
0C934 AD 6A 03                               lda BowserGfxFlag
0C937 F0 30                                  beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
0C939 C9 01                                  cmp #$01
0C93B D0 13                                  bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
0C93D AD 63 03                               lda BowserBodyControls      ;check bowser's body control bits
0C940 10 02                                  bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)      
0C942 A2 DE                                  ldx #$de                    ;otherwise load offset for second frame
0C944 A5 ED                     ChkFrontSte: lda $ed                     ;check saved enemy state
0C946 29 20                                  and #%00100000              ;if bowser not defeated, do not set flag
0C948 F0 03                                  beq DrawBowser
0C94A                           
0C94A                           FlipBowserOver:
0C94A 8E 09 01                        stx VerticalFlipFlag  ;set vertical flip flag to nonzero
0C94D                           
0C94D                           DrawBowser:
0C94D 4C 4F CA                        jmp DrawEnemyObject   ;draw bowser's graphics now
0C950                           
0C950                           CheckBowserRear:
0C950 AD 63 03                              lda BowserBodyControls  ;check bowser's body control bits
0C953 29 01                                 and #$01
0C955 F0 02                                 beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
0C957 A2 E4                                 ldx #$e4                ;otherwise load offset for second frame
0C959 A5 ED                     ChkRearSte: lda $ed                 ;check saved enemy state
0C95B 29 20                                 and #%00100000          ;if bowser not defeated, do not set flag
0C95D F0 EE                                 beq DrawBowser
0C95F A5 02                                 lda $02                 ;subtract 16 pixels from
0C961 38                                    sec                     ;saved vertical coordinate
0C962 E9 10                                 sbc #$10
0C964 85 02                                 sta $02
0C966 4C 4A C9                              jmp FlipBowserOver      ;jump to set vertical flip flag
0C969                           
0C969                           CheckForSpiny:
0C969 E0 24                             cpx #$24               ;check if value loaded is for spiny
0C96B D0 11                             bne CheckForLakitu     ;if not found, branch
0C96D C0 05                             cpy #$05               ;if enemy state set to $05, do this,
0C96F D0 0A                             bne NotEgg             ;otherwise branch
0C971 A2 30                             ldx #$30               ;set to spiny egg offset
0C973 A9 02                             lda #$02
0C975 85 03                             sta $03                ;set enemy direction to reverse sprites horizontally
0C977 A9 05                             lda #$05
0C979 85 EC                             sta $ec                ;set enemy state
0C97B 4C CE C9                  NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
0C97E                           
0C97E                           CheckForLakitu:
0C97E E0 90                             cpx #$90                  ;check value for lakitu's offset loaded
0C980 D0 12                             bne CheckUpsideDownShell  ;branch if not loaded
0C982 A5 ED                             lda $ed
0C984 29 20                             and #%00100000            ;check for d5 set in enemy state
0C986 D0 09                             bne NoLAFr                ;branch if set
0C988 AD 8F 07                          lda FrenzyEnemyTimer
0C98B C9 10                             cmp #$10                  ;check timer to see if we've reached a certain range
0C98D B0 02                             bcs NoLAFr                ;branch if not
0C98F A2 96                             ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
0C991 4C 3B CA                  NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
0C994                           
0C994                           CheckUpsideDownShell:
0C994 A5 EF                           lda $ef                    ;check for enemy object => $04
0C996 C9 04                           cmp #$04
0C998 B0 10                           bcs CheckRightSideUpShell  ;branch if true
0C99A C0 02                           cpy #$02
0C99C 90 0C                           bcc CheckRightSideUpShell  ;branch if enemy state < $02
0C99E A2 5A                           ldx #$5a                   ;set for upside-down koopa shell by default
0C9A0 A4 EF                           ldy $ef
0C9A2 C0 02                           cpy #BuzzyBeetle           ;check for buzzy beetle object
0C9A4 D0 04                           bne CheckRightSideUpShell
0C9A6 A2 7E                           ldx #$7e                   ;set for upside-down buzzy beetle shell if found
0C9A8 E6 02                           inc $02                    ;increment vertical position by one pixel
0C9AA                           
0C9AA                           CheckRightSideUpShell:
0C9AA A5 EC                           lda $ec                ;check for value set here
0C9AC C9 04                           cmp #$04               ;if enemy state < $02, do not change to shell, if
0C9AE D0 1E                           bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
0C9B0 A2 72                           ldx #$72               ;set right-side up buzzy beetle shell by default
0C9B2 E6 02                           inc $02                ;increment saved vertical position by one pixel
0C9B4 A4 EF                           ldy $ef
0C9B6 C0 02                           cpy #BuzzyBeetle       ;check for buzzy beetle object
0C9B8 F0 04                           beq CheckForDefdGoomba ;branch if found
0C9BA A2 66                           ldx #$66               ;change to right-side up koopa shell if not found
0C9BC E6 02                           inc $02                ;and increment saved vertical position again
0C9BE                           
0C9BE                           CheckForDefdGoomba:
0C9BE C0 06                           cpy #Goomba            ;check for goomba object (necessary if previously
0C9C0 D0 0C                           bne CheckForHammerBro  ;failed buzzy beetle object test)
0C9C2 A2 54                           ldx #$54               ;load for regular goomba
0C9C4 A5 ED                           lda $ed                ;note that this only gets performed if enemy state => $02
0C9C6 29 20                           and #%00100000         ;check saved enemy state for d5 set
0C9C8 D0 04                           bne CheckForHammerBro  ;branch if set
0C9CA A2 8A                           ldx #$8a               ;load offset for defeated goomba
0C9CC C6 02                           dec $02                ;set different value and decrement saved vertical position
0C9CE                           
0C9CE                           CheckForHammerBro:
0C9CE A4 08                           ldy ObjectOffset
0C9D0 A5 EF                           lda $ef                  ;check for hammer bro object
0C9D2 C9 05                           cmp #HammerBro
0C9D4 D0 0C                           bne CheckForBloober      ;branch if not found
0C9D6 A5 ED                           lda $ed
0C9D8 F0 24                           beq CheckToAnimateEnemy  ;branch if not in normal enemy state
0C9DA 29 08                           and #%00001000
0C9DC F0 5D                           beq CheckDefeatedState   ;if d3 not set, branch further away
0C9DE A2 B4                           ldx #$b4                 ;otherwise load offset for different frame
0C9E0 D0 1C                           bne CheckToAnimateEnemy  ;unconditional branch
0C9E2                           
0C9E2                           CheckForBloober:
0C9E2 E0 48                           cpx #$48                 ;check for cheep-cheep offset loaded
0C9E4 F0 18                           beq CheckToAnimateEnemy  ;branch if found
0C9E6 B9 96 07                        lda EnemyIntervalTimer,y
0C9E9 C9 05                           cmp #$05
0C9EB B0 4E                           bcs CheckDefeatedState   ;branch if some timer is above a certain point
0C9ED E0 3C                           cpx #$3c                 ;check for bloober offset loaded
0C9EF D0 0D                           bne CheckToAnimateEnemy  ;branch if not found this time
0C9F1 C9 01                           cmp #$01
0C9F3 F0 46                           beq CheckDefeatedState   ;branch if timer is set to certain point
0C9F5 E6 02                           inc $02                  ;increment saved vertical coordinate three pixels
0C9F7 E6 02                           inc $02
0C9F9 E6 02                           inc $02
0C9FB 4C 2D CA                        jmp CheckAnimationStop   ;and do something else
0C9FE                           
0C9FE                           CheckToAnimateEnemy:
0C9FE A5 EF                           lda $ef                  ;check for specific enemy objects
0CA00 C9 06                           cmp #Goomba
0CA02 F0 37                           beq CheckDefeatedState   ;branch if goomba
0CA04 C9 08                           cmp #$08
0CA06 F0 33                           beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
0CA08 C9 0C                           cmp #Podoboo
0CA0A F0 2F                           beq CheckDefeatedState   ;branch if podoboo
0CA0C C9 18                           cmp #$18                 ;branch if => $18
0CA0E B0 2B                           bcs CheckDefeatedState
0CA10 A0 00                           ldy #$00    
0CA12 C9 15                           cmp #$15                 ;check for mushroom retainer/princess object
0CA14 D0 10                           bne CheckForSecondFrame  ;which uses different code here, branch if not found
0CA16 C8                              iny                      ;residual instruction
0CA17 AD 5F 07                        lda WorldNumber          ;are we on world 8?
0CA1A C9 07                           cmp #World8
0CA1C B0 1D                           bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
0CA1E A2 A2                           ldx #$a2                 ;otherwise, set for mushroom retainer object instead
0CA20 A9 03                           lda #$03                 ;set alternate state here
0CA22 85 EC                           sta $ec
0CA24 D0 15                           bne CheckDefeatedState   ;unconditional branch
0CA26                           
0CA26                           CheckForSecondFrame:
0CA26 A5 09                           lda FrameCounter            ;load frame counter
0CA28 39 7A C8                        and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
0CA2B D0 0E                           bne CheckDefeatedState      ;branch if timing is off
0CA2D                           
0CA2D                           CheckAnimationStop:
0CA2D A5 ED                           lda $ed                 ;check saved enemy state
0CA2F 29 A0                           and #%10100000          ;for d7 or d5, or check for timers stopped
0CA31 0D 47 07                        ora TimerControl
0CA34 D0 05                           bne CheckDefeatedState  ;if either condition true, branch
0CA36 8A                              txa
0CA37 18                              clc
0CA38 69 06                           adc #$06                ;add $06 to current enemy offset
0CA3A AA                              tax                     ;to animate various enemy objects
0CA3B                           
0CA3B                           CheckDefeatedState:
0CA3B A5 ED                           lda $ed               ;check saved enemy state
0CA3D 29 20                           and #%00100000        ;for d5 set
0CA3F F0 0E                           beq DrawEnemyObject   ;branch if not set
0CA41 A5 EF                           lda $ef
0CA43 C9 04                           cmp #$04              ;check for saved enemy object => $04
0CA45 90 08                           bcc DrawEnemyObject   ;branch if less
0CA47 A0 01                           ldy #$01
0CA49 8C 09 01                        sty VerticalFlipFlag  ;set vertical flip flag
0CA4C 88                              dey
0CA4D 84 EC                           sty $ec               ;init saved value here
0CA4F                           
0CA4F                           DrawEnemyObject:
0CA4F A4 EB                           ldy $eb                    ;load sprite data offset
0CA51 20 AE CB                        jsr DrawEnemyObjRow        ;draw six tiles of data
0CA54 20 AE CB                        jsr DrawEnemyObjRow        ;into sprite data
0CA57 20 AE CB                        jsr DrawEnemyObjRow
0CA5A A6 08                           ldx ObjectOffset           ;get enemy object offset
0CA5C BC E5 06                        ldy Enemy_SprDataOffset,x  ;get sprite data offset
0CA5F A5 EF                           lda $ef
0CA61 C9 08                           cmp #$08                   ;get saved enemy object and check
0CA63 D0 03                           bne CheckForVerticalFlip   ;for bullet bill, branch if not found
0CA65                           
0CA65                           SkipToOffScrChk:
0CA65 4C 68 CB                        jmp SprObjectOffscrChk     ;jump if found
0CA68                           
0CA68                           CheckForVerticalFlip:
0CA68 AD 09 01                        lda VerticalFlipFlag       ;check if vertical flip flag is set here
0CA6B F0 3D                           beq CheckForESymmetry      ;branch if not
0CA6D B9 02 02                        lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
0CA70 09 80                           ora #%10000000             ;set bit for vertical flip
0CA72 C8                              iny
0CA73 C8                              iny                        ;increment two bytes so that we store the vertical flip
0CA74 20 B9 C5                        jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
0CA77 88                              dey
0CA78 88                              dey                        ;now go back to the Y coordinate offset
0CA79 98                              tya
0CA7A AA                              tax                        ;give offset to X
0CA7B A5 EF                           lda $ef
0CA7D C9 05                           cmp #HammerBro             ;check saved enemy object for hammer bro
0CA7F F0 0D                           beq FlipEnemyVertically
0CA81 C9 11                           cmp #Lakitu                ;check saved enemy object for lakitu
0CA83 F0 09                           beq FlipEnemyVertically    ;branch for hammer bro or lakitu
0CA85 C9 15                           cmp #$15
0CA87 B0 05                           bcs FlipEnemyVertically    ;also branch if enemy object => $15
0CA89 8A                              txa
0CA8A 18                              clc
0CA8B 69 08                           adc #$08                   ;if not selected objects or => $15, set
0CA8D AA                              tax                        ;offset in X for next row
0CA8E                           
0CA8E                           FlipEnemyVertically:
0CA8E BD 01 02                        lda Sprite_Tilenumber,x     ;load first or second row tiles
0CA91 48                              pha                         ;and save tiles to the stack
0CA92 BD 05 02                        lda Sprite_Tilenumber+4,x
0CA95 48                              pha
0CA96 B9 11 02                        lda Sprite_Tilenumber+16,y  ;exchange third row tiles
0CA99 9D 01 02                        sta Sprite_Tilenumber,x     ;with first or second row tiles
0CA9C B9 15 02                        lda Sprite_Tilenumber+20,y
0CA9F 9D 05 02                        sta Sprite_Tilenumber+4,x
0CAA2 68                              pla                         ;pull first or second row tiles from stack
0CAA3 99 15 02                        sta Sprite_Tilenumber+20,y  ;and save in third row
0CAA6 68                              pla
0CAA7 99 11 02                        sta Sprite_Tilenumber+16,y
0CAAA                           
0CAAA                           CheckForESymmetry:
0CAAA AD 6A 03                          lda BowserGfxFlag           ;are we drawing bowser at all?
0CAAD D0 B6                             bne SkipToOffScrChk         ;branch if so
0CAAF A5 EF                             lda $ef       
0CAB1 A6 EC                             ldx $ec                     ;get alternate enemy state
0CAB3 C9 05                             cmp #$05                    ;check for hammer bro object
0CAB5 D0 03                             bne ContES
0CAB7 4C 68 CB                          jmp SprObjectOffscrChk      ;jump if found
0CABA C9 07                     ContES: cmp #Bloober                ;check for bloober object
0CABC F0 1D                             beq MirrorEnemyGfx
0CABE C9 0D                             cmp #PiranhaPlant           ;check for piranha plant object
0CAC0 F0 19                             beq MirrorEnemyGfx
0CAC2 C9 0C                             cmp #Podoboo                ;check for podoboo object
0CAC4 F0 15                             beq MirrorEnemyGfx          ;branch if either of three are found
0CAC6 C9 12                             cmp #Spiny                  ;check for spiny object
0CAC8 D0 04                             bne ESRtnr                  ;branch closer if not found
0CACA E0 05                             cpx #$05                    ;check spiny's state
0CACC D0 48                             bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
0CACE C9 15                     ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
0CAD0 D0 05                             bne SpnySC
0CAD2 A9 42                             lda #$42                    ;set horizontal flip on bottom right sprite
0CAD4 99 16 02                          sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
0CAD7 E0 02                     SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
0CAD9 90 3B                             bcc CheckToMirrorLakitu
0CADB                           
0CADB                           MirrorEnemyGfx:
0CADB AD 6A 03                          lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
0CADE D0 36                             bne CheckToMirrorLakitu
0CAE0 B9 02 02                          lda Sprite_Attributes,y     ;load attribute bits of first sprite
0CAE3 29 A3                             and #%10100011
0CAE5 99 02 02                          sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
0CAE8 99 0A 02                          sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
0CAEB 99 12 02                          sta Sprite_Attributes+16,y
0CAEE 09 40                             ora #%01000000              ;set horizontal flip
0CAF0 E0 05                             cpx #$05                    ;check for state used by spiny's egg
0CAF2 D0 02                             bne EggExc                  ;if alternate state not set to $05, branch
0CAF4 09 80                             ora #%10000000              ;otherwise set vertical flip
0CAF6 99 06 02                  EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
0CAF9 99 0E 02                          sta Sprite_Attributes+12,y  ;of enemy object sprite data
0CAFC 99 16 02                          sta Sprite_Attributes+20,y
0CAFF E0 04                             cpx #$04                    ;check alternate enemy state
0CB01 D0 13                             bne CheckToMirrorLakitu     ;branch if not $04
0CB03 B9 0A 02                          lda Sprite_Attributes+8,y   ;get second row left sprite attributes
0CB06 09 80                             ora #%10000000
0CB08 99 0A 02                          sta Sprite_Attributes+8,y   ;store bits with vertical flip in
0CB0B 99 12 02                          sta Sprite_Attributes+16,y  ;second and third row left sprites
0CB0E 09 40                             ora #%01000000
0CB10 99 0E 02                          sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
0CB13 99 16 02                          sta Sprite_Attributes+20,y  ;second and third row right sprites
0CB16                           
0CB16                           CheckToMirrorLakitu:
0CB16 A5 EF                             lda $ef                     ;check for lakitu enemy object
0CB18 C9 11                             cmp #Lakitu
0CB1A D0 36                             bne CheckToMirrorJSpring    ;branch if not found
0CB1C AD 09 01                          lda VerticalFlipFlag
0CB1F D0 21                             bne NVFLak                  ;branch if vertical flip flag not set
0CB21 B9 12 02                          lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
0CB24 29 81                             and #%10000001              ;in third row left sprite
0CB26 99 12 02                          sta Sprite_Attributes+16,y
0CB29 B9 16 02                          lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
0CB2C 09 41                             ora #%01000001              ;in third row right sprite
0CB2E 99 16 02                          sta Sprite_Attributes+20,y
0CB31 AE 8F 07                          ldx FrenzyEnemyTimer        ;check timer
0CB34 E0 10                             cpx #$10
0CB36 B0 30                             bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
0CB38 99 0E 02                          sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
0CB3B 29 81                             and #%10000001
0CB3D 99 0A 02                          sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
0CB40 90 26                             bcc SprObjectOffscrChk      ;unconditional branch
0CB42 B9 02 02                  NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
0CB45 29 81                             and #%10000001
0CB47 99 02 02                          sta Sprite_Attributes,y     ;save vertical flip and palette bits
0CB4A B9 06 02                          lda Sprite_Attributes+4,y   ;get first row right sprite attributes
0CB4D 09 41                             ora #%01000001              ;set horizontal flip and palette bits
0CB4F 99 06 02                          sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
0CB52                           
0CB52                           CheckToMirrorJSpring:
0CB52 A5 EF                           lda $ef                     ;check for jumpspring object (any frame)
0CB54 C9 18                           cmp #$18
0CB56 90 10                           bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
0CB58 A9 82                           lda #$82
0CB5A 99 0A 02                        sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of 
0CB5D 99 12 02                        sta Sprite_Attributes+16,y  ;second and third row left sprites
0CB60 09 40                           ora #%01000000
0CB62 99 0E 02                        sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
0CB65 99 16 02                        sta Sprite_Attributes+20,y  ;for second and third row right sprites
0CB68                           
0CB68                           SprObjectOffscrChk:
0CB68 A6 08                              ldx ObjectOffset          ;get enemy buffer offset
0CB6A AD D1 03                           lda Enemy_OffscreenBits   ;check offscreen information
0CB6D 4A                                 lsr
0CB6E 4A                                 lsr                       ;shift three times to the right
0CB6F 4A                                 lsr                       ;which puts d2 into carry
0CB70 48                                 pha                       ;save to stack
0CB71 90 05                              bcc LcChk                 ;branch if not set
0CB73 A9 04                              lda #$04                  ;set for right column sprites
0CB75 20 C5 CB                           jsr MoveESprColOffscreen  ;and move them offscreen
0CB78 68                        LcChk:   pla                       ;get from stack
0CB79 4A                                 lsr                       ;move d3 to carry
0CB7A 48                                 pha                       ;save to stack
0CB7B 90 05                              bcc Row3C                 ;branch if not set
0CB7D A9 00                              lda #$00                  ;set for left column sprites,
0CB7F 20 C5 CB                           jsr MoveESprColOffscreen  ;move them offscreen
0CB82 68                        Row3C:   pla                       ;get from stack again
0CB83 4A                                 lsr                       ;move d5 to carry this time
0CB84 4A                                 lsr
0CB85 48                                 pha                       ;save to stack again
0CB86 90 05                              bcc Row23C                ;branch if carry not set
0CB88 A9 10                              lda #$10                  ;set for third row of sprites
0CB8A 20 BB CB                           jsr MoveESprRowOffscreen  ;and move them offscreen
0CB8D 68                        Row23C:  pla                       ;get from stack
0CB8E 4A                                 lsr                       ;move d6 into carry
0CB8F 48                                 pha                       ;save to stack
0CB90 90 05                              bcc AllRowC
0CB92 A9 08                              lda #$08                  ;set for second and third rows
0CB94 20 BB CB                           jsr MoveESprRowOffscreen  ;move them offscreen
0CB97 68                        AllRowC: pla                       ;get from stack once more
0CB98 4A                                 lsr                       ;move d7 into carry
0CB99 90 12                              bcc ExEGHandler
0CB9B 20 BB CB                           jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
0CB9E B5 16                              lda Enemy_ID,x
0CBA0 C9 0C                              cmp #Podoboo              ;check enemy identifier for podoboo
0CBA2 F0 09                              beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
0CBA4 B5 B6                              lda Enemy_Y_HighPos,x     ;check high byte of vertical position
0CBA6 C9 02                              cmp #$02                  ;if not yet past the bottom of the screen, branch
0CBA8 D0 03                              bne ExEGHandler
0CBAA 20 A0 A9                           jsr EraseEnemyObject      ;what it says
0CBAD                           
0CBAD                           ExEGHandler:
0CBAD 60                              rts
0CBAE                           
0CBAE                           DrawEnemyObjRow:
0CBAE BD 42 C7                        lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
0CBB1 85 00                           sta $00
0CBB3 BD 43 C7                        lda EnemyGraphicsTable+1,x
0CBB6                           
0CBB6                           DrawOneSpriteRow:
0CBB6 85 01                           sta $01
0CBB8 4C 86 D2                        jmp DrawSpriteObject        ;draw them
0CBBB                           
0CBBB                           MoveESprRowOffscreen:
0CBBB 18                              clc                         ;add A to enemy object OAM data offset
0CBBC 7D E5 06                        adc Enemy_SprDataOffset,x
0CBBF A8                              tay                         ;use as offset
0CBC0 A9 F8                           lda #$f8
0CBC2 4C C5 C5                        jmp DumpTwoSpr              ;move first row of sprites offscreen
0CBC5                           
0CBC5                           MoveESprColOffscreen:
0CBC5 18                              clc                         ;add A to enemy object OAM data offset
0CBC6 7D E5 06                        adc Enemy_SprDataOffset,x
0CBC9 A8                              tay                         ;use as offset
0CBCA 20 4E CC                        jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
0CBCD 99 10 02                        sta Sprite_Data+16,y        ;move third row sprite in column offscreen
0CBD0 60                              rts
0CBD1                           
0CBD1                           ;-------------------------------------------------------------------------------------
0CBD1                           ;$00-$01 - tile numbers
0CBD1                           ;$02 - relative Y position
0CBD1                           ;$03 - horizontal flip flag (not used here)
0CBD1                           ;$04 - attributes
0CBD1                           ;$05 - relative X position
0CBD1                           
0CBD1                           DefaultBlockObjTiles:
0CBD1 85 85 86 86                     .db $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
0CBD5                           
0CBD5                           DrawBlock:
0CBD5 AD BC 03                             lda Block_Rel_YPos            ;get relative vertical coordinate of block object
0CBD8 85 02                                sta $02                       ;store here
0CBDA AD B1 03                             lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
0CBDD 85 05                                sta $05                       ;store here
0CBDF A9 03                                lda #$03
0CBE1 85 04                                sta $04                       ;set attribute byte here
0CBE3 4A                                   lsr
0CBE4 85 03                                sta $03                       ;set horizontal flip bit here (will not be used)
0CBE6 BC EC 06                             ldy Block_SprDataOffset,x     ;get sprite data offset
0CBE9 A2 00                                ldx #$00                      ;reset X for use as offset to tile data
0CBEB BD D1 CB                  DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
0CBEE 85 00                                sta $00                       ;set here
0CBF0 BD D2 CB                             lda DefaultBlockObjTiles+1,x  ;get right tile number
0CBF3 20 B6 CB                             jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
0CBF6 E0 04                                cpx #$04                      ;check incremented offset
0CBF8 D0 F1                                bne DBlkLoop                  ;and loop back until all four sprites are done
0CBFA A6 08                                ldx ObjectOffset              ;get block object offset
0CBFC BC EC 06                             ldy Block_SprDataOffset,x     ;get sprite data offset
0CBFF AD 4E 07                             lda AreaType
0CC02 C9 01                                cmp #$01                      ;check for ground level type area
0CC04 F0 08                                beq ChkRep                    ;if found, branch to next part
0CC06 A9 86                                lda #$86
0CC08 99 01 02                             sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
0CC0B 99 05 02                             sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
0CC0E BD E8 03                  ChkRep:    lda Block_Metatile,x          ;check replacement metatile
0CC11 C9 C4                                cmp #$c4                      ;if not used block metatile, then
0CC13 D0 24                                bne BlkOffscr                 ;branch ahead to use current graphics
0CC15 A9 87                                lda #$87                      ;set A for used block tile
0CC17 C8                                   iny                           ;increment Y to write to tile bytes
0CC18 20 BF C5                             jsr DumpFourSpr               ;do sub to dump into all four sprites
0CC1B 88                                   dey                           ;return Y to original offset
0CC1C A9 03                                lda #$03                      ;set palette bits
0CC1E AE 4E 07                             ldx AreaType
0CC21 CA                                   dex                           ;check for ground level type area again
0CC22 F0 01                                beq SetBFlip                  ;if found, use current palette bits
0CC24 4A                                   lsr                           ;otherwise set to $01
0CC25 A6 08                     SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
0CC27 99 02 02                             sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
0CC2A 09 40                                ora #%01000000
0CC2C 99 06 02                             sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
0CC2F 09 80                                ora #%10000000
0CC31 99 0E 02                             sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
0CC34 29 83                                and #%10000011
0CC36 99 0A 02                             sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
0CC39 AD D4 03                  BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
0CC3C 48                                   pha                           ;save to stack
0CC3D 29 04                                and #%00000100                ;check to see if d2 in offscreen bits are set
0CC3F F0 08                                beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
0CC41 A9 F8                                lda #$f8                      ;move offscreen two OAMs
0CC43 99 04 02                             sta Sprite_Y_Position+4,y     ;on the right side
0CC46 99 0C 02                             sta Sprite_Y_Position+12,y
0CC49 68                        PullOfsB:  pla                           ;pull offscreen bits from stack
0CC4A 29 08                     ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
0CC4C F0 08                                beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
0CC4E                           
0CC4E                           MoveColOffscreen:
0CC4E A9 F8                             lda #$f8                   ;move offscreen two OAMs
0CC50 99 00 02                          sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
0CC53 99 08 02                          sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
0CC56 60                        ExDBlk: rts
0CC57                           
0CC57                           ;-------------------------------------------------------------------------------------
0CC57                           ;$00 - used to hold palette bits for attribute byte or relative X position
0CC57                           
0CC57                           DrawBrickChunks:
0CC57 A9 02                              lda #$02                   ;set palette bits here
0CC59 85 00                              sta $00
0CC5B A9 75                              lda #$75                   ;set tile number for ball (something residual, likely)
0CC5D A4 0E                              ldy GameEngineSubroutine
0CC5F C0 05                              cpy #$05                   ;if end-of-level routine running,
0CC61 F0 06                              beq DChunks                ;use palette and tile number assigned
0CC63 A9 03                              lda #$03                   ;otherwise set different palette bits
0CC65 85 00                              sta $00
0CC67 A9 84                              lda #$84                   ;and set tile number for brick chunks
0CC69 BC EC 06                  DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
0CC6C C8                                 iny                        ;increment to start with tile bytes in OAM
0CC6D 20 BF C5                           jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
0CC70 A5 09                              lda FrameCounter           ;get frame counter
0CC72 0A                                 asl
0CC73 0A                                 asl
0CC74 0A                                 asl                        ;move low nybble to high
0CC75 0A                                 asl
0CC76 29 C0                              and #$c0                   ;get what was originally d3-d2 of low nybble
0CC78 05 00                              ora $00                    ;add palette bits
0CC7A C8                                 iny                        ;increment offset for attribute bytes
0CC7B 20 BF C5                           jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
0CC7E 88                                 dey
0CC7F 88                                 dey                        ;decrement offset to Y coordinate
0CC80 AD BC 03                           lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
0CC83 20 C5 C5                           jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
0CC86 AD B1 03                           lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
0CC89 99 03 02                           sta Sprite_X_Position,y    ;save into X coordinate of first sprite
0CC8C BD F1 03                           lda Block_Orig_XPos,x      ;get original horizontal coordinate
0CC8F 38                                 sec
0CC90 ED 1C 07                           sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
0CC93 85 00                              sta $00                    ;store result as relative horizontal coordinate of original
0CC95 38                                 sec
0CC96 ED B1 03                           sbc Block_Rel_XPos         ;get difference of relative positions of original - current
0CC99 65 00                              adc $00                    ;add original relative position to result
0CC9B 69 06                              adc #$06                   ;plus 6 pixels to position second brick chunk correctly
0CC9D 99 07 02                           sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
0CCA0 AD BD 03                           lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
0CCA3 99 08 02                           sta Sprite_Y_Position+8,y
0CCA6 99 0C 02                           sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
0CCA9 AD B2 03                           lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
0CCAC 99 0B 02                           sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
0CCAF A5 00                              lda $00                    ;use original relative horizontal position
0CCB1 38                                 sec
0CCB2 ED B2 03                           sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
0CCB5 65 00                              adc $00                    ;add original relative position to result
0CCB7 69 06                              adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
0CCB9 99 0F 02                           sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
0CCBC AD D4 03                           lda Block_OffscreenBits    ;get offscreen bits for block object
0CCBF 20 4A CC                           jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
0CCC2 AD D4 03                           lda Block_OffscreenBits    ;get offscreen bits again
0CCC5 0A                                 asl                        ;shift d7 into carry
0CCC6 90 05                              bcc ChnkOfs                ;if d7 not set, branch to last part
0CCC8 A9 F8                              lda #$f8
0CCCA 20 C5 C5                           jsr DumpTwoSpr             ;otherwise move top sprites offscreen
0CCCD A5 00                     ChnkOfs: lda $00                    ;if relative position on left side of screen,
0CCCF 10 10                              bpl ExBCDr                 ;go ahead and leave
0CCD1 B9 03 02                           lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
0CCD4 D9 07 02                           cmp Sprite_X_Position+4,y  ;to right-side X coordinate
0CCD7 90 08                              bcc ExBCDr                 ;branch to leave if less
0CCD9 A9 F8                              lda #$f8                   ;otherwise move right half of sprites offscreen
0CCDB 99 04 02                           sta Sprite_Y_Position+4,y
0CCDE 99 0C 02                           sta Sprite_Y_Position+12,y
0CCE1 60                        ExBCDr:  rts                        ;leave
0CCE2                           
0CCE2                           ;-------------------------------------------------------------------------------------
0CCE2                           
0CCE2                           DrawFireball:
0CCE2 BC F1 06                        ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
0CCE5 AD BA 03                        lda Fireball_Rel_YPos      ;get relative vertical coordinate
0CCE8 99 00 02                        sta Sprite_Y_Position,y    ;store as sprite Y coordinate
0CCEB AD AF 03                        lda Fireball_Rel_XPos      ;get relative horizontal coordinate
0CCEE 99 03 02                        sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
0CCF1                           
0CCF1                           DrawFirebar:
0CCF1 A5 09                            lda FrameCounter         ;get frame counter
0CCF3 4A                               lsr                      ;divide by four
0CCF4 4A                               lsr
0CCF5 48                               pha                      ;save result to stack
0CCF6 29 01                            and #$01                 ;mask out all but last bit
0CCF8 49 64                            eor #$64                 ;set either tile $64 or $65 as fireball tile
0CCFA 99 01 02                         sta Sprite_Tilenumber,y  ;thus tile changes every four frames
0CCFD 68                               pla                      ;get from stack
0CCFE 4A                               lsr                      ;divide by four again
0CCFF 4A                               lsr
0CD00 A9 02                            lda #$02                 ;load value $02 to set palette in attrib byte
0CD02 90 02                            bcc FireA                ;if last bit shifted out was not set, skip this
0CD04 09 C0                            ora #%11000000           ;otherwise flip both ways every eight frames
0CD06 99 02 02                  FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
0CD09 60                               rts
0CD0A                           
0CD0A                           ;-------------------------------------------------------------------------------------
0CD0A                           
0CD0A                           ExplosionTiles:
0CD0A 68 67 66                        .db $68, $67, $66
0CD0D                           
0CD0D                           DrawExplosion_Fireball:
0CD0D BC EC 06                        ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
0CD10 B5 24                           lda Fireball_State,x     ;load fireball state
0CD12 F6 24                           inc Fireball_State,x     ;increment state for next frame
0CD14 4A                              lsr                      ;divide by 2
0CD15 29 07                           and #%00000111           ;mask out all but d3-d1
0CD17 C9 03                           cmp #$03                 ;check to see if time to kill fireball
0CD19 B0 4A                           bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
0CD1B                           
0CD1B                           DrawExplosion_Fireworks:
0CD1B AA                              tax                         ;use whatever's in A for offset
0CD1C BD 0A CD                        lda ExplosionTiles,x        ;get tile number using offset
0CD1F C8                              iny                         ;increment Y (contains sprite data offset)
0CD20 20 BF C5                        jsr DumpFourSpr             ;and dump into tile number part of sprite data
0CD23 88                              dey                         ;decrement Y so we have the proper offset again
0CD24 A6 08                           ldx ObjectOffset            ;return enemy object buffer offset to X
0CD26 AD BA 03                        lda Fireball_Rel_YPos       ;get relative vertical coordinate
0CD29 38                              sec                         ;subtract four pixels vertically
0CD2A E9 04                           sbc #$04                    ;for first and third sprites
0CD2C 99 00 02                        sta Sprite_Y_Position,y
0CD2F 99 08 02                        sta Sprite_Y_Position+8,y
0CD32 18                              clc                         ;add eight pixels vertically
0CD33 69 08                           adc #$08                    ;for second and fourth sprites
0CD35 99 04 02                        sta Sprite_Y_Position+4,y
0CD38 99 0C 02                        sta Sprite_Y_Position+12,y
0CD3B AD AF 03                        lda Fireball_Rel_XPos       ;get relative horizontal coordinate
0CD3E 38                              sec                         ;subtract four pixels horizontally
0CD3F E9 04                           sbc #$04                    ;for first and second sprites
0CD41 99 03 02                        sta Sprite_X_Position,y
0CD44 99 07 02                        sta Sprite_X_Position+4,y
0CD47 18                              clc                         ;add eight pixels horizontally
0CD48 69 08                           adc #$08                    ;for third and fourth sprites
0CD4A 99 0B 02                        sta Sprite_X_Position+8,y
0CD4D 99 0F 02                        sta Sprite_X_Position+12,y
0CD50 A9 02                           lda #$02                    ;set palette attributes for all sprites, but
0CD52 99 02 02                        sta Sprite_Attributes,y     ;set no flip at all for first sprite
0CD55 A9 82                           lda #$82
0CD57 99 06 02                        sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
0CD5A A9 42                           lda #$42
0CD5C 99 0A 02                        sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
0CD5F A9 C2                           lda #$c2
0CD61 99 0E 02                        sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
0CD64 60                              rts                         ;we are done
0CD65                           
0CD65                           KillFireBall:
0CD65 A9 00                           lda #$00                    ;clear fireball state to kill it
0CD67 95 24                           sta Fireball_State,x
0CD69 60                              rts
0CD6A                           
0CD6A                           ;-------------------------------------------------------------------------------------
0CD6A                           
0CD6A                           DrawSmallPlatform:
0CD6A BC E5 06                         ldy Enemy_SprDataOffset,x   ;get OAM data offset
0CD6D A9 5B                            lda #$5b                    ;load tile number for small platforms
0CD6F C8                               iny                         ;increment offset for tile numbers
0CD70 20 B9 C5                         jsr DumpSixSpr              ;dump tile number into all six sprites
0CD73 C8                               iny                         ;increment offset for attributes
0CD74 A9 02                            lda #$02                    ;load palette controls
0CD76 20 B9 C5                         jsr DumpSixSpr              ;dump attributes into all six sprites
0CD79 88                               dey                         ;decrement for original offset
0CD7A 88                               dey
0CD7B AD AE 03                         lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0CD7E 99 03 02                         sta Sprite_X_Position,y
0CD81 99 0F 02                         sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
0CD84 18                               clc
0CD85 69 08                            adc #$08                    ;add eight pixels
0CD87 99 07 02                         sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
0CD8A 99 13 02                         sta Sprite_X_Position+16,y
0CD8D 18                               clc
0CD8E 69 08                            adc #$08                    ;add eight more pixels
0CD90 99 0B 02                         sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
0CD93 99 17 02                         sta Sprite_X_Position+20,y
0CD96 B5 CF                            lda Enemy_Y_Position,x      ;get vertical coordinate
0CD98 AA                               tax
0CD99 48                               pha                         ;save to stack
0CD9A E0 20                            cpx #$20                    ;if vertical coordinate below status bar,
0CD9C B0 02                            bcs TopSP                   ;do not mess with it
0CD9E A9 F8                            lda #$f8                    ;otherwise move first three sprites offscreen
0CDA0 20 C2 C5                  TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
0CDA3 68                               pla                         ;pull from stack
0CDA4 18                               clc
0CDA5 69 80                            adc #$80                    ;add 128 pixels
0CDA7 AA                               tax
0CDA8 E0 20                            cpx #$20                    ;if below status bar (taking wrap into account)
0CDAA B0 02                            bcs BotSP                   ;then do not change altered coordinate
0CDAC A9 F8                            lda #$f8                    ;otherwise move last three sprites offscreen
0CDAE 99 0C 02                  BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
0CDB1 99 10 02                         sta Sprite_Y_Position+16,y  ;into Y coordinates
0CDB4 99 14 02                         sta Sprite_Y_Position+20,y
0CDB7 AD D1 03                         lda Enemy_OffscreenBits     ;get offscreen bits
0CDBA 48                               pha                         ;save to stack
0CDBB 29 08                            and #%00001000              ;check d3
0CDBD F0 08                            beq SOfs
0CDBF A9 F8                            lda #$f8                    ;if d3 was set, move first and
0CDC1 99 00 02                         sta Sprite_Y_Position,y     ;fourth sprites offscreen
0CDC4 99 0C 02                         sta Sprite_Y_Position+12,y
0CDC7 68                        SOfs:  pla                         ;move out and back into stack
0CDC8 48                               pha
0CDC9 29 04                            and #%00000100              ;check d2
0CDCB F0 08                            beq SOfs2
0CDCD A9 F8                            lda #$f8                    ;if d2 was set, move second and
0CDCF 99 04 02                         sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
0CDD2 99 10 02                         sta Sprite_Y_Position+16,y
0CDD5 68                        SOfs2: pla                         ;get from stack
0CDD6 29 02                            and #%00000010              ;check d1
0CDD8 F0 08                            beq ExSPl
0CDDA A9 F8                            lda #$f8                    ;if d1 was set, move third and
0CDDC 99 08 02                         sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
0CDDF 99 14 02                         sta Sprite_Y_Position+20,y
0CDE2 A6 08                     ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
0CDE4 60                               rts
0CDE5                           
0CDE5                           ;-------------------------------------------------------------------------------------
0CDE5                           
0CDE5                           DrawBubble:
0CDE5 A4 B5                             ldy Player_Y_HighPos        ;if player's vertical high position
0CDE7 88                                dey                         ;not within screen, skip all of this
0CDE8 D0 20                             bne ExDBub
0CDEA AD D3 03                          lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
0CDED 29 08                             and #%00001000
0CDEF D0 19                             bne ExDBub                  ;if bit set, branch to leave
0CDF1 BC EE 06                          ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
0CDF4 AD B0 03                          lda Bubble_Rel_XPos         ;get relative horizontal coordinate
0CDF7 99 03 02                          sta Sprite_X_Position,y     ;store as X coordinate here
0CDFA AD BB 03                          lda Bubble_Rel_YPos         ;get relative vertical coordinate
0CDFD 99 00 02                          sta Sprite_Y_Position,y     ;store as Y coordinate here
0CE00 A9 74                             lda #$74
0CE02 99 01 02                          sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
0CE05 A9 02                             lda #$02
0CE07 99 02 02                          sta Sprite_Attributes,y     ;set attribute byte
0CE0A 60                        ExDBub: rts                         ;leave
0CE0B                           
0CE0B                           ;-------------------------------------------------------------------------------------
0CE0B                           ;$00 - used to store player's vertical offscreen bits
0CE0B                           
0CE0B                           PlayerGfxTblOffsets:
0CE0B 20 28 C8 18 00 40 50 58         .db $20, $28, $c8, $18, $00, $40, $50, $58
0CE13 80 88 B8 78 60 A0 B0 B8         .db $80, $88, $b8, $78, $60, $a0, $b0, $b8
0CE1B                           
0CE1B                           ;tiles arranged in order, 2 tiles per row, top to bottom
0CE1B                           
0CE1B                           PlayerGraphicsTable:
0CE1B                           ;big player table
0CE1B 00 01 02 03 04 05 06 07         .db $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
0CE23 08 09 0A 0B 0C 0D 0E 0F         .db $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
0CE2B 10 11 12 13 14 15 16 17         .db $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
0CE33 18 19 1A 1B 1C 1D 1E 1F         .db $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
0CE3B 20 21 22 23 24 25 26 27         .db $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
0CE43 08 09 28 29 2A 2B 2C 2D         .db $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
0CE4B 08 09 0A 0B 0C 30 2C 2D         .db $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
0CE53 08 09 0A 0B 2E 2F 2C 2D         .db $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
0CE5B 08 09 28 29 2A 2B 5C 5D         .db $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
0CE63 08 09 0A 0B 0C 0D 5E 5F         .db $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
0CE6B FC FC 08 09 58 59 5A 5A         .db $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
0CE73 08 09 28 29 2A 2B 0E 0F         .db $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
0CE7B                           
0CE7B                           ;small player table
0CE7B FC FC FC FC 32 33 34 35         .db $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
0CE83 FC FC FC FC 36 37 38 39         .db $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
0CE8B FC FC FC FC 3A 37 3B 3C         .db $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
0CE93 FC FC FC FC 3D 3E 3F 40         .db $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
0CE9B FC FC FC FC 32 41 42 43         .db $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
0CEA3 FC FC FC FC 32 33 44 45         .db $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
0CEAB FC FC FC FC 32 33 44 47         .db $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
0CEB3 FC FC FC FC 32 33 48 49         .db $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
0CEBB FC FC FC FC 32 33 90 91         .db $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
0CEC3 FC FC FC FC 3A 37 92 93         .db $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
0CECB FC FC FC FC 9E 9E 9F 9F         .db $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
0CED3                           
0CED3                           ;used by both player sizes
0CED3 FC FC FC FC 3A 37 4F 4F         .db $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
0CEDB FC FC 00 01 4C 4D 4E 4E         .db $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
0CEE3 00 01 4C 4D 4A 4A 4B 4B         .db $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
0CEEB                           
0CEEB                           SwimKickTileNum:
0CEEB 31 46                           .db $31, $46
0CEED                           
0CEED                           PlayerGfxHandler:
0CEED AD 9E 07                          lda InjuryTimer             ;if player's injured invincibility timer
0CEF0 F0 05                             beq CntPl                   ;not set, skip checkpoint and continue code
0CEF2 A5 09                             lda FrameCounter
0CEF4 4A                                lsr                         ;otherwise check frame counter and branch
0CEF5 B0 40                             bcs ExPGH                   ;to leave on every other frame (when d0 is set)
0CEF7 A5 0E                     CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
0CEF9 C9 0B                             cmp #$0b                    ;branch ahead to some other part
0CEFB F0 47                             beq PlayerKilled
0CEFD AD 0B 07                          lda PlayerChangeSizeFlag    ;if grow/shrink flag set
0CF00 D0 3C                             bne DoChangeSize            ;then branch to some other code
0CF02 AC 04 07                          ldy SwimmingFlag            ;if swimming flag set, branch to
0CF05 F0 31                             beq FindPlayerAction        ;different part, do not return
0CF07 A5 1D                             lda Player_State
0CF09 C9 00                             cmp #$00                    ;if player status normal,
0CF0B F0 2B                             beq FindPlayerAction        ;branch and do not return
0CF0D 20 38 CF                          jsr FindPlayerAction        ;otherwise jump and return
0CF10 A5 09                             lda FrameCounter
0CF12 29 04                             and #%00000100              ;check frame counter for d2 set (8 frames every
0CF14 D0 21                             bne ExPGH                   ;eighth frame), and branch if set to leave
0CF16 AA                                tax                         ;initialize X to zero
0CF17 AC E4 06                          ldy Player_SprDataOffset    ;get player sprite data offset
0CF1A A5 33                             lda PlayerFacingDir         ;get player's facing direction
0CF1C 4A                                lsr
0CF1D B0 04                             bcs SwimKT                  ;if player facing to the right, use current offset
0CF1F C8                                iny
0CF20 C8                                iny                         ;otherwise move to next OAM data
0CF21 C8                                iny
0CF22 C8                                iny
0CF23 AD 54 07                  SwimKT: lda PlayerSize              ;check player's size
0CF26 F0 09                             beq BigKTS                  ;if big, use first tile
0CF28 B9 19 02                          lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
0CF2B CD B9 CE                          cmp SwimTileRepOffset       ;against tile number in player graphics table
0CF2E F0 07                             beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
0CF30 E8                                inx                         ;otherwise increment X for second tile
0CF31 BD EB CE                  BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
0CF34 99 19 02                          sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
0CF37 60                        ExPGH:  rts                         ;then leave
0CF38                           
0CF38                           FindPlayerAction:
0CF38 20 F0 CF                        jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
0CF3B 4C 49 CF                        jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
0CF3E                           
0CF3E                           DoChangeSize:
0CF3E 20 B4 D0                        jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
0CF41 4C 49 CF                        jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
0CF44                           
0CF44                           PlayerKilled:
0CF44 A0 0E                           ldy #$0e                      ;load offset for player killed
0CF46 B9 0B CE                        lda PlayerGfxTblOffsets,y     ;get offset to graphics table
0CF49                           
0CF49                           PlayerGfxProcessing:
0CF49 8D D5 06                         sta PlayerGfxOffset           ;store offset to graphics table here
0CF4C A9 04                            lda #$04
0CF4E 20 C2 CF                         jsr RenderPlayerSub           ;draw player based on offset loaded
0CF51 20 ED D0                         jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
0CF54 AD 11 07                         lda FireballThrowingTimer
0CF57 F0 25                            beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
0CF59 A0 00                            ldy #$00                      ;set value to initialize by default
0CF5B AD 81 07                         lda PlayerAnimTimer           ;get animation frame timer
0CF5E CD 11 07                         cmp FireballThrowingTimer     ;compare to fireball throw timer
0CF61 8C 11 07                         sty FireballThrowingTimer     ;initialize fireball throw timer
0CF64 B0 18                            bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
0CF66 8D 11 07                         sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
0CF69 A0 07                            ldy #$07                      ;load offset for throwing
0CF6B B9 0B CE                         lda PlayerGfxTblOffsets,y     ;get offset to graphics table
0CF6E 8D D5 06                         sta PlayerGfxOffset           ;store it for use later
0CF71 A0 04                            ldy #$04                      ;set to update four sprite rows by default
0CF73 A5 57                            lda Player_X_Speed
0CF75 05 0C                            ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
0CF77 F0 01                            beq SUpdR                     ;if no speed or button press, branch using set value in Y
0CF79 88                               dey                           ;otherwise set to update only three sprite rows
0CF7A 98                        SUpdR: tya                           ;save in A for use
0CF7B 20 C2 CF                         jsr RenderPlayerSub           ;in sub, draw player object again
0CF7E                           
0CF7E                           PlayerOffscreenChk:
0CF7E AD D0 03                             lda Player_OffscreenBits      ;get player's offscreen bits
0CF81 4A                                   lsr
0CF82 4A                                   lsr                           ;move vertical bits to low nybble
0CF83 4A                                   lsr
0CF84 4A                                   lsr
0CF85 85 00                                sta $00                       ;store here
0CF87 A2 03                                ldx #$03                      ;check all four rows of player sprites
0CF89 AD E4 06                             lda Player_SprDataOffset      ;get player's sprite data offset
0CF8C 18                                   clc
0CF8D 69 18                                adc #$18                      ;add 24 bytes to start at bottom row
0CF8F A8                                   tay                           ;set as offset here
0CF90 A9 F8                     PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
0CF92 46 00                                lsr $00                       ;shift bit into carry
0CF94 90 03                                bcc NPROffscr                 ;if bit not set, skip, do not move sprites
0CF96 20 C5 C5                             jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
0CF99 98                        NPROffscr: tya
0CF9A 38                                   sec                           ;subtract eight bytes to do
0CF9B E9 08                                sbc #$08                      ;next row up
0CF9D A8                                   tay
0CF9E CA                                   dex                           ;decrement row counter
0CF9F 10 EF                                bpl PROfsLoop                 ;do this until all sprite rows are checked
0CFA1 60                                   rts                           ;then we are done!
0CFA2                           
0CFA2                           ;-------------------------------------------------------------------------------------
0CFA2                           
0CFA2                           IntermediatePlayerData:
0CFA2 58 01 00 60 FF 04                 .db $58, $01, $00, $60, $ff, $04
0CFA8                           
0CFA8                           DrawPlayer_Intermediate:
0CFA8 A2 05                               ldx #$05                       ;store data into zero page memory
0CFAA BD A2 CF                  PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
0CFAD 95 02                               sta $02,x                      ;appears on world/lives display
0CFAF CA                                  dex
0CFB0 10 F8                               bpl PIntLoop                   ;do this until all data is loaded
0CFB2 A2 B8                               ldx #$b8                       ;load offset for small standing
0CFB4 A0 04                               ldy #$04                       ;load sprite data offset
0CFB6 20 E0 CF                            jsr DrawPlayerLoop             ;draw player accordingly
0CFB9 AD 26 02                            lda Sprite_Attributes+36       ;get empty sprite attributes
0CFBC 09 40                               ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
0CFBE 8D 22 02                            sta Sprite_Attributes+32       ;store and leave
0CFC1 60                                  rts
0CFC2                           
0CFC2                           ;-------------------------------------------------------------------------------------
0CFC2                           ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
0CFC2                           ;$02 - vertical position
0CFC2                           ;$03 - facing direction, used as horizontal flip control
0CFC2                           ;$04 - attributes
0CFC2                           ;$05 - horizontal position
0CFC2                           ;$07 - number of rows to draw
0CFC2                           ;these also used in IntermediatePlayerData
0CFC2                           
0CFC2                           RenderPlayerSub:
0CFC2 85 07                             sta $07                      ;store number of rows of sprites to draw
0CFC4 AD AD 03                          lda Player_Rel_XPos
0CFC7 8D 55 07                          sta Player_Pos_ForScroll     ;store player's relative horizontal position
0CFCA 85 05                             sta $05                      ;store it here also
0CFCC AD B8 03                          lda Player_Rel_YPos
0CFCF 85 02                             sta $02                      ;store player's vertical position
0CFD1 A5 33                             lda PlayerFacingDir
0CFD3 85 03                             sta $03                      ;store player's facing direction
0CFD5 AD C4 03                          lda Player_SprAttrib
0CFD8 85 04                             sta $04                      ;store player's sprite attributes
0CFDA AE D5 06                          ldx PlayerGfxOffset          ;load graphics table offset
0CFDD AC E4 06                          ldy Player_SprDataOffset     ;get player's sprite data offset
0CFE0                           
0CFE0                           DrawPlayerLoop:
0CFE0 BD 1B CE                          lda PlayerGraphicsTable,x    ;load player's left side
0CFE3 85 00                             sta $00
0CFE5 BD 1C CE                          lda PlayerGraphicsTable+1,x  ;now load right side
0CFE8 20 B6 CB                          jsr DrawOneSpriteRow
0CFEB C6 07                             dec $07                      ;decrement rows of sprites to draw
0CFED D0 F1                             bne DrawPlayerLoop           ;do this until all rows are drawn
0CFEF 60                                rts
0CFF0                           
0CFF0                           ProcessPlayerAction:
0CFF0 A5 1D                             lda Player_State      ;get player's state
0CFF2 C9 03                             cmp #$03
0CFF4 F0 52                             beq ActionClimbing    ;if climbing, branch here
0CFF6 C9 02                             cmp #$02
0CFF8 F0 3E                             beq ActionFalling     ;if falling, branch here
0CFFA C9 01                             cmp #$01
0CFFC D0 11                             bne ProcOnGroundActs  ;if not jumping, branch here
0CFFE AD 04 07                          lda SwimmingFlag
0D001 D0 51                             bne ActionSwimming    ;if swimming flag set, branch elsewhere
0D003 A0 06                             ldy #$06              ;load offset for crouching
0D005 AD 14 07                          lda CrouchingFlag     ;get crouching flag
0D008 D0 22                             bne NonAnimatedActs   ;if set, branch to get offset for graphics table
0D00A A0 00                             ldy #$00              ;otherwise load offset for jumping
0D00C 4C 2C D0                          jmp NonAnimatedActs   ;go to get offset to graphics table
0D00F                           
0D00F                           ProcOnGroundActs:
0D00F A0 06                             ldy #$06                   ;load offset for crouching
0D011 AD 14 07                          lda CrouchingFlag          ;get crouching flag
0D014 D0 16                             bne NonAnimatedActs        ;if set, branch to get offset for graphics table
0D016 A0 02                             ldy #$02                   ;load offset for standing
0D018 A5 57                             lda Player_X_Speed         ;check player's horizontal speed
0D01A 05 0C                             ora Left_Right_Buttons     ;and left/right controller bits
0D01C F0 0E                             beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
0D01E AD 00 07                          lda Player_XSpeedAbsolute  ;load walking/running speed
0D021 C9 09                             cmp #$09
0D023 90 1B                             bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
0D025 A5 45                             lda Player_MovingDir       ;otherwise check to see if moving direction
0D027 25 33                             and PlayerFacingDir        ;and facing direction are the same
0D029 D0 15                             bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
0D02B C8                                iny                        ;otherwise increment to skid offset ($03)
0D02C                           
0D02C                           NonAnimatedActs:
0D02C 20 95 D0                          jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
0D02F A9 00                             lda #$00
0D031 8D 0D 07                          sta PlayerAnimCtrl         ;initialize animation frame control
0D034 B9 0B CE                          lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
0D037 60                                rts
0D038                           
0D038                           ActionFalling:
0D038 A0 04                             ldy #$04                  ;load offset for walking/running
0D03A 20 95 D0                          jsr GetGfxOffsetAdder     ;get offset to graphics table
0D03D 4C 66 D0                          jmp GetCurrentAnimOffset  ;execute instructions for falling state
0D040                           
0D040                           ActionWalkRun:
0D040 A0 04                             ldy #$04               ;load offset for walking/running
0D042 20 95 D0                          jsr GetGfxOffsetAdder  ;get offset to graphics table
0D045 4C 6C D0                          jmp FourFrameExtent    ;execute instructions for normal state
0D048                           
0D048                           ActionClimbing:
0D048 A0 05                             ldy #$05               ;load offset for climbing
0D04A A5 9F                             lda Player_Y_Speed     ;check player's vertical speed
0D04C F0 DE                             beq NonAnimatedActs    ;if no speed, branch, use offset as-is
0D04E 20 95 D0                          jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
0D051 4C 71 D0                          jmp ThreeFrameExtent   ;then skip ahead to more code
0D054                           
0D054                           ActionSwimming:
0D054 A0 01                             ldy #$01               ;load offset for swimming
0D056 20 95 D0                          jsr GetGfxOffsetAdder
0D059 AD 82 07                          lda JumpSwimTimer      ;check jump/swim timer
0D05C 0D 0D 07                          ora PlayerAnimCtrl     ;and animation frame control
0D05F D0 0B                             bne FourFrameExtent    ;if any one of these set, branch ahead
0D061 A5 0A                             lda A_B_Buttons
0D063 0A                                asl                    ;check for A button pressed
0D064 B0 06                             bcs FourFrameExtent    ;branch to same place if A button pressed
0D066                           
0D066                           GetCurrentAnimOffset:
0D066 AD 0D 07                          lda PlayerAnimCtrl         ;get animation frame control
0D069 4C D4 D0                          jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
0D06C                           
0D06C                           FourFrameExtent:
0D06C A9 03                             lda #$03              ;load upper extent for frame control
0D06E 4C 73 D0                          jmp AnimationControl  ;jump to get offset and animate player object
0D071                           
0D071                           ThreeFrameExtent:
0D071 A9 02                             lda #$02              ;load upper extent for frame control for climbing
0D073                           
0D073                           AnimationControl:
0D073 85 00                               sta $00                   ;store upper extent here
0D075 20 66 D0                            jsr GetCurrentAnimOffset  ;get proper offset to graphics table
0D078 48                                  pha                       ;save offset to stack
0D079 AD 81 07                            lda PlayerAnimTimer       ;load animation frame timer
0D07C D0 15                               bne ExAnimC               ;branch if not expired
0D07E AD 0C 07                            lda PlayerAnimTimerSet    ;get animation frame timer amount
0D081 8D 81 07                            sta PlayerAnimTimer       ;and set timer accordingly
0D084 AD 0D 07                            lda PlayerAnimCtrl
0D087 18                                  clc                       ;add one to animation frame control
0D088 69 01                               adc #$01
0D08A C5 00                               cmp $00                   ;compare to upper extent
0D08C 90 02                               bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
0D08E A9 00                               lda #$00                  ;otherwise initialize frame control
0D090 8D 0D 07                  SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
0D093 68                        ExAnimC:  pla                       ;get offset to graphics table from stack and leave
0D094 60                                  rts
0D095                           
0D095                           GetGfxOffsetAdder:
0D095 AD 54 07                          lda PlayerSize  ;get player's size
0D098 F0 05                             beq SzOfs       ;if player big, use current offset as-is
0D09A 98                                tya             ;for big player
0D09B 18                                clc             ;otherwise add eight bytes to offset
0D09C 69 08                             adc #$08        ;for small player
0D09E A8                                tay
0D09F 60                        SzOfs:  rts             ;go back
0D0A0                           
0D0A0                           ChangeSizeOffsetAdder:
0D0A0 00 01 00 01 00 01 02 00..         .db $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
0D0AA 02 00 02 00 02 00 02 00..         .db $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
0D0B4                           
0D0B4                           HandleChangeSize:
0D0B4 AC 0D 07                           ldy PlayerAnimCtrl           ;get animation frame control
0D0B7 A5 09                              lda FrameCounter
0D0B9 29 03                              and #%00000011               ;get frame counter and execute this code every
0D0BB D0 0D                              bne GorSLog                  ;fourth frame, otherwise branch ahead
0D0BD C8                                 iny                          ;increment frame control
0D0BE C0 0A                              cpy #$0a                     ;check for preset upper extent
0D0C0 90 05                              bcc CSzNext                  ;if not there yet, skip ahead to use
0D0C2 A0 00                              ldy #$00                     ;otherwise initialize both grow/shrink flag
0D0C4 8C 0B 07                           sty PlayerChangeSizeFlag     ;and animation frame control
0D0C7 8C 0D 07                  CSzNext: sty PlayerAnimCtrl           ;store proper frame control
0D0CA AD 54 07                  GorSLog: lda PlayerSize               ;get player's size
0D0CD D0 0C                              bne ShrinkPlayer             ;if player small, skip ahead to next part
0D0CF B9 A0 D0                           lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
0D0D2 A0 0F                              ldy #$0f                     ;load offset for player growing
0D0D4                           
0D0D4                           GetOffsetFromAnimCtrl:
0D0D4 0A                                asl                        ;multiply animation frame control
0D0D5 0A                                asl                        ;by eight to get proper amount
0D0D6 0A                                asl                        ;to add to our offset
0D0D7 79 0B CE                          adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
0D0DA 60                                rts                        ;and return with result in A
0D0DB                           
0D0DB                           ShrinkPlayer:
0D0DB 98                                tya                          ;add ten bytes to frame control as offset
0D0DC 18                                clc
0D0DD 69 0A                             adc #$0a                     ;this thing apparently uses two of the swimming frames
0D0DF AA                                tax                          ;to draw the player shrinking
0D0E0 A0 09                             ldy #$09                     ;load offset for small player swimming
0D0E2 BD A0 D0                          lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
0D0E5 D0 02                             bne ShrPlF                   ;and branch to use offset if nonzero
0D0E7 A0 01                             ldy #$01                     ;otherwise load offset for big player swimming
0D0E9 B9 0B CE                  ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
0D0EC 60                                rts                          ;and leave
0D0ED                           
0D0ED                           ChkForPlayerAttrib:
0D0ED AC E4 06                             ldy Player_SprDataOffset    ;get sprite data offset
0D0F0 A5 0E                                lda GameEngineSubroutine
0D0F2 C9 0B                                cmp #$0b                    ;if executing specific game engine routine,
0D0F4 F0 13                                beq KilledAtt               ;branch to change third and fourth row OAM attributes
0D0F6 AD D5 06                             lda PlayerGfxOffset         ;get graphics table offset
0D0F9 C9 50                                cmp #$50
0D0FB F0 1E                                beq C_S_IGAtt               ;if crouch offset, either standing offset,
0D0FD C9 B8                                cmp #$b8                    ;or intermediate growing offset,
0D0FF F0 1A                                beq C_S_IGAtt               ;go ahead and execute code to change 
0D101 C9 C0                                cmp #$c0                    ;fourth row OAM attributes only
0D103 F0 16                                beq C_S_IGAtt
0D105 C9 C8                                cmp #$c8
0D107 D0 24                                bne ExPlyrAt                ;if none of these, branch to leave
0D109 B9 12 02                  KilledAtt: lda Sprite_Attributes+16,y
0D10C 29 3F                                and #%00111111              ;mask out horizontal and vertical flip bits
0D10E 99 12 02                             sta Sprite_Attributes+16,y  ;for third row sprites and save
0D111 B9 16 02                             lda Sprite_Attributes+20,y
0D114 29 3F                                and #%00111111  
0D116 09 40                                ora #%01000000              ;set horizontal flip bit for second
0D118 99 16 02                             sta Sprite_Attributes+20,y  ;sprite in the third row
0D11B B9 1A 02                  C_S_IGAtt: lda Sprite_Attributes+24,y
0D11E 29 3F                                and #%00111111              ;mask out horizontal and vertical flip bits
0D120 99 1A 02                             sta Sprite_Attributes+24,y  ;for fourth row sprites and save
0D123 B9 1E 02                             lda Sprite_Attributes+28,y
0D126 29 3F                                and #%00111111
0D128 09 40                                ora #%01000000              ;set horizontal flip bit for second
0D12A 99 1E 02                             sta Sprite_Attributes+28,y  ;sprite in the fourth row
0D12D 60                        ExPlyrAt:  rts                         ;leave
0D12E                           
0D12E                           ;-------------------------------------------------------------------------------------
0D12E                           ;$00 - used in adding to get proper offset
0D12E                           
0D12E                           RelativePlayerPosition:
0D12E A2 00                             ldx #$00      ;set offsets for relative cooordinates
0D130 A0 00                             ldy #$00      ;routine to correspond to player object
0D132 4C 46 D1                          jmp RelWOfs   ;get the coordinates
0D135                           
0D135                           RelativeBubblePosition:
0D135 A0 01                             ldy #$01                ;set for air bubble offsets
0D137 20 AC D1                          jsr GetProperObjOffset  ;modify X to get proper air bubble offset
0D13A A0 03                             ldy #$03
0D13C 4C 46 D1                          jmp RelWOfs             ;get the coordinates
0D13F                           
0D13F                           RelativeFireballPosition:
0D13F A0 00                              ldy #$00                    ;set for fireball offsets
0D141 20 AC D1                           jsr GetProperObjOffset      ;modify X to get proper fireball offset
0D144 A0 02                              ldy #$02
0D146 20 75 D1                  RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
0D149 A6 08                              ldx ObjectOffset            ;return original offset
0D14B 60                                 rts                         ;leave
0D14C                           
0D14C                           RelativeMiscPosition:
0D14C A0 02                             ldy #$02                ;set for misc object offsets
0D14E 20 AC D1                          jsr GetProperObjOffset  ;modify X to get proper misc object offset
0D151 A0 06                             ldy #$06
0D153 4C 46 D1                          jmp RelWOfs             ;get the coordinates
0D156                           
0D156                           RelativeEnemyPosition:
0D156 A9 01                             lda #$01                     ;get coordinates of enemy object 
0D158 A0 01                             ldy #$01                     ;relative to the screen
0D15A 4C 69 D1                          jmp VariableObjOfsRelPos
0D15D                           
0D15D                           RelativeBlockPosition:
0D15D A9 09                             lda #$09                     ;get coordinates of one block object
0D15F A0 04                             ldy #$04                     ;relative to the screen
0D161 20 69 D1                          jsr VariableObjOfsRelPos
0D164 E8                                inx                          ;adjust offset for other block object if any
0D165 E8                                inx
0D166 A9 09                             lda #$09
0D168 C8                                iny                          ;adjust other and get coordinates for other one
0D169                           
0D169                           VariableObjOfsRelPos:
0D169 86 00                             stx $00                     ;store value to add to A here
0D16B 18                                clc
0D16C 65 00                             adc $00                     ;add A to value stored
0D16E AA                                tax                         ;use as enemy offset
0D16F 20 75 D1                          jsr GetObjRelativePosition
0D172 A6 08                             ldx ObjectOffset            ;reload old object offset and leave
0D174 60                                rts
0D175                           
0D175                           GetObjRelativePosition:
0D175 B5 CE                             lda SprObject_Y_Position,x  ;load vertical coordinate low
0D177 99 B8 03                          sta SprObject_Rel_YPos,y    ;store here
0D17A B5 86                             lda SprObject_X_Position,x  ;load horizontal coordinate
0D17C 38                                sec                         ;subtract left edge coordinate
0D17D ED 1C 07                          sbc ScreenLeft_X_Pos
0D180 99 AD 03                          sta SprObject_Rel_XPos,y    ;store result here
0D183 60                                rts
0D184                           
0D184                           ;-------------------------------------------------------------------------------------
0D184                           ;$00 - used as temp variable to hold offscreen bits
0D184                           
0D184                           GetPlayerOffscreenBits:
0D184 A2 00                             ldx #$00                 ;set offsets for player-specific variables
0D186 A0 00                             ldy #$00                 ;and get offscreen information about player
0D188 4C C4 D1                          jmp GetOffScreenBitsSet
0D18B                           
0D18B                           GetFireballOffscreenBits:
0D18B A0 00                             ldy #$00                 ;set for fireball offsets
0D18D 20 AC D1                          jsr GetProperObjOffset   ;modify X to get proper fireball offset
0D190 A0 02                             ldy #$02                 ;set other offset for fireball's offscreen bits
0D192 4C C4 D1                          jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
0D195                           
0D195                           GetBubbleOffscreenBits:
0D195 A0 01                             ldy #$01                 ;set for air bubble offsets
0D197 20 AC D1                          jsr GetProperObjOffset   ;modify X to get proper air bubble offset
0D19A A0 03                             ldy #$03                 ;set other offset for airbubble's offscreen bits
0D19C 4C C4 D1                          jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
0D19F                           
0D19F                           GetMiscOffscreenBits:
0D19F A0 02                             ldy #$02                 ;set for misc object offsets
0D1A1 20 AC D1                          jsr GetProperObjOffset   ;modify X to get proper misc object offset
0D1A4 A0 06                             ldy #$06                 ;set other offset for misc object's offscreen bits
0D1A6 4C C4 D1                          jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
0D1A9                           
0D1A9                           ObjOffsetData:
0D1A9 07 16 0D                          .db $07, $16, $0d
0D1AC                           
0D1AC                           GetProperObjOffset:
0D1AC 8A                                txa                  ;move offset to A
0D1AD 18                                clc
0D1AE 79 A9 D1                          adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
0D1B1 AA                                tax                  ;put back in X and leave
0D1B2 60                                rts
0D1B3                           
0D1B3                           GetEnemyOffscreenBits:
0D1B3 A9 01                             lda #$01                 ;set A to add 1 byte in order to get enemy offset
0D1B5 A0 01                             ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
0D1B7 4C BE D1                          jmp SetOffscrBitsOffset
0D1BA                           
0D1BA                           GetBlockOffscreenBits:
0D1BA A9 09                             lda #$09       ;set A to add 9 bytes in order to get block obj offset
0D1BC A0 04                             ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
0D1BE                           
0D1BE                           SetOffscrBitsOffset:
0D1BE 86 00                             stx $00
0D1C0 18                                clc           ;add contents of X to A to get
0D1C1 65 00                             adc $00       ;appropriate offset, then give back to X
0D1C3 AA                                tax
0D1C4                           
0D1C4                           GetOffScreenBitsSet:
0D1C4 98                                tya                         ;save offscreen bits offset to stack for now
0D1C5 48                                pha
0D1C6 20 DB D1                          jsr RunOffscrBitsSubs
0D1C9 0A                                asl                         ;move low nybble to high nybble
0D1CA 0A                                asl
0D1CB 0A                                asl
0D1CC 0A                                asl
0D1CD 05 00                             ora $00                     ;mask together with previously saved low nybble
0D1CF 85 00                             sta $00                     ;store both here
0D1D1 68                                pla                         ;get offscreen bits offset from stack
0D1D2 A8                                tay
0D1D3 A5 00                             lda $00                     ;get value here and store elsewhere
0D1D5 99 D0 03                          sta SprObject_OffscrBits,y
0D1D8 A6 08                             ldx ObjectOffset
0D1DA 60                                rts
0D1DB                           
0D1DB                           RunOffscrBitsSubs:
0D1DB 20 FA D1                          jsr GetXOffscreenBits  ;do subroutine here
0D1DE 4A                                lsr                    ;move high nybble to low
0D1DF 4A                                lsr
0D1E0 4A                                lsr
0D1E1 4A                                lsr
0D1E2 85 00                             sta $00                ;store here
0D1E4 4C 3D D2                          jmp GetYOffscreenBits
0D1E7                           
0D1E7                           ;--------------------------------
0D1E7                           ;(these apply to these three subsections)
0D1E7                           ;$04 - used to store proper offset
0D1E7                           ;$05 - used as adder in DividePDiff
0D1E7                           ;$06 - used to store preset value used to compare to pixel difference in $07
0D1E7                           ;$07 - used to store difference between coordinates of object and screen edges
0D1E7                           
0D1E7                           XOffscreenBitsData:
0D1E7 7F 3F 1F 0F 07 03 01 00           .db $7f, $3f, $1f, $0f, $07, $03, $01, $00
0D1EF 80 C0 E0 F0 F8 FC FE FF           .db $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
0D1F7                           
0D1F7                           DefaultXOnscreenOfs:
0D1F7 07 0F 07                          .db $07, $0f, $07
0D1FA                           
0D1FA                           GetXOffscreenBits:
0D1FA 86 04                               stx $04                     ;save position in buffer to here
0D1FC A0 01                               ldy #$01                    ;start with right side of screen
0D1FE B9 1C 07                  XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
0D201 38                                  sec                         ;get difference between pixel coordinate of edge
0D202 F5 86                               sbc SprObject_X_Position,x  ;and pixel coordinate of object position
0D204 85 07                               sta $07                     ;store here
0D206 B9 1A 07                            lda ScreenEdge_PageLoc,y    ;get page location of edge
0D209 F5 6D                               sbc SprObject_PageLoc,x     ;subtract from page location of object position
0D20B BE F7 D1                            ldx DefaultXOnscreenOfs,y   ;load offset value here
0D20E C9 00                               cmp #$00      
0D210 30 10                               bmi XLdBData                ;if beyond right edge or in front of left edge, branch
0D212 BE F8 D1                            ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
0D215 C9 01                               cmp #$01      
0D217 10 09                               bpl XLdBData                ;if one page or more to the left of either edge, branch
0D219 A9 38                               lda #$38                    ;if no branching, load value here and store
0D21B 85 06                               sta $06
0D21D A9 08                               lda #$08                    ;load some other value and execute subroutine
0D21F 20 71 D2                            jsr DividePDiff
0D222 BD E7 D1                  XLdBData: lda XOffscreenBitsData,x    ;get bits here
0D225 A6 04                               ldx $04                     ;reobtain position in buffer
0D227 C9 00                               cmp #$00                    ;if bits not zero, branch to leave
0D229 D0 03                               bne ExXOfsBS
0D22B 88                                  dey                         ;otherwise, do left side of screen now
0D22C 10 D0                               bpl XOfsLoop                ;branch if not already done with left side
0D22E 60                        ExXOfsBS: rts
0D22F                           
0D22F                           ;--------------------------------
0D22F                           
0D22F                           YOffscreenBitsData:
0D22F 00 08 0C 0E                       .db $00, $08, $0c, $0e
0D233 0F 07 03 01                       .db $0f, $07, $03, $01
0D237 00                                .db $00
0D238                           
0D238                           DefaultYOnscreenOfs:
0D238 04 00 04                          .db $04, $00, $04
0D23B                           
0D23B                           HighPosUnitData:
0D23B FF 00                             .db $ff, $00
0D23D                           
0D23D                           GetYOffscreenBits:
0D23D 86 04                               stx $04                      ;save position in buffer to here
0D23F A0 01                               ldy #$01                     ;start with top of screen
0D241 B9 3B D2                  YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
0D244 38                                  sec
0D245 F5 CE                               sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
0D247 85 07                               sta $07                      ;store here
0D249 A9 01                               lda #$01                     ;subtract one from vertical high byte of object
0D24B F5 B5                               sbc SprObject_Y_HighPos,x
0D24D BE 38 D2                            ldx DefaultYOnscreenOfs,y    ;load offset value here
0D250 C9 00                               cmp #$00
0D252 30 10                               bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
0D254 BE 39 D2                            ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
0D257 C9 01                               cmp #$01
0D259 10 09                               bpl YLdBData                 ;if one vertical unit or more above the screen, branch
0D25B A9 20                               lda #$20                     ;if no branching, load value here and store
0D25D 85 06                               sta $06
0D25F A9 04                               lda #$04                     ;load some other value and execute subroutine
0D261 20 71 D2                            jsr DividePDiff
0D264 BD 2F D2                  YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
0D267 A6 04                               ldx $04                      ;reobtain position in buffer
0D269 C9 00                               cmp #$00
0D26B D0 03                               bne ExYOfsBS                 ;if bits not zero, branch to leave
0D26D 88                                  dey                          ;otherwise, do bottom of the screen now
0D26E 10 D1                               bpl YOfsLoop
0D270 60                        ExYOfsBS: rts
0D271                           
0D271                           ;--------------------------------
0D271                           
0D271                           DividePDiff:
0D271 85 05                               sta $05       ;store current value in A here
0D273 A5 07                               lda $07       ;get pixel difference
0D275 C5 06                               cmp $06       ;compare to preset value
0D277 B0 0C                               bcs ExDivPD   ;if pixel difference >= preset value, branch
0D279 4A                                  lsr           ;divide by eight
0D27A 4A                                  lsr
0D27B 4A                                  lsr
0D27C 29 07                               and #$07      ;mask out all but 3 LSB
0D27E C0 01                               cpy #$01      ;right side of the screen or top?
0D280 B0 02                               bcs SetOscrO  ;if so, branch, use difference / 8 as offset
0D282 65 05                               adc $05       ;if not, add value to difference / 8
0D284 AA                        SetOscrO: tax           ;use as offset
0D285 60                        ExDivPD:  rts           ;leave
0D286                           
0D286                           ;-------------------------------------------------------------------------------------
0D286                           ;$00-$01 - tile numbers
0D286                           ;$02 - Y coordinate
0D286                           ;$03 - flip control
0D286                           ;$04 - sprite attributes
0D286                           ;$05 - X coordinate
0D286                           
0D286                           DrawSpriteObject:
0D286 A5 03                              lda $03                    ;get saved flip control bits
0D288 4A                                 lsr
0D289 4A                                 lsr                        ;move d1 into carry
0D28A A5 00                              lda $00
0D28C 90 0C                              bcc NoHFlip                ;if d1 not set, branch
0D28E 99 05 02                           sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
0D291 A5 01                              lda $01                    ;and second into first sprite
0D293 99 01 02                           sta Sprite_Tilenumber,y
0D296 A9 40                              lda #$40                   ;activate horizontal flip OAM attribute
0D298 D0 0A                              bne SetHFAt                ;and unconditionally branch
0D29A 99 01 02                  NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
0D29D A5 01                              lda $01                    ;and second into second sprite
0D29F 99 05 02                           sta Sprite_Tilenumber+4,y
0D2A2 A9 00                              lda #$00                   ;clear bit for horizontal flip
0D2A4 05 04                     SetHFAt: ora $04                    ;add other OAM attributes if necessary
0D2A6 99 02 02                           sta Sprite_Attributes,y    ;store sprite attributes
0D2A9 99 06 02                           sta Sprite_Attributes+4,y
0D2AC A5 02                              lda $02                    ;now the y coordinates
0D2AE 99 00 02                           sta Sprite_Y_Position,y    ;note because they are
0D2B1 99 04 02                           sta Sprite_Y_Position+4,y  ;side by side, they are the same
0D2B4 A5 05                              lda $05       
0D2B6 99 03 02                           sta Sprite_X_Position,y    ;store x coordinate, then
0D2B9 18                                 clc                        ;add 8 pixels and store another to
0D2BA 69 08                              adc #$08                   ;put them side by side
0D2BC 99 07 02                           sta Sprite_X_Position+4,y
0D2BF A5 02                              lda $02                    ;add eight pixels to the next y
0D2C1 18                                 clc                        ;coordinate
0D2C2 69 08                              adc #$08
0D2C4 85 02                              sta $02
0D2C6 98                                 tya                        ;add eight to the offset in Y to
0D2C7 18                                 clc                        ;move to the next two sprites
0D2C8 69 08                              adc #$08
0D2CA A8                                 tay
0D2CB E8                                 inx                        ;increment offset to return it to the
0D2CC E8                                 inx                        ;routine that called this subroutine
0D2CD 60                                 rts
0D2CE                           
0D2CE                           ;-------------------------------------------------------------------------------------
0D2CE                           
0D2CE                           ;unused space
0D2CE FF FF                             .db $ff, $ff
0D2D0                           
0D2D0                           ;-------------------------------------------------------------------------------------
0D2D0                           
0D2D0                           SoundEngine:
0D2D0 AD 70 07                           lda OperMode              ;are we in title screen mode?
0D2D3 D0 04                              bne SndOn
0D2D5 8D 15 40                           sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
0D2D8 60                                 rts
0D2D9 A9 FF                     SndOn:   lda #$ff
0D2DB 8D 17 40                           sta JOYPAD_PORT2          ;disable irqs and set frame counter mode???
0D2DE A9 0F                              lda #$0f
0D2E0 8D 15 40                           sta SND_MASTERCTRL_REG    ;enable first four channels
0D2E3 AD C6 07                           lda PauseModeFlag         ;is sound already in pause mode?
0D2E6 D0 06                              bne InPause
0D2E8 A5 FA                              lda PauseSoundQueue       ;if not, check pause sfx queue    
0D2EA C9 01                              cmp #$01
0D2EC D0 5D                              bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
0D2EE AD B2 07                  InPause: lda PauseSoundBuffer      ;check pause sfx buffer
0D2F1 D0 23                              bne ContPau
0D2F3 A5 FA                              lda PauseSoundQueue       ;check pause queue
0D2F5 F0 66                              beq SkipSoundSubroutines
0D2F7 8D B2 07                           sta PauseSoundBuffer      ;if queue full, store in buffer and activate
0D2FA 8D C6 07                           sta PauseModeFlag         ;pause mode to interrupt game sounds
0D2FD A9 00                              lda #$00                  ;disable sound and clear sfx buffers
0D2FF 8D 15 40                           sta SND_MASTERCTRL_REG
0D302 85 F1                              sta Square1SoundBuffer
0D304 85 F2                              sta Square2SoundBuffer
0D306 85 F3                              sta NoiseSoundBuffer
0D308 A9 0F                              lda #$0f
0D30A 8D 15 40                           sta SND_MASTERCTRL_REG    ;enable sound again
0D30D A9 2A                              lda #$2a                  ;store length of sound in pause counter
0D30F 8D BB 07                           sta Squ1_SfxLenCounter
0D312 A9 44                     PTone1F: lda #$44                  ;play first tone
0D314 D0 11                              bne PTRegC                ;unconditional branch
0D316 AD BB 07                  ContPau: lda Squ1_SfxLenCounter    ;check pause length left
0D319 C9 24                              cmp #$24                  ;time to play second?
0D31B F0 08                              beq PTone2F
0D31D C9 1E                              cmp #$1e                  ;time to play first again?
0D31F F0 F1                              beq PTone1F
0D321 C9 18                              cmp #$18                  ;time to play second again?
0D323 D0 09                              bne DecPauC               ;only load regs during times, otherwise skip
0D325 A9 64                     PTone2F: lda #$64                  ;store reg contents and play the pause sfx
0D327 A2 84                     PTRegC:  ldx #$84
0D329 A0 7F                              ldy #$7f
0D32B 20 88 D3                           jsr PlaySqu1Sfx
0D32E CE BB 07                  DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
0D331 D0 2A                              bne SkipSoundSubroutines
0D333 A9 00                              lda #$00                  ;disable sound if in pause mode and
0D335 8D 15 40                           sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
0D338 AD B2 07                           lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
0D33B C9 02                              cmp #$02                  ;if we need to be playing sound again
0D33D D0 05                              bne SkipPIn
0D33F A9 00                              lda #$00                  ;clear pause mode to allow game sounds again
0D341 8D C6 07                           sta PauseModeFlag
0D344 A9 00                     SkipPIn: lda #$00                  ;clear pause sfx buffer
0D346 8D B2 07                           sta PauseSoundBuffer
0D349 F0 12                              beq SkipSoundSubroutines
0D34B                           
0D34B                           RunSoundSubroutines:
0D34B 20 1B D4                           jsr Square1SfxHandler  ;play sfx on square channel 1
0D34E 20 7C D5                           jsr Square2SfxHandler  ; ''  ''  '' square channel 2
0D351 20 67 D6                           jsr NoiseSfxHandler    ; ''  ''  '' noise channel
0D354 20 94 D6                           jsr MusicHandler       ;play music on all channels
0D357 A9 00                              lda #$00               ;clear the music queues
0D359 85 FB                              sta AreaMusicQueue
0D35B 85 FC                              sta EventMusicQueue
0D35D                           
0D35D                           SkipSoundSubroutines:
0D35D A9 00                               lda #$00               ;clear the sound effects queues
0D35F 85 FF                               sta Square1SoundQueue
0D361 85 FE                               sta Square2SoundQueue
0D363 85 FD                               sta NoiseSoundQueue
0D365 85 FA                               sta PauseSoundQueue
0D367 AC C0 07                            ldy DAC_Counter        ;load some sort of counter 
0D36A A5 F4                               lda AreaMusicBuffer
0D36C 29 03                               and #%00000011         ;check for specific music
0D36E F0 07                               beq NoIncDAC
0D370 EE C0 07                            inc DAC_Counter        ;increment and check counter
0D373 C0 30                               cpy #$30
0D375 90 06                               bcc StrWave            ;if not there yet, just store it
0D377 98                        NoIncDAC: tya
0D378 F0 03                               beq StrWave            ;if we are at zero, do not decrement 
0D37A CE C0 07                            dec DAC_Counter        ;decrement counter
0D37D 8C 11 40                  StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
0D380 60                                  rts                    ;we are done here
0D381                           
0D381                           ;--------------------------------
0D381                           
0D381                           Dump_Squ1_Regs:
0D381 8C 01 40                        sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
0D384 8E 00 40                        stx SND_SQUARE1_REG
0D387 60                              rts
0D388                                 
0D388                           PlaySqu1Sfx:
0D388 20 81 D3                        jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
0D38B                           
0D38B                           SetFreq_Squ1:
0D38B A2 00                           ldx #$00               ;set frequency reg offset for square 1 sound channel
0D38D                           
0D38D                           Dump_Freq_Regs:
0D38D A8                                tay
0D38E B9 01 DF                          lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
0D391 F0 0B                             beq NoTone                ;if zero, then do not load
0D393 9D 02 40                          sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
0D396 B9 00 DF                          lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for 
0D399 09 08                             ora #%00001000            ;length counter
0D39B 9D 03 40                          sta SND_REGISTER+3,x
0D39E 60                        NoTone: rts
0D39F                           
0D39F                           Dump_Sq2_Regs:
0D39F 8E 04 40                        stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
0D3A2 8C 05 40                        sty SND_SQUARE2_REG+1
0D3A5 60                              rts
0D3A6                           
0D3A6                           PlaySqu2Sfx:
0D3A6 20 9F D3                        jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
0D3A9                           
0D3A9                           SetFreq_Squ2:
0D3A9 A2 04                           ldx #$04               ;set frequency reg offset for square 2 sound channel
0D3AB D0 E0                           bne Dump_Freq_Regs     ;unconditional branch
0D3AD                           
0D3AD                           SetFreq_Tri:
0D3AD A2 08                           ldx #$08               ;set frequency reg offset for triangle sound channel
0D3AF D0 DC                           bne Dump_Freq_Regs     ;unconditional branch
0D3B1                           
0D3B1                           ;--------------------------------
0D3B1                           
0D3B1                           SwimStompEnvelopeData:
0D3B1 9F 9B 98 96 95 94 92 90         .db $9f, $9b, $98, $96, $95, $94, $92, $90
0D3B9 90 9A 97 95 93 92               .db $90, $9a, $97, $95, $93, $92
0D3BF                           
0D3BF                           PlayFlagpoleSlide:
0D3BF A9 40                            lda #$40               ;store length of flagpole sound
0D3C1 8D BB 07                         sta Squ1_SfxLenCounter
0D3C4 A9 62                            lda #$62               ;load part of reg contents for flagpole sound
0D3C6 20 8B D3                         jsr SetFreq_Squ1
0D3C9 A2 99                            ldx #$99               ;now load the rest
0D3CB D0 25                            bne FPS2nd
0D3CD                           
0D3CD                           PlaySmallJump:
0D3CD A9 26                            lda #$26               ;branch here for small mario jumping sound
0D3CF D0 02                            bne JumpRegContents
0D3D1                           
0D3D1                           PlayBigJump:
0D3D1 A9 18                            lda #$18               ;branch here for big mario jumping sound
0D3D3                           
0D3D3                           JumpRegContents:
0D3D3 A2 82                            ldx #$82               ;note that small and big jump borrow each others' reg contents
0D3D5 A0 A7                            ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
0D3D7 20 88 D3                         jsr PlaySqu1Sfx
0D3DA A9 28                            lda #$28               ;store length of sfx for both jumping sounds
0D3DC 8D BB 07                         sta Squ1_SfxLenCounter ;then continue on here
0D3DF                           
0D3DF                           ContinueSndJump:
0D3DF AD BB 07                            lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
0D3E2 C9 25                               cmp #$25               ;check for time to play second part yet
0D3E4 D0 06                               bne N2Prt
0D3E6 A2 5F                               ldx #$5f               ;load second part
0D3E8 A0 F6                               ldy #$f6
0D3EA D0 08                               bne DmpJpFPS           ;unconditional branch
0D3EC C9 20                     N2Prt:    cmp #$20               ;check for third part
0D3EE D0 29                               bne DecJpFPS
0D3F0 A2 48                               ldx #$48               ;load third part
0D3F2 A0 BC                     FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
0D3F4 20 81 D3                  DmpJpFPS: jsr Dump_Squ1_Regs
0D3F7 D0 20                               bne DecJpFPS           ;unconditional branch outta here
0D3F9                           
0D3F9                           PlayFireballThrow:
0D3F9 A9 05                             lda #$05
0D3FB A0 99                             ldy #$99                 ;load reg contents for fireball throw sound
0D3FD D0 04                             bne Fthrow               ;unconditional branch
0D3FF                           
0D3FF                           PlayBump:
0D3FF A9 0A                               lda #$0a                ;load length of sfx and reg contents for bump sound
0D401 A0 93                               ldy #$93
0D403 A2 9E                     Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
0D405 8D BB 07                            sta Squ1_SfxLenCounter
0D408 A9 0C                               lda #$0c                ;load offset for bump sound
0D40A 20 88 D3                            jsr PlaySqu1Sfx
0D40D                           
0D40D                           ContinueBumpThrow:    
0D40D AD BB 07                            lda Squ1_SfxLenCounter  ;check for second part of bump sound
0D410 C9 06                               cmp #$06   
0D412 D0 05                               bne DecJpFPS
0D414 A9 BB                               lda #$bb                ;load second part directly
0D416 8D 01 40                            sta SND_SQUARE1_REG+1
0D419 D0 60                     DecJpFPS: bne BranchToDecLength1  ;unconditional branch
0D41B                           
0D41B                           
0D41B                           Square1SfxHandler:
0D41B A4 FF                            ldy Square1SoundQueue   ;check for sfx in queue
0D41D F0 20                            beq CheckSfx1Buffer
0D41F 84 F1                            sty Square1SoundBuffer  ;if found, put in buffer
0D421 30 AA                            bmi PlaySmallJump       ;small jump
0D423 46 FF                            lsr Square1SoundQueue
0D425 B0 AA                            bcs PlayBigJump         ;big jump
0D427 46 FF                            lsr Square1SoundQueue
0D429 B0 D4                            bcs PlayBump            ;bump
0D42B 46 FF                            lsr Square1SoundQueue
0D42D B0 2C                            bcs PlaySwimStomp       ;swim/stomp
0D42F 46 FF                            lsr Square1SoundQueue
0D431 B0 4A                            bcs PlaySmackEnemy      ;smack enemy
0D433 46 FF                            lsr Square1SoundQueue
0D435 B0 7F                            bcs PlayPipeDownInj     ;pipedown/injury
0D437 46 FF                            lsr Square1SoundQueue
0D439 B0 BE                            bcs PlayFireballThrow   ;fireball throw
0D43B 46 FF                            lsr Square1SoundQueue
0D43D B0 80                            bcs PlayFlagpoleSlide   ;slide flagpole
0D43F                           
0D43F                           CheckSfx1Buffer:
0D43F A5 F1                            lda Square1SoundBuffer   ;check for sfx in buffer 
0D441 F0 17                            beq ExS1H                ;if not found, exit sub
0D443 30 9A                            bmi ContinueSndJump      ;small mario jump 
0D445 4A                               lsr
0D446 B0 97                            bcs ContinueSndJump      ;big mario jump 
0D448 4A                               lsr
0D449 B0 C2                            bcs ContinueBumpThrow    ;bump
0D44B 4A                               lsr
0D44C B0 1B                            bcs ContinueSwimStomp    ;swim/stomp
0D44E 4A                               lsr
0D44F B0 3C                            bcs ContinueSmackEnemy   ;smack enemy
0D451 4A                               lsr
0D452 B0 67                            bcs ContinuePipeDownInj  ;pipedown/injury
0D454 4A                               lsr
0D455 B0 B6                            bcs ContinueBumpThrow    ;fireball throw
0D457 4A                               lsr
0D458 B0 48                            bcs DecrementSfx1Length  ;slide flagpole
0D45A 60                        ExS1H: rts
0D45B                           
0D45B                           PlaySwimStomp:
0D45B A9 0E                           lda #$0e               ;store length of swim/stomp sound
0D45D 8D BB 07                        sta Squ1_SfxLenCounter
0D460 A0 9C                           ldy #$9c               ;store reg contents for swim/stomp sound
0D462 A2 9E                           ldx #$9e
0D464 A9 26                           lda #$26
0D466 20 88 D3                        jsr PlaySqu1Sfx
0D469                           
0D469                           ContinueSwimStomp: 
0D469 AC BB 07                        ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
0D46C B9 B0 D3                        lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
0D46F 8D 00 40                        sta SND_SQUARE1_REG           ;envelope
0D472 C0 06                           cpy #$06   
0D474 D0 05                           bne BranchToDecLength1
0D476 A9 9E                           lda #$9e                      ;when the length counts down to a certain point, put this
0D478 8D 02 40                        sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
0D47B                           
0D47B                           BranchToDecLength1: 
0D47B D0 25                           bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
0D47D                           
0D47D                           PlaySmackEnemy:
0D47D A9 0E                           lda #$0e                 ;store length of smack enemy sound
0D47F A0 CB                           ldy #$cb
0D481 A2 9F                           ldx #$9f
0D483 8D BB 07                        sta Squ1_SfxLenCounter
0D486 A9 28                           lda #$28                 ;store reg contents for smack enemy sound
0D488 20 88 D3                        jsr PlaySqu1Sfx
0D48B D0 15                           bne DecrementSfx1Length  ;unconditional branch
0D48D                           
0D48D                           ContinueSmackEnemy:
0D48D AC BB 07                          ldy Squ1_SfxLenCounter  ;check about halfway through
0D490 C0 08                             cpy #$08
0D492 D0 09                             bne SmSpc
0D494 A9 A0                             lda #$a0                ;if we're at the about-halfway point, make the second tone
0D496 8D 02 40                          sta SND_SQUARE1_REG+2   ;in the smack enemy sound
0D499 A9 9F                             lda #$9f
0D49B D0 02                             bne SmTick
0D49D A9 90                     SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
0D49F 8D 00 40                  SmTick: sta SND_SQUARE1_REG
0D4A2                           
0D4A2                           DecrementSfx1Length:
0D4A2 CE BB 07                        dec Squ1_SfxLenCounter    ;decrement length of sfx
0D4A5 D0 0E                           bne ExSfx1
0D4A7                           
0D4A7                           StopSquare1Sfx:
0D4A7 A2 00                             ldx #$00                ;if end of sfx reached, clear buffer
0D4A9 86 F1                             stx $f1                 ;and stop making the sfx
0D4AB A2 0E                             ldx #$0e
0D4AD 8E 15 40                          stx SND_MASTERCTRL_REG
0D4B0 A2 0F                             ldx #$0f
0D4B2 8E 15 40                          stx SND_MASTERCTRL_REG
0D4B5 60                        ExSfx1: rts
0D4B6                           
0D4B6                           PlayPipeDownInj:  
0D4B6 A9 2F                           lda #$2f                ;load length of pipedown sound
0D4B8 8D BB 07                        sta Squ1_SfxLenCounter
0D4BB                           
0D4BB                           ContinuePipeDownInj:
0D4BB AD BB 07                           lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
0D4BE 4A                                 lsr                     ;to be written to only during six specific times
0D4BF B0 10                              bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
0D4C1 4A                                 lsr
0D4C2 B0 0D                              bcs NoPDwnL
0D4C4 29 02                              and #%00000010
0D4C6 F0 09                              beq NoPDwnL
0D4C8 A0 91                              ldy #$91                ;and this is where it actually gets written in
0D4CA A2 9A                              ldx #$9a
0D4CC A9 44                              lda #$44
0D4CE 20 88 D3                           jsr PlaySqu1Sfx
0D4D1 4C A2 D4                  NoPDwnL: jmp DecrementSfx1Length
0D4D4                           
0D4D4                           ;--------------------------------
0D4D4                           
0D4D4                           ExtraLifeFreqData:
0D4D4 58 02 54 56 4E 44               .db $58, $02, $54, $56, $4e, $44
0D4DA                           
0D4DA                           PowerUpGrabFreqData:
0D4DA 4C 52 4C 48 3E 36 3E 36..       .db $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
0D4E3 28 4A 50 4A 64 3C 32 3C..       .db $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
0D4EC 2C 24 3A 64 3A 34 2C 22..       .db $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
0D4F5                           
0D4F5                           ;residual frequency data
0D4F5 22 1C 14                        .db $22, $1c, $14
0D4F8                           
0D4F8                           PUp_VGrow_FreqData:
0D4F8 14 04 22 24 16 04 24 26         .db $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
0D500 18 04 26 28 1A 04 28 2A         .db $18, $04, $26, $28, $1a, $04, $28, $2a
0D508 1C 04 2A 2C 1E 04 2C 2E         .db $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
0D510 20 04 2E 30 22 04 30 32         .db $20, $04, $2e, $30, $22, $04, $30, $32
0D518                           
0D518                           PlayCoinGrab:
0D518 A9 35                             lda #$35             ;load length of coin grab sound
0D51A A2 8D                             ldx #$8d             ;and part of reg contents
0D51C D0 04                             bne CGrab_TTickRegL
0D51E                           
0D51E                           PlayTimerTick:
0D51E A9 06                             lda #$06             ;load length of timer tick sound
0D520 A2 98                             ldx #$98             ;and part of reg contents
0D522                           
0D522                           CGrab_TTickRegL:
0D522 8D BD 07                          sta Squ2_SfxLenCounter 
0D525 A0 7F                             ldy #$7f                ;load the rest of reg contents 
0D527 A9 42                             lda #$42                ;of coin grab and timer tick sound
0D529 20 A6 D3                          jsr PlaySqu2Sfx
0D52C                           
0D52C                           ContinueCGrabTTick:
0D52C AD BD 07                          lda Squ2_SfxLenCounter  ;check for time to play second tone yet
0D52F C9 30                             cmp #$30                ;timer tick sound also executes this, not sure why
0D531 D0 05                             bne N2Tone
0D533 A9 54                             lda #$54                ;if so, load the tone directly into the reg
0D535 8D 06 40                          sta SND_SQUARE2_REG+2
0D538 D0 2E                     N2Tone: bne DecrementSfx2Length
0D53A                           
0D53A                           PlayBlast:
0D53A A9 20                             lda #$20                ;load length of fireworks/gunfire sound
0D53C 8D BD 07                          sta Squ2_SfxLenCounter
0D53F A0 94                             ldy #$94                ;load reg contents of fireworks/gunfire sound
0D541 A9 5E                             lda #$5e
0D543 D0 0B                             bne SBlasJ
0D545                           
0D545                           ContinueBlast:
0D545 AD BD 07                          lda Squ2_SfxLenCounter  ;check for time to play second part
0D548 C9 18                             cmp #$18
0D54A D0 1C                             bne DecrementSfx2Length
0D54C A0 93                             ldy #$93                ;load second part reg contents then
0D54E A9 18                             lda #$18
0D550 D0 7F                     SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
0D552                           
0D552                           PlayPowerUpGrab:
0D552 A9 36                             lda #$36                    ;load length of power-up grab sound
0D554 8D BD 07                          sta Squ2_SfxLenCounter
0D557                           
0D557                           ContinuePowerUpGrab:   
0D557 AD BD 07                          lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
0D55A 4A                                lsr                         ;divide by 2
0D55B B0 0B                             bcs DecrementSfx2Length     ;alter frequency every other frame
0D55D A8                                tay
0D55E B9 D9 D4                          lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
0D561 A2 5D                             ldx #$5d                    ;store reg contents of power-up grab sound
0D563 A0 7F                             ldy #$7f
0D565                           
0D565                           LoadSqu2Regs:
0D565 20 A6 D3                          jsr PlaySqu2Sfx
0D568                           
0D568                           DecrementSfx2Length:
0D568 CE BD 07                          dec Squ2_SfxLenCounter   ;decrement length of sfx
0D56B D0 0E                             bne ExSfx2
0D56D                           
0D56D                           EmptySfx2Buffer:
0D56D A2 00                             ldx #$00                ;initialize square 2's sound effects buffer
0D56F 86 F2                             stx Square2SoundBuffer
0D571                           
0D571                           StopSquare2Sfx:
0D571 A2 0D                             ldx #$0d                ;stop playing the sfx
0D573 8E 15 40                          stx SND_MASTERCTRL_REG 
0D576 A2 0F                             ldx #$0f
0D578 8E 15 40                          stx SND_MASTERCTRL_REG
0D57B 60                        ExSfx2: rts
0D57C                           
0D57C                           Square2SfxHandler:
0D57C A5 F2                             lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
0D57E 29 40                             and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
0D580 D0 65                             bne ContinueExtraLife
0D582 A4 FE                             ldy Square2SoundQueue  ;check for sfx in queue
0D584 F0 20                             beq CheckSfx2Buffer
0D586 84 F2                             sty Square2SoundBuffer ;if found, put in buffer and check for the following
0D588 30 3E                             bmi PlayBowserFall     ;bowser fall
0D58A 46 FE                             lsr Square2SoundQueue
0D58C B0 8A                             bcs PlayCoinGrab       ;coin grab
0D58E 46 FE                             lsr Square2SoundQueue
0D590 B0 6A                             bcs PlayGrowPowerUp    ;power-up reveal
0D592 46 FE                             lsr Square2SoundQueue
0D594 B0 6A                             bcs PlayGrowVine       ;vine grow
0D596 46 FE                             lsr Square2SoundQueue
0D598 B0 A0                             bcs PlayBlast          ;fireworks/gunfire
0D59A 46 FE                             lsr Square2SoundQueue
0D59C B0 80                             bcs PlayTimerTick      ;timer tick
0D59E 46 FE                             lsr Square2SoundQueue
0D5A0 B0 B0                             bcs PlayPowerUpGrab    ;power-up grab
0D5A2 46 FE                             lsr Square2SoundQueue
0D5A4 B0 3C                             bcs PlayExtraLife      ;1-up
0D5A6                           
0D5A6                           CheckSfx2Buffer:
0D5A6 A5 F2                             lda Square2SoundBuffer   ;check for sfx in buffer
0D5A8 F0 17                             beq ExS2H                ;if not found, exit sub
0D5AA 30 27                             bmi ContinueBowserFall   ;bowser fall
0D5AC 4A                                lsr
0D5AD B0 13                             bcs Cont_CGrab_TTick     ;coin grab
0D5AF 4A                                lsr
0D5B0 B0 5D                             bcs ContinueGrowItems    ;power-up reveal
0D5B2 4A                                lsr
0D5B3 B0 5A                             bcs ContinueGrowItems    ;vine grow
0D5B5 4A                                lsr
0D5B6 B0 8D                             bcs ContinueBlast        ;fireworks/gunfire
0D5B8 4A                                lsr
0D5B9 B0 07                             bcs Cont_CGrab_TTick     ;timer tick
0D5BB 4A                                lsr
0D5BC B0 99                             bcs ContinuePowerUpGrab  ;power-up grab
0D5BE 4A                                lsr
0D5BF B0 26                             bcs ContinueExtraLife    ;1-up
0D5C1 60                        ExS2H:  rts
0D5C2                           
0D5C2                           Cont_CGrab_TTick:
0D5C2 4C 2C D5                          jmp ContinueCGrabTTick
0D5C5                           
0D5C5                           JumpToDecLength2:
0D5C5 4C 68 D5                          jmp DecrementSfx2Length
0D5C8                           
0D5C8                           PlayBowserFall:    
0D5C8 A9 38                              lda #$38                ;load length of bowser defeat sound
0D5CA 8D BD 07                           sta Squ2_SfxLenCounter
0D5CD A0 C4                              ldy #$c4                ;load contents of reg for bowser defeat sound
0D5CF A9 18                              lda #$18
0D5D1 D0 0B                     BlstSJp: bne PBFRegs
0D5D3                           
0D5D3                           ContinueBowserFall:
0D5D3 AD BD 07                            lda Squ2_SfxLenCounter   ;check for almost near the end
0D5D6 C9 08                               cmp #$08
0D5D8 D0 8E                               bne DecrementSfx2Length
0D5DA A0 A4                               ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
0D5DC A9 5A                               lda #$5a
0D5DE A2 9F                     PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
0D5E0 D0 83                     EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
0D5E2                           
0D5E2                           PlayExtraLife:
0D5E2 A9 30                             lda #$30                  ;load length of 1-up sound
0D5E4 8D BD 07                          sta Squ2_SfxLenCounter
0D5E7                           
0D5E7                           ContinueExtraLife:
0D5E7 AD BD 07                            lda Squ2_SfxLenCounter   
0D5EA A2 03                               ldx #$03                  ;load new tones only every eight frames
0D5EC 4A                        DivLLoop: lsr
0D5ED B0 D6                               bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
0D5EF CA                                  dex
0D5F0 D0 FA                               bne DivLLoop              ;do this until all bits checked, if none set, continue
0D5F2 A8                                  tay
0D5F3 B9 D3 D4                            lda ExtraLifeFreqData-1,y ;load our reg contents
0D5F6 A2 82                               ldx #$82
0D5F8 A0 7F                               ldy #$7f
0D5FA D0 E4                               bne EL_LRegs              ;unconditional branch
0D5FC                           
0D5FC                           PlayGrowPowerUp:
0D5FC A9 10                             lda #$10                ;load length of power-up reveal sound
0D5FE D0 02                             bne GrowItemRegs
0D600                           
0D600                           PlayGrowVine:
0D600 A9 20                             lda #$20                ;load length of vine grow sound
0D602                           
0D602                           GrowItemRegs:
0D602 8D BD 07                          sta Squ2_SfxLenCounter   
0D605 A9 7F                             lda #$7f                  ;load contents of reg for both sounds directly
0D607 8D 05 40                          sta SND_SQUARE2_REG+1
0D60A A9 00                             lda #$00                  ;start secondary counter for both sounds
0D60C 8D BE 07                          sta Sfx_SecondaryCounter
0D60F                           
0D60F                           ContinueGrowItems:
0D60F EE BE 07                          inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
0D612 AD BE 07                          lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
0D615 4A                                lsr                       ;divide by 2 to get the offset
0D616 A8                                tay
0D617 CC BD 07                          cpy Squ2_SfxLenCounter    ;have we reached the end yet?
0D61A F0 0C                             beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
0D61C A9 9D                             lda #$9d                  ;load contents of other reg directly
0D61E 8D 04 40                          sta SND_SQUARE2_REG
0D621 B9 F8 D4                          lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
0D624 20 A9 D3                          jsr SetFreq_Squ2
0D627 60                                rts
0D628                           
0D628                           StopGrowItems:
0D628 4C 6D D5                          jmp EmptySfx2Buffer       ;branch to stop playing sounds
0D62B                           
0D62B                           ;--------------------------------
0D62B                           
0D62B                           BrickShatterFreqData:
0D62B 01 0E 0E 0D 0B 06 0C 0F           .db $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
0D633 0A 09 03 0D 08 0D 06 0C           .db $0a, $09, $03, $0d, $08, $0d, $06, $0c
0D63B                           
0D63B                           PlayBrickShatter:
0D63B A9 20                             lda #$20                 ;load length of brick shatter sound
0D63D 8D BF 07                          sta Noise_SfxLenCounter
0D640                           
0D640                           ContinueBrickShatter:
0D640 AD BF 07                          lda Noise_SfxLenCounter  
0D643 4A                                lsr                         ;divide by 2 and check for bit set to use offset
0D644 90 12                             bcc DecrementSfx3Length
0D646 A8                                tay
0D647 BE 2B D6                          ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
0D64A B9 EA DF                          lda BrickShatterEnvData,y
0D64D                           
0D64D                           PlayNoiseSfx:
0D64D 8D 0C 40                          sta SND_NOISE_REG        ;play the sfx
0D650 8E 0E 40                          stx SND_NOISE_REG+2
0D653 A9 18                             lda #$18
0D655 8D 0F 40                          sta SND_NOISE_REG+3
0D658                           
0D658                           DecrementSfx3Length:
0D658 CE BF 07                          dec Noise_SfxLenCounter  ;decrement length of sfx
0D65B D0 09                             bne ExSfx3
0D65D A9 F0                             lda #$f0                 ;if done, stop playing the sfx
0D65F 8D 0C 40                          sta SND_NOISE_REG
0D662 A9 00                             lda #$00
0D664 85 F3                             sta NoiseSoundBuffer
0D666 60                        ExSfx3: rts
0D667                           
0D667                           NoiseSfxHandler:
0D667 A4 FD                             ldy NoiseSoundQueue   ;check for sfx in queue
0D669 F0 0A                             beq CheckNoiseBuffer
0D66B 84 F3                             sty NoiseSoundBuffer  ;if found, put in buffer
0D66D 46 FD                             lsr NoiseSoundQueue
0D66F B0 CA                             bcs PlayBrickShatter  ;brick shatter
0D671 46 FD                             lsr NoiseSoundQueue
0D673 B0 0B                             bcs PlayBowserFlame   ;bowser flame
0D675                           
0D675                           CheckNoiseBuffer:
0D675 A5 F3                             lda NoiseSoundBuffer      ;check for sfx in buffer
0D677 F0 06                             beq ExNH                  ;if not found, exit sub
0D679 4A                                lsr
0D67A B0 C4                             bcs ContinueBrickShatter  ;brick shatter
0D67C 4A                                lsr
0D67D B0 06                             bcs ContinueBowserFlame   ;bowser flame
0D67F 60                        ExNH:   rts
0D680                           
0D680                           PlayBowserFlame:
0D680 A9 40                             lda #$40                    ;load length of bowser flame sound
0D682 8D BF 07                          sta Noise_SfxLenCounter
0D685                           
0D685                           ContinueBowserFlame:
0D685 AD BF 07                          lda Noise_SfxLenCounter
0D688 4A                                lsr
0D689 A8                                tay
0D68A A2 0F                             ldx #$0f                    ;load reg contents of bowser flame sound
0D68C B9 C9 DF                          lda BowserFlameEnvData-1,y
0D68F D0 BC                             bne PlayNoiseSfx            ;unconditional branch here
0D691                           
0D691                           ;--------------------------------
0D691                           
0D691                           ContinueMusic:
0D691 4C 3A D7                          jmp HandleSquare2Music  ;if we have music, start with square 2 channel
0D694                           
0D694                           MusicHandler:
0D694 A5 FC                             lda EventMusicQueue     ;check event music queue
0D696 D0 0C                             bne LoadEventMusic
0D698 A5 FB                             lda AreaMusicQueue      ;check area music queue
0D69A D0 2C                             bne LoadAreaMusic
0D69C AD B1 07                          lda EventMusicBuffer    ;check both buffers
0D69F 05 F4                             ora AreaMusicBuffer
0D6A1 D0 EE                             bne ContinueMusic 
0D6A3 60                                rts                     ;no music, then leave
0D6A4                           
0D6A4                           LoadEventMusic:
0D6A4 8D B1 07                             sta EventMusicBuffer      ;copy event music queue contents to buffer
0D6A7 C9 01                                cmp #DeathMusic           ;is it death music?
0D6A9 D0 06                                bne NoStopSfx             ;if not, jump elsewhere
0D6AB 20 A7 D4                             jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
0D6AE 20 71 D5                             jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
0D6B1 A6 F4                     NoStopSfx: ldx AreaMusicBuffer
0D6B3 8E C5 07                             stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
0D6B6 A0 00                                ldy #$00
0D6B8 8C C4 07                             sty NoteLengthTblAdder    ;default value for additional length byte offset
0D6BB 84 F4                                sty AreaMusicBuffer       ;clear area music buffer
0D6BD C9 40                                cmp #TimeRunningOutMusic  ;is it time running out music?
0D6BF D0 30                                bne FindEventMusicHeader
0D6C1 A2 08                                ldx #$08                  ;load offset to be added to length byte of header
0D6C3 8E C4 07                             stx NoteLengthTblAdder
0D6C6 D0 29                                bne FindEventMusicHeader  ;unconditional branch
0D6C8                           
0D6C8                           LoadAreaMusic:
0D6C8 C9 04                              cmp #$04                  ;is it underground music?
0D6CA D0 03                              bne NoStop1               ;no, do not stop square 1 sfx
0D6CC 20 A7 D4                           jsr StopSquare1Sfx
0D6CF A0 10                     NoStop1: ldy #$10                  ;start counter used only by ground level music
0D6D1 8C C7 07                  GMLoopB: sty GroundMusicHeaderOfs
0D6D4                           
0D6D4                           HandleAreaMusicLoopB:
0D6D4 A0 00                              ldy #$00                  ;clear event music buffer
0D6D6 8C B1 07                           sty EventMusicBuffer
0D6D9 85 F4                              sta AreaMusicBuffer       ;copy area music queue contents to buffer
0D6DB C9 01                              cmp #$01                  ;is it ground level music?
0D6DD D0 0E                              bne FindAreaMusicHeader
0D6DF EE C7 07                           inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
0D6E2 AC C7 07                           ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
0D6E5 C0 32                              cpy #$32
0D6E7 D0 0C                              bne LoadHeader            ;branch ahead with alternate offset
0D6E9 A0 11                              ldy #$11
0D6EB D0 E4                              bne GMLoopB               ;unconditional branch
0D6ED                           
0D6ED                           FindAreaMusicHeader:
0D6ED A0 08                             ldy #$08                   ;load Y for offset of area music
0D6EF 84 F7                             sty MusicOffset_Square2    ;residual instruction here
0D6F1                           
0D6F1                           FindEventMusicHeader:
0D6F1 C8                                iny                       ;increment Y pointer based on previously loaded queue contents
0D6F2 4A                                lsr                       ;bit shift and increment until we find a set bit for music
0D6F3 90 FC                             bcc FindEventMusicHeader
0D6F5                           
0D6F5                           LoadHeader:
0D6F5 B9 0C D9                          lda MusicHeaderOffsetData,y  ;load offset for header
0D6F8 A8                                tay
0D6F9 B9 0D D9                          lda MusicHeaderData,y        ;now load the header
0D6FC 85 F0                             sta NoteLenLookupTblOfs
0D6FE B9 0E D9                          lda MusicHeaderData+1,y
0D701 85 F5                             sta MusicDataLow
0D703 B9 0F D9                          lda MusicHeaderData+2,y
0D706 85 F6                             sta MusicDataHigh
0D708 B9 10 D9                          lda MusicHeaderData+3,y
0D70B 85 F9                             sta MusicOffset_Triangle
0D70D B9 11 D9                          lda MusicHeaderData+4,y
0D710 85 F8                             sta MusicOffset_Square1
0D712 B9 12 D9                          lda MusicHeaderData+5,y
0D715 8D B0 07                          sta MusicOffset_Noise
0D718 8D C1 07                          sta NoiseDataLoopbackOfs
0D71B A9 01                             lda #$01                     ;initialize music note counters
0D71D 8D B4 07                          sta Squ2_NoteLenCounter
0D720 8D B6 07                          sta Squ1_NoteLenCounter
0D723 8D B9 07                          sta Tri_NoteLenCounter
0D726 8D BA 07                          sta Noise_BeatLenCounter
0D729 A9 00                             lda #$00                     ;initialize music data offset for square 2
0D72B 85 F7                             sta MusicOffset_Square2
0D72D 8D CA 07                          sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
0D730 A9 0B                             lda #$0b                     ;disable triangle channel and reenable it
0D732 8D 15 40                          sta SND_MASTERCTRL_REG
0D735 A9 0F                             lda #$0f
0D737 8D 15 40                          sta SND_MASTERCTRL_REG
0D73A                           
0D73A                           HandleSquare2Music:
0D73A CE B4 07                          dec Squ2_NoteLenCounter  ;decrement square 2 note length
0D73D D0 5F                             bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
0D73F A4 F7                             ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
0D741 E6 F7                             inc MusicOffset_Square2
0D743 B1 F5                             lda (MusicData),y
0D745 F0 04                             beq EndOfMusicData       ;if zero, the data is a null terminator
0D747 10 3D                             bpl Squ2NoteHandler      ;if non-negative, data is a note
0D749 D0 2F                             bne Squ2LengthHandler    ;otherwise it is length data
0D74B                           
0D74B                           EndOfMusicData:
0D74B AD B1 07                          lda EventMusicBuffer     ;check secondary buffer for time running out music
0D74E C9 40                             cmp #TimeRunningOutMusic
0D750 D0 05                             bne NotTRO
0D752 AD C5 07                          lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
0D755 D0 1D                             bne MusicLoopBack        ;and start playing the song again if there is one
0D757 29 04                     NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
0D759 D0 1C                             bne VictoryMLoopBack
0D75B A5 F4                             lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
0D75D 29 5F                             and #%01011111
0D75F D0 13                             bne MusicLoopBack        ;if any area music except pipe intro, music loops
0D761 A9 00                             lda #$00                 ;clear primary and secondary buffers and initialize
0D763 85 F4                             sta AreaMusicBuffer      ;control regs of square and triangle channels
0D765 8D B1 07                          sta EventMusicBuffer
0D768 8D 08 40                          sta SND_TRIANGLE_REG
0D76B A9 90                             lda #$90    
0D76D 8D 00 40                          sta SND_SQUARE1_REG
0D770 8D 04 40                          sta SND_SQUARE2_REG
0D773 60                                rts
0D774                           
0D774                           MusicLoopBack:
0D774 4C D4 D6                          jmp HandleAreaMusicLoopB
0D777                           
0D777                           VictoryMLoopBack:
0D777 4C A4 D6                          jmp LoadEventMusic
0D77A                           
0D77A                           Squ2LengthHandler:
0D77A 20 CB D8                          jsr ProcessLengthData    ;store length of note
0D77D 8D B3 07                          sta Squ2_NoteLenBuffer
0D780 A4 F7                             ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
0D782 E6 F7                             inc MusicOffset_Square2
0D784 B1 F5                             lda (MusicData),y
0D786                           
0D786                           Squ2NoteHandler:
0D786 A6 F2                               ldx Square2SoundBuffer     ;is there a sound playing on this channel?
0D788 D0 0E                               bne SkipFqL1
0D78A 20 A9 D3                            jsr SetFreq_Squ2           ;no, then play the note
0D78D F0 03                               beq Rest                   ;check to see if note is rest
0D78F 20 D8 D8                            jsr LoadControlRegs        ;if not, load control regs for square 2
0D792 8D B5 07                  Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
0D795 20 9F D3                            jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
0D798 AD B3 07                  SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
0D79B 8D B4 07                            sta Squ2_NoteLenCounter
0D79E                           
0D79E                           MiscSqu2MusicTasks:
0D79E A5 F2                                lda Square2SoundBuffer     ;is there a sound playing on square 2?
0D7A0 D0 1A                                bne HandleSquare1Music
0D7A2 AD B1 07                             lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
0D7A5 29 91                                and #%10010001             ;note that regs for death music or d4 are loaded by default
0D7A7 D0 13                                bne HandleSquare1Music
0D7A9 AC B5 07                             ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
0D7AC F0 03                                beq NoDecEnv1
0D7AE CE B5 07                             dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
0D7B1 20 F4 D8                  NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
0D7B4 8D 04 40                             sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
0D7B7 A2 7F                                ldx #$7f                   ;death music or d4 set on secondary buffer
0D7B9 8E 05 40                             stx SND_SQUARE2_REG+1
0D7BC                           
0D7BC                           HandleSquare1Music:
0D7BC A4 F8                             ldy MusicOffset_Square1    ;is there a nonzero offset here?
0D7BE F0 5A                             beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
0D7C0 CE B6 07                          dec Squ1_NoteLenCounter    ;decrement square 1 note length
0D7C3 D0 32                             bne MiscSqu1MusicTasks     ;is it time for more data?
0D7C5                           
0D7C5                           FetchSqu1MusicData:
0D7C5 A4 F8                             ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
0D7C7 E6 F8                             inc MusicOffset_Square1
0D7C9 B1 F5                             lda (MusicData),y
0D7CB D0 0F                             bne Squ1NoteHandler        ;if nonzero, then skip this part
0D7CD A9 83                             lda #$83
0D7CF 8D 00 40                          sta SND_SQUARE1_REG        ;store some data into control regs for square 1
0D7D2 A9 94                             lda #$94                   ;and fetch another byte of data, used to give
0D7D4 8D 01 40                          sta SND_SQUARE1_REG+1      ;death music its unique sound
0D7D7 8D CA 07                          sta AltRegContentFlag
0D7DA D0 E9                             bne FetchSqu1MusicData     ;unconditional branch
0D7DC                           
0D7DC                           Squ1NoteHandler:
0D7DC 20 C5 D8                             jsr AlternateLengthHandler
0D7DF 8D B6 07                             sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
0D7E2 A4 F1                                ldy Square1SoundBuffer     ;is there a sound playing on square 1?
0D7E4 D0 34                                bne HandleTriangleMusic
0D7E6 8A                                   txa
0D7E7 29 3E                                and #%00111110             ;change saved data to appropriate note format
0D7E9 20 8B D3                             jsr SetFreq_Squ1           ;play the note
0D7EC F0 03                                beq SkipCtrlL
0D7EE 20 D8 D8                             jsr LoadControlRegs
0D7F1 8D B7 07                  SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
0D7F4 20 81 D3                             jsr Dump_Squ1_Regs
0D7F7                           
0D7F7                           MiscSqu1MusicTasks:
0D7F7 A5 F1                                   lda Square1SoundBuffer     ;is there a sound playing on square 1?
0D7F9 D0 1F                                   bne HandleTriangleMusic
0D7FB AD B1 07                                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
0D7FE 29 91                                   and #%10010001
0D800 D0 0E                                   bne DeathMAltReg
0D802 AC B7 07                                ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
0D805 F0 03                                   beq NoDecEnv2
0D807 CE B7 07                                dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
0D80A 20 F4 D8                  NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
0D80D 8D 00 40                                sta SND_SQUARE1_REG        ;based on offset set by first load
0D810 AD CA 07                  DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
0D813 D0 02                                   bne DoAltLoad
0D815 A9 7F                                   lda #$7f                   ;load this value if zero, the alternate value
0D817 8D 01 40                  DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
0D81A                           
0D81A                           HandleTriangleMusic:
0D81A A5 F9                             lda MusicOffset_Triangle
0D81C CE B9 07                          dec Tri_NoteLenCounter    ;decrement triangle note length
0D81F D0 4C                             bne HandleNoiseMusic      ;is it time for more data?
0D821 A4 F9                             ldy MusicOffset_Triangle  ;increment square 1 music offset and fetch data
0D823 E6 F9                             inc MusicOffset_Triangle
0D825 B1 F5                             lda (MusicData),y
0D827 F0 41                             beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise 
0D829 10 13                             bpl TriNoteHandler        ;if non-negative, data is note
0D82B 20 CB D8                          jsr ProcessLengthData     ;otherwise, it is length data
0D82E 8D B8 07                          sta Tri_NoteLenBuffer     ;save contents of A
0D831 A9 1F                             lda #$1f
0D833 8D 08 40                          sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
0D836 A4 F9                             ldy MusicOffset_Triangle  ;fetch another byte
0D838 E6 F9                             inc MusicOffset_Triangle
0D83A B1 F5                             lda (MusicData),y
0D83C F0 2C                             beq LoadTriCtrlReg        ;check once more for nonzero data
0D83E                           
0D83E                           TriNoteHandler:
0D83E 20 AD D3                            jsr SetFreq_Tri
0D841 AE B8 07                            ldx Tri_NoteLenBuffer   ;save length in triangle note counter
0D844 8E B9 07                            stx Tri_NoteLenCounter
0D847 AD B1 07                            lda EventMusicBuffer
0D84A 29 6E                               and #%01101110          ;check for death music or d4 set on secondary buffer
0D84C D0 06                               bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
0D84E A5 F4                               lda AreaMusicBuffer     ;check primary buffer for water or castle level music
0D850 29 0A                               and #%00001010
0D852 F0 19                               beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
0D854 8A                        NotDOrD4: txa                     ;if playing water or castle music or any secondary
0D855 C9 12                               cmp #$12                ;besides death music or d4 set, check length of note
0D857 B0 0F                               bcs LongN
0D859 AD B1 07                            lda EventMusicBuffer    ;check for win castle music again if not playing a long note
0D85C 29 08                               and #EndOfCastleMusic
0D85E F0 04                               beq MediN
0D860 A9 0F                               lda #$0f                ;load value $0f if playing the win castle music and playing a short
0D862 D0 06                               bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
0D864 A9 1F                     MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
0D866 D0 02                               bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
0D868 A9 FF                     LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
0D86A                           
0D86A                           LoadTriCtrlReg:           
0D86A 8D 08 40                          sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
0D86D                           
0D86D                           HandleNoiseMusic:
0D86D A5 F4                             lda AreaMusicBuffer       ;check if playing underground or castle music
0D86F 29 F3                             and #%11110011
0D871 F0 51                             beq ExitMusicHandler      ;if so, skip the noise routine
0D873 CE BA 07                          dec Noise_BeatLenCounter  ;decrement noise beat length
0D876 D0 4C                             bne ExitMusicHandler      ;is it time for more data?
0D878                           
0D878                           FetchNoiseBeatData:
0D878 AC B0 07                          ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
0D87B EE B0 07                          inc MusicOffset_Noise
0D87E B1 F5                             lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
0D880 D0 08                             bne NoiseBeatHandler
0D882 AD C1 07                          lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
0D885 8D B0 07                          sta MusicOffset_Noise       ;and loopback next time around
0D888 D0 EE                             bne FetchNoiseBeatData      ;unconditional branch
0D88A                           
0D88A                           NoiseBeatHandler:
0D88A 20 C5 D8                          jsr AlternateLengthHandler
0D88D 8D BA 07                          sta Noise_BeatLenCounter    ;store length in noise beat counter
0D890 8A                                txa
0D891 29 3E                             and #%00111110              ;reload data and erase length bits
0D893 F0 24                             beq SilentBeat              ;if no beat data, silence
0D895 C9 30                             cmp #$30                    ;check the beat data and play the appropriate
0D897 F0 18                             beq LongBeat                ;noise accordingly
0D899 C9 20                             cmp #$20
0D89B F0 0C                             beq StrongBeat
0D89D 29 10                             and #%00010000  
0D89F F0 18                             beq SilentBeat
0D8A1 A9 1C                             lda #$1c        ;short beat data
0D8A3 A2 03                             ldx #$03
0D8A5 A0 18                             ldy #$18
0D8A7 D0 12                             bne PlayBeat
0D8A9                           
0D8A9                           StrongBeat:
0D8A9 A9 1C                             lda #$1c        ;strong beat data
0D8AB A2 0C                             ldx #$0c
0D8AD A0 18                             ldy #$18
0D8AF D0 0A                             bne PlayBeat
0D8B1                           
0D8B1                           LongBeat:
0D8B1 A9 1C                             lda #$1c        ;long beat data
0D8B3 A2 03                             ldx #$03
0D8B5 A0 58                             ldy #$58
0D8B7 D0 02                             bne PlayBeat
0D8B9                           
0D8B9                           SilentBeat:
0D8B9 A9 10                             lda #$10        ;silence
0D8BB                           
0D8BB                           PlayBeat:
0D8BB 8D 0C 40                          sta SND_NOISE_REG    ;load beat data into noise regs
0D8BE 8E 0E 40                          stx SND_NOISE_REG+2
0D8C1 8C 0F 40                          sty SND_NOISE_REG+3
0D8C4                           
0D8C4                           ExitMusicHandler:
0D8C4 60                                rts
0D8C5                           
0D8C5                           AlternateLengthHandler:
0D8C5 AA                                tax            ;save a copy of original byte into X
0D8C6 6A                                ror            ;save LSB from original byte into carry
0D8C7 8A                                txa            ;reload original byte and rotate three times
0D8C8 2A                                rol            ;turning xx00000x into 00000xxx, with the
0D8C9 2A                                rol            ;bit in carry as the MSB here
0D8CA 2A                                rol
0D8CB                           
0D8CB                           ProcessLengthData:
0D8CB 29 07                             and #%00000111              ;clear all but the three LSBs
0D8CD 18                                clc
0D8CE 65 F0                             adc $f0                     ;add offset loaded from first header byte
0D8D0 6D C4 07                          adc NoteLengthTblAdder      ;add extra if time running out music
0D8D3 A8                                tay
0D8D4 B9 66 DF                          lda MusicLengthLookupTbl,y  ;load length
0D8D7 60                                rts
0D8D8                           
0D8D8                           LoadControlRegs:
0D8D8 AD B1 07                             lda EventMusicBuffer  ;check secondary buffer for win castle music
0D8DB 29 08                                and #EndOfCastleMusic
0D8DD F0 04                                beq NotECstlM
0D8DF A9 04                                lda #$04              ;this value is only used for win castle music
0D8E1 D0 0C                                bne AllMus            ;unconditional branch
0D8E3 A5 F4                     NotECstlM: lda AreaMusicBuffer
0D8E5 29 7D                                and #%01111101        ;check primary buffer for water music
0D8E7 F0 04                                beq WaterMus
0D8E9 A9 08                                lda #$08              ;this is the default value for all other music
0D8EB D0 02                                bne AllMus
0D8ED A9 28                     WaterMus:  lda #$28              ;this value is used for water music and all other event music
0D8EF A2 82                     AllMus:    ldx #$82              ;load contents of other sound regs for square 2
0D8F1 A0 7F                                ldy #$7f
0D8F3 60                                   rts
0D8F4                           
0D8F4                           LoadEnvelopeData:
0D8F4 AD B1 07                          lda EventMusicBuffer           ;check secondary buffer for win castle music
0D8F7 29 08                             and #EndOfCastleMusic
0D8F9 F0 04                             beq LoadUsualEnvData
0D8FB B9 96 DF                          lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
0D8FE 60                                rts
0D8FF                           
0D8FF                           LoadUsualEnvData:
0D8FF A5 F4                             lda AreaMusicBuffer            ;check primary buffer for water music
0D901 29 7D                             and #%01111101
0D903 F0 04                             beq LoadWaterEventMusEnvData
0D905 B9 9A DF                          lda AreaMusicEnvData,y         ;load default data from offset for all other music
0D908 60                                rts
0D909                           
0D909                           LoadWaterEventMusEnvData:
0D909 B9 A2 DF                          lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
0D90C 60                                rts
0D90D                           
0D90D                           ;--------------------------------
0D90D                           
0D90D                           ;music header offsets
0D90D                           
0D90D                           MusicHeaderData:
0D90D A5                              .db DeathMusHdr-MHD           ;event music
0D90E 59                              .db GameOverMusHdr-MHD
0D90F 54                              .db VictoryMusHdr-MHD
0D910 64                              .db WinCastleMusHdr-MHD
0D911 59                              .db GameOverMusHdr-MHD
0D912 3C                              .db EndOfLevelMusHdr-MHD
0D913 31                              .db TimeRunningOutHdr-MHD
0D914 4B                              .db SilenceHdr-MHD
0D915                           
0D915 69                              .db GroundLevelPart1Hdr-MHD   ;area music
0D916 5E                              .db WaterMusHdr-MHD
0D917 46                              .db UndergroundMusHdr-MHD
0D918 4F                              .db CastleMusHdr-MHD
0D919 36                              .db Star_CloudHdr-MHD
0D91A 8D                              .db GroundLevelLeadInHdr-MHD
0D91B 36                              .db Star_CloudHdr-MHD
0D91C 4B                              .db SilenceHdr-MHD
0D91D                           
0D91D 8D                              .db GroundLevelLeadInHdr-MHD  ;ground level music layout
0D91E 69 69                           .db GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
0D920 6F 75 6F 7B                     .db GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
0D924 6F 75 6F 7B                     .db GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
0D928 81 87 81 8D                     .db GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
0D92C 69 69                           .db GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
0D92E 93 99 93 9F                     .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
0D932 93 99 93 9F                     .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
0D936 81 87 81 8D                     .db GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
0D93A 93 99 93 9F                     .db GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
0D93E                           
0D93E                           ;music headers
0D93E                           ;header format is as follows: 
0D93E                           ;1 byte - length byte offset
0D93E                           ;2 bytes -  music data address
0D93E                           ;1 byte - triangle data offset
0D93E                           ;1 byte - square 1 data offset
0D93E                           ;1 byte - noise data offset (not used by secondary music)
0D93E                           
0D93E 08 72 DC 27 18            TimeRunningOutHdr:    .db $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
0D943 20 B8 D9 2E 1A 40         Star_CloudHdr:        .db $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
0D949 20 B0 DC 3D 21            EndOfLevelMusHdr:     .db $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
0D94E 20 C4 FC 3F 1D            ResidualHeaderData:   .db $20, $c4, $fc, $3f, $1d
0D953 18 11 DD 00 00            UndergroundMusHdr:    .db $18, <UndergroundMusData, >UndergroundMusData, $00, $00
0D958 08 1C DA 00               SilenceHdr:           .db $08, <SilenceData, >SilenceData, $00
0D95C 00 A4 DB 93 62            CastleMusHdr:         .db $00, <CastleMusData, >CastleMusData, $93, $62
0D961 10 C8 DE 24 14            VictoryMusHdr:        .db $10, <VictoryMusData, >VictoryMusData, $24, $14
0D966 18 45 DC 1E 14            GameOverMusHdr:       .db $18, <GameOverMusData, >GameOverMusData, $1e, $14
0D96B 08 52 DD A0 70 68         WaterMusHdr:          .db $08, <WaterMusData, >WaterMusData, $a0, $70, $68
0D971 08 51 DE 4C 24            WinCastleMusHdr:      .db $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
0D976 18 01 DA 2D 1C B8         GroundLevelPart1Hdr:  .db $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
0D97C 18 49 DA 20 12 70         GroundLevelPart2AHdr: .db $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
0D982 18 75 DA 1B 10 44         GroundLevelPart2BHdr: .db $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
0D988 18 9D DA 11 0A 1C         GroundLevelPart2CHdr: .db $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
0D98E 18 C2 DA 2D 10 58         GroundLevelPart3AHdr: .db $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
0D994 18 DB DA 14 0D 3F         GroundLevelPart3BHdr: .db $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
0D99A 18 F9 DA 15 0D 21         GroundLevelLeadInHdr: .db $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
0D9A0 18 25 DB 18 10 7A         GroundLevelPart4AHdr: .db $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
0D9A6 18 4B DB 19 0F 54         GroundLevelPart4BHdr: .db $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
0D9AC 18 74 DB 1E 12 2B         GroundLevelPart4CHdr: .db $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
0D9B2 18 72 DB 1E 0F 2D         DeathMusHdr:          .db $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
0D9B8                           
0D9B8                           ;--------------------------------
0D9B8                           
0D9B8                           ;MUSIC DATA
0D9B8                           ;square 2/triangle format
0D9B8                           ;d7 - length byte flag (0-note, 1-length)
0D9B8                           ;if d7 is set to 0 and d6-d0 is nonzero:
0D9B8                           ;d6-d0 - note offset in frequency look-up table (must be even)
0D9B8                           ;if d7 is set to 1:
0D9B8                           ;d6-d3 - unused
0D9B8                           ;d2-d0 - length offset in length look-up table
0D9B8                           ;value of $00 in square 2 data is used as null terminator, affects all sound channels
0D9B8                           ;value of $00 in triangle data causes routine to skip note
0D9B8                           
0D9B8                           ;square 1 format
0D9B8                           ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
0D9B8                           ;d5-d1 - note offset in frequency look-up table
0D9B8                           ;value of $00 in square 1 data is flag alternate control reg data to be loaded
0D9B8                           
0D9B8                           ;noise format
0D9B8                           ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
0D9B8                           ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
0D9B8                           ;d3-d1 - unused
0D9B8                           ;value of $00 in noise data is used as null terminator, affects only noise
0D9B8                           
0D9B8                           ;all music data is organized into sections (unless otherwise stated):
0D9B8                           ;square 2, square 1, triangle, noise
0D9B8                           
0D9B8                           Star_CloudMData:
0D9B8 84 2C 2C 2C 82 04 2C 04..       .db $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
0D9C5 2A 2A 2A 82 04 2A 04 85..       .db $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
0D9D2                           
0D9D2 1F 1F 1F 98 1F 1F 98 9E..       .db $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
0D9DC 1D 1D 1D 94 1D 1D 94 9C..       .db $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
0D9E6                           
0D9E6 86 18 85 26 30 84 04 26..       .db $86, $18, $85, $26, $30, $84, $04, $26, $30
0D9EF 86 14 85 22 2C 84 04 22..       .db $86, $14, $85, $22, $2c, $84, $04, $22, $2c
0D9F8                           
0D9F8 21 D0 C4 D0 31 D0 C4 D0..       .db $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
0DA01                           
0DA01                           GroundM_P1Data:
0DA01 85 2C 22 1C 84 26 2A 82..       .db $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
0DA0C 87 22 34 3A 82 40 04 36..       .db $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
0DA17 82 2C 30 85 2A                  .db $82, $2c, $30, $85, $2a
0DA1C                           
0DA1C                           SilenceData:
0DA1C 00                              .db $00
0DA1D                           
0DA1D 5D 55 4D 15 19 96 15 D5..       .db $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
0DA27 2D A6 2B 27 9C 9E 59            .db $2d, $a6, $2b, $27, $9c, $9e, $59
0DA2E                           
0DA2E 85 22 1C 14 84 1E 22 82..       .db $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
0DA3A 1C 2C 34 82 36 04 30 34..       .db $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
0DA46 2A 85 22                        .db $2a, $85, $22
0DA49                           
0DA49                           GroundM_P2AData:
0DA49 84 04 82 3A 38 36 32 04..       .db $84, $04, $82, $3a, $38, $36, $32, $04, $34
0DA52 04 24 26 2C 04 26 2C 30..       .db $04, $24, $26, $2c, $04, $26, $2c, $30, $00
0DA5B                           
0DA5B 05 B4 B2 B0 2B AC 84            .db $05, $b4, $b2, $b0, $2b, $ac, $84
0DA62 9C 9E A2 84 94 9C 9E            .db $9c, $9e, $a2, $84, $94, $9c, $9e
0DA69                           
0DA69 85 14 22 84 2C 85 1E            .db $85, $14, $22, $84, $2c, $85, $1e
0DA70 82 2C 84 2C 1E                  .db $82, $2c, $84, $2c, $1e
0DA75                           
0DA75                           GroundM_P2BData:
0DA75 84 04 82 3A 38 36 32 04..       .db $84, $04, $82, $3a, $38, $36, $32, $04, $34
0DA7E 04 64 04 64 86 64 00            .db $04, $64, $04, $64, $86, $64, $00
0DA85                           
0DA85 05 B4 B2 B0 2B AC 84            .db $05, $b4, $b2, $b0, $2b, $ac, $84
0DA8C 37 B6 B6 45                     .db $37, $b6, $b6, $45
0DA90                           
0DA90 85 14 1C 82 22 84 2C            .db $85, $14, $1c, $82, $22, $84, $2c
0DA97 4E 82 4E 84 4E 22               .db $4e, $82, $4e, $84, $4e, $22
0DA9D                           
0DA9D                           GroundM_P2CData:
0DA9D 84 04 85 32 85 30 86 2C..       .db $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
0DAA7                           
0DAA7 05 A4 05 9E 05 9D 85            .db $05, $a4, $05, $9e, $05, $9d, $85
0DAAE                                 
0DAAE 84 14 85 24 28 2C 82            .db $84, $14, $85, $24, $28, $2c, $82
0DAB5 22 84 22 14                     .db $22, $84, $22, $14
0DAB9                           
0DAB9 21 D0 C4 D0 31 D0 C4 D0..       .db $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
0DAC2                           
0DAC2                           GroundM_P3AData:
0DAC2 82 2C 84 2C 2C 82 2C 30         .db $82, $2c, $84, $2c, $2c, $82, $2c, $30
0DACA 04 34 2C 04 26 86 22 00         .db $04, $34, $2c, $04, $26, $86, $22, $00
0DAD2                           
0DAD2 A4 25 25 A4 29 A2 1D 9C..       .db $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
0DADB                           
0DADB                           GroundM_P3BData:
0DADB 82 2C 2C 04 2C 04 2C 30..       .db $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
0DAE8                           
0DAE8 A4 25 25 A4 A8 63 04            .db $a4, $25, $25, $a4, $a8, $63, $04
0DAEF                           
0DAEF                           ;triangle data used by both sections of third part
0DAEF 85 0E 1A 84 24 85 22 14..       .db $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
0DAF9                           
0DAF9                           GroundMLdInData:
0DAF9 82 34 84 34 34 82 2C 84..       .db $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
0DB06                           
0DB06 A0 21 21 A0 21 2B 05 A3         .db $a0, $21, $21, $a0, $21, $2b, $05, $a3
0DB0E                           
0DB0E 82 18 84 18 18 82 18 18..       .db $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
0DB1A                           
0DB1A                           ;noise data used by lead-in and third part sections
0DB1A 31 90 31 90 31 71 31 90..       .db $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
0DB25                           
0DB25                           GroundM_P4AData:
0DB25 82 34 84 2C 85 22 84 24         .db $82, $34, $84, $2c, $85, $22, $84, $24
0DB2D 82 26 36 04 36 86 26 00         .db $82, $26, $36, $04, $36, $86, $26, $00
0DB35                           
0DB35 AC 27 5D 1D 9E 2D AC 9F         .db $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
0DB3D                           
0DB3D 85 14 82 20 84 22 2C            .db $85, $14, $82, $20, $84, $22, $2c
0DB44 1E 1E 82 2C 2C 1E 04            .db $1e, $1e, $82, $2c, $2c, $1e, $04
0DB4B                           
0DB4B                           GroundM_P4BData:
0DB4B 87 2A 40 40 40 3A 36            .db $87, $2a, $40, $40, $40, $3a, $36 
0DB52 82 34 2C 04 26 86 22 00         .db $82, $34, $2c, $04, $26, $86, $22, $00
0DB5A                           
0DB5A E3 F7 F7 F7 F5 F1 AC 27..       .db $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
0DB64                           
0DB64 85 18 82 1E 84 22 2A            .db $85, $18, $82, $1e, $84, $22, $2a
0DB6B 22 22 82 2C 2C 22 04            .db $22, $22, $82, $2c, $2c, $22, $04
0DB72                           
0DB72                           DeathMusData:
0DB72 86 04                           .db $86, $04 ;death music share data with fourth part c of ground level music 
0DB74                           
0DB74                           GroundM_P4CData:
0DB74 82 2A 36 04 36 87 36 34..       .db $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
0DB81                                 
0DB81 00 68 6A 6C 45                  .db $00, $68, $6a, $6c, $45 ;death music only
0DB86                           
0DB86 A2 31 B0 F1 ED EB A2 1D..       .db $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
0DB90                           
0DB90 86 04                           .db $86, $04 ;death music only
0DB92                           
0DB92 85 22 82 22 87 22 26 2A..       .db $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
0DB9F                           
0DB9F                           ;noise data used by fourth part sections
0DB9F 51 90 31 11 00                  .db $51, $90, $31, $11, $00
0DBA4                           
0DBA4                           CastleMusData:
0DBA4 80 22 28 22 26 22 24 22..       .db $80, $22, $28, $22, $26, $22, $24, $22, $26
0DBAD 22 28 22 2A 22 28 22 26         .db $22, $28, $22, $2a, $22, $28, $22, $26
0DBB5 22 28 22 26 22 24 22 26         .db $22, $28, $22, $26, $22, $24, $22, $26
0DBBD 22 28 22 2A 22 28 22 26         .db $22, $28, $22, $2a, $22, $28, $22, $26
0DBC5 20 26 20 24 20 26 20 28         .db $20, $26, $20, $24, $20, $26, $20, $28
0DBCD 20 26 20 28 20 26 20 24         .db $20, $26, $20, $28, $20, $26, $20, $24
0DBD5 20 26 20 24 20 26 20 28         .db $20, $26, $20, $24, $20, $26, $20, $28
0DBDD 20 26 20 28 20 26 20 24         .db $20, $26, $20, $28, $20, $26, $20, $24
0DBE5 28 30 28 32 28 30 28 2E         .db $28, $30, $28, $32, $28, $30, $28, $2e
0DBED 28 30 28 2E 28 2C 28 2E         .db $28, $30, $28, $2e, $28, $2c, $28, $2e
0DBF5 28 30 28 32 28 30 28 2E         .db $28, $30, $28, $32, $28, $30, $28, $2e
0DBFD 28 30 28 2E 28 2C 28 2E..       .db $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
0DC06                           
0DC06 04 70 6E 6C 6E 70 72 70..       .db $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
0DC0F 70 6E 6C 6E 70 72 70 6E         .db $70, $6e, $6c, $6e, $70, $72, $70, $6e
0DC17 6E 6C 6E 70 6E 70 6E 6C         .db $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
0DC1F 6E 6C 6E 70 6E 70 6E 6C         .db $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
0DC27 76 78 76 74 76 74 72 74         .db $76, $78, $76, $74, $76, $74, $72, $74
0DC2F 76 78 76 74 76 74 72 74         .db $76, $78, $76, $74, $76, $74, $72, $74
0DC37                           
0DC37 84 1A 83 18 20 84 1E 83..       .db $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
0DC41 26 1C 1A 1C                     .db $26, $1c, $1a, $1c
0DC45                           
0DC45                           GameOverMusData:
0DC45 82 2C 04 04 22 04 04 84..       .db $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
0DC4F 26 2A 26 84 24 28 24 80..       .db $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
0DC59                           
0DC59 9C 05 94 05 0D 9F 1E 9C..       .db $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
0DC63                           
0DC63 82 22 04 04 1C 04 04 84..       .db $82, $22, $04, $04, $1c, $04, $04, $84, $14
0DC6C 86 1E 80 16 80 14               .db $86, $1e, $80, $16, $80, $14
0DC72                           
0DC72                           TimeRunOutMusData:
0DC72 81 1C 30 04 30 30 04 1E..       .db $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
0DC7E 04 20 34 04 34 34 04 36..       .db $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
0DC8A                           
0DC8A 46 A4 64 A4 48 A6 66 A6..       .db $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
0DC96 6A 44 2B                        .db $6a, $44, $2b
0DC99                           
0DC99 81 2A 42 04 42 42 04 2C..       .db $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
0DCA5 04 2E 46 04 46 46 04 22..       .db $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
0DCB0                           
0DCB0                           WinLevelMusData:
0DCB0 87 04 06 0C 14 1C 22 86..       .db $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
0DCBA 87 04 60 0E 14 1A 24 86..       .db $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
0DCC4 87 04 08 10 18 1E 28 86..       .db $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
0DCCE 80 64 00                        .db $80, $64, $00
0DCD1                           
0DCD1 CD D5 DD E3 ED F5 BB B5..       .db $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
0DCDB DB E5 ED F3 BD B3 D1 D9..       .db $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
0DCE5 F1 F7 BF FF FF FF 34            .db $f1, $f7, $bf, $ff, $ff, $ff, $34
0DCEC 00                              .db $00 ;unused byte
0DCED                           
0DCED 86 04 87 14 1C 22 86 34..       .db $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
0DCF7 04 04 04 87 14 1A 24 86..       .db $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
0DD01 2C 04 86 04 87 18 1E 28..       .db $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
0DD0B 87 30 30 30 80 2C               .db $87, $30, $30, $30, $80, $2c
0DD11                           
0DD11                           ;square 2 and triangle use the same data, square 1 is unused
0DD11                           UndergroundMusData:
0DD11 82 14 2C 62 26 10 28 80..       .db $82, $14, $2c, $62, $26, $10, $28, $80, $04
0DD1A 82 14 2C 62 26 10 28 80..       .db $82, $14, $2c, $62, $26, $10, $28, $80, $04
0DD23 82 08 1E 5E 18 60 1A 80..       .db $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
0DD2C 82 08 1E 5E 18 60 1A 86..       .db $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
0DD35 83 1A 18 16 84 14 1A 18..       .db $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
0DD3F 16 83 14 20 1E 1C 28 26..       .db $16, $83, $14, $20, $1e, $1c, $28, $26, $87
0DD48 24 1A 12 10 62 0E 80 04..       .db $24, $1a, $12, $10, $62, $0e, $80, $04, $04
0DD51 00                              .db $00
0DD52                           
0DD52                           ;noise data directly follows square 2 here unlike in other songs
0DD52                           WaterMusData:
0DD52 82 18 1C 20 22 26 28            .db $82, $18, $1c, $20, $22, $26, $28 
0DD59 81 2A 2A 2A 04 2A 04 83..       .db $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
0DD64 86 34 32 34 81 04 22 26..       .db $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
0DD6F 86 34 83 32 82 36 84 34..       .db $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
0DD7B 86 30 2E 30 81 04 22 26..       .db $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
0DD86 86 30 83 22 82 36 84 34..       .db $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
0DD92 86 3A 3A 3A 82 3A 81 40..       .db $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
0DD9E 86 36 36 36 82 36 81 3A..       .db $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
0DDAA 86 34 82 26 2A 36               .db $86, $34, $82, $26, $2a, $36
0DDB0 81 34 34 85 34 81 2A 86..       .db $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
0DDBA                           
0DDBA 84 90 B0 84 50 50 B0 00         .db $84, $90, $b0, $84, $50, $50, $b0, $00
0DDC2                           
0DDC2 98 96 94 92 94 96 58 58..       .db $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
0DDCC 5C 44 9F A3 A1 A3 85 A3..       .db $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
0DDD6 23 C4 9F 9D 9F 85 9F D2..       .db $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
0DDE0 C4 B5 B1 AF 85 B1 AF AD..       .db $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
0DDEA 9E A2 AA 6A 6A 6B 5E 9D         .db $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
0DDF2                           
0DDF2 84 04 04 82 22 86 22            .db $84, $04, $04, $82, $22, $86, $22
0DDF9 82 14 22 2C 12 22 2A 14..       .db $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
0DE03 1C 22 2C 14 22 2C 12 22..       .db $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
0DE0D 22 2C 1C 22 2C 18 22 2A..       .db $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
0DE17 28 18 22 2A 12 22 2A 18..       .db $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
0DE21 12 22 2A 14 22 2C 0C 22..       .db $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
0DE2E 22 30 10 22 2E 16 22 34..       .db $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
0DE38 36 16 26 36 14 26 36 12..       .db $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
0DE42 5C 22 34 0C 22 22 81 1E..       .db $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
0DE4D 81 12 86 14                     .db $81, $12, $86, $14
0DE51                           
0DE51                           EndOfCastleMusData:
0DE51 81 2C 22 1C 2C 22 1C 85..       .db $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
0DE5B 81 2E 24 1E 2E 24 1E 85..       .db $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
0DE65 81 32 28 22 32 28 22 85..       .db $81, $32, $28, $22, $32, $28, $22, $85, $32
0DE6E 87 36 36 36 84 3A 00            .db $87, $36, $36, $36, $84, $3a, $00
0DE75                           
0DE75 5C 54 4C 5C 54 4C               .db $5c, $54, $4c, $5c, $54, $4c
0DE7B 5C 1C 1C 5C 5C 5C 5C            .db $5c, $1c, $1c, $5c, $5c, $5c, $5c
0DE82 5E 56 4E 5E 56 4E               .db $5e, $56, $4e, $5e, $56, $4e
0DE88 5E 1E 1E 5E 5E 5E 5E            .db $5e, $1e, $1e, $5e, $5e, $5e, $5e
0DE8F 62 5A 50 62 5A 50               .db $62, $5a, $50, $62, $5a, $50
0DE95 62 22 22 62 E7 E7 E7 2B         .db $62, $22, $22, $62, $e7, $e7, $e7, $2b
0DE9D                           
0DE9D 86 14 81 14 80 14 14 81..       .db $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
0DEA9 86 16 81 16 80 16 16 81..       .db $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
0DEB5 81 28 22 1A 28 22 1A 28..       .db $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
0DEC0 81 28 87 2C 2C 2C 84 30         .db $81, $28, $87, $2c, $2c, $2c, $84, $30
0DEC8                           
0DEC8                           VictoryMusData:
0DEC8 83 04 84 0C 83 62 10 84..       .db $83, $04, $84, $0c, $83, $62, $10, $84, $12
0DED1 83 1C 22 1E 22 26 18 1E..       .db $83, $1c, $22, $1e, $22, $26, $18, $1e, $04, $1c, $00
0DEDC                           
0DEDC E3 E1 E3 1D DE E0 23            .db $e3, $e1, $e3, $1d, $de, $e0, $23
0DEE3 EC 75 74 F0 F4 F6 EA 31..       .db $ec, $75, $74, $f0, $f4, $f6, $ea, $31, $2d
0DEEC                           
0DEEC 83 12 14 04 18 1A 1C 14         .db $83, $12, $14, $04, $18, $1a, $1c, $14
0DEF4 26 22 1E 1C 18 1E 22 0C..       .db $26, $22, $1e, $1c, $18, $1e, $22, $0c, $14
0DEFD                           
0DEFD                           ;unused space
0DEFD FF FF FF                        .db $ff, $ff, $ff
0DF00                           
0DF00                           FreqRegLookupTbl:
0DF00 00 88 00 2F 00 00               .db $00, $88, $00, $2f, $00, $00
0DF06 02 A6 02 80 02 5C 02 3A         .db $02, $a6, $02, $80, $02, $5c, $02, $3a
0DF0E 02 1A 01 DF 01 C4 01 AB         .db $02, $1a, $01, $df, $01, $c4, $01, $ab
0DF16 01 93 01 7C 01 67 01 53         .db $01, $93, $01, $7c, $01, $67, $01, $53
0DF1E 01 40 01 2E 01 1D 01 0D         .db $01, $40, $01, $2e, $01, $1d, $01, $0d
0DF26 00 FE 00 EF 00 E2 00 D5         .db $00, $fe, $00, $ef, $00, $e2, $00, $d5
0DF2E 00 C9 00 BE 00 B3 00 A9         .db $00, $c9, $00, $be, $00, $b3, $00, $a9
0DF36 00 A0 00 97 00 8E 00 86         .db $00, $a0, $00, $97, $00, $8e, $00, $86
0DF3E 00 77 00 7E 00 71 00 54         .db $00, $77, $00, $7e, $00, $71, $00, $54
0DF46 00 64 00 5F 00 59 00 50         .db $00, $64, $00, $5f, $00, $59, $00, $50
0DF4E 00 47 00 43 00 3B 00 35         .db $00, $47, $00, $43, $00, $3b, $00, $35
0DF56 00 2A 00 23 04 75 03 57         .db $00, $2a, $00, $23, $04, $75, $03, $57
0DF5E 02 F9 02 CF 01 FC 00 6A         .db $02, $f9, $02, $cf, $01, $fc, $00, $6a
0DF66                           
0DF66                           MusicLengthLookupTbl:
0DF66 05 0A 14 28 50 1E 3C 02         .db $05, $0a, $14, $28, $50, $1e, $3c, $02
0DF6E 04 08 10 20 40 18 30 0C         .db $04, $08, $10, $20, $40, $18, $30, $0c
0DF76 03 06 0C 18 30 12 24 08         .db $03, $06, $0c, $18, $30, $12, $24, $08
0DF7E 36 03 09 06 12 1B 24 0C         .db $36, $03, $09, $06, $12, $1b, $24, $0c
0DF86 24 02 06 04 0C 12 18 08         .db $24, $02, $06, $04, $0c, $12, $18, $08
0DF8E 12 01 03 02 06 09 0C 04         .db $12, $01, $03, $02, $06, $09, $0c, $04
0DF96                           
0DF96                           EndOfCastleMusicEnvData:
0DF96 98 99 9A 9B                     .db $98, $99, $9a, $9b
0DF9A                           
0DF9A                           AreaMusicEnvData:
0DF9A 90 94 94 95 95 96 97 98         .db $90, $94, $94, $95, $95, $96, $97, $98
0DFA2                           
0DFA2                           WaterEventMusEnvData:
0DFA2 90 91 92 92 93 93 93 94         .db $90, $91, $92, $92, $93, $93, $93, $94
0DFAA 94 94 94 94 94 95 95 95         .db $94, $94, $94, $94, $94, $95, $95, $95
0DFB2 95 95 95 96 96 96 96 96         .db $95, $95, $95, $96, $96, $96, $96, $96
0DFBA 96 96 96 96 96 96 96 96         .db $96, $96, $96, $96, $96, $96, $96, $96
0DFC2 96 96 96 96 95 95 94 93         .db $96, $96, $96, $96, $95, $95, $94, $93
0DFCA                           
0DFCA                           BowserFlameEnvData:
0DFCA 15 16 16 17 17 18 19 19         .db $15, $16, $16, $17, $17, $18, $19, $19
0DFD2 1A 1A 1C 1D 1D 1E 1E 1F         .db $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
0DFDA 1F 1F 1F 1E 1D 1C 1E 1F         .db $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
0DFE2 1F 1E 1D 1C 1A 18 16 14         .db $1f, $1e, $1d, $1c, $1a, $18, $16, $14
0DFEA                           
0DFEA                           BrickShatterEnvData:
0DFEA 15 16 16 17 17 18 19 19         .db $15, $16, $16, $17, $17, $18, $19, $19
0DFF2 1A 1A 1C 1D 1D 1E 1E 1F         .db $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
0DFFA                           
0DFFA                           ;-------------------------------------------------------------------------------------
0DFFA                           ;INTERRUPT VECTORS
0DFFA                           
0DFFA                           .org $dffa
0DFFA                           
0DFFA                           ;"VECTORS"
0DFFA 87 60                           .dw NonMaskableInterrupt
0DFFC 00 60                           .dw Start
0DFFE F0 FF                           .dw $fff0  ;unused
0E000                           
