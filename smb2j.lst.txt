ca65 V2.18 - N/A
Main file   : fdswrap.asm
Current file: fdswrap.asm

000000r 1               ;This file takes the assembled binaries of the program files and puts
000000r 1               ;them into an FDS file along with the character files that are needed.
000000r 1               ;In order for this to work, the program files need to already be assembled
000000r 1               ;and the character files from the disk or disk image are also needed.
000000r 1               
000000r 1               DiskInfoBlock     = 1
000000r 1               FileAmountBlock   = 2
000000r 1               FileHeaderBlock   = 3
000000r 1               FileDataBlock     = 4
000000r 1               PRG = 0
000000r 1               CHR = 1
000000r 1               VRAM = 2
000000r 1               
000000r 1               ;FWNES header
000000r 1               ;.byte "FDS",$1a,1,0,0,0,0,0,0,0,0,0,0,0
000000r 1               
000000r 1  01           .byte DiskInfoBlock
000001r 1  2A 4E 49 4E  .byte "*NINTENDO-HVC*"
000005r 1  54 45 4E 44  
000009r 1  4F 2D 48 56  
00000Fr 1  01 53 4D 42  .byte $01,"SMB ",0,0,0,0,0,$0f
000013r 1  20 00 00 00  
000017r 1  00 00 0F     
00001Ar 1  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff
00001Er 1  FF           
00001Fr 1  61 07 23     .byte $61,$07,$23
000022r 1  49 61 00 00  .byte $49,$61,$00,$00,$02,$00,$1b,$00,$97,$00
000026r 1  02 00 1B 00  
00002Ar 1  97 00        
00002Cr 1  61 07 23     .byte $61,$07,$23
00002Fr 1  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$00,$00,$00,$00
000033r 1  FF 00 00 00  
000037r 1  00           
000038r 1               
000038r 1  02           .byte FileAmountBlock
000039r 1  08           .byte 8
00003Ar 1               
00003Ar 1  03           .byte FileHeaderBlock
00003Br 1  00 00        .byte $00,$00
00003Dr 1  4B 59 4F 44  .byte "KYODAKU-"
000041r 1  41 4B 55 2D  
000045r 1  00 28        .word $2800
000047r 1  E0 00        .word KyodakuEnd-KyodakuStart
000049r 1  02           .byte VRAM
00004Ar 1               
00004Ar 1  04           .byte FileDataBlock
00004Br 1               KyodakuStart:
00004Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$17,$12,$17,$1d,$0e
00004Fr 1  24 24 24 24  
000053r 1  24 24 24 17  
00005Br 1  17 0D 18 24  .byte $17,$0d,$18,$24,$28,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00005Fr 1  28 24 24 24  
000063r 1  24 24 24 24  
00006Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$0f,$0a,$16,$12,$15,$22,$24,$0c,$18
00006Fr 1  24 24 24 0F  
000073r 1  0A 16 12 15  
00007Br 1  16 19 1E 1D  .byte $16,$19,$1e,$1d,$0e,$1b,$24,$1d,$16,$24,$24,$24,$24,$24,$24,$24
00007Fr 1  0E 1B 24 1D  
000083r 1  16 24 24 24  
00008Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00008Fr 1  24 24 24 24  
000093r 1  24 24 24 24  
00009Br 1  24 24 24 24  .byte $24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24
00009Fr 1  24 24 24 24  
0000A3r 1  24 24 24 24  
0000ABr 1  24 24 1D 11  .byte $24,$24,$1d,$11,$12,$1c,$24,$19,$1b,$18,$0d,$1e,$0c,$1d,$24,$12
0000AFr 1  12 1C 24 19  
0000B3r 1  1B 18 0D 1E  
0000BBr 1  1C 24 16 0A  .byte $1c,$24,$16,$0a,$17,$1e,$0f,$0a,$0c,$1d,$1e,$1b,$0e,$0d,$24,$24
0000BFr 1  17 1E 0F 0A  
0000C3r 1  0C 1D 1E 1B  
0000CBr 1  24 24 0A 17  .byte $24,$24,$0a,$17,$0d,$24,$1c,$18,$15,$0d,$24,$0b,$22,$24,$17,$12
0000CFr 1  0D 24 1C 18  
0000D3r 1  15 0D 24 0B  
0000DBr 1  17 1D 0E 17  .byte $17,$1d,$0e,$17,$0d,$18,$24,$0c,$18,$27,$15,$1d,$0d,$26,$24,$24
0000DFr 1  0D 18 24 0C  
0000E3r 1  18 27 15 1D  
0000EBr 1  24 24 18 1B  .byte $24,$24,$18,$1b,$24,$0b,$22,$24,$18,$1d,$11,$0e,$1b,$24,$0c,$18
0000EFr 1  24 0B 22 24  
0000F3r 1  18 1D 11 0E  
0000FBr 1  16 19 0A 17  .byte $16,$19,$0a,$17,$22,$24,$1e,$17,$0d,$0e,$1b,$24,$24,$24,$24,$24
0000FFr 1  22 24 1E 17  
000103r 1  0D 0E 1B 24  
00010Br 1  24 24 15 12  .byte $24,$24,$15,$12,$0c,$0e,$17,$1c,$0e,$24,$18,$0f,$24,$17,$12,$17
00010Fr 1  0C 0E 17 1C  
000113r 1  0E 24 18 0F  
00011Br 1  1D 0E 17 0D  .byte $1d,$0e,$17,$0d,$18,$24,$0c,$18,$27,$15,$1d,$0d,$26,$26,$24,$24
00011Fr 1  18 24 0C 18  
000123r 1  27 15 1D 0D  
00012Br 1               KyodakuEnd:
00012Br 1               
00012Br 1  03           .byte FileHeaderBlock
00012Cr 1  01 01        .byte $01,$01
00012Er 1  53 4D 32 43  .byte "SM2CHAR1"
000132r 1  48 41 52 31  
000136r 1  00 00        .word $0000
000138r 1  00 20        .word Char1End-Char1Start
00013Ar 1  01 04        .byte CHR,FileDataBlock
00013Cr 1               Char1Start:
00013Cr 1  03 0F 1F 1F  .incbin "SM2CHAR1.CHR"
000140r 1  1C 24 26 66  
000144r 1  00 00 00 00  
00213Cr 1               Char1End:
00213Cr 1               
00213Cr 1  03           .byte FileHeaderBlock
00213Dr 1  02 10        .byte $02,$10
00213Fr 1  53 4D 32 43  .byte "SM2CHAR2"
002143r 1  48 41 52 32  
002147r 1  60 07        .word $0760
002149r 1  40 00        .word Char2End-Char2Start
00214Br 1  01 04        .byte CHR,FileDataBlock
00214Dr 1               Char2Start:
00214Dr 1  05 07 07 0F  .incbin "SM2CHAR2.CHR"
002151r 1  1F 1F 3D 3D  
002155r 1  05 07 07 00  
00218Dr 1               Char2End:
00218Dr 1               
00218Dr 1  03 03 05     .byte FileHeaderBlock,$03,$05
002190r 1  53 4D 32 4D  .byte "SM2MAIN "
002194r 1  41 49 4E 20  
002198r 1  00 60 00 80  .word $6000, MainEnd-MainStart
00219Cr 1  00 04        .byte PRG, FileDataBlock
00219Er 1               MainStart:
00219Er 1               .scope FILE_SM2MAIN
00219Er 1               .org $6000
006000  1               .include "sm2main.asm"
006000  2               ;SMB2J DISASSEMBLY (SM2MAIN portion)
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               ;DEFINES
006000  2               
006000  2               ;NES specific hardware defines
006000  2               
006000  2               PPU_CTRL              = $2000
006000  2               PPU_MASK              = $2001
006000  2               PPU_STATUS            = $2002
006000  2               PPU_SPR_ADDR          = $2003
006000  2               PPU_SPR_DATA          = $2004
006000  2               PPU_SCROLL            = $2005
006000  2               PPU_ADDRESS           = $2006
006000  2               PPU_DATA              = $2007
006000  2               
006000  2               SND_REGISTER          = $4000
006000  2               SND_SQUARE1_REG       = $4000
006000  2               SND_SQUARE2_REG       = $4004
006000  2               SND_TRIANGLE_REG      = $4008
006000  2               SND_NOISE_REG         = $400c
006000  2               SND_DELTA_REG         = $4010
006000  2               SND_MASTERCTRL_REG    = $4015
006000  2               
006000  2               SPR_DMA               = $4014
006000  2               JOYPAD_PORT           = $4016
006000  2               JOYPAD_PORT1          = $4016
006000  2               JOYPAD_PORT2          = $4017
006000  2               
006000  2               FDS_IRQTIMER_LOW      = $4020
006000  2               FDS_IRQTIMER_HIGH     = $4021
006000  2               FDS_IRQTIMER_CTRL     = $4022
006000  2               FDS_CTRL_REG          = $4025
006000  2               FDS_STATUS            = $4030
006000  2               FDS_DRIVE_STATUS      = $4032
006000  2               
006000  2               ; GAME SPECIFIC DEFINES
006000  2               
006000  2               ObjectOffset          = $08
006000  2               
006000  2               FrameCounter          = $09
006000  2               
006000  2               SavedJoypadBits       = $06fc
006000  2               SavedJoypad1Bits      = $06fc
006000  2               SavedJoypad2Bits      = $06fd
006000  2               JoypadBitMask         = $074a
006000  2               JoypadOverride        = $0758
006000  2               
006000  2               A_B_Buttons           = $0a
006000  2               PreviousA_B_Buttons   = $0d
006000  2               Up_Down_Buttons       = $0b
006000  2               Left_Right_Buttons    = $0c
006000  2               
006000  2               GameEngineSubroutine  = $0e
006000  2               
006000  2               Mirror_PPU_CTRL       = $0778
006000  2               Mirror_PPU_MASK       = $0779
006000  2               Mirror_FDS_CTRL_REG   = $fa
006000  2               NameTableSelect       = $077a
006000  2               FileListNumber        = $07f7
006000  2               
006000  2               OperMode              = $0770
006000  2               OperMode_Task         = $0772
006000  2               ScreenRoutineTask     = $073c
006000  2               
006000  2               FDSBIOS_IRQFlag       = $0101
006000  2               IRQUpdateFlag         = $0722
006000  2               IRQAckFlag            = $077b
006000  2               DiskIOTask            = $07fc
006000  2               NotColdFlag           = $07fd
006000  2               
006000  2               GamePauseStatus       = $0776
006000  2               GamePauseTimer        = $0777
006000  2               
006000  2               DemoAction            = $0717
006000  2               DemoActionTimer       = $0718
006000  2               
006000  2               TimerControl          = $0747
006000  2               IntervalTimerControl  = $077f
006000  2               
006000  2               Timers                = $0780
006000  2               SelectTimer           = $0780
006000  2               PlayerAnimTimer       = $0781
006000  2               JumpSwimTimer         = $0782
006000  2               RunningTimer          = $0783
006000  2               BlockBounceTimer      = $0784
006000  2               SideCollisionTimer    = $0785
006000  2               JumpspringTimer       = $0786
006000  2               GameTimerCtrlTimer    = $0787
006000  2               ClimbSideTimer        = $0789
006000  2               EnemyFrameTimer       = $078a
006000  2               FrenzyEnemyTimer      = $078f
006000  2               BowserFireBreathTimer = $0790
006000  2               StompTimer            = $0791
006000  2               AirBubbleTimer        = $0792
006000  2               ScrollIntervalTimer   = $0795
006000  2               EnemyIntervalTimer    = $0796
006000  2               BrickCoinTimer        = $079d
006000  2               InjuryTimer           = $079e
006000  2               StarInvincibleTimer   = $079f
006000  2               ScreenTimer           = $07a0
006000  2               WorldEndTimer         = $07a1
006000  2               DemoTimer             = $07a2
006000  2               
006000  2               Sprite_Data           = $0200
006000  2               
006000  2               Sprite_Y_Position     = $0200
006000  2               Sprite_Tilenumber     = $0201
006000  2               Sprite_Attributes     = $0202
006000  2               Sprite_X_Position     = $0203
006000  2               
006000  2               ScreenEdge_PageLoc    = $071a
006000  2               ScreenEdge_X_Pos      = $071c
006000  2               ScreenLeft_PageLoc    = $071a
006000  2               ScreenRight_PageLoc   = $071b
006000  2               ScreenLeft_X_Pos      = $071c
006000  2               ScreenRight_X_Pos     = $071d
006000  2               
006000  2               PlayerFacingDir       = $33
006000  2               DestinationPageLoc    = $34
006000  2               VictoryWalkControl    = $35
006000  2               ScrollFractional      = $0768
006000  2               SecondaryMsgCounter   = $0749
006000  2               MsgCounter            = $0719
006000  2               MsgFractional         = $0749
006000  2               
006000  2               HorizontalScroll      = $073f
006000  2               VerticalScroll        = $0740
006000  2               ScrollLock            = $0723
006000  2               ScrollThirtyTwo       = $073d
006000  2               Player_X_Scroll       = $06ff
006000  2               Player_Pos_ForScroll  = $0755
006000  2               ScrollAmount          = $0775
006000  2               
006000  2               AreaData              = $e7
006000  2               AreaDataLow           = $e7
006000  2               AreaDataHigh          = $e8
006000  2               EnemyData             = $e9
006000  2               EnemyDataLow          = $e9
006000  2               EnemyDataHigh         = $ea
006000  2               
006000  2               AreaParserTaskNum     = $071f
006000  2               ColumnSets            = $071e
006000  2               CurrentPageLoc        = $0725
006000  2               CurrentColumnPos      = $0726
006000  2               BackloadingFlag       = $0728
006000  2               BehindAreaParserFlag  = $0729
006000  2               AreaObjectPageLoc     = $072a
006000  2               AreaObjectPageSel     = $072b
006000  2               AreaDataOffset        = $072c
006000  2               AreaObjOffsetBuffer   = $072d
006000  2               AreaObjectLength      = $0730
006000  2               StaircaseControl      = $0734
006000  2               AreaObjectHeight      = $0735
006000  2               MushroomLedgeHalfLen  = $0736
006000  2               EnemyDataOffset       = $0739
006000  2               EnemyObjectPageLoc    = $073a
006000  2               EnemyObjectPageSel    = $073b
006000  2               MetatileBuffer        = $06a1
006000  2               BlockBufferColumnPos  = $06a0
006000  2               CurrentNTAddr_Low     = $0721
006000  2               CurrentNTAddr_High    = $0720
006000  2               AttributeBuffer       = $03f9
006000  2               
006000  2               LoopCommand           = $0745
006000  2               
006000  2               DisplayDigits         = $07d7
006000  2               TopScoreDisplay       = $07d7
006000  2               ScoreAndCoinDisplay   = $07dd
006000  2               PlayerScoreDisplay    = $07dd
006000  2               GameTimerDisplay      = $07ec
006000  2               CoinDisplay           = $07e7
006000  2               DigitModifier         = $0134
006000  2               
006000  2               VerticalFlipFlag      = $0109
006000  2               FloateyNum_Control    = $0110
006000  2               ShellChainCounter     = $0125
006000  2               FloateyNum_Timer      = $012c
006000  2               FloateyNum_X_Pos      = $0117
006000  2               FloateyNum_Y_Pos      = $011e
006000  2               FlagpoleFNum_Y_Pos    = $010d
006000  2               FlagpoleFNum_YMFDummy = $010e
006000  2               FlagpoleScore         = $010f
006000  2               FlagpoleCollisionYPos = $070f
006000  2               StompChainCounter     = $0484
006000  2               FlagpoleMusicFlag     = $07f6
006000  2               
006000  2               VRAM_Buffer1_Offset   = $0300
006000  2               VRAM_Buffer1          = $0301
006000  2               VRAM_Buffer2_Offset   = $0340
006000  2               VRAM_Buffer2          = $0341
006000  2               VRAM_Buffer_AddrCtrl  = $0773
006000  2               
006000  2               DisableScreenFlag     = $0774
006000  2               DisableIntermediate   = $0769
006000  2               ColorRotateOffset     = $06d4
006000  2               
006000  2               TerrainControl        = $0727
006000  2               AreaStyle             = $0733
006000  2               ForegroundScenery     = $0741
006000  2               BackgroundScenery     = $0742
006000  2               CloudTypeOverride     = $0743
006000  2               BackgroundColorCtrl   = $0744
006000  2               AreaType              = $074e
006000  2               AreaAddrsLOffset      = $074f
006000  2               AreaPointer           = $0750
006000  2               
006000  2               PlayerEntranceCtrl    = $0710
006000  2               GameTimerSetting      = $0715
006000  2               AltEntranceControl    = $0752
006000  2               EntrancePage          = $0751
006000  2               WarpZoneControl       = $06d6
006000  2               ChangeAreaTimer       = $06de
006000  2               
006000  2               MultiLoopCorrectCntr  = $06d9
006000  2               MultiLoopPassCntr     = $06da
006000  2               
006000  2               FetchNewGameTimerFlag = $0757
006000  2               GameTimerExpiredFlag  = $0759
006000  2               
006000  2               PrimaryHardMode       = $076a
006000  2               SecondaryHardMode     = $06cc
006000  2               WorldSelectNumber     = $076b
006000  2               CompletedWorlds       = $07fa
006000  2               HardWorldFlag         = $07fb
006000  2               ContinueMenuSelect    = $07f8
006000  2               
006000  2               SelectedPlayer        = $0753
006000  2               PlayerSize            = $0754
006000  2               PlayerStatus          = $0756
006000  2               
006000  2               OnscreenPlayerInfo    = $075a
006000  2               NumberofLives         = $075a ;used by current player
006000  2               HalfwayPage           = $075b
006000  2               LevelNumber           = $075c ;the actual dash number
006000  2               Hidden1UpFlag         = $075d
006000  2               CoinTally             = $075e
006000  2               WorldNumber           = $075f
006000  2               AreaNumber            = $0760 ;internal number used to find areas
006000  2               
006000  2               CoinTallyFor1Ups      = $0748
006000  2               
006000  2               BalPlatformAlignment  = $03a0
006000  2               Platform_X_Scroll     = $03a1
006000  2               PlatformCollisionFlag = $03a2
006000  2               YPlatformTopYPos      = $0401
006000  2               YPlatformCenterYPos   = $58
006000  2               
006000  2               BrickCoinTimerFlag    = $06bc
006000  2               StarFlagTaskControl   = $0746
006000  2               
006000  2               PseudoRandomBitReg    = $07a7
006000  2               WarmBootValidation    = $07ff
006000  2               
006000  2               SprShuffleAmtOffset   = $06e0
006000  2               SprShuffleAmt         = $06e1
006000  2               SprDataOffset         = $06e4
006000  2               Player_SprDataOffset  = $06e4
006000  2               Enemy_SprDataOffset   = $06e5
006000  2               Block_SprDataOffset   = $06ec
006000  2               Alt_SprDataOffset     = $06ec
006000  2               Bubble_SprDataOffset  = $06ee
006000  2               FBall_SprDataOffset   = $06f1
006000  2               Misc_SprDataOffset    = $06f3
006000  2               SprDataOffset_Ctrl    = $03ee
006000  2               
006000  2               Player_State          = $1d
006000  2               Enemy_State           = $1e
006000  2               Fireball_State        = $24
006000  2               Block_State           = $26
006000  2               Misc_State            = $2a
006000  2               
006000  2               Player_MovingDir      = $45
006000  2               Enemy_MovingDir       = $46
006000  2               
006000  2               SprObject_X_Speed     = $57
006000  2               Player_X_Speed        = $57
006000  2               Enemy_X_Speed         = $58
006000  2               Fireball_X_Speed      = $5e
006000  2               Block_X_Speed         = $60
006000  2               Misc_X_Speed          = $64
006000  2               
006000  2               Jumpspring_FixedYPos  = $58
006000  2               JumpspringAnimCtrl    = $070e
006000  2               JumpspringForce       = $06db
006000  2               
006000  2               SprObject_PageLoc     = $6d
006000  2               Player_PageLoc        = $6d
006000  2               Enemy_PageLoc         = $6e
006000  2               Fireball_PageLoc      = $74
006000  2               Block_PageLoc         = $76
006000  2               Misc_PageLoc          = $7a
006000  2               Bubble_PageLoc        = $83
006000  2               
006000  2               SprObject_X_Position  = $86
006000  2               Player_X_Position     = $86
006000  2               Enemy_X_Position      = $87
006000  2               Fireball_X_Position   = $8d
006000  2               Block_X_Position      = $8f
006000  2               Misc_X_Position       = $93
006000  2               Bubble_X_Position     = $9c
006000  2               
006000  2               SprObject_Y_Speed     = $9f
006000  2               Player_Y_Speed        = $9f
006000  2               Enemy_Y_Speed         = $a0
006000  2               Fireball_Y_Speed      = $a6
006000  2               Block_Y_Speed         = $a8
006000  2               Misc_Y_Speed          = $ac
006000  2               
006000  2               SprObject_Y_HighPos   = $b5
006000  2               Player_Y_HighPos      = $b5
006000  2               Enemy_Y_HighPos       = $b6
006000  2               Fireball_Y_HighPos    = $bc
006000  2               Block_Y_HighPos       = $be
006000  2               Misc_Y_HighPos        = $c2
006000  2               Bubble_Y_HighPos      = $cb
006000  2               
006000  2               SprObject_Y_Position  = $ce
006000  2               Player_Y_Position     = $ce
006000  2               Enemy_Y_Position      = $cf
006000  2               Fireball_Y_Position   = $d5
006000  2               Block_Y_Position      = $d7
006000  2               Misc_Y_Position       = $db
006000  2               Bubble_Y_Position     = $e4
006000  2               
006000  2               SprObject_Rel_XPos    = $03ad
006000  2               Player_Rel_XPos       = $03ad
006000  2               Enemy_Rel_XPos        = $03ae
006000  2               Fireball_Rel_XPos     = $03af
006000  2               Bubble_Rel_XPos       = $03b0
006000  2               Block_Rel_XPos        = $03b1
006000  2               Misc_Rel_XPos         = $03b3
006000  2               
006000  2               SprObject_Rel_YPos    = $03b8
006000  2               Player_Rel_YPos       = $03b8
006000  2               Enemy_Rel_YPos        = $03b9
006000  2               Fireball_Rel_YPos     = $03ba
006000  2               Bubble_Rel_YPos       = $03bb
006000  2               Block_Rel_YPos        = $03bc
006000  2               Misc_Rel_YPos         = $03be
006000  2               
006000  2               SprObject_SprAttrib   = $03c4
006000  2               Player_SprAttrib      = $03c4
006000  2               Enemy_SprAttrib       = $03c5
006000  2               
006000  2               SprObject_X_MoveForce = $0400
006000  2               Enemy_X_MoveForce     = $0401
006000  2               
006000  2               SprObject_YMF_Dummy   = $0416
006000  2               Player_YMF_Dummy      = $0416
006000  2               Enemy_YMF_Dummy       = $0417
006000  2               Bubble_YMF_Dummy      = $042c
006000  2               
006000  2               SprObject_Y_MoveForce = $0433
006000  2               Player_Y_MoveForce    = $0433
006000  2               Enemy_Y_MoveForce     = $0434
006000  2               Block_Y_MoveForce     = $043c
006000  2               
006000  2               DisableCollisionDet   = $0716
006000  2               Player_CollisionBits  = $0490
006000  2               Enemy_CollisionBits   = $0491
006000  2               
006000  2               SprObj_BoundBoxCtrl   = $0499
006000  2               Player_BoundBoxCtrl   = $0499
006000  2               Enemy_BoundBoxCtrl    = $049a
006000  2               Fireball_BoundBoxCtrl = $04a0
006000  2               Misc_BoundBoxCtrl     = $04a2
006000  2               
006000  2               EnemyFrenzyBuffer     = $06cb
006000  2               EnemyFrenzyQueue      = $06cd
006000  2               Enemy_Flag            = $0f
006000  2               Enemy_ID              = $16
006000  2               
006000  2               PlayerGfxOffset       = $06d5
006000  2               Player_XSpeedAbsolute = $0700
006000  2               FrictionAdderHigh     = $0701
006000  2               FrictionAdderLow      = $0702
006000  2               RunningSpeed          = $0703
006000  2               SwimmingFlag          = $0704
006000  2               Player_X_MoveForce    = $0705
006000  2               DiffToHaltJump        = $0706
006000  2               JumpOrigin_Y_HighPos  = $0707
006000  2               JumpOrigin_Y_Position = $0708
006000  2               VerticalForce         = $0709
006000  2               VerticalForceDown     = $070a
006000  2               PlayerChangeSizeFlag  = $070b
006000  2               PlayerAnimTimerSet    = $070c
006000  2               PlayerAnimCtrl        = $070d
006000  2               DeathMusicLoaded      = $0712
006000  2               FlagpoleSoundQueue    = $0713
006000  2               CrouchingFlag         = $0714
006000  2               MaximumLeftSpeed      = $0450
006000  2               MaximumRightSpeed     = $0456
006000  2               
006000  2               WindFlag              = $07f9
006000  2               
006000  2               SprObject_OffscrBits  = $03d0
006000  2               Player_OffscreenBits  = $03d0
006000  2               Enemy_OffscreenBits   = $03d1
006000  2               FBall_OffscreenBits   = $03d2
006000  2               Bubble_OffscreenBits  = $03d3
006000  2               Block_OffscreenBits   = $03d4
006000  2               Misc_OffscreenBits    = $03d6
006000  2               EnemyOffscrBitsMasked = $03d8
006000  2               
006000  2               Cannon_Offset         = $046a
006000  2               Cannon_PageLoc        = $046b
006000  2               Cannon_X_Position     = $0471
006000  2               Cannon_Y_Position     = $0477
006000  2               Cannon_Timer          = $047d
006000  2               
006000  2               Whirlpool_Offset      = $046a
006000  2               Whirlpool_PageLoc     = $046b
006000  2               Whirlpool_LeftExtent  = $0471
006000  2               Whirlpool_Length      = $0477
006000  2               Whirlpool_Flag        = $047d
006000  2               
006000  2               VineFlagOffset        = $0398
006000  2               VineHeight            = $0399
006000  2               VineObjOffset         = $039a
006000  2               VineStart_Y_Position  = $039d
006000  2               
006000  2               Block_Orig_YPos       = $03e4
006000  2               Block_BBuf_Low        = $03e6
006000  2               Block_Metatile        = $03e8
006000  2               Block_PageLoc2        = $03ea
006000  2               Block_RepFlag         = $03ec
006000  2               Block_ResidualCounter = $03f0
006000  2               Block_Orig_XPos       = $03f1
006000  2               
006000  2               BoundingBox_UL_XPos   = $04ac
006000  2               BoundingBox_UL_YPos   = $04ad
006000  2               BoundingBox_DR_XPos   = $04ae
006000  2               BoundingBox_DR_YPos   = $04af
006000  2               BoundingBox_UL_Corner = $04ac
006000  2               BoundingBox_LR_Corner = $04ae
006000  2               EnemyBoundingBoxCoord = $04b0
006000  2               
006000  2               PowerUpType           = $39
006000  2               
006000  2               FireballBouncingFlag  = $3a
006000  2               FireballCounter       = $06ce
006000  2               FireballThrowingTimer = $0711
006000  2               
006000  2               HammerEnemyOffset     = $06ae
006000  2               JumpCoinMiscOffset    = $06b7
006000  2               
006000  2               Block_Buffer_1        = $0500
006000  2               Block_Buffer_2        = $05d0
006000  2               
006000  2               HammerThrowingTimer   = $03a2
006000  2               HammerBroJumpTimer    = $3c
006000  2               Misc_Collision_Flag   = $06be
006000  2               
006000  2               RedPTroopaOrigXPos    = $0401
006000  2               RedPTroopaCenterYPos  = $58
006000  2               
006000  2               XMovePrimaryCounter   = $a0
006000  2               XMoveSecondaryCounter = $58
006000  2               
006000  2               CheepCheepMoveMFlag   = $58
006000  2               CheepCheepOrigYPos    = $0434
006000  2               BitMFilter            = $06dd
006000  2               
006000  2               LakituReappearTimer   = $06d1
006000  2               LakituMoveSpeed       = $58
006000  2               LakituMoveDirection   = $a0
006000  2               
006000  2               FirebarSpinState_Low  = $58
006000  2               FirebarSpinState_High = $a0
006000  2               FirebarSpinSpeed      = $0388
006000  2               FirebarSpinDirection  = $34
006000  2               
006000  2               DuplicateObj_Offset   = $06cf
006000  2               NumberofGroupEnemies  = $06d3
006000  2               
006000  2               BlooperMoveCounter    = $a0
006000  2               BlooperMoveSpeed      = $58
006000  2               
006000  2               BowserBodyControls    = $0363
006000  2               BowserFeetCounter     = $0364
006000  2               BowserMovementSpeed   = $0365
006000  2               BowserOrigXPos        = $0366
006000  2               BowserFlameTimerCtrl  = $0367
006000  2               BowserFront_Offset    = $0368
006000  2               BridgeCollapseOffset  = $0369
006000  2               BowserGfxFlag         = $036a
006000  2               BowserHitPoints       = $0483
006000  2               MaxRangeFromOrigin    = $06dc
006000  2               
006000  2               BowserFlamePRandomOfs = $0417
006000  2               
006000  2               PiranhaPlantUpYPos    = $0417
006000  2               PiranhaPlantDownYPos  = $0434
006000  2               PiranhaPlant_Y_Speed  = $58
006000  2               PiranhaPlant_MoveFlag = $a0
006000  2               
006000  2               FireworksCounter      = $06d7
006000  2               ExplosionGfxCounter   = $58
006000  2               ExplosionTimerCounter = $a0
006000  2               
006000  2               ;sound related defines
006000  2               Squ2_NoteLenBuffer    = $07b3
006000  2               Squ2_NoteLenCounter   = $07b4
006000  2               Squ2_EnvelopeDataCtrl = $07b5
006000  2               Squ1_NoteLenCounter   = $07b6
006000  2               Squ1_EnvelopeDataCtrl = $07b7
006000  2               Tri_NoteLenBuffer     = $07b8
006000  2               Tri_NoteLenCounter    = $07b9
006000  2               Noise_BeatLenCounter  = $07ba
006000  2               Squ1_SfxLenCounter    = $07bb
006000  2               Squ2_SfxLenCounter    = $07bd
006000  2               Sfx_SecondaryCounter  = $07be
006000  2               Noise_SfxLenCounter   = $07bf
006000  2               
006000  2               PauseSoundQueue       = $fa
006000  2               Square1SoundQueue     = $ff
006000  2               Square2SoundQueue     = $fe
006000  2               NoiseSoundQueue       = $fd
006000  2               AreaMusicQueue        = $fb
006000  2               EventMusicQueue       = $fc
006000  2               
006000  2               Square1SoundBuffer    = $f1
006000  2               Square2SoundBuffer    = $f2
006000  2               NoiseSoundBuffer      = $f3
006000  2               AreaMusicBuffer       = $f4
006000  2               EventMusicBuffer      = $07b1
006000  2               PauseSoundBuffer      = $07b2
006000  2               
006000  2               MusicData             = $f5
006000  2               MusicDataLow          = $f5
006000  2               MusicDataHigh         = $f6
006000  2               MusicOffset_Square2   = $f7
006000  2               MusicOffset_Square1   = $f8
006000  2               MusicOffset_Triangle  = $f9
006000  2               MusicOffset_Noise     = $07b0
006000  2               
006000  2               NoteLenLookupTblOfs   = $f0
006000  2               DAC_Counter           = $07c0
006000  2               NoiseDataLoopbackOfs  = $07c1
006000  2               NoteLengthTblAdder    = $07c4
006000  2               AreaMusicBuffer_Alt   = $07c5
006000  2               PauseModeFlag         = $07c6
006000  2               GroundMusicHeaderOfs  = $07c7
006000  2               AltRegContentFlag     = $07ca
006000  2               
006000  2               ;SUBROUTINES IN FAMICOM DISK SYSTEM BIOS
006000  2               FDSBIOS_DELAY     = $e149
006000  2               FDSBIOS_LOADFILES = $e1f8
006000  2               FDSBIOS_WRITEFILE = $e239
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               ;CONSTANTS
006000  2               
006000  2               ;sound effects constants
006000  2               Sfx_SmallJump         = %10000000
006000  2               Sfx_Flagpole          = %01000000
006000  2               Sfx_Fireball          = %00100000
006000  2               Sfx_PipeDown_Injury   = %00010000
006000  2               Sfx_EnemySmack        = %00001000
006000  2               Sfx_EnemyStomp        = %00000100
006000  2               Sfx_Bump              = %00000010
006000  2               Sfx_BigJump           = %00000001
006000  2               
006000  2               Sfx_BowserFall        = %10000000
006000  2               Sfx_ExtraLife         = %01000000
006000  2               Sfx_PowerUpGrab       = %00100000
006000  2               Sfx_TimerTick         = %00010000
006000  2               Sfx_Blast             = %00001000
006000  2               Sfx_GrowVine          = %00000100
006000  2               Sfx_GrowPowerUp       = %00000010
006000  2               Sfx_CoinGrab          = %00000001
006000  2               
006000  2               Sfx_BowserFlame       = %00000010
006000  2               Sfx_BrickShatter      = %00000001
006000  2               
006000  2               ;music constants
006000  2               Silence               = %10000000
006000  2               
006000  2               StarPowerMusic        = %01000000
006000  2               PipeIntroMusic        = %00100000
006000  2               CloudMusic            = %00010000
006000  2               CastleMusic           = %00001000
006000  2               UndergroundMusic      = %00000100
006000  2               WaterMusic            = %00000010
006000  2               GroundMusic           = %00000001
006000  2               
006000  2               TimeRunningOutMusic   = %01000000
006000  2               EndOfLevelMusic       = %00100000
006000  2               AltGameOverMusic      = %00010000
006000  2               EndOfCastleMusic      = %00001000
006000  2               VictoryMusic          = %00000100
006000  2               GameOverMusic         = %00000010
006000  2               DeathMusic            = %00000001
006000  2               
006000  2               ;enemy object constants
006000  2               GreenKoopa            = $00
006000  2               BuzzyBeetle           = $02
006000  2               RedKoopa              = $03
006000  2               HammerBro             = $05
006000  2               Goomba                = $06
006000  2               Bloober               = $07
006000  2               BulletBill_FrenzyVar  = $08
006000  2               GreyCheepCheep        = $0a
006000  2               RedCheepCheep         = $0b
006000  2               Podoboo               = $0c
006000  2               PiranhaPlant          = $0d
006000  2               GreenParatroopaJump   = $0e
006000  2               RedParatroopa         = $0f
006000  2               GreenParatroopaFly    = $10
006000  2               Lakitu                = $11
006000  2               Spiny                 = $12
006000  2               FlyCheepCheepFrenzy   = $14
006000  2               FlyingCheepCheep      = $14
006000  2               BowserFlame           = $15
006000  2               Fireworks             = $16
006000  2               BBill_CCheep_Frenzy   = $17
006000  2               Stop_Frenzy           = $18
006000  2               Bowser                = $2d
006000  2               PowerUpObject         = $2e
006000  2               VineObject            = $2f
006000  2               FlagpoleFlagObject    = $30
006000  2               StarFlagObject        = $31
006000  2               JumpspringObject      = $32
006000  2               BulletBill_CannonVar  = $33
006000  2               RetainerObject        = $35
006000  2               TallEnemy             = $09
006000  2               UpsideDownPiranhaP    = $04
006000  2               
006000  2               ;other constants
006000  2               World1 = 0
006000  2               World2 = 1
006000  2               World3 = 2
006000  2               World4 = 3
006000  2               World5 = 4
006000  2               World6 = 5
006000  2               World7 = 6
006000  2               World8 = 7
006000  2               World9 = 8
006000  2               Level1 = 0
006000  2               Level2 = 1
006000  2               Level3 = 2
006000  2               Level4 = 3
006000  2               
006000  2               WarmBootOffset        = <$07d6
006000  2               ColdBootOffset        = <$07fe
006000  2               SoundMemory           = $07b0
006000  2               SwimTileRepOffset     = PlayerGraphicsTable + $9e
006000  2               MusicHeaderOffsetData = MusicHeaderData - 1
006000  2               MHD                   = MusicHeaderData
006000  2               
006000  2               A_Button              = %10000000
006000  2               B_Button              = %01000000
006000  2               Select_Button         = %00100000
006000  2               Start_Button          = %00010000
006000  2               Up_Dir                = %00001000
006000  2               Down_Dir              = %00000100
006000  2               Left_Dir              = %00000010
006000  2               Right_Dir             = %00000001
006000  2               
006000  2               AttractMode           = 0
006000  2               GameMode              = 1
006000  2               VictoryMode           = 2
006000  2               GameOverMode          = 3
006000  2               
006000  2               ; imports from other files
006000  2               ;SUBROUTINES IN SM2DATA2 AND SM2DATA4
006000  2               .import UpsideDownPipe_High
006000  2               .import UpsideDownPipe_Low
006000  2               .import WindOn
006000  2               .import WindOff
006000  2               .import SimulateWind
006000  2               .import BlowPlayerAround
006000  2               .import MoveUpsideDownPiranhaP
006000  2               .import ChangeHalfwayPages
006000  2               ;SUBROUTINES IN SM2DATA3
006000  2               .import EraseLivesLines
006000  2               .import RunMushroomRetainers
006000  2               .import EndingDiskRoutines
006000  2               .import AwardExtraLives
006000  2               .import PrintVictoryMsgsForWorld8
006000  2               .import FadeToBlue
006000  2               .import ScreenSubsForFinalRoom
006000  2               ;LABELS FROM SM2DATA3
006000  2               .import WriteNameToVictoryMsg
006000  2               .import UnusedAttribData
006000  2               .import FinalRoomPalette
006000  2               .import ThankYouMessageFinal
006000  2               .import PeaceIsPavedMsg
006000  2               .import WithKingdomSavedMsg
006000  2               .import HurrahMsg
006000  2               .import OurOnlyHeroMsg
006000  2               .import ThisEndsYourTripMsg
006000  2               .import OfALongFriendshipMsg
006000  2               .import PointsAddedMsg
006000  2               .import ForEachPlayerLeftMsg
006000  2               .import PrincessPeachsRoom
006000  2               .import FantasyWorld9Msg
006000  2               .import SuperPlayerMsg
006000  2               ;from sm2data2
006000  2               .import E_CastleArea5
006000  2               .import E_CastleArea6
006000  2               .import E_CastleArea7
006000  2               .import E_CastleArea8
006000  2               .import E_GroundArea12
006000  2               .import E_GroundArea13
006000  2               .import E_GroundArea14
006000  2               .import E_GroundArea15
006000  2               .import E_GroundArea16
006000  2               .import E_GroundArea17
006000  2               .import E_GroundArea18
006000  2               .import E_GroundArea19
006000  2               .import E_GroundArea22
006000  2               .import E_GroundArea23
006000  2               .import E_GroundArea24
006000  2               .import E_GroundArea29
006000  2               .import E_UndergroundArea4
006000  2               .import E_UndergroundArea5
006000  2               .import E_WaterArea2
006000  2               .import E_WaterArea4
006000  2               .import E_WaterArea5
006000  2               .import L_CastleArea5
006000  2               .import L_CastleArea6
006000  2               .import L_CastleArea7
006000  2               .import L_CastleArea8
006000  2               .import L_GroundArea12
006000  2               .import L_GroundArea13
006000  2               .import L_GroundArea14
006000  2               .import L_GroundArea15
006000  2               .import L_GroundArea16
006000  2               .import L_GroundArea17
006000  2               .import L_GroundArea18
006000  2               .import L_GroundArea19
006000  2               .import L_GroundArea22
006000  2               .import L_GroundArea23
006000  2               .import L_GroundArea24
006000  2               .import L_GroundArea29
006000  2               .import L_UndergroundArea4
006000  2               .import L_UndergroundArea5
006000  2               .import L_WaterArea2
006000  2               .import L_WaterArea4
006000  2               .import L_WaterArea5
006000  2               ;from sm2data3
006000  2               .import E_CastleArea9
006000  2               .import E_CastleArea10
006000  2               .import E_GroundArea25
006000  2               .import E_GroundArea26
006000  2               .import E_GroundArea27
006000  2               .import E_WaterArea6
006000  2               .import E_WaterArea7
006000  2               .import E_WaterArea8
006000  2               .import L_CastleArea9
006000  2               .import L_CastleArea10
006000  2               .import L_GroundArea25
006000  2               .import L_GroundArea26
006000  2               .import L_GroundArea27
006000  2               .import L_WaterArea6
006000  2               .import L_WaterArea7
006000  2               .import L_WaterArea8
006000  2               
006000  2               ; exports to other files
006000  2               .export SoundEngineJSRCode
006000  2               .export MoveSpritesOffscreen
006000  2               .export FreqRegLookupTbl
006000  2               .export NextWorld
006000  2               .export WriteTopStatusLine
006000  2               .export WriteBottomStatusLine
006000  2               .export GetAreaPalette
006000  2               .export GetBackgroundColor
006000  2               .export EndAreaPoints
006000  2               .export JumpEngine
006000  2               .export Square2SfxHandler
006000  2               .export PrintStatusBarNumbers
006000  2               .export DiskIDString
006000  2               .export EnemyGfxHandler
006000  2               .export SoundEngine
006000  2               .export DiskScreen
006000  2               .export WaitForEject
006000  2               .export WaitForReinsert
006000  2               .export ResetDiskVars
006000  2               .export DiskErrorHandler
006000  2               .export AttractModeSubs
006000  2               .export InitScreenPalette
006000  2               ; sm2data4
006000  2               .export HalfwayPageNybbles
006000  2               .export GetPipeHeight
006000  2               .export FindEmptyEnemySlot
006000  2               .export SetupPiranhaPlant
006000  2               .export VerticalPipeData
006000  2               .export RenderUnderPart
006000  2               .export MetatileBuffer
006000  2               .export GetAreaType
006000  2               .export E_GroundArea21
006000  2               .export E_GroundArea28
006000  2               .export L_GroundArea10
006000  2               .export L_GroundArea28
006000  2               
006000  2               ;-------------------------------------------------------------------------------------
006000  2               
006000  2               Start:
006000  2  A5 FA                    lda Mirror_FDS_CTRL_REG     ;get setting previously used by FDS bios
006002  2  29 F7                    and #$f7                    ;and set for vertical mirroring
006004  2  8D 25 40                 sta FDS_CTRL_REG
006007  2  AD 5F 07                 lda WorldNumber             ;get world number and save it temporarily
00600A  2  48                       pha
00600B  2  A0 FE                    ldy #ColdBootOffset         ;load default cold boot pointer
00600D  2  A2 05                    ldx #$05
00600F  2  BD D7 07     WBootCheck: lda TopScoreDisplay,x       ;first checkpoint, check each score digit
006012  2  C9 0A                    cmp #10                     ;in the top score for a valid digit
006014  2  B0 0C                    bcs ColdBoot                ;if even one digit isn't valid (greater than 10 decimal)
006016  2  CA                       dex                         ;then branch to perform cold boot
006017  2  10 F6                    bpl WBootCheck
006019  2  AD FF 07                 lda WarmBootValidation      ;second checkpoint, check to see if
00601C  2  C9 A5                    cmp #$a5                    ;another location has a specific value
00601E  2  D0 02                    bne ColdBoot
006020  2  A0 D6                    ldy #WarmBootOffset         ;if passed both, load warm boot pointer
006022  2  20 08 6F     ColdBoot:   jsr InitializeMemory        ;clear memory using pointer in Y
006025  2  8D 11 40                 sta SND_DELTA_REG+1
006028  2  8D 70 07                 sta OperMode                ;now manually reset some other stuff
00602B  2  8D FC 07                 sta DiskIOTask
00602E  2  68                       pla
00602F  2  8D 5F 07                 sta WorldNumber
006032  2  A9 A5                    lda #$a5                    ;set warm boot flag in case the player hits reset
006034  2  8D FF 07                 sta WarmBootValidation
006037  2  8D A7 07                 sta PseudoRandomBitReg      ;set seed for pseudorandom register
00603A  2  A9 0F                    lda #%00001111
00603C  2  8D 15 40                 sta SND_MASTERCTRL_REG      ;enable all sound channels except dmc
00603F  2  A9 06                    lda #%00000110
006041  2  8D 01 20                 sta PPU_MASK                ;turn off clipping for OAM and background
006044  2  20 87 62                 jsr MoveAllSpritesOffscreen
006047  2  20 92 6C                 jsr InitializeNameTables
00604A  2  EE 74 07                 inc DisableScreenFlag
00604D  2  A9 C0                    lda #$c0                    ;set FDS BIOS flag to use NMI vector at $dffa
00604F  2  8D 01 01                 sta FDSBIOS_IRQFlag         ;enable all interrupts
006052  2  58                       cli
006053  2  AD 78 07                 lda Mirror_PPU_CTRL
006056  2  09 80                    ora #%10000000
006058  2  20 66 6D                 jsr WritePPUReg1
00605B  2               EndlessLoop:
00605B  2  A5 00                    lda $00                     ;endless loop
00605D  2  4C 5B 60                 jmp EndlessLoop
006060  2               
006060  2               ;-------------------------------------------------------------------------------------
006060  2               
006060  2               VRAM_AddrTable:
006060  2  01 03 8D 6B     .word VRAM_Buffer1, WaterPaletteData, GroundPaletteData, UndergroundPaletteData
006064  2  B1 6B D5 6B  
006068  2  F9 6B 2B C6     .word CastlePaletteData, TitleScreenGfxData, VRAM_Buffer2, VRAM_Buffer2
00606C  2  41 03 41 03  
006070  2  35 6C 1D 6C     .word BowserPaletteData, DaySnowPaletteData, NightSnowPaletteData, MushroomPaletteData
006074  2  25 6C 2D 6C  
006078  2  3D 6C 51 6C     .word ThankYouMessage, MushroomRetainerMsg, UnusedAttribData, FinalRoomPalette
00607C  2  rr rr rr rr  
006080  2  rr rr rr rr     .word ThankYouMessageFinal, PeaceIsPavedMsg, WithKingdomSavedMsg, HurrahMsg
006084  2  rr rr rr rr  
006088  2  rr rr rr rr     .word OurOnlyHeroMsg, ThisEndsYourTripMsg, OfALongFriendshipMsg, PointsAddedMsg
00608C  2  rr rr rr rr  
006090  2  rr rr 49 C1     .word ForEachPlayerLeftMsg, DiskErrorMainMsg, DiskScreenPalette, PrincessPeachsRoom
006094  2  0B C1 rr rr  
006098  2  11 C5 rr rr     .word MenuCursorTemplate, FantasyWorld9Msg, SuperPlayerMsg
00609C  2  rr rr        
00609E  2               
00609E  2               VRAM_Buffer_Offset:
00609E  2  00 40           .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
0060A0  2               
0060A0  2               ;-------------------------------------------------------------------------------------
0060A0  2               
0060A0  2               NMIHandler:
0060A0  2  AD 78 07        lda Mirror_PPU_CTRL       ;alter name table address to be $2800
0060A3  2  29 7E           and #%01111110            ;(essentially $2000) and disable another NMI
0060A5  2  8D 78 07        sta Mirror_PPU_CTRL       ;from interrupting this one
0060A8  2  8D 00 20        sta PPU_CTRL
0060AB  2  78              sei
0060AC  2  AD 22 07        lda IRQUpdateFlag
0060AF  2  F0 12           beq SkipIRQ
0060B1  2  A9 58           lda #$58
0060B3  2  8D 20 40        sta FDS_IRQTIMER_LOW      ;set FDS IRQ timer to occur at the end of the status bar
0060B6  2  A9 16           lda #$16
0060B8  2  8D 21 40        sta FDS_IRQTIMER_HIGH
0060BB  2  A9 02           lda #$02
0060BD  2  8D 22 40        sta FDS_IRQTIMER_CTRL     ;enable it
0060C0  2  EE 7B 07        inc IRQAckFlag            ;reset flag to wait for next IRQ
0060C3  2               SkipIRQ:
0060C3  2  AD 79 07        lda Mirror_PPU_MASK
0060C6  2  29 E6           and #%11100110            ;disable OAM and background display by default
0060C8  2  AC 74 07        ldy DisableScreenFlag     ;if screen disabled, skip this
0060CB  2  D0 05           bne ScrnSwch
0060CD  2  AD 79 07        lda Mirror_PPU_MASK       ;otherwise reenable bits and save them
0060D0  2  09 1E           ora #%00011110
0060D2  2               ScrnSwch:
0060D2  2  8D 79 07        sta Mirror_PPU_MASK
0060D5  2  29 E7           and #%11100111            ;turn screen off regardless of mirror reg
0060D7  2  8D 01 20        sta PPU_MASK
0060DA  2  AE 02 20        ldx PPU_STATUS
0060DD  2  A9 00           lda #$00
0060DF  2  20 5F 6D        jsr InitScroll
0060E2  2  8D 03 20        sta PPU_SPR_ADDR
0060E5  2  A9 02           lda #$02                  ;dump OAM data to PPU's sprite RAM
0060E7  2  8D 14 40        sta SPR_DMA
0060EA  2  AD 73 07        lda VRAM_Buffer_AddrCtrl
0060ED  2  0A              asl
0060EE  2  AA              tax
0060EF  2  BD 60 60        lda VRAM_AddrTable,x      ;get pointer to VRAM data
0060F2  2  85 00           sta $00
0060F4  2  E8              inx
0060F5  2  BD 60 60        lda VRAM_AddrTable,x
0060F8  2  85 01           sta $01
0060FA  2  20 56 6D        jsr UpdateScreen          ;now update the screen with it
0060FD  2  A0 00           ldy #$00
0060FF  2  AE 73 07        ldx VRAM_Buffer_AddrCtrl
006102  2  E0 06           cpx #$06                  ;if pointer number was set to 6 (for
006104  2  D0 01           bne InitVRAMVars          ;second VRAM buffer), increment Y to get
006106  2  C8              iny                       ;offset for second VRAM buffer
006107  2               InitVRAMVars:
006107  2  BE 9E 60        ldx VRAM_Buffer_Offset,y  ;get pointer to correct buffer offset
00610A  2  A9 00           lda #$00                  ;erase the VRAM buffer offset, init first VRAM buffer
00610C  2  9D 00 03        sta VRAM_Buffer1_Offset,x ;by writing end terminator at the first byte, and
00610F  2  9D 01 03        sta VRAM_Buffer1,x        ;init address control to point at first VRAM buffer
006112  2  8D 73 07        sta VRAM_Buffer_AddrCtrl
006115  2  AD 79 07        lda Mirror_PPU_MASK
006118  2  8D 01 20        sta PPU_MASK              ;dump PPU control register 2
00611B  2  58              cli
00611C  2               SoundEngineJSRCode:
00611C  2  20 A0 D2        jsr SoundEngine           ;run subs that need to be run on every frame
00611F  2  20 D5 6C        jsr ReadJoypads
006122  2  20 E9 61        jsr PauseRoutine
006125  2  20 08 6E        jsr UpdateTopScore
006128  2  AD 76 07        lda GamePauseStatus       ;check d0 of game pause flags
00612B  2  4A              lsr                       ;if set, branch to skip
00612C  2  B0 25           bcs SeedLFSR
00612E  2  AD 47 07        lda TimerControl          ;if master timer control not set, branch
006131  2  F0 05           beq CheckIntervalTC       ;to decrement frame and interval timers
006133  2  CE 47 07        dec TimerControl          ;otherwise count this timer down
006136  2  D0 19           bne IncFrameCntr
006138  2               CheckIntervalTC:
006138  2  A2 14           ldx #$14                  ;set offset to decrement only frame timers
00613A  2  CE 7F 07        dec IntervalTimerControl  ;if interval timer control not expired, branch
00613D  2  10 07           bpl DecrTheTimers         ;to skip and thus decrement only frame timers
00613F  2  A9 14           lda #$14
006141  2  8D 7F 07        sta IntervalTimerControl  ;otherwise reset interval timer control to 20 frames
006144  2  A2 23           ldx #$23                  ;and load offset to decrement frame and interval timers
006146  2               DecrTheTimers:
006146  2  BD 80 07        lda Timers,x              ;if current timer is already expired, skip it
006149  2  F0 03           beq DTTLoop               ;otherwise decrement it
00614B  2  DE 80 07        dec Timers,x
00614E  2               DTTLoop:
00614E  2  CA              dex                       ;loop until all timers that need to be counted down are
00614F  2  10 F5           bpl DecrTheTimers
006151  2               IncFrameCntr:
006151  2  E6 09           inc FrameCounter
006153  2               SeedLFSR:
006153  2  A2 00           ldx #$00
006155  2  A0 07           ldy #$07
006157  2  AD A7 07        lda PseudoRandomBitReg    ;get d1 of first byte
00615A  2  29 02           and #$02
00615C  2  85 00           sta $00
00615E  2  AD A8 07        lda PseudoRandomBitReg+1  ;get d1 of second byte, XOR it with the first byte
006161  2  29 02           and #$02
006163  2  45 00           eor $00
006165  2  18              clc
006166  2  F0 01           beq RotateLFSR            ;prepare to rotate the result in
006168  2  38              sec
006169  2               RotateLFSR:
006169  2  7E A7 07        ror PseudoRandomBitReg,x  ;basically, rotate the operation result into d7
00616C  2  E8              inx                       ;then rotate the entire LFSR
00616D  2  88              dey
00616E  2  D0 F9           bne RotateLFSR
006170  2  AD 76 07        lda GamePauseStatus       ;if d0 of game pause flag is set, skip this part
006173  2  4A              lsr
006174  2  B0 18           bcs WaitForIRQ
006176  2  AD 22 07        lda IRQUpdateFlag
006179  2  F0 06           beq CheckInvalidWorldNum
00617B  2  20 8A 62        jsr MoveSpritesOffscreen
00617E  2  20 2D 62        jsr SpriteShuffler
006181  2               CheckInvalidWorldNum:
006181  2  AD 5F 07        lda WorldNumber           ;if world number somehow goes past 9, just end the game
006184  2  C9 09           cmp #$09
006186  2  90 03           bcc ExecutionTree
006188  2  20 8D 70        jsr TerminateGame
00618B  2               ExecutionTree:
00618B  2  20 79 62        jsr OperModeExecutionTree ;run one of the program's four modes
00618E  2               WaitForIRQ:
00618E  2  AD 7B 07        lda IRQAckFlag            ;wait for IRQ
006191  2  D0 FB           bne WaitForIRQ
006193  2  AD 02 20        lda PPU_STATUS
006196  2  AD 78 07        lda Mirror_PPU_CTRL       ;reenable NMIs
006199  2  09 80           ora #$80
00619B  2  8D 78 07        sta Mirror_PPU_CTRL       ;then park it at endless loop until next NMI
00619E  2  8D 00 20        sta PPU_CTRL
0061A1  2  40              rti
0061A2  2               
0061A2  2               IRQHandler:
0061A2  2  78                       sei
0061A3  2  08                       php                      ;save regs
0061A4  2  48                       pha
0061A5  2  8A                       txa
0061A6  2  48                       pha
0061A7  2  98                       tya
0061A8  2  48                       pha
0061A9  2  AD 30 40                 lda FDS_STATUS           ;get disk status register, acknowledge IRQs
0061AC  2  48                       pha
0061AD  2  29 02                    and #$02                 ;if byte transfer flag set, branch elsewhere
0061AF  2  D0 2C                    bne DelayNoScr
0061B1  2  68                       pla
0061B2  2  29 01                    and #$01                 ;if IRQ timer flag not set, branch to leave
0061B4  2  F0 2B                    beq ExitIRQ
0061B6  2  AD 78 07                 lda Mirror_PPU_CTRL
0061B9  2  29 F7                    and #$f7                 ;mask out sprite address high reg of ctrl reg mirror
0061BB  2  0D 7A 07                 ora NameTableSelect      ;mask in whatever's set here
0061BE  2  8D 78 07                 sta Mirror_PPU_CTRL      ;update the register and its mirror
0061C1  2  8D 00 20                 sta PPU_CTRL
0061C4  2  A9 00                    lda #$00
0061C6  2  8D 22 40                 sta FDS_IRQTIMER_CTRL    ;disable IRQ timer for the rest of the frame
0061C9  2  AD 3F 07                 lda HorizontalScroll
0061CC  2  8D 05 20                 sta PPU_SCROLL           ;set scroll regs for the screen under the status bar
0061CF  2  AD 40 07                 lda VerticalScroll       ;to achieve the split screen effect
0061D2  2  8D 05 20                 sta PPU_SCROLL
0061D5  2  A9 00                    lda #$00
0061D7  2  8D 7B 07                 sta IRQAckFlag           ;indicate IRQ was acknowledged
0061DA  2  4C E1 61                 jmp ExitIRQ              ;skip over the next part to end IRQ
0061DD  2  68           DelayNoScr: pla                      ;throw away disk status reg byte
0061DE  2  20 49 E1                 jsr FDSBIOS_DELAY        ;run delay subroutine in FDS bios
0061E1  2  68           ExitIRQ:    pla
0061E2  2  A8                       tay                      ;return regs, reenable IRQs and leave
0061E3  2  68                       pla
0061E4  2  AA                       tax
0061E5  2  68                       pla
0061E6  2  28                       plp
0061E7  2  58                       cli
0061E8  2  40                       rti
0061E9  2               
0061E9  2               ;-------------------------------------------------------------------------------------
0061E9  2               
0061E9  2               PauseRoutine:
0061E9  2  AD 70 07                    lda OperMode           ;are we in victory mode?
0061EC  2  C9 02                       cmp #VictoryMode       ;if so, go ahead
0061EE  2  F0 0B                       beq ChkPauseTimer
0061F0  2  C9 01                       cmp #GameMode          ;are we in game mode?
0061F2  2  D0 38                       bne ExitPause          ;if not, leave
0061F4  2  AD 72 07                    lda OperMode_Task      ;if we are in game mode, are we running game engine?
0061F7  2  C9 04                       cmp #$04
0061F9  2  D0 31                       bne ExitPause          ;if not, leave
0061FB  2  AD 77 07     ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
0061FE  2  F0 04                       beq ChkStart
006200  2  CE 77 07                    dec GamePauseTimer     ;if so, decrement and leave
006203  2  60                          rts
006204  2  AD FC 06     ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
006207  2  29 10                       and #Start_Button
006209  2  F0 19                       beq ClrPauseTimer
00620B  2  AD 76 07                    lda GamePauseStatus    ;check to see if timer flag is set
00620E  2  29 80                       and #%10000000         ;and if so, do not reset timer (residual,
006210  2  D0 1A                       bne ExitPause          ;joypad reading routine makes this unnecessary)
006212  2  A9 2B                       lda #$2b               ;set pause timer
006214  2  8D 77 07                    sta GamePauseTimer
006217  2  AD 76 07                    lda GamePauseStatus
00621A  2  A8                          tay
00621B  2  C8                          iny                    ;set pause sfx queue for next pause mode
00621C  2  84 FA                       sty PauseSoundQueue
00621E  2  49 01                       eor #%00000001         ;invert d0 and set d7
006220  2  09 80                       ora #%10000000
006222  2  D0 05                       bne SetPause           ;unconditional branch
006224  2  AD 76 07     ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
006227  2  29 7F                       and #%01111111         ;is not pressed
006229  2  8D 76 07     SetPause:      sta GamePauseStatus
00622C  2  60           ExitPause:     rts
00622D  2               
00622D  2               
00622D  2               ;-------------------------------------------------------------------------------------
00622D  2               ;$00 - used for preset value
00622D  2               
00622D  2               SpriteShuffler:
00622D  2  AC 4E 07                    ldy AreaType                ;residual code, this value is never used
006230  2  A9 28                       lda #$28                    ;load preset value which will put it at
006232  2  85 00                       sta $00                     ;sprite #10
006234  2  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
006236  2  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
006239  2  C5 00                       cmp $00                     ;the preset value
00623B  2  90 0F                       bcc NextSprOffset           ;if less, skip this part
00623D  2  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
006240  2  18                          clc
006241  2  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
006244  2  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
006246  2  18                          clc
006247  2  65 00                       adc $00                     ;otherwise add preset value $28 to offset
006249  2  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
00624C  2  CA           NextSprOffset: dex                         ;move backwards to next one
00624D  2  10 E7                       bpl ShuffleLoop
00624F  2  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
006252  2  E8                          inx
006253  2  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
006255  2  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
006257  2  A2 00                       ldx #$00                    ;otherwise, init to 0
006259  2  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
00625C  2  A2 08                       ldx #$08                    ;load offsets for values and storage
00625E  2  A0 02                       ldy #$02
006260  2  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
006263  2  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
006266  2  18                          clc                         ;add eight to the second and eight
006267  2  69 08                       adc #$08                    ;more to the third one
006269  2  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
00626C  2  18                          clc                         ;this code loads into the misc sprite offsets
00626D  2  69 08                       adc #$08
00626F  2  9D F3 06                    sta Misc_SprDataOffset,x
006272  2  CA                          dex
006273  2  CA                          dex
006274  2  CA                          dex
006275  2  88                          dey
006276  2  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
006278  2  60                          rts
006279  2               
006279  2               ;-------------------------------------------------------------------------------------
006279  2               
006279  2               OperModeExecutionTree:
006279  2  AD 70 07           lda OperMode     ;this is the heart of the entire program,
00627C  2  20 7D 6C           jsr JumpEngine   ;most of what goes on starts here
00627F  2               
00627F  2  B0 BF              .word AttractModeSubs
006281  2  37 7A              .word GameModeSubs
006283  2  98 62              .word VictoryModeMain
006285  2  57 70              .word GameOverSubs
006287  2               
006287  2               ;-------------------------------------------------------------------------------------
006287  2               
006287  2               MoveAllSpritesOffscreen:
006287  2  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
006289  2  2C                         .byte $2c                 ;BIT instruction opcode
00628A  2               
00628A  2               MoveSpritesOffscreen:
00628A  2  A0 04                      ldy #$04                ;this routine moves all but sprite 0
00628C  2  A9 F8                      lda #$f8                ;off the screen
00628E  2  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
006291  2  C8                         iny                     ;which will move it off the screen
006292  2  C8                         iny
006293  2  C8                         iny
006294  2  C8                         iny
006295  2  D0 F7                      bne SprInitLoop
006297  2  60           VMExit:       rts
006298  2               
006298  2               ;-------------------------------------------------------------------------------------
006298  2               
006298  2               VictoryModeMain:
006298  2  20 BC 62               jsr VictoryModeSubroutines ;run victory mode subroutines in order
00629B  2  AD 72 07               lda OperMode_Task          ;if running bridge collapse subroutine
00629E  2  F0 16                  beq BrdgSkip               ;then skip most of this
0062A0  2  AE 5F 07               ldx WorldNumber
0062A3  2  E0 07                  cpx #World8                ;if not on world 8, skip, don't bother checking
0062A5  2  D0 08                  bne NotW8                  ;to see which subroutine we're on
0062A7  2  C9 05                  cmp #$05
0062A9  2  F0 EC                  beq VMExit                 ;if running disk subroutines, branch to leave
0062AB  2  C9 0D                  cmp #$0d                   ;because the screen will be blank during this
0062AD  2  F0 E8                  beq VMExit
0062AF  2  A2 00        NotW8:    ldx #$00
0062B1  2  86 08                  stx ObjectOffset           ;run code for a single enemy object
0062B3  2  20 23 8C               jsr EnemiesAndLoopsCore    ;(either the mushroom retainer or door/princess)
0062B6  2  20 0F BE     BrdgSkip: jsr RelativePlayerPosition ;draw the player as usual
0062B9  2  4C C4 BB               jmp PlayerGfxHandler
0062BC  2               
0062BC  2               VictoryModeSubroutines:
0062BC  2  AD 5F 07         lda WorldNumber               ;run different list of subroutines if on world 8
0062BF  2  C9 07            cmp #World8
0062C1  2  F0 12            beq VictoryModeSubsForW8      ;note that world D will also run second set of subs
0062C3  2  AD 72 07         lda OperMode_Task             ;after running the first two subs in the first set
0062C6  2  20 7D 6C         jsr JumpEngine
0062C9  2               
0062C9  2  21 9C            .word BridgeCollapse
0062CB  2  FF 62            .word SetupVictoryMode
0062CD  2  34 63            .word PlayerVictoryWalk
0062CF  2  6D 63            .word PrintVictoryMessages
0062D1  2  AF 63            .word EndCastleAward
0062D3  2  D2 63            .word EndWorld1Thru7
0062D5  2               
0062D5  2               VictoryModeSubsForW8:
0062D5  2  AD 72 07         lda OperMode_Task
0062D8  2  20 7D 6C         jsr JumpEngine
0062DB  2               
0062DB  2  21 9C            .word BridgeCollapse
0062DD  2  FF 62            .word SetupVictoryMode
0062DF  2  34 63            .word PlayerVictoryWalk
0062E1  2  81 C0            .word StartVMDelay
0062E3  2  88 C0            .word ContinueVMDelay
0062E5  2  8E C0            .word VictoryModeDiskRoutines
0062E7  2  rr rr            .word ScreenSubsForFinalRoom    ;all these subs are in SM2DATA3
0062E9  2  rr rr            .word PrintVictoryMsgsForWorld8
0062EB  2  AF 63            .word EndCastleAward            ;except this one
0062ED  2  rr rr            .word AwardExtraLives
0062EF  2  rr rr            .word FadeToBlue
0062F1  2  rr rr            .word EraseLivesLines
0062F3  2  rr rr            .word RunMushroomRetainers
0062F5  2  rr rr            .word EndingDiskRoutines
0062F7  2               
0062F7  2               ;-------------------------------------------------------------------------------------
0062F7  2               
0062F7  2               WorldBits:
0062F7  2  01 02 04 08      .byte $01, $02, $04, $08, $10, $20, $40, $80
0062FB  2  10 20 40 80  
0062FF  2               
0062FF  2               SetupVictoryMode:
0062FF  2  AE 1B 07              ldx ScreenRight_PageLoc ;get page location of right side of screen
006302  2  E8                    inx                     ;increment to next page
006303  2  86 34                 stx DestinationPageLoc
006305  2  AC 5F 07              ldy WorldNumber
006308  2  B9 F7 62              lda WorldBits,y
00630B  2  0D FA 07              ora CompletedWorlds     ;set bit according to the world the player was in
00630E  2  8D FA 07              sta CompletedWorlds
006311  2  AD FB 07              lda HardWorldFlag       ;if not playing worlds A-D, branch to skip this
006314  2  F0 0C                 beq W1Thru8
006316  2  AD 5F 07              lda WorldNumber         ;otherwise, if not on world D, branch to skip this
006319  2  C9 03                 cmp #World4             ;(note worlds A-D use values 0-3 in this variable)
00631B  2  90 05                 bcc W1Thru8
00631D  2  A9 07                 lda #World8             ;if on world D, set world number to 8 to satisfy
00631F  2  8D 5F 07              sta WorldNumber         ;end of game condition in later victory mode subs
006322  2  A9 08        W1Thru8: lda #EndOfCastleMusic
006324  2  85 FC                 sta EventMusicQueue     ;play win castle music
006326  2               
006326  2               IncModeTask:
006326  2  EE 72 07         inc OperMode_Task
006329  2  60               rts
00632A  2               
00632A  2               ;-------------------------------------------------------------------------------------
00632A  2               
00632A  2               DrawTitleScreen:
00632A  2  AD 70 07         lda OperMode       ;if not in attract mode, do not draw title screen
00632D  2  D0 F7            bne IncModeTask    ;yes, this routine is run in other modes
00632F  2  A9 05            lda #$05
006331  2  4C A1 65         jmp SetVRAMAddr_B  ;otherwise set up VRAM address controller accordingly
006334  2               
006334  2               ;-------------------------------------------------------------------------------------
006334  2               
006334  2               PlayerVictoryWalk:
006334  2  A0 00                     ldy #$00                ;set value here to not walk player by default
006336  2  84 35                     sty VictoryWalkControl
006338  2  A5 6D                     lda Player_PageLoc      ;get player's page location
00633A  2  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
00633C  2  D0 06                     bne PerformWalk         ;if page locations don't match, branch
00633E  2  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
006340  2  C9 60                     cmp #$60                ;compare with preset horizontal position
006342  2  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
006344  2  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
006346  2  C8                        iny                     ;note Y will be used to walk the player
006347  2  98           DontWalk:    tya                     ;put contents of Y in A and
006348  2  20 3E 7C                  jsr AutoControlPlayer   ;use A to move player to the right or not
00634B  2  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
00634E  2  C5 34                     cmp DestinationPageLoc  ;against set value here
006350  2  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
006352  2  AD 68 07                  lda ScrollFractional
006355  2  18                        clc                     ;do fixed point math on fractional part of scroll
006356  2  69 80                     adc #$80
006358  2  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
00635B  2  A9 01                     lda #$01                ;set 1 pixel per frame
00635D  2  69 00                     adc #$00                ;add carry from previous addition
00635F  2  A8                        tay                     ;use as scroll amount
006360  2  20 20 7B                  jsr ScrollScreen        ;do sub to scroll the screen
006363  2  20 CB 7A                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
006366  2  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
006368  2  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
00636A  2  F0 3F                     beq IncModeTask_A       ;if zero, branch to change modes
00636C  2  60                        rts                     ;otherwise leave
00636D  2               
00636D  2               PrintVictoryMessages:
00636D  2  AD 49 07                    lda MsgFractional        ;load message counter fractional
006370  2  D0 1F                       bne IncMsgCounter        ;if not yet wrapped, branch to increment it
006372  2  AD 19 07                    lda MsgCounter           ;otherwise load message counter
006375  2  F0 08                       beq ThankPlayer          ;if set to zero, branch to print first message
006377  2  C9 08                       cmp #$08                 ;if at 8 or above, branch elsewhere
006379  2  B0 16                       bcs IncMsgCounter
00637B  2  C9 01                       cmp #$01                 ;if at zero, branch (note, this branch is never
00637D  2  90 12                       bcc IncMsgCounter        ;taken because we already branched at zero earlier)
00637F  2  A8           ThankPlayer:   tay
006380  2  F0 08                       beq PrintMsgs
006382  2  C0 03                       cpy #$03
006384  2  B0 1E                       bcs SetEndTimer          ;wait until a specific point to set the timer
006386  2  C0 02                       cpy #$02
006388  2  B0 07                       bcs IncMsgCounter        ;skip printing of messages after the first two
00638A  2  98           PrintMsgs:     tya                      ;put primary message counter in A
00638B  2  18                          clc                      ;add 12 to counter, thus giving an appropriate value
00638C  2  69 0C                       adc #$0c
00638E  2  8D 73 07                    sta VRAM_Buffer_AddrCtrl ;write message counter to vram address controller
006391  2  AD 49 07     IncMsgCounter: lda MsgFractional
006394  2  18                          clc
006395  2  69 04                       adc #$04                 ;add four to fractional
006397  2  8D 49 07                    sta MsgFractional
00639A  2  AD 19 07                    lda MsgCounter
00639D  2  69 00                       adc #$00                 ;carry the one if fractional wraps
00639F  2  8D 19 07                    sta MsgCounter
0063A2  2  C9 06                       cmp #$06                 ;check message counter one more time
0063A4  2  90 08        SetEndTimer:   bcc ExitMsgs             ;if not reached 6 yet, branch to leave
0063A6  2  A9 08                       lda #$08
0063A8  2  8D A1 07                    sta WorldEndTimer        ;otherwise set world end timer
0063AB  2  EE 72 07     IncModeTask_A: inc OperMode_Task        ;move onto next task in mode
0063AE  2  60           ExitMsgs:      rts
0063AF  2               
0063AF  2               EndCastleAward:
0063AF  2  AD A1 07        lda WorldEndTimer      ;if world end timer has not yet reached a certain point
0063B2  2  C9 06           cmp #$06               ;then go ahead and skip all of this
0063B4  2  B0 1B           bcs ExEWA
0063B6  2  20 57 9F        jsr AwardTimerCastle
0063B9  2  AD EC 07        lda GameTimerDisplay   ;if game timer points not all awarded, skip this part
0063BC  2  0D ED 07        ora GameTimerDisplay+1
0063BF  2  0D EE 07        ora GameTimerDisplay+2
0063C2  2  D0 0D           bne ExEWA
0063C4  2  A9 30           lda #$30
0063C6  2  8D 80 07        sta SelectTimer        ;set select timer (used for world 8 ending only)
0063C9  2  A9 06           lda #$06
0063CB  2  8D A1 07        sta WorldEndTimer      ;another short delay, then on to the next task
0063CE  2  EE 72 07        inc OperMode_Task
0063D1  2               ExEWA:
0063D1  2  60              rts
0063D2  2               
0063D2  2               EndWorld1Thru7:
0063D2  2  AD A1 07                lda WorldEndTimer         ;skip this until world end timer expires
0063D5  2  D0 25                   bne EndExit
0063D7  2  A9 00        NextWorld: lda #$00
0063D9  2  8D 60 07                sta AreaNumber            ;reset area/level numbers to start the next world
0063DC  2  8D 5C 07                sta LevelNumber
0063DF  2  8D 72 07                sta OperMode_Task
0063E2  2  AD 5F 07                lda WorldNumber
0063E5  2  18                      clc
0063E6  2  69 01                   adc #$01                  ;add one, but only up to world 9
0063E8  2  C9 08                   cmp #World9
0063EA  2  90 02                   bcc NoPast9
0063EC  2  A9 08                   lda #World9               ;make world 9 loop forever (or until game is over)
0063EE  2  8D 5F 07     NoPast9:   sta WorldNumber           ;update the world number
0063F1  2  20 A4 C2                jsr LoadAreaPointer       ;get pointer for the next area
0063F4  2  EE 57 07                inc FetchNewGameTimerFlag ;and get a new game timer
0063F7  2  A9 01                   lda #$01
0063F9  2  8D 70 07                sta OperMode              ;and oh yeah, go back to game mode also
0063FC  2  60           EndExit:   rts
0063FD  2               
0063FD  2               ;-------------------------------------------------------------------------------------
0063FD  2               
0063FD  2               ;data is used as tiles for numbers
0063FD  2               ;that appear when you defeat enemies
0063FD  2               FloateyNumTileData:
0063FD  2  FF FF              .byte $ff, $ff ;dummy
0063FF  2  F6 FB              .byte $f6, $fb ; "100"
006401  2  F7 FB              .byte $f7, $fb ; "200"
006403  2  F8 FB              .byte $f8, $fb ; "400"
006405  2  F9 FB              .byte $f9, $fb ; "500"
006407  2  FA FB              .byte $fa, $fb ; "800"
006409  2  F6 50              .byte $f6, $50 ; "1000"
00640B  2  F7 50              .byte $f7, $50 ; "2000"
00640D  2  F8 50              .byte $f8, $50 ; "4000"
00640F  2  F9 50              .byte $f9, $50 ; "5000"
006411  2  FA 50              .byte $fa, $50 ; "8000"
006413  2  FD FE              .byte $fd, $fe ; "1-UP"
006415  2               
006415  2               ;high nybble is digit number, low nybble is number to
006415  2               ;add to the digit of the player's score
006415  2               ScoreUpdateData:
006415  2  FF                 .byte $ff ;dummy
006416  2  41 42 44 45        .byte $41, $42, $44, $45, $48
00641A  2  48           
00641B  2  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
00641F  2  38 00        
006421  2               
006421  2               FloateyNumbersRoutine:
006421  2  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
006424  2  F0 D6                      beq EndExit                  ;if zero, branch to leave
006426  2  C9 0B                      cmp #$0b                     ;if less than $0b, branch
006428  2  90 05                      bcc ChkNumTimer
00642A  2  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
00642C  2  9D 10 01                   sta FloateyNum_Control,x     ;it in range
00642F  2  A8           ChkNumTimer:  tay                          ;use as Y
006430  2  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
006433  2  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
006435  2  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
006438  2  60                         rts
006439  2  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
00643C  2  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
00643E  2  D0 1E                      bne ChkTallEnemy
006440  2  C0 0B                      cpy #$0b                     ;check offset for $0b
006442  2  D0 07                      bne LoadNumTiles             ;branch ahead if not found
006444  2  EE 5A 07                   inc NumberofLives            ;give player one extra life (1-up)
006447  2  A9 40                      lda #Sfx_ExtraLife
006449  2  85 FE                      sta Square2SoundQueue        ;and play the 1-up sound
00644B  2  B9 15 64     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
00644E  2  4A                         lsr                          ;move high nybble to low
00644F  2  4A                         lsr
006450  2  4A                         lsr
006451  2  4A                         lsr
006452  2  AA                         tax                          ;use as X offset, essentially the digit
006453  2  B9 15 64                   lda ScoreUpdateData,y        ;load again and this time
006456  2  29 0F                      and #%00001111               ;mask out the high nybble
006458  2  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
00645B  2  20 E8 87                   jsr AddToScore               ;update the score accordingly
00645E  2  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
006461  2  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
006463  2  C9 12                      cmp #Spiny
006465  2  F0 22                      beq FloateyPart              ;branch if spiny
006467  2  C9 0D                      cmp #PiranhaPlant
006469  2  F0 1E                      beq FloateyPart              ;branch if piranha plant
00646B  2  C9 05                      cmp #HammerBro
00646D  2  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
00646F  2  C9 0A                      cmp #GreyCheepCheep
006471  2  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
006473  2  C9 0B                      cmp #RedCheepCheep
006475  2  F0 12                      beq FloateyPart
006477  2  C9 09                      cmp #TallEnemy
006479  2  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
00647B  2  B5 1E                      lda Enemy_State,x
00647D  2  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
00647F  2  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
006481  2  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
006484  2  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
006487  2  A6 08                      ldx ObjectOffset             ;get enemy object offset again
006489  2  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
00648C  2  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
00648E  2  90 05                      bcc SetupNumSpr              ;status bar, branch
006490  2  E9 01                      sbc #$01
006492  2  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
006495  2  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
006498  2  E9 08                      sbc #$08                     ;subtract eight and dump into the
00649A  2  20 67 B2                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
00649D  2  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
0064A0  2  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
0064A3  2  18                         clc
0064A4  2  69 08                      adc #$08                     ;add eight pixels and store into X
0064A6  2  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
0064A9  2  A9 02                      lda #$02
0064AB  2  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
0064AE  2  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
0064B1  2  BD 10 01                   lda FloateyNum_Control,x
0064B4  2  0A                         asl                          ;multiply our floatey number control by 2
0064B5  2  AA                         tax                          ;and use as offset for look-up table
0064B6  2  BD FD 63                   lda FloateyNumTileData,x
0064B9  2  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
0064BC  2  BD FE 63                   lda FloateyNumTileData+1,x
0064BF  2  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
0064C2  2  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
0064C4  2  60                         rts
0064C5  2               
0064C5  2               ;-------------------------------------------------------------------------------------
0064C5  2               
0064C5  2               ScreenRoutines:
0064C5  2  AD 3C 07        lda ScreenRoutineTask
0064C8  2  20 7D 6C        jsr JumpEngine
0064CB  2               
0064CB  2  EB 64           .word InitScreen
0064CD  2  FB 64           .word SetupIntermediate
0064CF  2  A7 65           .word WriteTopStatusLine
0064D1  2  AF 65           .word WriteBottomStatusLine
0064D3  2  F8 65           .word DisplayTimeUp
0064D5  2  7A 67           .word ResetSpritesAndScreenTimer
0064D7  2  17 66           .word DisplayIntermediate
0064D9  2  D0 C5           .word DemoReset
0064DB  2  7A 67           .word ResetSpritesAndScreenTimer
0064DD  2  59 66           .word AreaParserTaskControl
0064DF  2  1F 65           .word GetAreaPalette
0064E1  2  3F 65           .word GetBackgroundColor
0064E3  2  98 65           .word GetAlternatePalette1
0064E5  2  2A 63           .word DrawTitleScreen
0064E7  2  73 C5           .word ClearBuffersDrawIcon
0064E9  2  8A C5           .word WriteTopScore
0064EB  2               
0064EB  2               InitScreen:
0064EB  2  20 87 62           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
0064EE  2  20 92 6C           jsr InitializeNameTables    ;and erase both name and attribute tables
0064F1  2  AD 70 07           lda OperMode
0064F4  2  F0 32              beq NextSubtask             ;if in attact mode, do not set pointer control
0064F6  2               InitScreenPalette:
0064F6  2  A2 03              ldx #$03                    ;otherwise set for underground palette
0064F8  2  4C 25 65           jmp SetVRAMAddr_A
0064FB  2               
0064FB  2               SetupIntermediate:
0064FB  2  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
0064FE  2  48                 pha                      ;and player status to stack
0064FF  2  AD 56 07           lda PlayerStatus
006502  2  48                 pha
006503  2  A9 00              lda #$00                 ;set background color to black
006505  2  8D 56 07           sta PlayerStatus         ;and player status to not fiery
006508  2  A9 02              lda #$02                 ;this is the ONLY time background color control
00650A  2  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
00650D  2  20 4D 65           jsr GetPlayerColors
006510  2  68                 pla                      ;set up colors for intermediate lives display
006511  2  8D 56 07           sta PlayerStatus
006514  2  68                 pla                      ;return bg color control and player status
006515  2  8D 44 07           sta BackgroundColorCtrl
006518  2  4C 13 66           jmp IncSubtask           ;then move onto the next task
00651B  2               
00651B  2               AreaPalette:
00651B  2  01 02 03 04        .byte $01, $02, $03, $04
00651F  2               
00651F  2               GetAreaPalette:
00651F  2  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
006522  2  BE 1B 65                    ldx AreaPalette,y        ;based on area type
006525  2  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
006528  2  4C 13 66     NextSubtask:   jmp IncSubtask           ;move onto next task
00652B  2               
00652B  2               ;-------------------------------------------------------------------------------------
00652B  2               ;$00 - used as temp counter in GetPlayerColors
00652B  2               
00652B  2               BGColorCtrl_Addr:
00652B  2  00 09 0A 04        .byte $00, $09, $0a, $04
00652F  2               
00652F  2               BackgroundColors:
00652F  2  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
006533  2  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
006537  2               
006537  2               PlayerColors:
006537  2  22 16 27 18        .byte $22, $16, $27, $18 ;player's normal colors, may be overwritten
00653B  2  22 37 27 16        .byte $22, $37, $27, $16 ;player's colors after grabbing fire flower
00653F  2               
00653F  2               GetBackgroundColor:
00653F  2  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
006542  2  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
006544  2  B9 27 65                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
006547  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, first VRAM buffer will not be read
00654A  2  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
00654D  2               
00654D  2               GetPlayerColors:
00654D  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;get current buffer offset
006550  2  A0 00                       ldy #$00
006552  2  AD 56 07     ChkFiery:      lda PlayerStatus         ;check player status
006555  2  C9 02                       cmp #$02
006557  2  D0 02                       bne StartClrGet          ;if fiery, load alternate offset for fiery player
006559  2  A0 04                       ldy #$04
00655B  2  A9 03        StartClrGet:   lda #$03                 ;do four colors
00655D  2  85 00                       sta $00
00655F  2  B9 37 65     ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
006562  2  9D 04 03                    sta VRAM_Buffer1+3,x     ;in the buffer
006565  2  C8                          iny
006566  2  E8                          inx
006567  2  C6 00                       dec $00
006569  2  10 F4                       bpl ClrGetLoop
00656B  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;load original offset from before
00656E  2  AC 44 07                    ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
006571  2  D0 03                       bne SetBGColor           ;therefore use it as offset to background color
006573  2  AC 4E 07                    ldy AreaType             ;otherwise use area type bits from area offset as offset
006576  2  B9 2F 65     SetBGColor:    lda BackgroundColors,y   ;to background color instead
006579  2  9D 04 03                    sta VRAM_Buffer1+3,x
00657C  2  A9 3F                       lda #$3f                 ;set for sprite palette address
00657E  2  9D 01 03                    sta VRAM_Buffer1,x       ;save to buffer
006581  2  A9 10                       lda #$10
006583  2  9D 02 03                    sta VRAM_Buffer1+1,x
006586  2  A9 04                       lda #$04                 ;write length byte to buffer
006588  2  9D 03 03                    sta VRAM_Buffer1+2,x
00658B  2  A9 00                       lda #$00                 ;now the null terminator
00658D  2  9D 08 03                    sta VRAM_Buffer1+7,x
006590  2  8A                          txa                      ;move the buffer pointer ahead 7 bytes
006591  2  18                          clc                      ;in case we want to write anything else later
006592  2  69 07                       adc #$07
006594  2  8D 00 03     SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
006597  2  60                          rts
006598  2               
006598  2               GetAlternatePalette1:
006598  2  AD 33 07                    lda AreaStyle            ;check for mushroom level style
00659B  2  C9 01                       cmp #$01
00659D  2  D0 05                       bne NoAltPal
00659F  2  A9 0B                       lda #$0b                 ;if found, load appropriate palette
0065A1  2  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
0065A4  2  4C 13 66     NoAltPal:      jmp IncSubtask           ;now onto the next task
0065A7  2               
0065A7  2               WriteTopStatusLine:
0065A7  2  A9 00              lda #$00          ;select main status bar
0065A9  2  20 1B 67           jsr WriteGameText ;output it
0065AC  2  4C 13 66           jmp IncSubtask    ;onto the next task
0065AF  2               
0065AF  2               WriteBottomStatusLine:
0065AF  2  20 ED 87           jsr WriteScoreAndCoinTally ;write player's score and coin tally to screen
0065B2  2  AE 00 03           ldx VRAM_Buffer1_Offset
0065B5  2  A9 20              lda #$20                   ;write address for world-area number on screen
0065B7  2  9D 01 03           sta VRAM_Buffer1,x
0065BA  2  A9 73              lda #$73
0065BC  2  9D 02 03           sta VRAM_Buffer1+1,x
0065BF  2  A9 03              lda #$03                   ;write length for it
0065C1  2  9D 03 03           sta VRAM_Buffer1+2,x
0065C4  2  20 E6 65           jsr GetWorldNumForDisplay  ;first the world number
0065C7  2  9D 04 03           sta VRAM_Buffer1+3,x
0065CA  2  A9 28              lda #$28                   ;next the dash
0065CC  2  9D 05 03           sta VRAM_Buffer1+4,x
0065CF  2  AC 5C 07           ldy LevelNumber            ;next the level number
0065D2  2  C8                 iny                        ;increment for proper number display
0065D3  2  98                 tya
0065D4  2  9D 06 03           sta VRAM_Buffer1+5,x
0065D7  2  A9 00              lda #$00                   ;put null terminator at the end
0065D9  2  9D 07 03           sta VRAM_Buffer1+6,x
0065DC  2  8A                 txa                        ;move the buffer offset up by 6 bytes
0065DD  2  18                 clc
0065DE  2  69 06              adc #$06
0065E0  2  8D 00 03           sta VRAM_Buffer1_Offset
0065E3  2  4C 13 66           jmp IncSubtask
0065E6  2               
0065E6  2               GetWorldNumForDisplay:
0065E6  2  AC 5F 07            ldy WorldNumber
0065E9  2  AD FB 07            lda HardWorldFlag  ;if not in worlds A-D, branch to use digits 1-8
0065EC  2  F0 07               beq WNumD
0065EE  2  98                  tya
0065EF  2  29 03               and #$03           ;otherwise mask out any world numbers higher than 4
0065F1  2  18                  clc                ;and add 9 to get the proper letter A thru D
0065F2  2  69 09               adc #$09
0065F4  2  A8                  tay
0065F5  2  C8           WNumD: iny                ;increment the world number/letter because
0065F6  2  98                  tya                ;the internal world number counts from 0, not 1
0065F7  2  60                  rts
0065F8  2               
0065F8  2               DisplayTimeUp:
0065F8  2  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
0065FB  2  F0 13                  beq IncSubtaskby2         ;control 2 tasks forward, otherwise, stay here
0065FD  2  A9 00                  lda #$00
0065FF  2  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
006602  2  A9 02                  lda #$02                  ;output time-up screen to buffer
006604  2               OtherInter:
006604  2  20 1B 67               jsr WriteGameText
006607  2  20 82 67               jsr ResetScreenTimer
00660A  2  A9 00                  lda #$00
00660C  2  8D 74 07               sta DisableScreenFlag
00660F  2  60                     rts
006610  2               
006610  2               IncSubtaskby2:
006610  2  EE 3C 07           inc ScreenRoutineTask
006613  2               IncSubtask:
006613  2  EE 3C 07           inc ScreenRoutineTask
006616  2  60                 rts
006617  2               
006617  2               DisplayIntermediate:
006617  2  AD 70 07                    lda OperMode                 ;check primary mode of operation
00661A  2  F0 37                       beq NoInter                  ;if in attract mode, do not display intermediate screens
00661C  2  C9 03                       cmp #GameOverMode            ;are we in game over mode?
00661E  2  F0 24                       beq GameOverInter            ;if so, proceed to display game over screen
006620  2  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
006623  2  D0 2E                       bne NoInter                  ;and branch if found
006625  2  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
006628  2  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
00662A  2  F0 05                       beq PlayerInter
00662C  2  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
00662F  2  D0 22                       bne NoInter                  ;and jump to specific task, otherwise
006631  2  20 7F BC     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
006634  2  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
006636  2  20 04 66     OutputInter:   jsr OtherInter
006639  2  AD 5F 07                    lda WorldNumber              ;if on any world besides 9, do next task
00663C  2  C9 08                       cmp #World9
00663E  2  D0 D3                       bne IncSubtask
006640  2  EE 74 07                    inc DisableScreenFlag        ;disable screen output
006643  2  60                          rts
006644  2               
006644  2  A9 03        GameOverInter: lda #$03                     ;output game over screen to buffer
006646  2  20 1B 67                    jsr WriteGameText
006649  2  AD 5F 07                    lda WorldNumber
00664C  2  C9 08                       cmp #World9
00664E  2  F0 C3                       beq IncSubtask
006650  2  4C 26 63                    jmp IncModeTask
006653  2               
006653  2  A9 09        NoInter:       lda #$09                     ;skip ahead in screen routine list
006655  2  8D 3C 07                    sta ScreenRoutineTask        ;to execute area parser
006658  2  60                          rts
006659  2               
006659  2               AreaParserTaskControl:
006659  2  EE 74 07                inc DisableScreenFlag     ;turn off screen
00665C  2  20 C1 70     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
00665F  2  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
006662  2  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
006664  2  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
006667  2  10 03                   bpl OutputCol
006669  2  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
00666C  2  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
00666E  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
006671  2  60                      rts
006672  2               
006672  2               GameText:
006672  2               TopStatusBarLine:
006672  2  20 43 05 16    .byte $20, $43, $05, $16, $0a, $1b, $12, $18 ;"MARIO"
006676  2  0A 1B 12 18  
00667A  2  20 52 0B 20    .byte $20, $52, $0b, $20, $18, $1b, $15, $0d ;"WORLD  TIME"
00667E  2  18 1B 15 0D  
006682  2  24 24 1D 12    .byte $24, $24, $1d, $12, $16, $0e
006686  2  16 0E        
006688  2  20 68 05 00    .byte $20, $68, $05, $00, $24, $24, $2e, $29 ;score trailing digit and coin display
00668C  2  24 24 2E 29  
006690  2  23 C0 7F AA    .byte $23, $c0, $7f, $aa ;attribute table data, clears name table 0 to palette 2
006694  2  23 C2 01 EA    .byte $23, $c2, $01, $ea ;attribute table data, used for coin icon in status bar
006698  2  FF             .byte $ff ;end of data block
006699  2               
006699  2               WorldLivesDisplay:
006699  2  21 CD 07 24    .byte $21, $cd, $07, $24, $24 ;cross with spaces used on
00669D  2  24           
00669E  2  29 24 24 24    .byte $29, $24, $24, $24, $24 ;lives display
0066A2  2  24           
0066A3  2  21 4B 09 20    .byte $21, $4b, $09, $20, $18 ;"WORLD  - " used on lives display
0066A7  2  18           
0066A8  2  1B 15 0D 24    .byte $1b, $15, $0d, $24, $24, $28, $24
0066AC  2  24 28 24     
0066AF  2  22 0C 47 24    .byte $22, $0c, $47, $24 ;possibly used to clear time up
0066B3  2  23 DC 01 BA    .byte $23, $dc, $01, $ba ;attribute table data for crown if more than 9 lives
0066B7  2  FF             .byte $ff
0066B8  2               
0066B8  2               TimeUp:
0066B8  2  22 0C 07 1D    .byte $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
0066BC  2  12 16 0E 24  
0066C0  2  1E 19        
0066C2  2  FF             .byte $ff
0066C3  2               
0066C3  2               GameOver:
0066C3  2  21 6B 09 10    .byte $21, $6b, $09, $10, $0a, $16, $0e, $24 ;"GAME OVER"
0066C7  2  0A 16 0E 24  
0066CB  2  18 1F 0E 1B    .byte $18, $1f, $0e, $1b
0066CF  2  21 EB 08 0C    .byte $21, $eb, $08, $0c, $18, $17, $1d, $12, $17, $1e, $0e ;"CONTINUE"
0066D3  2  18 17 1D 12  
0066D7  2  17 1E 0E     
0066DA  2  22 0C 47 24    .byte $22, $0c, $47, $24
0066DE  2  22 4B 05 1B    .byte $22, $4b, $05, $1b, $0e, $1d, $1b, $22 ;"RETRY"
0066E2  2  0E 1D 1B 22  
0066E6  2  FF             .byte $ff
0066E7  2               
0066E7  2               WarpZone:
0066E7  2  25 84 15       .byte $25, $84, $15
0066EA  2  20 0E 15 0C    .byte $20, $0e, $15, $0c, $18, $16, $0e, $24, $1d, $18 ; "WELCOME TO WARP ZONE!"
0066EE  2  18 16 0E 24  
0066F2  2  1D 18        
0066F4  2  24 20 0A 1B    .byte $24, $20, $0a, $1b, $19, $24, $23, $18, $17, $0e
0066F8  2  19 24 23 18  
0066FC  2  17 0E        
0066FE  2  2B             .byte $2b
0066FF  2  26 2D 01 24    .byte $26, $2d, $01, $24 ;blank filler for world number
006703  2  27 D9 46 AA    .byte $27, $d9, $46, $aa ;attribute data
006707  2  27 E1 45 AA    .byte $27, $e1, $45, $aa
00670B  2  00             .byte $00
00670C  2               
00670C  2               WarpZoneNumbers:
00670C  2  02 03 04 01    .byte $02, $03, $04, $01, $06, $07, $08, $05, $0b, $0c, $0d
006710  2  06 07 08 05  
006714  2  0B 0C 0D     
006717  2               
006717  2               GameTextOffsets:
006717  2  00              .byte <(TopStatusBarLine-GameText)
006718  2  27              .byte <(WorldLivesDisplay-GameText)
006719  2  46              .byte <(TimeUp-GameText)
00671A  2  51              .byte <(GameOver-GameText)
00671B  2               
00671B  2               WriteGameText:
00671B  2  48                          pha                       ;save text number to stack and use as offset
00671C  2  A8                          tay
00671D  2  BE 17 67                    ldx GameTextOffsets,y     ;get offset to game text we want to print
006720  2  A0 00                       ldy #$00
006722  2  BD 72 66     GameTextLoop:  lda GameText,x            ;load game text data
006725  2  C9 FF                       cmp #$ff                  ;check for terminator
006727  2  F0 07                       beq EndGameText           ;branch to end text if found
006729  2  99 01 03                    sta VRAM_Buffer1,y        ;otherwise write data to buffer
00672C  2  E8                          inx                       ;and increment increment
00672D  2  C8                          iny
00672E  2  D0 F2                       bne GameTextLoop          ;do this for 256 bytes if no terminator found
006730  2  A9 00        EndGameText:   lda #$00                  ;put null terminator at end
006732  2  99 01 03                    sta VRAM_Buffer1,y
006735  2  68                          pla                       ;pull original text number from stack
006736  2  F0 25                       beq ExWGT                 ;if printing top status bar, branch to leave
006738  2  AA                          tax
006739  2  CA                          dex                       ;if printing anything else besides world/lives display
00673A  2  D0 21                       bne ExWGT                 ;then branch to leave
00673C  2  AD 5A 07                    lda NumberofLives         ;otherwise, check number of lives
00673F  2  18                          clc                       ;and increment by one for display
006740  2  69 01                       adc #$01
006742  2  C9 0A                       cmp #10                   ;more than 9 lives?
006744  2  90 07                       bcc PutLives
006746  2  E9 0A                       sbc #10                   ;if so, subtract 10 and put a crown tile
006748  2  A0 9F                       ldy #$9f                  ;next to the difference...strange things happen if
00674A  2  8C 08 03                    sty VRAM_Buffer1+7        ;the number of lives exceeds 19
00674D  2  8D 09 03     PutLives:      sta VRAM_Buffer1+8
006750  2  20 E6 65                    jsr GetWorldNumForDisplay ;get world number or letter
006753  2  8D 14 03                    sta VRAM_Buffer1+19
006756  2  AC 5C 07                    ldy LevelNumber
006759  2  C8                          iny
00675A  2  8C 16 03                    sty VRAM_Buffer1+21       ;we're done here
00675D  2  60           ExWGT:         rts
00675E  2               
00675E  2               WriteWarpZoneMessage:
00675E  2  48                    pha                   ;save warp zone control temporarily
00675F  2  A0 FF                 ldy #$ff
006761  2  C8           WZMLoop: iny
006762  2  B9 E7 66              lda WarpZone,y        ;write warp zone message to VRAM buffer
006765  2  99 01 03              sta VRAM_Buffer1,y
006768  2  D0 F7                 bne WZMLoop
00676A  2  68                    pla
00676B  2  38                    sec
00676C  2  E9 80                 sbc #$80              ;clear d7 of warp zone control, use as offset
00676E  2  AA                    tax
00676F  2  BD 0C 67              lda WarpZoneNumbers,x ;replace blank tile with world number
006772  2  8D 1C 03              sta VRAM_Buffer1+27   ;that the warp zone leads to
006775  2  A9 24                 lda #$24              ;set VRAM offset after the contents
006777  2  4C 94 65              jmp SetVRAMOffset     ;in case anything else needs to go in there
00677A  2               
00677A  2               ResetSpritesAndScreenTimer:
00677A  2  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
00677D  2  D0 0B                 bne NoReset                 ;if not, branch to leave
00677F  2  20 87 62              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
006782  2               
006782  2               ResetScreenTimer:
006782  2  A9 07                 lda #$07                    ;reset timer again
006784  2  8D A0 07              sta ScreenTimer
006787  2  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
00678A  2  60           NoReset: rts
00678B  2               
00678B  2               ;-------------------------------------------------------------------------------------
00678B  2               ;$00 - temp vram buffer offset
00678B  2               ;$01 - temp metatile buffer offset
00678B  2               ;$02 - temp metatile graphics table offset
00678B  2               ;$03 - used to store attribute bits
00678B  2               ;$04 - used to determine attribute table row
00678B  2               ;$05 - used to determine attribute table column
00678B  2               ;$06 - metatile graphics table address low
00678B  2               ;$07 - metatile graphics table address high
00678B  2               
00678B  2               RenderAreaGraphics:
00678B  2  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
00678E  2  29 01                    and #$01
006790  2  85 05                    sta $05
006792  2  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
006795  2  84 00                    sty $00
006797  2  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
00679A  2  99 42 03                 sta VRAM_Buffer2+1,y
00679D  2  AD 20 07                 lda CurrentNTAddr_High
0067A0  2  99 41 03                 sta VRAM_Buffer2,y
0067A3  2  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
0067A5  2  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
0067A8  2  A9 00                    lda #$00                     ;init attribute row
0067AA  2  85 04                    sta $04
0067AC  2  AA                       tax
0067AD  2  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
0067AF  2  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
0067B2  2  29 C0                    and #%11000000
0067B4  2  85 03                    sta $03                      ;store attribute table bits here
0067B6  2  0A                       asl                          ;note that metatile format is:
0067B7  2  2A                       rol                          ;%xx000000 - attribute table bits,
0067B8  2  2A                       rol                          ;%00xxxxxx - metatile number
0067B9  2  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
0067BA  2  B9 E5 69                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
0067BD  2  85 06                    sta $06
0067BF  2  B9 E9 69                 lda MetatileGraphics_High,y
0067C2  2  85 07                    sta $07
0067C4  2  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
0067C7  2  0A                       asl                          ;multiply by 4 and use as tile offset
0067C8  2  0A                       asl
0067C9  2  85 02                    sta $02
0067CB  2  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
0067CE  2  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
0067D0  2  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
0067D2  2  0A                       asl                          ;then add to the tile offset so we can draw either side
0067D3  2  65 02                    adc $02                      ;of the metatiles
0067D5  2  A8                       tay
0067D6  2  A6 00                    ldx $00                      ;use vram buffer offset from before as X
0067D8  2  B1 06                    lda ($06),y
0067DA  2  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
0067DD  2  C8                       iny
0067DE  2  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
0067E0  2  9D 45 03                 sta VRAM_Buffer2+4,x
0067E3  2  A4 04                    ldy $04                      ;get current attribute row
0067E5  2  A5 05                    lda $05                      ;get LSB of current column where we're at, and
0067E7  2  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
0067E9  2  A5 01                    lda $01                      ;get current row we're rendering
0067EB  2  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
0067EC  2  B0 19                    bcs LLeft
0067EE  2  26 03                    rol $03                      ;rotate attribute bits 3 to the left
0067F0  2  26 03                    rol $03                      ;thus in d1-d0, for upper left square
0067F2  2  26 03                    rol $03
0067F4  2  4C 0D 68                 jmp SetAttrib
0067F7  2  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
0067F9  2  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
0067FA  2  B0 0F                    bcs NextMTRow
0067FC  2  46 03                    lsr $03                      ;shift attribute bits 4 to the right
0067FE  2  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
006800  2  46 03                    lsr $03
006802  2  46 03                    lsr $03
006804  2  4C 0D 68                 jmp SetAttrib
006807  2  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
006809  2  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
00680B  2  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
00680D  2  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
006810  2  05 03                    ora $03                      ;if any, and put new bits, if any, onto
006812  2  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
006815  2  E6 00                    inc $00                      ;increment vram buffer offset by 2
006817  2  E6 00                    inc $00
006819  2  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
00681B  2  E8                       inx                          ;the bottom of the screen
00681C  2  E0 0D                    cpx #$0d
00681E  2  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
006820  2  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
006822  2  C8                       iny                          ;(for name table address and length bytes)
006823  2  C8                       iny
006824  2  C8                       iny
006825  2  A9 00                    lda #$00
006827  2  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
00682A  2  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
00682D  2  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
006830  2  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
006833  2  29 1F                    and #%00011111               ;if no wraparound, just skip this part
006835  2  D0 0D                    bne ExitDrawM
006837  2  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
006839  2  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
00683C  2  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
00683F  2  49 04                    eor #%00000100               ;to move onto the next appropriate name table
006841  2  8D 20 07                 sta CurrentNTAddr_High
006844  2  4C 9A 68     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set VRAM address controller
006847  2               
006847  2               RenderAttributeTables:
006847  2  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
00684A  2  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
00684C  2  38                        sec                      ;subtract four
00684D  2  E9 04                     sbc #$04
00684F  2  29 1F                     and #%00011111           ;mask out bits again and store
006851  2  85 01                     sta $01
006853  2  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
006856  2  B0 02                     bcs SetATHigh
006858  2  49 04                     eor #%00000100           ;otherwise invert d2
00685A  2  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
00685C  2  09 23                     ora #$23                 ;add $2300 (for attribute table) to the high byte
00685E  2  85 00                     sta $00
006860  2  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
006862  2  4A                        lsr                      ;attribute table and store
006863  2  4A                        lsr
006864  2  69 C0                     adc #$c0                 ;we should now have the appropriate block of
006866  2  85 01                     sta $01                  ;attribute table in our temp address
006868  2  A2 00                     ldx #$00
00686A  2  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
00686D  2  A5 00        AttribLoop:  lda $00
00686F  2  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
006872  2  A5 01                     lda $01
006874  2  18                        clc                      ;get low byte, add 8 because we want to start
006875  2  69 08                     adc #$08                 ;below the status bar, and store
006877  2  99 42 03                  sta VRAM_Buffer2+1,y
00687A  2  85 01                     sta $01                  ;also store in temp again
00687C  2  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
00687F  2  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
006882  2  A9 01                     lda #$01
006884  2  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
006887  2  4A                        lsr
006888  2  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
00688B  2  C8                        iny                      ;increment buffer offset by 4 bytes
00688C  2  C8                        iny
00688D  2  C8                        iny
00688E  2  C8                        iny
00688F  2  E8                        inx                      ;increment attribute offset and check to see
006890  2  E0 07                     cpx #$07                 ;if we're at the end yet
006892  2  90 D9                     bcc AttribLoop
006894  2  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
006897  2  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
00689A  2  A9 06        SetVRAMCtrl: lda #$06
00689C  2  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set VRAM address controller to second VRAM buffer
00689F  2  60                        rts
0068A0  2               
0068A0  2               ;-------------------------------------------------------------------------------------
0068A0  2               ;$00 - used as temporary counter in ColorRotation
0068A0  2               
0068A0  2               ColorRotatePalette:
0068A0  2  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
0068A4  2  07 17        
0068A6  2               
0068A6  2               BlankPalette:
0068A6  2  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
0068AA  2  FF FF FF 00  
0068AE  2               
0068AE  2               ;used based on area type
0068AE  2               Palette3Data:
0068AE  2  0F 07 12 0F         .byte $0f, $07, $12, $0f
0068B2  2  0F 07 17 0F         .byte $0f, $07, $17, $0f
0068B6  2  0F 07 17 1C         .byte $0f, $07, $17, $1c
0068BA  2  0F 07 17 00         .byte $0f, $07, $17, $00
0068BE  2               
0068BE  2               ColorRotation:
0068BE  2  A5 09                      lda FrameCounter         ;get frame counter
0068C0  2  29 07                      and #$07                 ;mask out all but three LSB
0068C2  2  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
0068C4  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
0068C7  2  E0 31                      cpx #$31
0068C9  2  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
0068CB  2  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
0068CC  2  B9 A6 68     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
0068CF  2  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
0068D2  2  E8                         inx                      ;increment offsets
0068D3  2  C8                         iny
0068D4  2  C0 08                      cpy #$08
0068D6  2  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
0068D8  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0068DB  2  A9 03                      lda #$03
0068DD  2  85 00                      sta $00                  ;set counter here
0068DF  2  AD 4E 07                   lda AreaType             ;get area type
0068E2  2  0A                         asl                      ;multiply by 4 to get proper offset
0068E3  2  0A                         asl
0068E4  2  A8                         tay                      ;save as offset here
0068E5  2  B9 AE 68     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
0068E8  2  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
0068EB  2  C8                         iny
0068EC  2  E8                         inx
0068ED  2  C6 00                      dec $00                  ;decrement counter
0068EF  2  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
0068F1  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0068F4  2  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
0068F7  2  B9 A0 68                   lda ColorRotatePalette,y
0068FA  2  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
0068FD  2  AD 00 03                   lda VRAM_Buffer1_Offset
006900  2  18                         clc                      ;add seven bytes to vram buffer offset
006901  2  69 07                      adc #$07
006903  2  8D 00 03                   sta VRAM_Buffer1_Offset
006906  2  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
006909  2  AD D4 06                   lda ColorRotateOffset
00690C  2  C9 06                      cmp #$06                 ;check to see if it's still in range
00690E  2  90 05                      bcc ExitColorRot         ;if so, branch to leave
006910  2  A9 00                      lda #$00
006912  2  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
006915  2  60           ExitColorRot: rts                      ;leave
006916  2               
006916  2               ;-------------------------------------------------------------------------------------
006916  2               ;$00 - temp store for offset control bit
006916  2               ;$01 - temp vram buffer offset
006916  2               ;$02 - temp store for vertical high nybble in block buffer routine
006916  2               ;$03 - temp adder for high byte of name table address
006916  2               ;$04, $05 - name table address low/high
006916  2               ;$06, $07 - block buffer address low/high
006916  2               
006916  2               BlockGfxData:
006916  2  45 45 47 47         .byte $45, $45, $47, $47
00691A  2  47 47 47 47         .byte $47, $47, $47, $47
00691E  2  57 58 59 5A         .byte $57, $58, $59, $5a
006922  2  24 24 24 24         .byte $24, $24, $24, $24
006926  2  26 26 26 26         .byte $26, $26, $26, $26
00692A  2               
00692A  2               RemoveCoin_Axe:
00692A  2  A0 41                      ldy #$41                 ;set low byte so offset points to second vram buffer
00692C  2  A9 03                      lda #$03                 ;load offset for default blank metatile
00692E  2  AE 4E 07                   ldx AreaType             ;check area type
006931  2  D0 02                      bne WriteBlankMT         ;if not water type, use offset
006933  2  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
006935  2  20 74 69     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
006938  2  A9 06                      lda #$06
00693A  2  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to second vram buffer and leave
00693D  2  60                         rts
00693E  2               
00693E  2               ReplaceBlockMetatile:
00693E  2  20 4A 69            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
006941  2  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
006944  2  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
006947  2  60                  rts                       ;leave
006948  2               
006948  2               DestroyBlockMetatile:
006948  2  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
00694A  2               
00694A  2               WriteBlockMetatile:
00694A  2  A0 03                     ldy #$03                ;load offset for blank metatile
00694C  2  C9 00                     cmp #$00                ;check contents of A for blank metatile
00694E  2  F0 14                     beq UseBOffset          ;branch if found (unconditional if destroying metatile)
006950  2  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
006952  2  C9 56                     cmp #$56
006954  2  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
006956  2  C9 4F                     cmp #$4f
006958  2  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
00695A  2  C8                        iny                     ;increment offset for brick metatile w/o line
00695B  2  C9 5C                     cmp #$5c
00695D  2  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
00695F  2  C9 50                     cmp #$50
006961  2  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
006963  2  C8                        iny                     ;if any other metatile, increment offset for empty block
006964  2  98           UseBOffset:  tya                     ;put Y in A
006965  2  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
006968  2  C8                        iny                     ;move onto next byte
006969  2  20 74 69                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
00696C  2  88           MoveVOffset: dey                     ;decrement vram buffer offset
00696D  2  98                        tya                     ;add 10 bytes to it
00696E  2  18                        clc
00696F  2  69 0A                     adc #10
006971  2  4C 94 65                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
006974  2               
006974  2               PutBlockMetatile:
006974  2  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
006976  2  84 01                    sty $01               ;store vram buffer offset for next byte
006978  2  0A                       asl
006979  2  0A                       asl                   ;multiply A by four and use as X
00697A  2  AA                       tax
00697B  2  A0 20                    ldy #$20              ;load high byte for name table 0
00697D  2  A5 06                    lda $06               ;get low byte of block buffer pointer
00697F  2  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
006981  2  90 02                    bcc SaveHAdder        ;if not, use current high byte
006983  2  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
006985  2  84 03        SaveHAdder: sty $03               ;save high byte here
006987  2  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
006989  2  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
00698A  2  85 04                    sta $04               ;and then store it here
00698C  2  A9 00                    lda #$00
00698E  2  85 05                    sta $05               ;initialize temp high byte
006990  2  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
006992  2  18                       clc
006993  2  69 20                    adc #$20              ;add 32 pixels for the status bar
006995  2  0A                       asl
006996  2  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
006998  2  0A                       asl
006999  2  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
00699B  2  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
00699D  2  85 04                    sta $04               ;and store here
00699F  2  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
0069A1  2  69 00                    adc #$00              ;add carry
0069A3  2  18                       clc
0069A4  2  65 03                    adc $03               ;then add high byte of name table
0069A6  2  85 05                    sta $05               ;store here
0069A8  2  A4 01                    ldy $01               ;get vram buffer offset to be used
0069AA  2  BD 16 69     RemBridge:  lda BlockGfxData,x    ;write top left and top right
0069AD  2  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
0069B0  2  BD 17 69                 lda BlockGfxData+1,x
0069B3  2  99 04 03                 sta VRAM_Buffer1+3,y
0069B6  2  BD 18 69                 lda BlockGfxData+2,x  ;write bottom left and bottom
0069B9  2  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
0069BC  2  BD 19 69                 lda BlockGfxData+3,x  ;second spot
0069BF  2  99 09 03                 sta VRAM_Buffer1+8,y
0069C2  2  A5 04                    lda $04
0069C4  2  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
0069C7  2  18                       clc                   ;into first slot as read
0069C8  2  69 20                    adc #$20              ;add 32 bytes to value
0069CA  2  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
0069CD  2  A5 05                    lda $05               ;plus 32 bytes into second slot
0069CF  2  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
0069D2  2  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
0069D5  2  A9 02                    lda #$02
0069D7  2  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
0069DA  2  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
0069DD  2  A9 00                    lda #$00
0069DF  2  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
0069E2  2  A6 00                    ldx $00               ;get offset control bit here
0069E4  2  60                       rts                   ;and leave
0069E5  2               
0069E5  2               ;-------------------------------------------------------------------------------------
0069E5  2               ;METATILE GRAPHICS TABLE
0069E5  2               
0069E5  2               MetatileGraphics_Low:
0069E5  2  ED 7D 3D 71    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
0069E9  2               
0069E9  2               MetatileGraphics_High:
0069E9  2  69 6A 6B 6B    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
0069ED  2               
0069ED  2               Palette0_MTiles:
0069ED  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank
0069F1  2  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
0069F5  2  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
0069F9  2  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
0069FD  2  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
006A01  2  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
006A05  2  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
006A09  2  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
006A0D  2  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
006A11  2  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
006A15  2  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
006A19  2  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
006A1D  2  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
006A21  2  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
006A25  2  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
006A29  2  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
006A2D  2  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
006A31  2  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
006A35  2  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
006A39  2  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
006A3D  2  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
006A41  2  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
006A45  2  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
006A49  2  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
006A4D  2  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
006A51  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
006A55  2  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
006A59  2  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
006A5D  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
006A61  2  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
006A65  2  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
006A69  2  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
006A6D  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
006A71  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
006A75  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
006A79  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
006A7D  2               
006A7D  2               Palette1_MTiles:
006A7D  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
006A81  2  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
006A85  2  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
006A89  2  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
006A8D  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
006A91  2  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
006A95  2  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
006A99  2  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
006A9D  2  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
006AA1  2  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
006AA5  2  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
006AA9  2  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
006AAD  2  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
006AB1  2  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
006AB5  2  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
006AB9  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
006ABD  2  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
006AC1  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
006AC5  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
006AC9  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (poison shroom)
006ACD  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
006AD1  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
006AD5  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
006AD9  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
006ADD  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
006AE1  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (poison shroom)
006AE5  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
006AE9  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
006AED  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
006AF1  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
006AF5  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
006AF9  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
006AFD  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (poison shroom)
006B01  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (power-up)
006B05  2  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
006B09  2  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
006B0D  2  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
006B11  2  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
006B15  2  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
006B19  2  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
006B1D  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
006B21  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
006B25  2  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
006B29  2  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
006B2D  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (not used)
006B31  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
006B35  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
006B39  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
006B3D  2               
006B3D  2               Palette2_MTiles:
006B3D  2  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
006B41  2  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
006B45  2  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
006B49  2  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
006B4D  2  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
006B51  2  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
006B55  2  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
006B59  2  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
006B5D  2  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
006B61  2  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
006B65  2  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;cloud ledge left edge
006B69  2  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;cloud ledge middle
006B6D  2  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;cloud ledge right edge
006B71  2               
006B71  2               Palette3_MTiles:
006B71  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
006B75  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
006B79  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (poison shroom)
006B7D  2  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
006B81  2  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
006B85  2  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
006B89  2  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
006B8D  2               
006B8D  2               ;------------------------------------------------------------------------------------
006B8D  2               
006B8D  2               WaterPaletteData:
006B8D  2  3F 00 20       .byte $3f, $00, $20
006B90  2  0F 15 12 25    .byte $0f, $15, $12, $25
006B94  2  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
006B98  2  0F 30 12 0F    .byte $0f, $30, $12, $0f
006B9C  2  0F 27 12 0F    .byte $0f, $27, $12, $0f
006BA0  2  22 16 27 18    .byte $22, $16, $27, $18
006BA4  2  0F 10 30 27    .byte $0f, $10, $30, $27
006BA8  2  0F 16 30 27    .byte $0f, $16, $30, $27
006BAC  2  0F 0F 30 10    .byte $0f, $0f, $30, $10
006BB0  2  00             .byte $00
006BB1  2               
006BB1  2               GroundPaletteData:
006BB1  2  3F 00 20       .byte $3f, $00, $20
006BB4  2  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
006BB8  2  0F 36 17 0F    .byte $0f, $36, $17, $0f
006BBC  2  0F 30 21 0F    .byte $0f, $30, $21, $0f
006BC0  2  0F 27 17 0F    .byte $0f, $27, $17, $0f
006BC4  2  0F 16 27 18    .byte $0f, $16, $27, $18
006BC8  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
006BCC  2  0F 16 30 27    .byte $0f, $16, $30, $27
006BD0  2  0F 0F 36 17    .byte $0f, $0f, $36, $17
006BD4  2  00             .byte $00
006BD5  2               
006BD5  2               UndergroundPaletteData:
006BD5  2  3F 00 20       .byte $3f, $00, $20
006BD8  2  0F 29 1A 09    .byte $0f, $29, $1a, $09
006BDC  2  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
006BE0  2  0F 30 21 1C    .byte $0f, $30, $21, $1c
006BE4  2  0F 27 17 1C    .byte $0f, $27, $17, $1c
006BE8  2  0F 16 27 18    .byte $0f, $16, $27, $18
006BEC  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
006BF0  2  0F 16 30 27    .byte $0f, $16, $30, $27
006BF4  2  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
006BF8  2  00             .byte $00
006BF9  2               
006BF9  2               CastlePaletteData:
006BF9  2  3F 00 20       .byte $3f, $00, $20
006BFC  2  0F 30 10 00    .byte $0f, $30, $10, $00
006C00  2  0F 30 10 00    .byte $0f, $30, $10, $00
006C04  2  0F 30 16 00    .byte $0f, $30, $16, $00
006C08  2  0F 27 17 00    .byte $0f, $27, $17, $00
006C0C  2  0F 16 27 18    .byte $0f, $16, $27, $18
006C10  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
006C14  2  0F 16 30 27    .byte $0f, $16, $30, $27
006C18  2  0F 00 30 10    .byte $0f, $00, $30, $10
006C1C  2  00             .byte $00
006C1D  2               
006C1D  2               DaySnowPaletteData:
006C1D  2  3F 00 04       .byte $3f, $00, $04
006C20  2  22 30 00 10    .byte $22, $30, $00, $10
006C24  2  00             .byte $00
006C25  2               
006C25  2               NightSnowPaletteData:
006C25  2  3F 00 04       .byte $3f, $00, $04
006C28  2  0F 30 00 10    .byte $0f, $30, $00, $10
006C2C  2  00             .byte $00
006C2D  2               
006C2D  2               MushroomPaletteData:
006C2D  2  3F 00 04       .byte $3f, $00, $04
006C30  2  22 27 16 0F    .byte $22, $27, $16, $0f
006C34  2  00             .byte $00
006C35  2               
006C35  2               BowserPaletteData:
006C35  2  3F 14 04       .byte $3f, $14, $04
006C38  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
006C3C  2  00             .byte $00
006C3D  2               
006C3D  2               ThankYouMessage:
006C3D  2  25 48 10       .byte $25, $48, $10
006C40  2  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24, $22, $18
006C44  2  14 24 22 18  
006C48  2  1E 24 16 0A    .byte $1e, $24, $16, $0a, $1b, $12, $18, $2b
006C4C  2  1B 12 18 2B  
006C50  2  00             .byte $00
006C51  2               
006C51  2               MushroomRetainerMsg:
006C51  2  25 C5 16       .byte $25, $c5, $16
006C54  2  0B 1E 1D 24    .byte $0b, $1e, $1d, $24, $18, $1e, $1b, $24
006C58  2  18 1E 1B 24  
006C5C  2  19 1B 12 17    .byte $19, $1b, $12, $17, $0c, $0e, $1c, $1c
006C60  2  0C 0E 1C 1C  
006C64  2  24 12 1C 24    .byte $24, $12, $1c, $24, $12, $17
006C68  2  12 17        
006C6A  2  26 05 0F       .byte $26, $05, $0f
006C6D  2  0A 17 18 1D    .byte $0a, $17, $18, $1d, $11, $0e, $1b, $24
006C71  2  11 0E 1B 24  
006C75  2  0C 0A 1C 1D    .byte $0c, $0a, $1c, $1d, $15, $0e, $2b
006C79  2  15 0E 2B     
006C7C  2  00             .byte $00
006C7D  2               
006C7D  2               ;------------------------------------------------------------------------------------
006C7D  2               
006C7D  2               JumpEngine:
006C7D  2  0A                  asl          ;shift bit from contents of A
006C7E  2  A8                  tay
006C7F  2  68                  pla          ;pull saved return address from stack
006C80  2  85 04               sta $04      ;save to indirect
006C82  2  68                  pla
006C83  2  85 05               sta $05
006C85  2  C8                  iny
006C86  2  B1 04               lda ($04),y  ;load pointer from indirect
006C88  2  85 06               sta $06      ;note that if an RTS is performed in next routine
006C8A  2  C8                  iny          ;it will return to the execution before the sub
006C8B  2  B1 04               lda ($04),y  ;that called this routine
006C8D  2  85 07               sta $07
006C8F  2  6C 06 00            jmp ($0006)  ;jump to the address we loaded
006C92  2               
006C92  2               ;------------------------------------------------------------------------------------
006C92  2               
006C92  2               InitializeNameTables:
006C92  2  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
006C95  2  AD 78 07                   lda Mirror_PPU_CTRL       ;load mirror of first ppu control reg
006C98  2  09 10                      ora #%00010000            ;set sprites for first 4k and background for second 4k
006C9A  2  29 F0                      and #%11110000            ;clear rest of lower nybble, leave higher alone
006C9C  2  20 66 6D                   jsr WritePPUReg1
006C9F  2  A9 24                      lda #$24                  ;set vram address to start of name table 1
006CA1  2  20 A6 6C                   jsr WriteNTAddr
006CA4  2  A9 20                      lda #$20                  ;and then set it to name table 0
006CA6  2  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
006CA9  2  A9 00                      lda #$00
006CAB  2  8D 06 20                   sta PPU_ADDRESS
006CAE  2  A2 04                      ldx #$04                  ;clear name table with blank tile $24
006CB0  2  A0 C0                      ldy #$c0
006CB2  2  A9 24                      lda #$24
006CB4  2  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
006CB7  2  88                         dey
006CB8  2  D0 FA                      bne InitNTLoop
006CBA  2  CA                         dex
006CBB  2  D0 F7                      bne InitNTLoop
006CBD  2  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
006CBF  2  8A                         txa
006CC0  2  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
006CC3  2  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
006CC6  2  8D 07 20     InitATLoop:   sta PPU_DATA
006CC9  2  88                         dey
006CCA  2  D0 FA                      bne InitATLoop
006CCC  2  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
006CCF  2  8D 40 07                   sta VerticalScroll
006CD2  2  4C 5F 6D                   jmp InitScroll            ;initialize scroll registers to zero
006CD5  2               
006CD5  2               ;------------------------------------------------------------------------------------
006CD5  2               
006CD5  2               ReadJoypads:
006CD5  2  A9 01                      lda #$01               ;reset and clear strobe of joypad ports
006CD7  2  8D 16 40                   sta JOYPAD_PORT
006CDA  2  4A                         lsr
006CDB  2  AA                         tax                    ;start with joypad 1's port
006CDC  2  8D 16 40                   sta JOYPAD_PORT
006CDF  2  20 E3 6C                   jsr ReadPortBits
006CE2  2  E8                         inx                    ;increment for joypad 2's port
006CE3  2  A0 08        ReadPortBits: ldy #$08
006CE5  2  48           PortLoop:     pha                    ;push previous bit onto stack
006CE6  2  BD 16 40                   lda JOYPAD_PORT,x      ;read current bit on joypad port
006CE9  2  85 00                      sta $00                ;check d1 and d0 of port output
006CEB  2  4A                         lsr                    ;this is necessary on the old
006CEC  2  05 00                      ora $00                ;famicom systems in japan
006CEE  2  4A                         lsr
006CEF  2  68                         pla                    ;read bits from stack
006CF0  2  2A                         rol                    ;rotate bit from carry flag
006CF1  2  88                         dey
006CF2  2  D0 F1                      bne PortLoop           ;count down bits left
006CF4  2  9D FC 06                   sta SavedJoypadBits,x  ;save controller status here always
006CF7  2  48                         pha
006CF8  2  29 30                      and #%00110000         ;check for select or start
006CFA  2  3D 4A 07                   and JoypadBitMask,x    ;if neither saved state nor current state
006CFD  2  F0 07                      beq Save8Bits          ;have any of these two set, branch
006CFF  2  68                         pla
006D00  2  29 CF                      and #%11001111         ;otherwise store without select
006D02  2  9D FC 06                   sta SavedJoypadBits,x  ;or start bits and leave
006D05  2  60                         rts
006D06  2  68           Save8Bits:    pla
006D07  2  9D 4A 07                   sta JoypadBitMask,x    ;save with all bits in another place and leave
006D0A  2  60                         rts
006D0B  2               
006D0B  2               ;------------------------------------------------------------------------------------
006D0B  2               
006D0B  2               WriteBufferToScreen:
006D0B  2  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
006D0E  2  C8                          iny
006D0F  2  B1 00                       lda ($00),y               ;load next byte (second)
006D11  2  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
006D14  2  C8                          iny
006D15  2  B1 00                       lda ($00),y               ;load next byte (third)
006D17  2  0A                          asl                       ;shift to left and save in stack
006D18  2  48                          pha
006D19  2  AD 78 07                    lda Mirror_PPU_CTRL
006D1C  2  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
006D1E  2  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
006D20  2  29 FB                       and #%11111011            ;only increment by 1
006D22  2  20 66 6D     SetupWrites:   jsr WritePPUReg1          ;write to register
006D25  2  68                          pla                       ;pull from stack and shift to left again
006D26  2  0A                          asl
006D27  2  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
006D29  2  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
006D2B  2  C8                          iny
006D2C  2  4A           GetLength:     lsr                       ;shift back to the right to get proper length
006D2D  2  4A                          lsr                       ;note that d1 will now be in carry
006D2E  2  AA                          tax
006D2F  2  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
006D31  2  C8                          iny                       ;otherwise increment Y to load next byte
006D32  2  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
006D34  2  8D 07 20                    sta PPU_DATA
006D37  2  CA                          dex                       ;done writing?
006D38  2  D0 F5                       bne OutputToVRAM
006D3A  2  38                          sec
006D3B  2  98                          tya
006D3C  2  65 00                       adc $00                   ;add end length plus one to the indirect at $00
006D3E  2  85 00                       sta $00                   ;to allow this routine to read another set of updates
006D40  2  A9 00                       lda #$00
006D42  2  65 01                       adc $01
006D44  2  85 01                       sta $01
006D46  2  A9 3F                       lda #$3f                  ;sets vram address to palette memory
006D48  2  8D 06 20                    sta PPU_ADDRESS
006D4B  2  A9 00                       lda #$00
006D4D  2  8D 06 20                    sta PPU_ADDRESS
006D50  2  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
006D53  2  8D 06 20                    sta PPU_ADDRESS
006D56  2  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
006D59  2  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
006D5B  2  B1 00                       lda ($00),y
006D5D  2  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
006D5F  2  8D 05 20     InitScroll:    sta PPU_SCROLL            ;store contents of A into scroll registers
006D62  2  8D 05 20                    sta PPU_SCROLL            ;and end whatever subroutine led us here
006D65  2  60                          rts
006D66  2               
006D66  2               ;------------------------------------------------------------------------------------
006D66  2               
006D66  2               WritePPUReg1:
006D66  2  8D 00 20                   sta PPU_CTRL              ;write contents of A to PPU register 1
006D69  2  8D 78 07                   sta Mirror_PPU_CTRL       ;and its mirror
006D6C  2  60                         rts
006D6D  2               
006D6D  2               ;------------------------------------------------------------------------------------
006D6D  2               ;$00 - used to store status bar nybbles
006D6D  2               ;$02 - used as temp vram offset
006D6D  2               ;$03 - used to store length of status bar number
006D6D  2               
006D6D  2               ;status bar name table offset and length data
006D6D  2               StatusBarData:
006D6D  2  EF 06              .byte $ef, $06 ; top score display on title screen
006D6F  2  62 06              .byte $62, $06 ; player score
006D71  2  6D 02              .byte $6d, $02 ; coin tally
006D73  2  7A 03              .byte $7a, $03 ; game timer
006D75  2               
006D75  2               StatusBarOffset:
006D75  2  06 0C 12 18        .byte $06, $0c, $12, $18
006D79  2               
006D79  2               PrintStatusBarNumbers:
006D79  2  85 00              sta $00            ;store player-specific offset
006D7B  2  20 84 6D           jsr OutputNumbers  ;use first nybble to print the coin display
006D7E  2  A5 00              lda $00            ;move high nybble to low
006D80  2  4A                 lsr                ;and print the score display
006D81  2  4A                 lsr
006D82  2  4A                 lsr
006D83  2  4A                 lsr
006D84  2               
006D84  2               OutputNumbers:
006D84  2  18                        clc                      ;add 1 to low nybble
006D85  2  69 01                     adc #$01
006D87  2  29 0F                     and #%00001111           ;mask out high nybble
006D89  2  C9 06                     cmp #$06
006D8B  2  B0 44                     bcs ExitOutputN
006D8D  2  48                        pha                      ;save incremented value to stack for now and
006D8E  2  0A                        asl                      ;multiply by 2 to use as offset
006D8F  2  A8                        tay
006D90  2  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
006D93  2  A9 20                     lda #$20                 ;put at top of screen by default
006D95  2  C0 00                     cpy #$00                 ;are we writing top score on title screen?
006D97  2  D0 02                     bne SetupNums
006D99  2  A9 22                     lda #$22                 ;if so, put further down on the screen
006D9B  2  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
006D9E  2  B9 6D 6D                  lda StatusBarData,y      ;write vram address low and length of thing
006DA1  2  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
006DA4  2  B9 6E 6D                  lda StatusBarData+1,y
006DA7  2  9D 03 03                  sta VRAM_Buffer1+2,x
006DAA  2  85 03                     sta $03                  ;save length byte in counter
006DAC  2  86 02                     stx $02                  ;and buffer pointer elsewhere for now
006DAE  2  68                        pla                      ;pull original incremented value from stack
006DAF  2  AA                        tax
006DB0  2  BD 75 6D                  lda StatusBarOffset,x    ;load offset to value we want to write
006DB3  2  38                        sec
006DB4  2  F9 6E 6D                  sbc StatusBarData+1,y    ;subtract from length byte we read before
006DB7  2  A8                        tay                      ;use value as offset to display digits
006DB8  2  A6 02                     ldx $02
006DBA  2  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
006DBD  2  9D 04 03                  sta VRAM_Buffer1+3,x
006DC0  2  E8                        inx
006DC1  2  C8                        iny
006DC2  2  C6 03                     dec $03                  ;do this until all the digits are written
006DC4  2  D0 F4                     bne DigitPLoop
006DC6  2  A9 00                     lda #$00                 ;put null terminator at end
006DC8  2  9D 04 03                  sta VRAM_Buffer1+3,x
006DCB  2  E8                        inx                      ;increment buffer pointer by 3
006DCC  2  E8                        inx
006DCD  2  E8                        inx
006DCE  2  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
006DD1  2  60           ExitOutputN: rts
006DD2  2               
006DD2  2               DigitsMathRoutine:
006DD2  2  AD 70 07                 lda OperMode              ;check mode of operation
006DD5  2  F0 16                    beq EraseDMods            ;if in attract mode, branch to lock score
006DD7  2  A2 05                    ldx #$05
006DD9  2  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
006DDC  2  18                       clc
006DDD  2  79 D7 07                 adc DisplayDigits,y       ;add to current digit
006DE0  2  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
006DE2  2  C9 0A                    cmp #10
006DE4  2  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
006DE6  2  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
006DE9  2  88                       dey                       ;move onto next digits in score or game timer
006DEA  2  CA                       dex                       ;and digit amounts to increment
006DEB  2  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
006DED  2  A9 00        EraseDMods: lda #$00                  ;now we need to erase the digit modifiers
006DEF  2  A2 06                    ldx #$06                  ;start with the last digit
006DF1  2  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
006DF4  2  CA                       dex
006DF5  2  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
006DF7  2  60                       rts
006DF8  2               
006DF8  2  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
006DFB  2  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
006DFD  2  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
006DFF  2  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
006E00  2  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
006E02  2  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
006E05  2  4C E6 6D                 jmp StoreNewD             ;go back to just after we branched here
006E08  2               
006E08  2               UpdateTopScore:
006E08  2  A2 05                      ldx #$05                 ;start with the lowest digit
006E0A  2  A0 05                      ldy #$05
006E0C  2  38                         sec
006E0D  2  BD DD 07     GetScoreDiff: lda PlayerScoreDisplay,x ;subtract the regular score digit from each high score digit
006E10  2  F9 D7 07                   sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
006E13  2  CA                         dex                      ;the player score digit, borrow will be set until a subsequent
006E14  2  88                         dey                      ;subtraction clears it (player digit is higher than top)
006E15  2  10 F6                      bpl GetScoreDiff
006E17  2  90 0E                      bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
006E19  2  E8                         inx                      ;increment X and Y once to the start of the score
006E1A  2  C8                         iny
006E1B  2  BD DD 07     CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
006E1E  2  99 D7 07                   sta TopScoreDisplay,y
006E21  2  E8                         inx
006E22  2  C8                         iny
006E23  2  C0 06                      cpy #$06                 ;do this until we have stored them all
006E25  2  90 F4                      bcc CopyScore
006E27  2  60           NoTopSc:      rts
006E28  2               
006E28  2               ;-------------------------------------------------------------------------------------
006E28  2               
006E28  2               ;unused memory
006E28  2  FF FF              .byte $ff, $ff
006E2A  2               
006E2A  2               DefaultSprOffsets:
006E2A  2  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
006E2E  2  78 90 A8 C0  
006E32  2  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
006E36  2  FC 28 2C     
006E39  2               
006E39  2               ;-------------------------------------------------------------------------------------
006E39  2               
006E39  2               InitializeArea:
006E39  2  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
006E3B  2  20 08 6F                    jsr InitializeMemory     ;this is only necessary in game mode
006E3E  2  A2 21                       ldx #$21
006E40  2  A9 00                       lda #$00
006E42  2  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out timer memory
006E45  2  CA                          dex
006E46  2  10 FA                       bpl ClrTimersLoop
006E48  2  AD 5B 07                    lda HalfwayPage
006E4B  2  AC 52 07                    ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
006E4E  2  F0 03                       beq StartPage
006E50  2  AD 51 07                    lda EntrancePage         ;otherwise use saved entry page number here
006E53  2  8D 1A 07     StartPage:     sta ScreenLeft_PageLoc   ;set as value here
006E56  2  8D 25 07                    sta CurrentPageLoc       ;also set as current page
006E59  2  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
006E5C  2  20 90 7B                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
006E5F  2  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
006E61  2  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
006E63  2  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
006E65  2  A0 24                       ldy #$24
006E67  2  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
006E6A  2  A0 80                       ldy #$80
006E6C  2  8C 21 07                    sty CurrentNTAddr_Low
006E6F  2  0A                          asl                      ;store LSB of page number in high nybble
006E70  2  0A                          asl                      ;of block buffer column position
006E71  2  0A                          asl
006E72  2  0A                          asl
006E73  2  8D A0 06                    sta BlockBufferColumnPos
006E76  2  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
006E79  2  CE 31 07                    dec AreaObjectLength+1
006E7C  2  CE 32 07                    dec AreaObjectLength+2
006E7F  2  A9 0B                       lda #$0b                 ;set value for renderer to update 12 column sets
006E81  2  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
006E84  2  20 C3 C2                    jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
006E87  2  AD FB 07                    lda HardWorldFlag        ;check to see if we're in worlds A-D
006E8A  2  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
006E8C  2  AD 5F 07                    lda WorldNumber          ;otherwise check world number
006E8F  2  C9 03                       cmp #World4              ;if less than 4, do not activate secondary
006E91  2  90 0C                       bcc CheckHalfway
006E93  2  D0 07                       bne SetSecHard           ;if not equal to, then world > 4, thus activate
006E95  2  AD 5C 07                    lda LevelNumber          ;otherwise, world 4, so check level number
006E98  2  C9 03                       cmp #Level4              ;if not 4, do not set secondary hard mode flag
006E9A  2  90 03                       bcc CheckHalfway
006E9C  2  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 4-4 and beyond
006E9F  2  AD 5B 07     CheckHalfway:  lda HalfwayPage
006EA2  2  F0 05                       beq DoneInitArea
006EA4  2  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
006EA6  2  8D 10 07                    sta PlayerEntranceCtrl
006EA9  2  A9 80        DoneInitArea:  lda #Silence             ;silence music
006EAB  2  85 FB                       sta AreaMusicQueue
006EAD  2  A9 01                       lda #$01                 ;disable screen output
006EAF  2  8D 74 07                    sta DisableScreenFlag
006EB2  2  20 41 C2                    jsr LoadPhysicsData
006EB5  2  EE 72 07                    inc OperMode_Task        ;increment task for this mode
006EB8  2  60                          rts
006EB9  2               
006EB9  2               ;-------------------------------------------------------------------------------------
006EB9  2               
006EB9  2               SecondaryGameSetup:
006EB9  2  A9 00               lda #$00
006EBB  2  8D 74 07            sta DisableScreenFlag    ;reenable screen, reset some flags
006EBE  2  8D F9 07            sta WindFlag
006EC1  2  8D F6 07            sta FlagpoleMusicFlag
006EC4  2  A8                  tay
006EC5  2  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
006EC8  2  C8                        iny
006EC9  2  D0 FA                     bne ClearVRLoop
006ECB  2  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
006ECE  2  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
006ED1  2  8D 28 07                  sta BackloadingFlag       ;clear value here
006ED4  2  A9 FF                     lda #$ff
006ED6  2  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
006ED9  2  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
006EDC  2  29 01                     and #$01
006EDE  2  8D 7A 07                  sta NameTableSelect
006EE1  2  20 2D 6F                  jsr GetAreaMusic
006EE4  2  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
006EE6  2  8D E3 06                  sta SprShuffleAmt+2
006EE9  2  A9 48                     lda #$48
006EEB  2  8D E2 06                  sta SprShuffleAmt+1
006EEE  2  A9 58                     lda #$58
006EF0  2  8D E1 06                  sta SprShuffleAmt
006EF3  2  A2 0E                     ldx #$0e                  ;load default OAM offsets
006EF5  2  BD 2A 6E     ShufAmtLoop: lda DefaultSprOffsets,x
006EF8  2  9D E4 06                  sta SprDataOffset,x
006EFB  2  CA                        dex                       ;do this until they're all set
006EFC  2  10 F7                     bpl ShufAmtLoop
006EFE  2  20 BB 70                  jsr DoNothing             ;do slightly less of nothing than in super mario bros 1
006F01  2  EE 22 07                  inc IRQUpdateFlag
006F04  2  EE 72 07                  inc OperMode_Task
006F07  2  60                        rts
006F08  2               
006F08  2               ;-------------------------------------------------------------------------------------
006F08  2               
006F08  2               InitializeMemory:
006F08  2  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
006F0A  2  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
006F0C  2  85 06                      sta $06
006F0E  2  86 07        InitPageLoop: stx $07
006F10  2  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
006F12  2  D0 08                      bne InitByte      ;if not, go ahead anyway
006F14  2  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
006F16  2  B0 06                      bcs SkipByte      ;if so, skip write
006F18  2  C0 09                      cpy #$09          ;otherwise, check to see if we're at $0100-$0108
006F1A  2  90 02                      bcc SkipByte      ;if so, skip write
006F1C  2  91 06        InitByte:     sta ($06),y       ;otherwise, initialize memory
006F1E  2  88           SkipByte:     dey
006F1F  2  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
006F21  2  D0 ED                      bne InitByteLoop
006F23  2  CA                         dex               ;go onto the next page
006F24  2  10 E8                      bpl InitPageLoop  ;do this until all desired pages of memory have been erased
006F26  2  60                         rts
006F27  2               
006F27  2               ;-------------------------------------------------------------------------------------
006F27  2               
006F27  2               MusicSelectData:
006F27  2  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
006F2B  2  10 20              .byte CloudMusic, PipeIntroMusic
006F2D  2               
006F2D  2               GetAreaMusic:
006F2D  2  AD 70 07                  lda OperMode           ;if in attract mode, leave
006F30  2  F0 23                     beq ExitGetM
006F32  2  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
006F35  2  C9 02                     cmp #$02               ;if found, branch without checking starting position
006F37  2  F0 0D                     beq ChkAreaType        ;from area object data header
006F39  2  A0 05                     ldy #$05               ;select music for pipe intro scene by default
006F3B  2  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
006F3E  2  C9 06                     cmp #$06
006F40  2  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
006F42  2  C9 07                     cmp #$07               ;start position either value $06 or $07
006F44  2  F0 0A                     beq StoreMusic
006F46  2  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
006F49  2  AD 43 07                  lda CloudTypeOverride
006F4C  2  F0 02                     beq StoreMusic         ;check for cloud type override
006F4E  2  A0 04                     ldy #$04               ;select music for cloud type level if found
006F50  2  B9 27 6F     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
006F53  2  85 FB                     sta AreaMusicQueue     ;store in queue and leave
006F55  2  60           ExitGetM:    rts
006F56  2               
006F56  2               ;-------------------------------------------------------------------------------------
006F56  2               
006F56  2               PlayerStarting_X_Pos:
006F56  2  28 18              .byte $28, $18
006F58  2  38 28              .byte $38, $28
006F5A  2               
006F5A  2               AltYPosOffset:
006F5A  2  08 00              .byte $08, $00
006F5C  2               
006F5C  2               PlayerStarting_Y_Pos:
006F5C  2  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
006F60  2  00 00 B0 B0  
006F64  2  F0                 .byte $f0
006F65  2               
006F65  2               PlayerBGPriorityData:
006F65  2  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
006F69  2  00 00 00 00  
006F6D  2               
006F6D  2               GameTimerData:
006F6D  2  20                 .byte $20 ;dummy byte, used as part of bg priority data
006F6E  2  04 03 02           .byte $04, $03, $02
006F71  2               
006F71  2               Entrance_GameTimerSetup:
006F71  2  AD 1A 07               lda ScreenLeft_PageLoc      ;set current page for area objects
006F74  2  85 6D                  sta Player_PageLoc          ;as page location for player
006F76  2  A9 28                  lda #$28                    ;store value here
006F78  2  8D 0A 07               sta VerticalForceDown       ;for fractional movement downwards if necessary
006F7B  2  A9 01                  lda #$01                    ;set high byte of player position and
006F7D  2  85 33                  sta PlayerFacingDir         ;set facing direction so that player faces right
006F7F  2  85 B5                  sta Player_Y_HighPos
006F81  2  A9 00                  lda #$00                    ;set player state to on the ground by default
006F83  2  85 1D                  sta Player_State
006F85  2  CE 90 04               dec Player_CollisionBits    ;initialize player's collision bits
006F88  2  A0 00                  ldy #$00                    ;initialize halfway page
006F8A  2  8C 5B 07               sty HalfwayPage
006F8D  2  AD 4E 07               lda AreaType                ;check area type
006F90  2  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
006F92  2  C8                     iny
006F93  2  8C 04 07     ChkStPos: sty SwimmingFlag
006F96  2  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
006F99  2  AC 52 07               ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
006F9C  2  F0 07                  beq SetStPos
006F9E  2  C0 01                  cpy #$01
006FA0  2  F0 03                  beq SetStPos
006FA2  2  BE 58 6F               ldx AltYPosOffset-2,y       ;if not 0 or 1, override start pos from header with alt offset
006FA5  2  B9 56 6F     SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
006FA8  2  85 86                  sta Player_X_Position       ;and vertical positions for the player, using
006FAA  2  BD 5C 6F               lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either
006FAD  2  85 CE                  sta Player_Y_Position       ;the original offset from the header or alt offset for vertical
006FAF  2  BD 65 6F               lda PlayerBGPriorityData,x
006FB2  2  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
006FB5  2  20 4D 65               jsr GetPlayerColors         ;get appropriate player palette
006FB8  2  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
006FBB  2  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
006FBD  2  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
006FC0  2  F0 15                  beq ChkOverR                ;old game timer setting
006FC2  2  B9 6D 6F               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
006FC5  2  8D EC 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
006FC8  2  A9 01                  lda #$01
006FCA  2  8D EE 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
006FCD  2  4A                     lsr
006FCE  2  8D ED 07               sta GameTimerDisplay+1      ;set second digit of game timer
006FD1  2  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
006FD4  2  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
006FD7  2  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
006FDA  2  F0 14                  beq ChkSwimE
006FDC  2  A9 03                  lda #$03                    ;set player state to climbing
006FDE  2  85 1D                  sta Player_State
006FE0  2  A2 00                  ldx #$00                    ;set offset for first slot, for block object
006FE2  2  20 45 89               jsr InitBlock_XY_Pos
006FE5  2  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
006FE7  2  85 D7                  sta Block_Y_Position
006FE9  2  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
006FEB  2  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
006FED  2  20 AA 84               jsr Setup_Vine              ;do a sub to grow vine
006FF0  2  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
006FF3  2  D0 03                  bne SetPESub                ;skip this subroutine
006FF5  2  20 77 82               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
006FF8  2  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
006FFA  2  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
006FFC  2  60                     rts
006FFD  2               
006FFD  2               ;-------------------------------------------------------------------------------------
006FFD  2               
006FFD  2               ;page numbers are in order from level numbers 1 to 4
006FFD  2               HalfwayPageNybbles:
006FFD  2  66 60              .byte $66, $60
006FFF  2  88 60              .byte $88, $60
007001  2  66 70              .byte $66, $70
007003  2  77 60              .byte $77, $60
007005  2  D6 00              .byte $d6, $00
007007  2  77 80              .byte $77, $80
007009  2  70 B0              .byte $70, $b0
00700B  2  00 00              .byte $00, $00
00700D  2  00 00              .byte $00, $00
00700F  2               
00700F  2               PlayerLoseLife:
00700F  2  EE 74 07                  inc DisableScreenFlag    ;disable screen and IRQ updates
007012  2  A9 00                     lda #$00
007014  2  8D 22 07                  sta IRQUpdateFlag
007017  2  A9 80                     lda #Silence             ;silence music
007019  2  85 FC                     sta EventMusicQueue
00701B  2  CE 5A 07                  dec NumberofLives        ;take one life from player
00701E  2  10 0B                     bpl StillInGame          ;if player still has lives, branch
007020  2  A9 00                     lda #$00
007022  2  8D 72 07                  sta OperMode_Task        ;initialize mode task,
007025  2  A9 03                     lda #GameOverMode        ;switch to game over mode
007027  2  8D 70 07                  sta OperMode             ;and leave
00702A  2  60                        rts
00702B  2  AD 5F 07     StillInGame: lda WorldNumber          ;multiply world number by 2 and use
00702E  2  0A                        asl                      ;as offset
00702F  2  AA                        tax
007030  2  AD 5C 07                  lda LevelNumber          ;if in level 3 or 4, increment
007033  2  29 02                     and #$02                 ;offset by one byte, otherwise
007035  2  F0 01                     beq GetHalfway           ;leave offset alone
007037  2  E8                        inx
007038  2  BC FD 6F     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
00703B  2  AD 5C 07                  lda LevelNumber          ;check area number's LSB
00703E  2  4A                        lsr
00703F  2  98                        tya                      ;if in level 2 or 4, use lower nybble
007040  2  B0 04                     bcs MaskHPNyb
007042  2  4A                        lsr                      ;move higher nybble to lower if
007043  2  4A                        lsr                      ;level number is 1 or 3
007044  2  4A                        lsr
007045  2  4A                        lsr
007046  2  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
007048  2  CD 1A 07                  cmp ScreenLeft_PageLoc
00704B  2  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
00704D  2  90 02                     bcc SetHalfway           ;otherwise player must start at the
00704F  2  A9 00                     lda #$00                 ;beginning of the level
007051  2  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
007054  2  4C 9D 70                  jmp ContinueGame         ;continue the game
007057  2               
007057  2               ;-------------------------------------------------------------------------------------
007057  2               
007057  2               GameOverSubs:
007057  2  AD 72 07           lda OperMode_Task
00705A  2  20 7D 6C           jsr JumpEngine
00705D  2               
00705D  2  63 70              .word SetupGameOver
00705F  2  C5 64              .word ScreenRoutines
007061  2  79 70              .word RunGameOver
007063  2               
007063  2               ;-------------------------------------------------------------------------------------
007063  2               
007063  2               SetupGameOver:
007063  2  A9 00              lda #$00
007065  2  8D 3C 07           sta ScreenRoutineTask
007068  2  8D 22 07           sta IRQUpdateFlag
00706B  2  8D F8 07           sta ContinueMenuSelect ;set continue as default choice
00706E  2  A9 02              lda #$02
007070  2  85 FC              sta EventMusicQueue    ;play game over music
007072  2  EE 74 07           inc DisableScreenFlag
007075  2  EE 72 07           inc OperMode_Task
007078  2  60                 rts
007079  2               
007079  2               RunGameOver:
007079  2  A9 00               lda #$00
00707B  2  8D 74 07            sta DisableScreenFlag
00707E  2  AD 5F 07            lda WorldNumber       ;if on world 9, branch on to end the game
007081  2  C9 08               cmp #World9
007083  2  F0 03               beq W9End
007085  2  4C C2 C1            jmp GameOverMenu      ;otherwise run game over menu
007088  2  AD A0 07     W9End: lda ScreenTimer
00708B  2  D0 0F               bne ExRGO
00708D  2               
00708D  2               TerminateGame:
00708D  2  A9 80               lda #Silence          ;silence music
00708F  2  85 FC               sta EventMusicQueue
007091  2  A9 00               lda #$00
007093  2  8D 72 07            sta OperMode_Task     ;reset to attract mode and leave
007096  2  8D A0 07            sta ScreenTimer
007099  2  8D 70 07            sta OperMode
00709C  2  60           ExRGO: rts
00709D  2               
00709D  2               ContinueGame:
00709D  2  20 A4 C2                jsr LoadAreaPointer       ;update level pointer with
0070A0  2  A9 01                   lda #$01                  ;actual world and area numbers, then
0070A2  2  8D 54 07                sta PlayerSize            ;reset player's size, status, and
0070A5  2  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
0070A8  2  A9 00                   lda #$00                  ;game timer from header
0070AA  2  8D 47 07                sta TimerControl          ;also set flag for timers to count again
0070AD  2  8D 56 07                sta PlayerStatus
0070B0  2  85 0E                   sta GameEngineSubroutine  ;reset task for game core
0070B2  2  8D 72 07                sta OperMode_Task         ;set modes and leave
0070B5  2  A9 01                   lda #$01                  ;if in game over mode, switch back to
0070B7  2  8D 70 07                sta OperMode              ;game mode, because game is still on
0070BA  2  60           GameIsOn:  rts
0070BB  2               
0070BB  2               ;-------------------------------------------------------------------------------------
0070BB  2               
0070BB  2               DoNothing:
0070BB  2  A9 FF              lda #$ff       ;this is residual code, this value is
0070BD  2  8D C9 06           sta $06c9      ;not used anywhere in the program
0070C0  2  60                 rts
0070C1  2               
0070C1  2               ;-------------------------------------------------------------------------------------
0070C1  2               
0070C1  2               AreaParserTaskHandler:
0070C1  2  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
0070C4  2  D0 05                      bne DoAPTasks             ;if already set, go ahead
0070C6  2  A0 08                      ldy #$08
0070C8  2  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
0070CB  2  88           DoAPTasks:    dey
0070CC  2  98                         tya
0070CD  2  20 D9 70                   jsr AreaParserTasks
0070D0  2  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
0070D3  2  D0 03                      bne SkipATRender          ;render attribute table yet
0070D5  2  20 47 68                   jsr RenderAttributeTables
0070D8  2  60           SkipATRender: rts
0070D9  2               
0070D9  2               AreaParserTasks:
0070D9  2  20 7D 6C           jsr JumpEngine
0070DC  2               
0070DC  2  EC 70              .word IncrementColumnPos
0070DE  2  8B 67              .word RenderAreaGraphics
0070E0  2  8B 67              .word RenderAreaGraphics
0070E2  2  0D 72              .word AreaParserCore
0070E4  2  EC 70              .word IncrementColumnPos
0070E6  2  8B 67              .word RenderAreaGraphics
0070E8  2  8B 67              .word RenderAreaGraphics
0070EA  2  0D 72              .word AreaParserCore
0070EC  2               
0070EC  2               ;-------------------------------------------------------------------------------------
0070EC  2               
0070EC  2               IncrementColumnPos:
0070EC  2  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
0070EF  2  AD 26 07                lda CurrentColumnPos
0070F2  2  29 0F                   and #%00001111           ;mask out higher nybble
0070F4  2  D0 06                   bne NoColWrap
0070F6  2  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
0070F9  2  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
0070FC  2  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
0070FF  2  AD A0 06                lda BlockBufferColumnPos
007102  2  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
007104  2  8D A0 06                sta BlockBufferColumnPos ;and save
007107  2  60                      rts
007108  2               
007108  2               ;-------------------------------------------------------------------------------------
007108  2               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
007108  2               ;$01 - used to store floor byte for terrain
007108  2               ;$07 - used to store terrain metatile
007108  2               ;$06-$07 - used to store block buffer address
007108  2               
007108  2               BSceneDataOffsets:
007108  2  00 30 60           .byte $00, $30, $60
00710B  2               
00710B  2               BackSceneryData:
00710B  2  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
00710F  2  12 12 13 00  
007113  2  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
007117  2  00 00 00 00  
00711B  2  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
00711F  2  02 03 00 00  
007123  2  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
007127  2  91 92 93 00  
00712B  2  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
00712F  2  52 53 41 42  
007133  2  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
007137  2  00 00 91 92  
00713B  2               
00713B  2  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
00713F  2  99 00 00 00  
007143  2  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
007147  2  A5 A5 A5 A6  
00714B  2  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
00714F  2  02 03 00 A4  
007153  2  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
007157  2  12 12 12 13  
00715B  2  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
00715F  2  01 02 02 03  
007163  2  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
007167  2  A6 00 00 00  
00716B  2               
00716B  2  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
00716F  2  00 00 00 00  
007173  2  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
007177  2  00 8B AA AA  
00717B  2  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
00717F  2  13 8B 00 9C  
007183  2  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
007187  2  02 03 11 12  
00718B  2  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
00718F  2  00 00 AA AA  
007193  2  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
007197  2  00 01 02 03  
00719B  2               
00719B  2               BackSceneryMetatiles:
00719B  2  80 83 00        .byte $80, $83, $00 ;cloud left
00719E  2  81 84 00        .byte $81, $84, $00 ;cloud middle
0071A1  2  82 85 00        .byte $82, $85, $00 ;cloud right
0071A4  2  02 00 00        .byte $02, $00, $00 ;bush left
0071A7  2  03 00 00        .byte $03, $00, $00 ;bush middle
0071AA  2  04 00 00        .byte $04, $00, $00 ;bush right
0071AD  2  00 05 06        .byte $00, $05, $06 ;mountain left
0071B0  2  07 06 0A        .byte $07, $06, $0a ;mountain middle
0071B3  2  00 08 09        .byte $00, $08, $09 ;mountain right
0071B6  2  4D 00 00        .byte $4d, $00, $00 ;fence
0071B9  2  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
0071BC  2  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
0071BF  2               
0071BF  2               FSceneDataOffsets:
0071BF  2  00 0D 1A           .byte $00, $0d, $1a
0071C2  2               
0071C2  2               ForeSceneryData:
0071C2  2  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
0071C6  2  87 87 87     
0071C9  2  87 87 87 87     .byte $87, $87, $87, $87, $6a, $6a
0071CD  2  6A 6A        
0071CF  2               
0071CF  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
0071D3  2  00 45 47     
0071D6  2  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
0071DA  2  00 00        
0071DC  2               
0071DC  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
0071E0  2  00 00 00     
0071E3  2  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
0071E7  2  86 87        
0071E9  2               
0071E9  2               TerrainMetatiles:
0071E9  2  6A 6B 50 63        .byte $6a, $6b, $50, $63
0071ED  2               
0071ED  2               TerrainRenderBits:
0071ED  2  00 00              .byte %00000000, %00000000 ;no ceiling or floor
0071EF  2  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
0071F1  2  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
0071F3  2  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
0071F5  2  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
0071F7  2  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
0071F9  2  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
0071FB  2  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
0071FD  2  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
0071FF  2  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
007201  2  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
007203  2  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
007205  2  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
007207  2  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
007209  2  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
00720B  2  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
00720D  2               
00720D  2               AreaParserCore:
00720D  2  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
007210  2  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
007212  2  20 19 73           jsr ProcessAreaData       ;otherwise skip ahead and load level data
007215  2               
007215  2               RenderSceneryTerrain:
007215  2  A2 0C                  ldx #$0c
007217  2  A9 00                  lda #$00
007219  2  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
00721C  2  CA                     dex
00721D  2  10 FA                  bpl ClrMTBuf
00721F  2  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
007222  2  F0 42                  beq RendFore               ;if not, skip to check the foreground
007224  2  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
007227  2  C9 03        ThirdP:   cmp #$03
007229  2  30 05                  bmi RendBack               ;if less than three we're there
00722B  2  38                     sec
00722C  2  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
00722E  2  10 F7                  bpl ThirdP                 ;do an unconditional branch
007230  2  0A           RendBack: asl                        ;move results to higher nybble
007231  2  0A                     asl
007232  2  0A                     asl
007233  2  0A                     asl
007234  2  79 07 71               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
007237  2  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
00723A  2  AA                     tax
00723B  2  BD 0B 71               lda BackSceneryData,x      ;load data from sum of offsets
00723E  2  F0 26                  beq RendFore               ;if zero, no scenery for that part
007240  2  48                     pha
007241  2  29 0F                  and #$0f                   ;save to stack and clear high nybble
007243  2  38                     sec
007244  2  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
007246  2  85 00                  sta $00                    ;save low nybble
007248  2  0A                     asl                        ;multiply by three (shift to left and add result to old one)
007249  2  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
00724B  2  AA                     tax                        ;save as offset for background scenery metatile data
00724C  2  68                     pla                        ;get high nybble from stack, move low
00724D  2  4A                     lsr
00724E  2  4A                     lsr
00724F  2  4A                     lsr
007250  2  4A                     lsr
007251  2  A8                     tay                        ;use as second offset (used to determine height)
007252  2  A9 03                  lda #$03                   ;use previously saved memory location for counter
007254  2  85 00                  sta $00
007256  2  BD 9B 71     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
007259  2  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
00725C  2  E8                     inx
00725D  2  C8                     iny
00725E  2  C0 0B                  cpy #$0b                   ;if at this location, leave loop
007260  2  F0 04                  beq RendFore
007262  2  C6 00                  dec $00                    ;decrement until counter expires, barring exception
007264  2  D0 F0                  bne SceLoop1
007266  2  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
007269  2  F0 13                  beq RendTerr               ;if not, skip this part
00726B  2  BC BE 71               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
00726E  2  A2 00                  ldx #$00                   ;reinit X
007270  2  B9 C2 71     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
007273  2  F0 03                  beq NoFore                 ;do not store if zero found
007275  2  9D A1 06               sta MetatileBuffer,x
007278  2  C8           NoFore:   iny
007279  2  E8                     inx
00727A  2  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
00727C  2  D0 F2                  bne SceLoop2
00727E  2  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
007281  2  D0 0C                  bne TerMTile               ;if not water level, skip this part
007283  2  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
007286  2  C9 07                  cmp #World8                ;then skip this part
007288  2  D0 05                  bne TerMTile
00728A  2  A9 63                  lda #$63                   ;if set as water level and world number eight,
00728C  2  4C 99 72               jmp StoreMT                ;use castle wall metatile as terrain type
00728F  2  B9 E9 71     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
007292  2  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
007295  2  F0 02                  beq StoreMT                ;if not set, keep value otherwise
007297  2  A9 88                  lda #$88                   ;use cloud block terrain
007299  2  85 07        StoreMT:  sta $07                    ;store value here
00729B  2  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
00729D  2  AD 27 07               lda TerrainControl         ;use yet another value from the header
0072A0  2  0A                     asl                        ;multiply by 2 and use as yet another offset
0072A1  2  A8                     tay
0072A2  2  B9 ED 71     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
0072A5  2  85 00                  sta $00
0072A7  2  C8                     iny                        ;increment Y and use as offset next time around
0072A8  2  84 01                  sty $01
0072AA  2  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
0072AD  2  F0 0A                  beq NoCloud2
0072AF  2  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
0072B1  2  F0 06                  beq NoCloud2
0072B3  2  A5 00                  lda $00                    ;if not, mask out all but d3
0072B5  2  29 08                  and #%00001000
0072B7  2  85 00                  sta $00
0072B9  2  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
0072BB  2  B9 9B 92     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
0072BE  2  24 00                  bit $00
0072C0  2  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
0072C2  2  A5 07                  lda $07
0072C4  2  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
0072C7  2  E8           NextTBit: inx                        ;continue until end of buffer
0072C8  2  E0 0D                  cpx #$0d
0072CA  2  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
0072CC  2  AD 4E 07               lda AreaType               ;check world type for underground area
0072CF  2  C9 02                  cmp #$02
0072D1  2  D0 08                  bne EndUChk                ;if not underground, skip this part
0072D3  2  E0 0B                  cpx #$0b
0072D5  2  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
0072D7  2  A9 6B                  lda #$6b                   ;old terrain type with ground level terrain type
0072D9  2  85 07                  sta $07
0072DB  2  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
0072DC  2  C0 08                  cpy #$08
0072DE  2  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
0072E0  2  A4 01                  ldy $01
0072E2  2  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
0072E4  2  20 19 73     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
0072E7  2  AD A0 06               lda BlockBufferColumnPos
0072EA  2  20 22 7A               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
0072ED  2  A2 00                  ldx #$00
0072EF  2  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
0072F1  2  84 00        ChkMTLow: sty $00
0072F3  2  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
0072F6  2  29 C0                  and #%11000000             ;mask out all but 2 MSB
0072F8  2  0A                     asl
0072F9  2  2A                     rol                        ;make %xx000000 into %000000xx
0072FA  2  2A                     rol
0072FB  2  A8                     tay                        ;use as offset in Y
0072FC  2  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
0072FF  2  D9 15 73               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
007302  2  B0 02                  bcs StrBlock               ;if equal or greater, branch
007304  2  A9 00                  lda #$00                   ;if less, init value before storing
007306  2  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
007308  2  91 06                  sta ($06),y                ;store value into block buffer
00730A  2  98                     tya
00730B  2  18                     clc                        ;add 16 (move down one row) to offset
00730C  2  69 10                  adc #$10
00730E  2  A8                     tay
00730F  2  E8                     inx                        ;increment column value
007310  2  E0 0D                  cpx #$0d
007312  2  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
007314  2  60                     rts
007315  2               
007315  2               ;numbers lower than these with the same attribute bits
007315  2               ;will not be stored in the block buffer
007315  2               BlockBuffLowBounds:
007315  2  10 4F 88 C0        .byte $10, $4f, $88, $c0
007319  2               
007319  2               ;-------------------------------------------------------------------------------------
007319  2               ;$00 - used to store area object identifier
007319  2               ;$07 - used as adder to find proper area object code
007319  2               
007319  2               ProcessAreaData:
007319  2  A2 02                    ldx #$02                 ;start at the end of area object buffer
00731B  2  86 08        ProcADLoop: stx ObjectOffset
00731D  2  A9 00                    lda #$00                 ;reset flag
00731F  2  8D 29 07                 sta BehindAreaParserFlag
007322  2  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
007325  2  B1 E7                    lda (AreaData),y         ;get first byte of area object
007327  2  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
007329  2  F0 4B                    beq RdyDecode
00732B  2  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
00732E  2  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
007330  2  C8                       iny
007331  2  B1 E7                    lda (AreaData),y         ;get second byte of area object
007333  2  0A                       asl                      ;check for page select bit (d7), branch if not set
007334  2  90 0B                    bcc Chk1Row13
007336  2  AD 2B 07                 lda AreaObjectPageSel    ;check page select
007339  2  D0 06                    bne Chk1Row13
00733B  2  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
00733E  2  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
007341  2  88           Chk1Row13:  dey
007342  2  B1 E7                    lda (AreaData),y         ;reread first byte of level object
007344  2  29 0F                    and #$0f                 ;mask out high nybble
007346  2  C9 0D                    cmp #$0d                 ;row 13?
007348  2  D0 1B                    bne Chk1Row14
00734A  2  C8                       iny                      ;if so, reread second byte of level object
00734B  2  B1 E7                    lda (AreaData),y
00734D  2  88                       dey                      ;decrement to get ready to read first byte
00734E  2  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
007350  2  D0 1C                    bne CheckRear
007352  2  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
007355  2  D0 17                    bne CheckRear
007357  2  C8                       iny                      ;if d6 not set, reread second byte
007358  2  B1 E7                    lda (AreaData),y
00735A  2  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
00735C  2  8D 2A 07                 sta AreaObjectPageLoc
00735F  2  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
007362  2  4C 7F 73                 jmp NextAObj
007365  2  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
007367  2  D0 05                    bne CheckRear
007369  2  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
00736C  2  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
00736E  2  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
007371  2  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
007374  2  90 06                    bcc SetBehind            ;if so branch
007376  2  20 A6 73     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
007379  2  4C 82 73                 jmp ChkLength
00737C  2  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
00737F  2  20 9A 73     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
007382  2  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
007384  2  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
007387  2  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
007389  2  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
00738C  2  CA           ProcLoopb:  dex                      ;decrement buffer offset
00738D  2  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
00738F  2  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
007392  2  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
007394  2  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
007397  2  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
007399  2  60           EndAParse:  rts
00739A  2               
00739A  2               IncAreaObjOffset:
00739A  2  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
00739D  2  EE 2C 07           inc AreaDataOffset
0073A0  2  A9 00              lda #$00              ;reset page select
0073A2  2  8D 2B 07           sta AreaObjectPageSel
0073A5  2  60                 rts
0073A6  2               
0073A6  2               DecodeAreaData:
0073A6  2  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
0073A9  2  30 03                  bmi Chk1stB
0073AB  2  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
0073AE  2  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
0073B0  2  B1 E7                  lda (AreaData),y           ;get first byte of level object again
0073B2  2  C9 FD                  cmp #$fd
0073B4  2  F0 E3                  beq EndAParse              ;if end of level, leave this routine
0073B6  2  29 0F                  and #$0f                   ;otherwise, mask out low nybble
0073B8  2  C9 0F                  cmp #$0f                   ;row 15?
0073BA  2  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
0073BC  2  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
0073BE  2  C9 0C                  cmp #$0c                   ;row 12?
0073C0  2  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
0073C2  2  A2 00                  ldx #$00                   ;otherwise nullify value by default
0073C4  2  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
0073C6  2  A6 08                  ldx ObjectOffset           ;get object offset again
0073C8  2  C9 0E                  cmp #$0e                   ;row 14?
0073CA  2  D0 08                  bne ChkRow13
0073CC  2  A9 00                  lda #$00                   ;if so, load offset with $00
0073CE  2  85 07                  sta $07
0073D0  2  A9 36                  lda #$36                   ;and load A with another value
0073D2  2  D0 53                  bne NormObj                ;unconditional branch
0073D4  2  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
0073D6  2  D0 1B                  bne ChkSRows
0073D8  2  A9 28                  lda #$28                   ;if so, load offset with 40
0073DA  2  85 07                  sta $07
0073DC  2  C8                     iny                        ;get next byte
0073DD  2  B1 E7                  lda (AreaData),y
0073DF  2  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
0073E1  2  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
0073E3  2  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
0073E5  2  29 7F                  and #%01111111             ;mask out d7
0073E7  2  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
0073E9  2  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
0073EB  2  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
0073EE  2  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
0073F0  2  4C 27 74               jmp NormObj                ;and jump
0073F3  2  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
0073F5  2  B0 27                  bcs SpecObj
0073F7  2  C8                     iny                        ;if not, get second byte of level object
0073F8  2  B1 E7                  lda (AreaData),y
0073FA  2  29 70                  and #%01110000             ;mask out all but d6-d4
0073FC  2  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
0073FE  2  A9 18                  lda #$18
007400  2  85 07                  sta $07                    ;otherwise set offset of 24 for small object
007402  2  B1 E7                  lda (AreaData),y           ;reload second byte of level object
007404  2  29 0F                  and #%00001111             ;mask out higher nybble and jump
007406  2  4C 27 74               jmp NormObj
007409  2  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
00740B  2  C9 70                  cmp #$70                   ;check for vertical pipe object
00740D  2  D0 0A                  bne NotWPipe
00740F  2  B1 E7                  lda (AreaData),y           ;if not, reload second byte
007411  2  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
007413  2  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
007415  2  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
007417  2  85 00                  sta $00
007419  2  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
00741B  2  4C 23 74               jmp MoveAOId
00741E  2  C8           SpecObj:  iny                        ;branch here for rows 12-15
00741F  2  B1 E7                  lda (AreaData),y
007421  2  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
007423  2  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
007424  2  4A                     lsr
007425  2  4A                     lsr
007426  2  4A                     lsr
007427  2  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
007429  2  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
00742C  2  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
00742E  2  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
007431  2  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
007434  2  F0 11                  beq InitRear
007436  2  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
007439  2  B1 E7                  lda (AreaData),y           ;and reload first byte
00743B  2  29 0F                  and #%00001111
00743D  2  C9 0E                  cmp #$0e                   ;row 14?
00743F  2  D0 05                  bne LeavePar
007441  2  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
007444  2  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
007446  2  60           LeavePar: rts
007447  2  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
00744A  2  F0 0B                  beq BackColC               ;branch to column-wise check
00744C  2  A9 00                  lda #$00                   ;if not, initialize both backloading and
00744E  2  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
007451  2  8D 29 07               sta BehindAreaParserFlag
007454  2  85 08                  sta ObjectOffset
007456  2  60           LoopCmdE: rts
007457  2  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
00745A  2  B1 E7                  lda (AreaData),y
00745C  2  29 F0                  and #%11110000             ;mask out low nybble and move high to low
00745E  2  4A                     lsr
00745F  2  4A                     lsr
007460  2  4A                     lsr
007461  2  4A                     lsr
007462  2  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
007465  2  D0 DF                  bne LeavePar               ;if not, branch to leave
007467  2  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
00746A  2  9D 2D 07               sta AreaObjOffsetBuffer,x
00746D  2  20 9A 73               jsr IncAreaObjOffset       ;do sub to increment to next object data
007470  2  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
007472  2  18                     clc                        ;then use the jump engine with current contents of A
007473  2  65 07                  adc $07
007475  2  20 7D 6C               jsr JumpEngine
007478  2               
007478  2  31 77         .word VerticalPipe
00747A  2  97 75         .word AreaStyleObject
00747C  2  75 78         .word RowOfBricks
00747E  2  85 78         .word RowOfSolidBlocks
007480  2  39 78         .word RowOfCoins
007482  2  97 78         .word ColumnOfBricks
007484  2  A0 78         .word ColumnOfSolidBlocks
007486  2  31 77         .word VerticalPipe
007488  2               
007488  2  8A 79         .word Hole_Empty
00748A  2  06 76         .word PulleyRopeObject
00748C  2  C0 77         .word Bridge_High
00748E  2  C3 77         .word Bridge_Middle
007490  2  C6 77         .word Bridge_Low
007492  2  9E 77         .word Hole_Water
007494  2  AF 77         .word QuestionBlockRow_High
007496  2  B2 77         .word QuestionBlockRow_Low
007498  2               
007498  2  17 78         .word EndlessRope
00749A  2  1E 78         .word BalancePlatRope
00749C  2  52 76         .word CastleObject
00749E  2  FE 78         .word StaircaseObject
0074A0  2  F7 76         .word ExitPipe
0074A2  2  DB 77         .word FlagBalls_Residual
0074A4  2  rr rr         .word UpsideDownPipe_High
0074A6  2  rr rr         .word UpsideDownPipe_Low
0074A8  2               
0074A8  2  57 79         .word QuestionBlock
0074AA  2  57 79         .word QuestionBlock
0074AC  2  57 79         .word QuestionBlock
0074AE  2  57 79         .word QuestionBlock
0074B0  2  4A 79         .word Hidden1UpBlock
0074B2  2  57 79         .word QuestionBlock
0074B4  2  57 79         .word QuestionBlock
0074B6  2  62 79         .word BrickWithItem
0074B8  2  62 79         .word BrickWithItem
0074BA  2  62 79         .word BrickWithItem
0074BC  2  62 79         .word BrickWithItem
0074BE  2  5D 79         .word BrickWithCoins
0074C0  2  62 79         .word BrickWithItem
0074C2  2  BB 76         .word WaterPipe
0074C4  2  60 78         .word EmptyBlock
0074C6  2  1A 79         .word Jumpspring
0074C8  2               
0074C8  2  CE 76         .word IntroPipe
0074CA  2  E5 77         .word FlagpoleObject
0074CC  2  50 78         .word AxeObj
0074CE  2  55 78         .word ChainObj
0074D0  2  48 78         .word CastleBridgeObj
0074D2  2  13 75         .word ScrollLockObject_Warp
0074D4  2  64 75         .word ScrollLockObject
0074D6  2  64 75         .word ScrollLockObject
0074D8  2  82 75         .word AreaFrenzy
0074DA  2  82 75         .word AreaFrenzy
0074DC  2  82 75         .word AreaFrenzy
0074DE  2  56 74         .word LoopCmdE
0074E0  2  rr rr         .word WindOn                ;these two are in SM2DATA2 and SM2DATA4
0074E2  2  rr rr         .word WindOff
0074E4  2               
0074E4  2  E6 74         .word AlterAreaAttributes
0074E6  2               
0074E6  2               ;-------------------------------------------------------------------------------------
0074E6  2               ;(these apply to all area object subroutines in this section unless otherwise stated)
0074E6  2               ;$00 - used to store offset used to find object code
0074E6  2               ;$07 - starts with adder from area parser, used to store row offset
0074E6  2               
0074E6  2               AlterAreaAttributes:
0074E6  2  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
0074E9  2  C8                    iny                       ;load second byte
0074EA  2  B1 E7                 lda (AreaData),y
0074EC  2  48                    pha                       ;save in stack for now
0074ED  2  29 40                 and #%01000000
0074EF  2  D0 12                 bne Alter2                ;branch if d6 is set
0074F1  2  68                    pla
0074F2  2  48                    pha                       ;pull and push offset to copy to A
0074F3  2  29 0F                 and #%00001111            ;mask out high nybble and store as
0074F5  2  8D 27 07              sta TerrainControl        ;new terrain height type bits
0074F8  2  68                    pla
0074F9  2  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
0074FB  2  4A                    lsr                       ;move bits to lower nybble and store
0074FC  2  4A                    lsr                       ;as new background scenery bits
0074FD  2  4A                    lsr
0074FE  2  4A                    lsr
0074FF  2  8D 42 07              sta BackgroundScenery     ;then leave
007502  2  60                    rts
007503  2  68           Alter2:  pla
007504  2  29 07                 and #%00000111            ;mask out all but 3 LSB
007506  2  C9 04                 cmp #$04                  ;if four or greater, set color control bits
007508  2  90 05                 bcc SetFore               ;and nullify foreground scenery bits
00750A  2  8D 44 07              sta BackgroundColorCtrl
00750D  2  A9 00                 lda #$00
00750F  2  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
007512  2  60                    rts
007513  2               
007513  2               ;--------------------------------
007513  2               
007513  2               ScrollLockObject_Warp:
007513  2  A2 80                 ldx #$80                 ;use base number for warp to world 2
007515  2  AD FB 07              lda HardWorldFlag        ;if on worlds A-D, skip ahead to next part
007518  2  D0 15                 bne WarpWorldsAThruD     ;note d7 is set in all entries to prevent zero condition
00751A  2  AD 5F 07              lda WorldNumber          ;from happening in warp zone code elsewhere
00751D  2  D0 18                 bne WarpWorlds2Thru8     ;if not on world 1, branch to handle a different way
00751F  2  AC 4E 07              ldy AreaType             ;check to see if on ground level type
007522  2  88                    dey                      ;branch if so to add one to the number
007523  2  F0 06                 beq W1Warp2
007525  2  AD 4F 07              lda AreaAddrsLOffset     ;if on first underground level, branch to use base number
007528  2  F0 02                 beq W1Warp1
00752A  2  E8                    inx                      ;otherwise add two to the number and use it
00752B  2  E8           W1Warp2: inx
00752C  2  4C 58 75     W1Warp1: jmp BaseW
00752F  2               
00752F  2               WarpWorldsAThruD:
00752F  2  A9 87              lda #$87                 ;use base number for worlds A-D
007531  2  18                 clc
007532  2  6D 5C 07           adc LevelNumber          ;add level number itself to it
007535  2  D0 22              bne DumpWarpCtrl         ;then branch to use it
007537  2               
007537  2               WarpWorlds2Thru8:
007537  2  A2 83              ldx #$83                 ;use base number for worlds 2-8
007539  2  AD 5F 07           lda WorldNumber
00753C  2  C9 02              cmp #World3              ;branch if on world 3 to use
00753E  2  F0 18              beq BaseW
007540  2  E8                 inx                      ;otherwise add one to the number
007541  2  C9 04              cmp #World5              ;if not on world 5, branch to add 3 more
007543  2  D0 10              bne W678Warp
007545  2  AD 4F 07           lda AreaAddrsLOffset
007548  2  C9 0B              cmp #$0b                 ;if on the 12th ground area, branch to use
00754A  2  F0 0C              beq BaseW                ;(in normal map data this corresponds to world 5-1)
00754C  2  AC 4E 07           ldy AreaType             ;check to see if on ground level type
00754F  2  88                 dey                      ;branch if so to add 2 more to the number
007550  2  F0 04              beq W5Warp3
007552  2  4C 57 75           jmp W5Warp2              ;otherwise add 1 more
007555  2               
007555  2  E8           W678Warp: inx                  ;add 1, 2, or 3 to base number or use as-is
007556  2  E8           W5Warp3:  inx                  ;depending on where branched
007557  2  E8           W5Warp2:  inx
007558  2  8A           BaseW:    txa
007559  2               
007559  2               DumpWarpCtrl:
007559  2  8D D6 06           sta WarpZoneControl      ;set warp zone control
00755C  2  20 5E 67           jsr WriteWarpZoneMessage
00755F  2  A9 0D              lda #$0d                 ;kill piranha plants
007561  2  20 6D 75           jsr KillEnemies
007564  2               
007564  2               ScrollLockObject:
007564  2  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
007567  2  49 01              eor #%00000001
007569  2  8D 23 07           sta ScrollLock
00756C  2  60                 rts
00756D  2               
00756D  2               ;--------------------------------
00756D  2               ;$00 - used to store enemy identifier in KillEnemies
00756D  2               
00756D  2               KillEnemies:
00756D  2  85 00                   sta $00           ;store identifier here
00756F  2  A9 00                   lda #$00
007571  2  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
007573  2  B4 16        KillELoop: ldy Enemy_ID,x
007575  2  C4 00                   cpy $00           ;if not found, branch
007577  2  D0 02                   bne NoKillE
007579  2  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
00757B  2  CA           NoKillE:   dex               ;do this until all slots are checked
00757C  2  10 F5                   bpl KillELoop
00757E  2  60                      rts
00757F  2               
00757F  2               ;--------------------------------
00757F  2               
00757F  2               FrenzyIDData:
00757F  2  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
007582  2               
007582  2  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
007584  2  BD 77 75                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
007587  2  A0 05                     ldy #$05
007589  2  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
00758A  2  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
00758C  2  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
00758F  2  D0 F8                     bne FreCompLoop
007591  2  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
007593  2  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
007596  2  60                        rts
007597  2               
007597  2               
007597  2               ;--------------------------------
007597  2               ;$06 - used by CloudLedge to store length
007597  2               
007597  2               AreaStyleObject:
007597  2  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
00759A  2  20 7D 6C           jsr JumpEngine
00759D  2  A3 75              .word TreeLedge        ;also used for cloud bonus levels
00759F  2  CF 75              .word CloudLedge
0075A1  2  B0 78              .word BulletBillCannon
0075A3  2               
0075A3  2               TreeLedge:
0075A3  2  20 FC 79               jsr GetLrgObjAttrib     ;get row and length of green ledge
0075A6  2  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
0075A9  2  F0 1F                  beq EndTreeL
0075AB  2  10 11                  bpl MidTreeL
0075AD  2  98                     tya
0075AE  2  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
0075B1  2  AD 25 07               lda CurrentPageLoc
0075B4  2  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
0075B7  2  F0 05                  beq MidTreeL
0075B9  2  A9 16                  lda #$16                ;render start of tree ledge
0075BB  2  4C FC 75               jmp NoUnder
0075BE  2  A6 07        MidTreeL: ldx $07
0075C0  2  A9 17                  lda #$17                ;render middle of tree ledge
0075C2  2  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
0075C5  2  A9 4C                  lda #$4c                ;at the start of level for continuous effect
0075C7  2  4C F6 75               jmp AllUnder            ;now render the part underneath
0075CA  2  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
0075CC  2  4C FC 75               jmp NoUnder
0075CF  2               
0075CF  2               ;note: This is the style utilized by world 8-3 and part of world 8-2, and not to
0075CF  2               ;be confused with the cloud-type bonus levels full of coins found throughout the game.
0075CF  2               CloudLedge:
0075CF  2  20 ED 79               jsr ChkLrgObjLength        ;get cloud dimensions
0075D2  2  84 06                  sty $06                    ;store length here for now
0075D4  2  90 0C                  bcc EndCloud
0075D6  2  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
0075D9  2  4A                     lsr
0075DA  2  9D 36 07               sta MushroomLedgeHalfLen,x
0075DD  2  A9 8A                  lda #$8a                   ;render start of cloud
0075DF  2  4C FC 75               jmp NoUnder
0075E2  2  A9 8C        EndCloud: lda #$8c                   ;if at the end, render end of cloud
0075E4  2  BC 30 07               ldy AreaObjectLength,x
0075E7  2  F0 13                  beq NoUnder
0075E9  2  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
0075EC  2  85 06                  sta $06                    ;was stored originally
0075EE  2  A6 07                  ldx $07
0075F0  2  A9 8B                  lda #$8b
0075F2  2  9D A1 06               sta MetatileBuffer,x       ;render middle of cloud
0075F5  2  60                     rts
0075F6  2               
0075F6  2  E8           AllUnder: inx
0075F7  2  A0 0F                  ldy #$0f                   ;set $0f to render all way down
0075F9  2  4C C6 79               jmp RenderUnderPart        ;now render the support of the tree ledge
0075FC  2  A6 07        NoUnder:  ldx $07                    ;load row of ledge
0075FE  2  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
007600  2  4C C6 79               jmp RenderUnderPart
007603  2               
007603  2               ;--------------------------------
007603  2               
007603  2               ;tiles used by pulleys and rope object
007603  2               PulleyRopeMetatiles:
007603  2  42 41 43           .byte $42, $41, $43
007606  2               
007606  2               PulleyRopeObject:
007606  2  20 ED 79                jsr ChkLrgObjLength       ;get length of pulley/rope object
007609  2  A0 00                   ldy #$00                  ;initialize metatile offset
00760B  2  B0 07                   bcs RenderPul             ;if starting, render left pulley
00760D  2  C8                      iny
00760E  2  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
007611  2  D0 01                   bne RenderPul
007613  2  C8                      iny                       ;otherwise render right pulley
007614  2  B9 03 76     RenderPul: lda PulleyRopeMetatiles,y
007617  2  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
00761A  2  60           MushLExit: rts                       ;and leave
00761B  2               
00761B  2               ;--------------------------------
00761B  2               ;$06 - used to store upper limit of rows for CastleObject
00761B  2               
00761B  2               CastleMetatiles:
00761B  2  00 45 45 45        .byte $00, $45, $45, $45, $00
00761F  2  00           
007620  2  00 48 47 46        .byte $00, $48, $47, $46, $00
007624  2  00           
007625  2  45 49 49 49        .byte $45, $49, $49, $49, $45
007629  2  45           
00762A  2  47 47 4A 47        .byte $47, $47, $4a, $47, $47
00762E  2  47           
00762F  2  47 47 4B 47        .byte $47, $47, $4b, $47, $47
007633  2  47           
007634  2  49 49 49 49        .byte $49, $49, $49, $49, $49
007638  2  49           
007639  2  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
00763D  2  47           
00763E  2  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
007642  2  47           
007643  2  47 47 47 47        .byte $47, $47, $47, $47, $47
007647  2  47           
007648  2  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
00764C  2  4A           
00764D  2  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
007651  2  4B           
007652  2               
007652  2               CastleObject:
007652  2  20 FC 79                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
007655  2  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
007657  2  A0 04                    ldy #$04
007659  2  20 F0 79                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
00765C  2  8A                       txa
00765D  2  48                       pha                      ;save obj buffer offset to stack
00765E  2  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
007661  2  A6 07                    ldx $07                  ;begin at starting row
007663  2  A9 0B                    lda #$0b
007665  2  85 06                    sta $06                  ;load upper limit of number of rows to print
007667  2  B9 1B 76     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
00766A  2  9D A1 06                 sta MetatileBuffer,x
00766D  2  E8                       inx                      ;store in buffer and increment buffer offset
00766E  2  A5 06                    lda $06
007670  2  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
007672  2  C8                       iny                      ;if not, increment column-wise
007673  2  C8                       iny                      ;to byte in next row
007674  2  C8                       iny
007675  2  C8                       iny
007676  2  C8                       iny
007677  2  C6 06                    dec $06                  ;move closer to upper limit
007679  2  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
00767B  2  D0 EA                    bne CRendLoop            ;if not, go back and do another row
00767D  2  68                       pla
00767E  2  AA                       tax                      ;get obj buffer offset from before
00767F  2  AD 25 07                 lda CurrentPageLoc
007682  2  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
007684  2  BD 30 07                 lda AreaObjectLength,x   ;check length
007687  2  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
007689  2  F0 2A                    beq PlayerStop
00768B  2  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
00768D  2  D0 04                    bne NotTall
00768F  2  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
007691  2  F0 22                    beq PlayerStop
007693  2  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
007695  2  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
007697  2  20 0C 7A                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
00769A  2  48                       pha
00769B  2  20 91 77                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
00769E  2  68                       pla
00769F  2  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
0076A1  2  AD 25 07                 lda CurrentPageLoc
0076A4  2  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
0076A6  2  A9 01                    lda #$01
0076A8  2  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
0076AA  2  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
0076AC  2  A9 90                    lda #$90
0076AE  2  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
0076B0  2  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
0076B2  2  95 16                    sta Enemy_ID,x
0076B4  2  60                       rts
0076B5  2  A0 50        PlayerStop: ldy #$50                 ;put brick at floor to stop player at end of level
0076B7  2  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
0076BA  2  60           ExitCastle: rts
0076BB  2               
0076BB  2               ;--------------------------------
0076BB  2               
0076BB  2               WaterPipe:
0076BB  2  20 FC 79           jsr GetLrgObjAttrib     ;get row and lower nybble
0076BE  2  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
0076C1  2  A6 07              ldx $07                 ;get row
0076C3  2  A9 6D              lda #$6d
0076C5  2  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
0076C8  2  A9 6E              lda #$6e
0076CA  2  9D A2 06           sta MetatileBuffer+1,x
0076CD  2  60                 rts
0076CE  2               
0076CE  2               ;--------------------------------
0076CE  2               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
0076CE  2               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
0076CE  2               ; and vertical length in VerticalPipe and GetPipeHeight
0076CE  2               
0076CE  2               IntroPipe:
0076CE  2  A0 03                       ldy #$03                 ;check if length set, if not set, set it
0076D0  2  20 F0 79                    jsr ChkLrgObjFixedLength
0076D3  2  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
0076D5  2  20 FF 76                    jsr RenderSidewaysPipe
0076D8  2  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
0076DA  2  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
0076DC  2  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
0076DE  2  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
0076E1  2  CA                          dex
0076E2  2  10 F8                       bpl VPipeSectLoop
0076E4  2  B9 29 77                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
0076E7  2  8D A8 06                    sta MetatileBuffer+7
0076EA  2  60           NoBlankP:      rts
0076EB  2               
0076EB  2               SidePipeShaftData:
0076EB  2  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
0076ED  2  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
0076EF  2               SidePipeTopPart:
0076EF  2  15 1B              .byte $15, $1b  ;top part of sideways part of pipe
0076F1  2  1A 19              .byte $1a, $19
0076F3  2               SidePipeBottomPart:
0076F3  2  15 1E              .byte $15, $1e  ;bottom part of sideways part of pipe
0076F5  2  1D 1C              .byte $1d, $1c
0076F7  2               
0076F7  2               ExitPipe:
0076F7  2  A0 03              ldy #$03                 ;check if length set, if not set, set it
0076F9  2  20 F0 79           jsr ChkLrgObjFixedLength
0076FC  2  20 FC 79           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
0076FF  2               
0076FF  2               RenderSidewaysPipe:
0076FF  2  88                         dey                       ;decrement twice to make room for shaft at bottom
007700  2  88                         dey                       ;and store here for now as vertical length
007701  2  84 05                      sty $05
007703  2  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
007706  2  84 06                      sty $06
007708  2  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
00770A  2  E8                         inx
00770B  2  B9 EB 76                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
00770E  2  C9 00                      cmp #$00
007710  2  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
007712  2  A2 00                      ldx #$00
007714  2  A4 05                      ldy $05                   ;init buffer offset and get vertical length
007716  2  20 C6 79                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
007719  2  18                         clc                       ;clear carry flag to be used by IntroPipe
00771A  2  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
00771C  2  B9 EF 76                   lda SidePipeTopPart,y
00771F  2  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
007722  2  B9 F3 76                   lda SidePipeBottomPart,y  ;backwards horizontally
007725  2  9D A2 06                   sta MetatileBuffer+1,x
007728  2  60                         rts
007729  2               
007729  2               VerticalPipeData:
007729  2  11 10              .byte $11, $10 ;used by pipes that lead somewhere
00772B  2  15 14              .byte $15, $14
00772D  2  13 12              .byte $13, $12 ;used by decoration pipes
00772F  2  15 14              .byte $15, $14
007731  2               
007731  2               VerticalPipe:
007731  2  20 61 77               jsr GetPipeHeight
007734  2  A5 00                  lda $00                  ;check to see if value was nullified earlier
007736  2  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
007738  2  C8                     iny
007739  2  C8                     iny
00773A  2  C8                     iny
00773B  2  C8                     iny                      ;add four if usage control bit was not set
00773C  2  98           WarpPipe: tya                      ;save value in stack
00773D  2  48                     pha
00773E  2  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
007741  2  F0 0A                  beq DrawPipe             ;(because we only need to do this once)
007743  2  20 91 77               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
007746  2  B0 05                  bcs DrawPipe             ;if not found, too many enemies, thus skip
007748  2  A9 0D                  lda #PiranhaPlant
00774A  2  20 72 77               jsr SetupPiranhaPlant
00774D  2               
00774D  2  68           DrawPipe: pla                      ;get value saved earlier and use as Y
00774E  2  A8                     tay
00774F  2  A6 07                  ldx $07                  ;get buffer offset
007751  2  B9 29 77               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
007754  2  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
007757  2  E8                     inx
007758  2  B9 2B 77               lda VerticalPipeData+2,y ;render the rest of the pipe
00775B  2  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
00775D  2  88                     dey
00775E  2  4C C6 79               jmp RenderUnderPart
007761  2               
007761  2               GetPipeHeight:
007761  2  A0 01              ldy #$01       ;check for length loaded, if not, load
007763  2  20 F0 79           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
007766  2  20 FC 79           jsr GetLrgObjAttrib
007769  2  98                 tya            ;get saved lower nybble as height
00776A  2  29 07              and #$07       ;save only the three lower bits as
00776C  2  85 06              sta $06        ;vertical length, then load Y with
00776E  2  BC 30 07           ldy AreaObjectLength,x    ;length left over
007771  2  60                 rts
007772  2               
007772  2               SetupPiranhaPlant:
007772  2  95 16                  sta Enemy_ID,x
007774  2  20 0C 7A               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
007777  2  18                     clc
007778  2  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
00777A  2  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
00777C  2  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
00777F  2  69 00                  adc #$00
007781  2  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
007783  2  A9 01                  lda #$01
007785  2  95 B6                  sta Enemy_Y_HighPos,x
007787  2  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
007789  2  20 14 7A               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
00778C  2  95 CF                  sta Enemy_Y_Position,x
00778E  2  4C 98 93               jmp InitPiranhaPlant
007791  2               
007791  2               FindEmptyEnemySlot:
007791  2  A2 00                      ldx #$00          ;start at first enemy slot
007793  2  18           EmptyChkLoop: clc               ;clear carry flag by default
007794  2  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
007796  2  F0 05                      beq ExitEmptyChk  ;if zero, leave
007798  2  E8                         inx
007799  2  E0 05                      cpx #$05          ;if nonzero, check next value
00779B  2  D0 F6                      bne EmptyChkLoop
00779D  2  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
00779E  2               
00779E  2               ;--------------------------------
00779E  2               
00779E  2               Hole_Water:
00779E  2  20 ED 79           jsr ChkLrgObjLength   ;get low nybble and save as length
0077A1  2  A9 86              lda #$86              ;render waves
0077A3  2  8D AB 06           sta MetatileBuffer+10
0077A6  2  A2 0B              ldx #$0b
0077A8  2  A0 01              ldy #$01              ;now render the water underneath
0077AA  2  A9 87              lda #$87
0077AC  2  4C C6 79           jmp RenderUnderPart
0077AF  2               
0077AF  2               QuestionBlockRow_High:
0077AF  2  A9 03              lda #$03              ;start on the fourth row
0077B1  2  2C                 .byte $2c               ;BIT instruction opcode
0077B2  2               
0077B2  2               QuestionBlockRow_Low:
0077B2  2  A9 07              lda #$07             ;start on the eighth row
0077B4  2  48                 pha                  ;save whatever row to the stack for now
0077B5  2  20 ED 79           jsr ChkLrgObjLength  ;get low nybble and save as length
0077B8  2  68                 pla
0077B9  2  AA                 tax                  ;render question boxes with coins
0077BA  2  A9 C0              lda #$c0
0077BC  2  9D A1 06           sta MetatileBuffer,x
0077BF  2  60                 rts
0077C0  2               
0077C0  2               ;--------------------------------
0077C0  2               
0077C0  2               Bridge_High:
0077C0  2  A9 06              lda #$06  ;start on the seventh row from top of screen
0077C2  2  2C                 .byte $2c   ;BIT instruction opcode
0077C3  2               
0077C3  2               Bridge_Middle:
0077C3  2  A9 07              lda #$07  ;start on the eighth row
0077C5  2  2C                 .byte $2c   ;BIT instruction opcode
0077C6  2               
0077C6  2               Bridge_Low:
0077C6  2  A9 09              lda #$09             ;start on the tenth row
0077C8  2  48                 pha                  ;save whatever row to the stack for now
0077C9  2  20 ED 79           jsr ChkLrgObjLength  ;get low nybble and save as length
0077CC  2  68                 pla
0077CD  2  AA                 tax                  ;render bridge railing
0077CE  2  A9 0B              lda #$0b
0077D0  2  9D A1 06           sta MetatileBuffer,x
0077D3  2  E8                 inx
0077D4  2  A0 00              ldy #$00             ;now render the bridge itself
0077D6  2  A9 64              lda #$64
0077D8  2  4C C6 79           jmp RenderUnderPart
0077DB  2               
0077DB  2               ;--------------------------------
0077DB  2               
0077DB  2               FlagBalls_Residual:
0077DB  2  20 FC 79           jsr GetLrgObjAttrib  ;get low nybble from object byte
0077DE  2  A2 02              ldx #$02             ;render flag balls on third row from top
0077E0  2  A9 6F              lda #$6f             ;of screen downwards based on low nybble
0077E2  2  4C C6 79           jmp RenderUnderPart
0077E5  2               
0077E5  2               ;--------------------------------
0077E5  2               
0077E5  2               FlagpoleObject:
0077E5  2  A9 21              lda #$21                 ;render flagpole ball on top
0077E7  2  8D A1 06           sta MetatileBuffer
0077EA  2  A2 01              ldx #$01                 ;now render the flagpole shaft
0077EC  2  A0 08              ldy #$08
0077EE  2  A9 22              lda #$22
0077F0  2  20 C6 79           jsr RenderUnderPart
0077F3  2  A9 62              lda #$62                 ;render solid block at the bottom
0077F5  2  8D AB 06           sta MetatileBuffer+10
0077F8  2  20 0C 7A           jsr GetAreaObjXPosition
0077FB  2  38                 sec                      ;get pixel coordinate of where the flagpole is,
0077FC  2  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
0077FE  2  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
007800  2  AD 25 07           lda CurrentPageLoc
007803  2  E9 00              sbc #$00                 ;subtract borrow from page location and use as
007805  2  85 73              sta Enemy_PageLoc+5      ;page location for the flag
007807  2  A9 30              lda #$30
007809  2  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
00780B  2  A9 B0              lda #$b0
00780D  2  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
007810  2  A9 30              lda #FlagpoleFlagObject
007812  2  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
007814  2  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
007816  2  60                 rts
007817  2               
007817  2               ;--------------------------------
007817  2               
007817  2               EndlessRope:
007817  2  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
007819  2  A0 0F              ldy #$0f
00781B  2  4C 30 78           jmp DrawRope
00781E  2               
00781E  2               BalancePlatRope:
00781E  2  8A                     txa                 ;save object buffer offset for now
00781F  2  48                     pha
007820  2  A2 01                  ldx #$01            ;blank out all from second row to the bottom
007822  2  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
007824  2  A9 44                  lda #$44
007826  2  20 C6 79               jsr RenderUnderPart
007829  2  68                     pla                 ;get back object buffer offset
00782A  2  AA                     tax
00782B  2  20 FC 79               jsr GetLrgObjAttrib ;get vertical length from lower nybble
00782E  2  A2 01                  ldx #$01
007830  2  A9 40        DrawRope: lda #$40            ;render the actual rope
007832  2  4C C6 79               jmp RenderUnderPart
007835  2               
007835  2               ;--------------------------------
007835  2               
007835  2               CoinMetatileData:
007835  2  C4 C3 C3 C3        .byte $c4, $c3, $c3, $c3
007839  2               
007839  2               RowOfCoins:
007839  2  AC 4E 07           ldy AreaType            ;get area type
00783C  2  B9 35 78           lda CoinMetatileData,y  ;load appropriate coin metatile
00783F  2  4C 8B 78           jmp GetRow
007842  2               
007842  2               ;--------------------------------
007842  2               
007842  2               C_ObjectRow:
007842  2  06 07 08           .byte $06, $07, $08
007845  2               
007845  2               C_ObjectMetatile:
007845  2  C6 0C 89           .byte $c6, $0c, $89
007848  2               
007848  2               CastleBridgeObj:
007848  2  A0 0C              ldy #$0c                  ;load length of 13 columns
00784A  2  20 F0 79           jsr ChkLrgObjFixedLength
00784D  2  4C 55 78           jmp ChainObj
007850  2               
007850  2               AxeObj:
007850  2  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
007852  2  8D 73 07           sta VRAM_Buffer_AddrCtrl
007855  2               
007855  2               ChainObj:
007855  2  A4 00              ldy $00                   ;get value loaded earlier from decoder
007857  2  BE 40 78           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
00785A  2  B9 43 78           lda C_ObjectMetatile-2,y
00785D  2  4C 67 78           jmp ColObj
007860  2               
007860  2               EmptyBlock:
007860  2  20 FC 79             jsr GetLrgObjAttrib  ;get row location
007863  2  A6 07                ldx $07
007865  2  A9 C5                lda #$c5
007867  2  A0 00        ColObj: ldy #$00             ;column length of 1
007869  2  4C C6 79             jmp RenderUnderPart
00786C  2               
00786C  2               ;--------------------------------
00786C  2               
00786C  2               SolidBlockMetatiles:
00786C  2  6A 62 62 63        .byte $6a, $62, $62, $63
007870  2               
007870  2               BrickMetatiles:
007870  2  1F 4F 50 50        .byte $1f, $4f, $50, $50
007874  2  88                 .byte $88 ;used only by row of bricks object
007875  2               
007875  2               RowOfBricks:
007875  2  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
007878  2  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
00787B  2  F0 02                    beq DrawBricks
00787D  2  A0 04                    ldy #$04               ;if cloud type, override area type
00787F  2  B9 70 78     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
007882  2  4C 8B 78                 jmp GetRow             ;and go render it
007885  2               
007885  2               RowOfSolidBlocks:
007885  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
007888  2  B9 6C 78              lda SolidBlockMetatiles,y  ;get metatile
00788B  2  48           GetRow:  pha                        ;store metatile here
00788C  2  20 ED 79              jsr ChkLrgObjLength        ;get row number, load length
00788F  2  A6 07        DrawRow: ldx $07
007891  2  A0 00                 ldy #$00                   ;set vertical height of 1
007893  2  68                    pla
007894  2  4C C6 79              jmp RenderUnderPart        ;render object
007897  2               
007897  2               ColumnOfBricks:
007897  2  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
00789A  2  B9 70 78           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
00789D  2  4C A6 78           jmp GetRow2
0078A0  2               
0078A0  2               ColumnOfSolidBlocks:
0078A0  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
0078A3  2  B9 6C 78              lda SolidBlockMetatiles,y  ;get metatile
0078A6  2  48           GetRow2: pha                        ;save metatile to stack for now
0078A7  2  20 FC 79              jsr GetLrgObjAttrib        ;get length and row
0078AA  2  68                    pla                        ;restore metatile
0078AB  2  A6 07                 ldx $07                    ;get starting row
0078AD  2  4C C6 79              jmp RenderUnderPart        ;now render the column
0078B0  2               
0078B0  2               ;--------------------------------
0078B0  2               
0078B0  2               BulletBillCannon:
0078B0  2  20 FC 79                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
0078B3  2  A6 07                     ldx $07                  ;start at first row
0078B5  2  A9 65                     lda #$65                 ;render bullet bill cannon
0078B7  2  9D A1 06                  sta MetatileBuffer,x
0078BA  2  E8                        inx
0078BB  2  88                        dey                      ;done yet?
0078BC  2  30 0E                     bmi SetupCannon
0078BE  2  A9 66                     lda #$66                 ;if not, render middle part
0078C0  2  9D A1 06                  sta MetatileBuffer,x
0078C3  2  E8                        inx
0078C4  2  88                        dey                      ;done yet?
0078C5  2  30 05                     bmi SetupCannon
0078C7  2  A9 67                     lda #$67                 ;if not, render bottom until length expires
0078C9  2  20 C6 79                  jsr RenderUnderPart
0078CC  2  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
0078CF  2  20 14 7A                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
0078D2  2  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
0078D5  2  AD 25 07                  lda CurrentPageLoc
0078D8  2  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
0078DB  2  20 0C 7A                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
0078DE  2  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
0078E1  2  E8                        inx
0078E2  2  E0 06                     cpx #$06                 ;increment and check offset
0078E4  2  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
0078E6  2  A2 00                     ldx #$00                 ;otherwise initialize it
0078E8  2  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
0078EB  2  60                        rts
0078EC  2               
0078EC  2               ;--------------------------------
0078EC  2               
0078EC  2               StaircaseHeightData:
0078EC  2  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
0078F0  2  04 03 02 01  
0078F4  2  00           
0078F5  2               
0078F5  2               StaircaseRowData:
0078F5  2  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
0078F9  2  06 07 08 09  
0078FD  2  0A           
0078FE  2               
0078FE  2               StaircaseObject:
0078FE  2  20 ED 79                jsr ChkLrgObjLength       ;check and load length
007901  2  90 05                   bcc NextStair             ;if length already loaded, skip init part
007903  2  A9 09                   lda #$09                  ;start past the end for the bottom
007905  2  8D 34 07                sta StaircaseControl      ;of the staircase
007908  2  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
00790B  2  AC 34 07                ldy StaircaseControl
00790E  2  BE F5 78                ldx StaircaseRowData,y    ;get starting row and height to render
007911  2  B9 EC 78                lda StaircaseHeightData,y
007914  2  A8                      tay
007915  2  A9 62                   lda #$62                  ;now render solid block staircase
007917  2  4C C6 79                jmp RenderUnderPart
00791A  2               
00791A  2               ;--------------------------------
00791A  2               
00791A  2               Jumpspring:
00791A  2  20 FC 79           jsr GetLrgObjAttrib
00791D  2  20 91 77           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
007920  2  B0 27              bcs NoJs                    ;if none, cancel (potentially problematic!)
007922  2  20 0C 7A           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
007925  2  95 87              sta Enemy_X_Position,x      ;and store
007927  2  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
00792A  2  95 6E              sta Enemy_PageLoc,x
00792C  2  20 14 7A           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
00792F  2  95 CF              sta Enemy_Y_Position,x      ;and store
007931  2  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
007933  2  A9 32              lda #JumpspringObject
007935  2  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
007937  2  A0 01              ldy #$01
007939  2  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
00793B  2  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
00793D  2  A6 07              ldx $07
00793F  2  A9 68              lda #$68                    ;draw metatiles in two rows where jumpspring is
007941  2  9D A1 06           sta MetatileBuffer,x
007944  2  A9 69              lda #$69
007946  2  9D A2 06           sta MetatileBuffer+1,x
007949  2  60           NoJs: rts
00794A  2               
00794A  2               ;--------------------------------
00794A  2               ;$07 - used to save ID of brick object
00794A  2               
00794A  2               Hidden1UpBlock:
00794A  2  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
00794D  2  F0 36              beq ExitDecBlock
00794F  2  A9 00              lda #$00           ;if set, init for the next one
007951  2  8D 5D 07           sta Hidden1UpFlag
007954  2  4C 62 79           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
007957  2               
007957  2               QuestionBlock:
007957  2  20 7F 79           jsr GetAreaObjectID ;get value from level decoder routine
00795A  2  4C 75 79           jmp DrawQBlk        ;go to render it
00795D  2               
00795D  2               BrickWithCoins:
00795D  2  A9 00              lda #$00                 ;initialize multi-coin timer flag
00795F  2  8D BC 06           sta BrickCoinTimerFlag
007962  2               
007962  2               BrickWithItem:
007962  2  20 7F 79               jsr GetAreaObjectID         ;save area object ID
007965  2  84 07                  sty $07
007967  2  A9 00                  lda #$00                    ;load default adder for bricks with lines
007969  2  AC 4E 07               ldy AreaType                ;check level type for ground level
00796C  2  88                     dey
00796D  2  F0 02                  beq BWithL                  ;if ground type, do not start with 6
00796F  2  A9 06                  lda #$06                    ;otherwise use adder for bricks without lines
007971  2  18           BWithL:   clc                         ;add object ID to adder
007972  2  65 07                  adc $07
007974  2  A8                     tay                         ;use as offset for metatile
007975  2  B9 B4 89     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
007978  2  48                     pha                         ;if branched to here from question block routine)
007979  2  20 FC 79               jsr GetLrgObjAttrib         ;get row from location byte
00797C  2  4C 8F 78               jmp DrawRow                 ;now render the object
00797F  2               
00797F  2               GetAreaObjectID:
00797F  2  A5 00                      lda $00    ;get value saved from area parser routine
007981  2  38                         sec
007982  2  E9 00                      sbc #$00   ;possibly residual code
007984  2  A8                         tay        ;save to Y
007985  2  60           ExitDecBlock: rts
007986  2               
007986  2               ;--------------------------------
007986  2               
007986  2               HoleMetatiles:
007986  2  87 00 00 00        .byte $87, $00, $00, $00
00798A  2               
00798A  2               Hole_Empty:
00798A  2  20 ED 79                 jsr ChkLrgObjLength          ;get lower nybble and save as length
00798D  2  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
00798F  2  AD 4E 07                 lda AreaType                 ;check for water type level
007992  2  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
007994  2  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
007997  2  20 0C 7A                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
00799A  2  38                       sec
00799B  2  E9 10                    sbc #$10                     ;subtract 16 pixels
00799D  2  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
0079A0  2  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
0079A3  2  E9 00                    sbc #$00                     ;subtract borrow
0079A5  2  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
0079A8  2  C8                       iny
0079A9  2  C8                       iny                          ;increment length by 2
0079AA  2  98                       tya
0079AB  2  0A                       asl                          ;multiply by 16 to get size of whirlpool
0079AC  2  0A                       asl                          ;note that whirlpool will always be
0079AD  2  0A                       asl                          ;two blocks bigger than actual size of hole
0079AE  2  0A                       asl                          ;and extend one block beyond each edge
0079AF  2  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
0079B2  2  E8                       inx
0079B3  2  E0 05                    cpx #$05                     ;increment and check offset
0079B5  2  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
0079B7  2  A2 00                    ldx #$00                     ;otherwise initialize it
0079B9  2  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
0079BC  2  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
0079BF  2  BD 86 79                 lda HoleMetatiles,x          ;render the hole proper
0079C2  2  A2 08                    ldx #$08
0079C4  2  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
0079C6  2               
0079C6  2               ;--------------------------------
0079C6  2               
0079C6  2               RenderUnderPart:
0079C6  2  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
0079C9  2  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
0079CC  2  F0 10                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
0079CE  2  C0 17                     cpy #$17
0079D0  2  F0 0F                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
0079D2  2  C0 8B                     cpy #$8b
0079D4  2  F0 0B                     beq WaitOneRow        ;if middle part (cloud ledge), wait until next row
0079D6  2  C0 C0                     cpy #$c0
0079D8  2  F0 04                     beq DrawThisRow       ;if question block w/ coin, overwrite
0079DA  2  C0 C0                     cpy #$c0
0079DC  2  B0 03                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
0079DE  2  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
0079E1  2  E8           WaitOneRow:  inx
0079E2  2  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
0079E4  2  B0 06                     bcs ExitUPartR
0079E6  2  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
0079E9  2  88                        dey
0079EA  2  10 DA                     bpl RenderUnderPart
0079EC  2  60           ExitUPartR:  rts
0079ED  2               
0079ED  2               
0079ED  2               ChkLrgObjLength:
0079ED  2  20 FC 79             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
0079F0  2               
0079F0  2               ChkLrgObjFixedLength:
0079F0  2  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
0079F3  2  18                   clc                     ;clear carry flag for not just starting
0079F4  2  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
0079F6  2  98                   tya                     ;save length into length counter
0079F7  2  9D 30 07             sta AreaObjectLength,x
0079FA  2  38                   sec                     ;set carry flag if just starting
0079FB  2  60           LenSet: rts
0079FC  2               
0079FC  2               GetLrgObjAttrib:
0079FC  2  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
0079FF  2  B1 E7              lda (AreaData),y          ;get first byte of level object
007A01  2  29 0F              and #%00001111
007A03  2  85 07              sta $07                   ;save row location
007A05  2  C8                 iny
007A06  2  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
007A08  2  29 0F              and #%00001111            ;as Y, then leave
007A0A  2  A8                 tay
007A0B  2  60                 rts
007A0C  2               
007A0C  2               ;--------------------------------
007A0C  2               
007A0C  2               GetAreaObjXPosition:
007A0C  2  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
007A0F  2  0A                 asl                     ;to obtain horizontal pixel coordinate
007A10  2  0A                 asl
007A11  2  0A                 asl
007A12  2  0A                 asl
007A13  2  60                 rts
007A14  2               
007A14  2               ;--------------------------------
007A14  2               
007A14  2               GetAreaObjYPosition:
007A14  2  A5 07              lda $07  ;multiply value by 16
007A16  2  0A                 asl
007A17  2  0A                 asl      ;this will give us the proper vertical pixel coordinate
007A18  2  0A                 asl
007A19  2  0A                 asl
007A1A  2  18                 clc
007A1B  2  69 20              adc #32  ;add 32 pixels for the status bar
007A1D  2  60                 rts
007A1E  2               
007A1E  2               ;-------------------------------------------------------------------------------------
007A1E  2               ;$06-$07 - used to store block buffer address used as indirect
007A1E  2               
007A1E  2               BlockBufferAddr:
007A1E  2  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
007A20  2  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
007A22  2               
007A22  2               GetBlockBufferAddr:
007A22  2  48                 pha                      ;take value of A, save
007A23  2  4A                 lsr                      ;move high nybble to low
007A24  2  4A                 lsr
007A25  2  4A                 lsr
007A26  2  4A                 lsr
007A27  2  A8                 tay                      ;use nybble as pointer to high byte
007A28  2  B9 20 7A           lda BlockBufferAddr+2,y  ;of indirect here
007A2B  2  85 07              sta $07
007A2D  2  68                 pla
007A2E  2  29 0F              and #%00001111           ;pull from stack, mask out high nybble
007A30  2  18                 clc
007A31  2  79 1E 7A           adc BlockBufferAddr,y    ;add to low byte
007A34  2  85 06              sta $06                  ;store here and leave
007A36  2  60                 rts
007A37  2               
007A37  2               ;-------------------------------------------------------------------------------------
007A37  2               
007A37  2               GameModeSubs:
007A37  2  AD 72 07           lda OperMode_Task
007A3A  2  20 7D 6C           jsr JumpEngine
007A3D  2               
007A3D  2  4D C0              .word GameModeDiskRoutines
007A3F  2  39 6E              .word InitializeArea
007A41  2  C5 64              .word ScreenRoutines
007A43  2  B9 6E              .word SecondaryGameSetup
007A45  2  47 7A              .word GameCoreRoutine
007A47  2               
007A47  2               GameCoreRoutine:
007A47  2  20 A2 7B           jsr GameRoutines           ;execute one of many possible subs
007A4A  2  AD 72 07           lda OperMode_Task          ;check major task of operating mode
007A4D  2  C9 04              cmp #$04                   ;if we are supposed to be here,
007A4F  2  B0 01              bcs GameEngine             ;branch to the game engine itself
007A51  2  60                 rts
007A52  2               
007A52  2               GameEngine:
007A52  2  20 90 81                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
007A55  2  A2 00                      ldx #$00
007A57  2  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
007A59  2  20 23 8C                   jsr EnemiesAndLoopsCore    ;process enemy objects
007A5C  2  20 21 64                   jsr FloateyNumbersRoutine  ;process floatey numbers
007A5F  2  E8                         inx
007A60  2  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
007A62  2  D0 F3                      bne ProcELoop
007A64  2  20 65 BE                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
007A67  2  20 0F BE                   jsr RelativePlayerPosition ;get relative coordinates for player object
007A6A  2  20 C4 BB                   jsr PlayerGfxHandler       ;draw the player
007A6D  2  20 A5 8A                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
007A70  2  A2 01                      ldx #$01
007A72  2  86 08                      stx ObjectOffset           ;set offset for second
007A74  2  20 41 8A                   jsr BlockObjectsCore       ;process second block object
007A77  2  CA                         dex
007A78  2  86 08                      stx ObjectOffset           ;set offset for first
007A7A  2  20 41 8A                   jsr BlockObjectsCore       ;process first block object
007A7D  2  20 61 87                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
007A80  2  20 87 85                   jsr ProcessCannons         ;process bullet bill cannons
007A83  2  20 21 83                   jsr ProcessWhirlpools      ;process whirlpools
007A86  2  20 BE 83                   jsr FlagpoleRoutine        ;process the flagpole
007A89  2  20 BB 82                   jsr RunGameTimer           ;count down the game timer
007A8C  2  20 BE 68                   jsr ColorRotation          ;cycle one of the background colors
007A8F  2  AD F7 07                   lda FileListNumber
007A92  2  F0 03                      beq NoWind                 ;if in worlds 1-4, skip ahead
007A94  2  20 rr rr                   jsr SimulateWind           ;otherwise, simulate wind where needed
007A97  2  A5 B5        NoWind:       lda Player_Y_HighPos
007A99  2  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
007A9B  2  10 11                      bpl NoChgMus
007A9D  2  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
007AA0  2  F0 1E                      beq ClrPlrPal              ;skip this part
007AA2  2  C9 04                      cmp #$04
007AA4  2  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
007AA6  2  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
007AA9  2  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
007AAB  2  20 2D 6F                   jsr GetAreaMusic           ;to re-attain appropriate level music
007AAE  2  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
007AB1  2  A5 09                      lda FrameCounter           ;get frame counter
007AB3  2  C0 08                      cpy #$08                   ;if timer still above certain point,
007AB5  2  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
007AB7  2  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
007AB8  2  4A                         lsr
007AB9  2  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
007ABA  2  20 E0 7D                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
007ABD  2  4C C3 7A                   jmp SaveAB                 ;then skip this sub to finish up the game engine
007AC0  2  20 F2 7D     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
007AC3  2  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
007AC5  2  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
007AC7  2  A9 00                      lda #$00
007AC9  2  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
007ACB  2  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
007ACE  2  C9 06                      cmp #$06                   ;if vram address controller set to 6
007AD0  2  F0 1C                      beq ExitEng                ;then branch to leave
007AD2  2  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
007AD5  2  D0 14                      bne RunParser
007AD7  2  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
007ADA  2  C9 20                      cmp #$20                   ;check to see if exceeded $21
007ADC  2  30 10                      bmi ExitEng                ;branch to leave if not
007ADE  2  AD 3D 07                   lda ScrollThirtyTwo
007AE1  2  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
007AE3  2  8D 3D 07                   sta ScrollThirtyTwo        ;and store
007AE6  2  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
007AE8  2  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer in second VRAM buffer
007AEB  2  20 C1 70     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
007AEE  2  60           ExitEng:      rts                        ;and after all that, we're finally done!
007AEF  2               
007AEF  2               ScrollHandler:
007AEF  2  AD FF 06                 lda Player_X_Scroll       ;load value saved here
007AF2  2  18                       clc
007AF3  2  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
007AF6  2  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
007AF9  2  AD 23 07                 lda ScrollLock            ;check scroll lock flag
007AFC  2  D0 55                    bne InitScrlAmt           ;skip a bunch of code here if set
007AFE  2  AD 55 07                 lda Player_Pos_ForScroll
007B01  2  C9 50                    cmp #$50                  ;check player's horizontal screen position
007B03  2  90 4E                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
007B05  2  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
007B08  2  D0 49                    bne InitScrlAmt           ;not expired, branch
007B0A  2  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
007B0D  2  88                       dey                       ;if value originally set to zero or otherwise
007B0E  2  30 43                    bmi InitScrlAmt           ;negative for left movement, branch
007B10  2  C8                       iny
007B11  2  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
007B13  2  90 01                    bcc ChkNearMid
007B15  2  88                       dey                       ;otherwise decrement by one
007B16  2  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
007B19  2  C9 70                    cmp #$70                  ;check player's horizontal screen position
007B1B  2  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
007B1D  2  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
007B20  2               
007B20  2               ScrollScreen:
007B20  2  AD 7B 07                   lda IRQAckFlag
007B23  2  D0 FB                      bne ScrollScreen           ;loop if IRQ has not yet happened
007B25  2  98                         tya
007B26  2  8D 75 07                   sta ScrollAmount           ;save value here
007B29  2  18                         clc
007B2A  2  6D 3D 07                   adc ScrollThirtyTwo        ;add to value already set here
007B2D  2  8D 3D 07                   sta ScrollThirtyTwo        ;save as new value here
007B30  2  98                         tya
007B31  2  18                         clc
007B32  2  6D 1C 07                   adc ScreenLeft_X_Pos       ;add to left side coordinate
007B35  2  8D 1C 07                   sta ScreenLeft_X_Pos       ;save as new left side coordinate
007B38  2  8D 3F 07                   sta HorizontalScroll       ;save here also
007B3B  2  AD 1A 07                   lda ScreenLeft_PageLoc
007B3E  2  69 00                      adc #$00                   ;add carry to page location for left
007B40  2  8D 1A 07                   sta ScreenLeft_PageLoc     ;side of the screen
007B43  2  29 01                      and #$01                   ;get LSB of page location
007B45  2  8D 7A 07                   sta NameTableSelect        ;save as name table select for later use
007B48  2  20 90 7B                   jsr GetScreenPosition
007B4B  2  A9 08                      lda #$08
007B4D  2  8D 95 07                   sta ScrollIntervalTimer    ;set scroll timer (residual, not used elsewhere)
007B50  2  4C 58 7B                   jmp ChkPOffscr             ;skip this part
007B53  2  A9 00        InitScrlAmt:  lda #$00
007B55  2  8D 75 07                   sta ScrollAmount           ;initialize value here
007B58  2  A2 00        ChkPOffscr:   ldx #$00                   ;set X for player offset
007B5A  2  20 DB BE                   jsr GetXOffscreenBits      ;get horizontal offscreen bits for player
007B5D  2  85 00                      sta $00                    ;save them here
007B5F  2  A0 00                      ldy #$00                   ;load default offset (left side)
007B61  2  0A                         asl                        ;if d7 of offscreen bits are set,
007B62  2  B0 07                      bcs KeepOnscr              ;branch with default offset
007B64  2  C8                         iny                        ;otherwise use different offset (right side)
007B65  2  A5 00                      lda $00
007B67  2  29 20                      and #%00100000             ;check offscreen bits for d5 set
007B69  2  F0 1B                      beq InitPlatScrl           ;if not set, branch ahead of this part
007B6B  2  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y     ;get left or right side coordinate based on offset
007B6E  2  38                         sec
007B6F  2  F9 8C 7B                   sbc X_SubtracterData,y     ;subtract amount based on offset
007B72  2  85 86                      sta Player_X_Position      ;store as player position to prevent movement further
007B74  2  B9 1A 07                   lda ScreenEdge_PageLoc,y   ;get left or right page location based on offset
007B77  2  E9 00                      sbc #$00                   ;subtract borrow
007B79  2  85 6D                      sta Player_PageLoc         ;save as player's page location
007B7B  2  A5 0C                      lda Left_Right_Buttons     ;check saved controller bits
007B7D  2  D9 8E 7B                   cmp OffscrJoypadBitsData,y ;against bits based on offset
007B80  2  F0 04                      beq InitPlatScrl           ;if not equal, branch
007B82  2  A9 00                      lda #$00
007B84  2  85 57                      sta Player_X_Speed         ;otherwise nullify horizontal speed of player
007B86  2  A9 00        InitPlatScrl: lda #$00                   ;nullify platform force imposed on scroll
007B88  2  8D A1 03                   sta Platform_X_Scroll
007B8B  2  60                         rts
007B8C  2               
007B8C  2               X_SubtracterData:
007B8C  2  00 10              .byte $00, $10
007B8E  2               
007B8E  2               OffscrJoypadBitsData:
007B8E  2  01 02              .byte $01, $02
007B90  2               
007B90  2               ;-------------------------------------------------------------------------------------
007B90  2               
007B90  2               GetScreenPosition:
007B90  2  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
007B93  2  18                 clc
007B94  2  69 FF              adc #$ff                ;add 255 pixels
007B96  2  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
007B99  2  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
007B9C  2  69 00              adc #$00                ;add carry from before
007B9E  2  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
007BA1  2  60                 rts
007BA2  2               
007BA2  2               ;-------------------------------------------------------------------------------------
007BA2  2               
007BA2  2               GameRoutines:
007BA2  2  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
007BA4  2  20 7D 6C           jsr JumpEngine            ;merely placeholders as conditions for other routines)
007BA7  2               
007BA7  2  71 6F              .word Entrance_GameTimerSetup
007BA9  2  1F 7D              .word Vine_AutoClimb
007BAB  2  5E 7D              .word SideExitPipeEntry
007BAD  2  3D 7D              .word VerticalPipeEntry
007BAF  2  FB 7D              .word FlagpoleSlide
007BB1  2  19 7E              .word PlayerEndLevel
007BB3  2  0F 70              .word PlayerLoseLife
007BB5  2  C1 7B              .word PlayerEntrance
007BB7  2  41 7C              .word PlayerCtrlRoutine
007BB9  2  8B 7D              .word PlayerChangeSize
007BBB  2  9D 7D              .word PlayerInjuryBlink
007BBD  2  C1 7D              .word PlayerDeath
007BBF  2  D5 7D              .word PlayerFireFlower
007BC1  2               
007BC1  2               PlayerEntrance:
007BC1  2  AD 52 07                 lda AltEntranceControl    ;check for mode of alternate entry
007BC4  2  C9 02                    cmp #$02
007BC6  2  F0 2B                    beq EntrMode2             ;if found, branch to enter from pipe or with vine
007BC8  2  A9 00                    lda #$00
007BCA  2  A4 CE                    ldy Player_Y_Position     ;if vertical position above a certain
007BCC  2  C0 30                    cpy #$30                  ;point, nullify controller bits and continue
007BCE  2  90 6E                    bcc AutoControlPlayer     ;with player movement code, do not return
007BD0  2  AD 10 07                 lda PlayerEntranceCtrl    ;check player entry bits from header
007BD3  2  C9 06                    cmp #$06
007BD5  2  F0 04                    beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
007BD7  2  C9 07                    cmp #$07                  ;otherwise branch to normal entry
007BD9  2  D0 50                    bne PlayerRdy
007BDB  2  AD C4 03     ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
007BDE  2  D0 05                    bne IntroEntr             ;branch if found
007BE0  2  A9 01                    lda #$01
007BE2  2  4C 3E 7C                 jmp AutoControlPlayer     ;force player to walk to the right
007BE5  2  20 77 7D     IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
007BE8  2  CE DE 06                 dec ChangeAreaTimer       ;decrement timer for change of area
007BEB  2  D0 50                    bne ExitEntr              ;branch to exit if not yet expired
007BED  2  EE 69 07                 inc DisableIntermediate   ;set flag to skip world and lives display
007BF0  2  4C 66 7E                 jmp NextArea              ;jump to increment to next area and set modes
007BF3  2  AD 58 07     EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
007BF6  2  D0 0C                    bne VineEntr              ;branch to enter with vine
007BF8  2  A9 FF                    lda #$ff                  ;otherwise, set value here then execute sub
007BFA  2  20 58 7D                 jsr MovePlayerYAxis       ;to move player upwards
007BFD  2  A5 CE                    lda Player_Y_Position     ;check to see if player is at a specific coordinate
007BFF  2  C9 91                    cmp #$91                  ;if player risen to a certain point (this requires pipes
007C01  2  90 28                    bcc PlayerRdy             ;to be at specific height to look/function right) branch
007C03  2  60                       rts                       ;to the last part, otherwise leave
007C04  2  AD 99 03     VineEntr:   lda VineHeight
007C07  2  C9 60                    cmp #$60                  ;check vine height
007C09  2  D0 32                    bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
007C0B  2  A5 CE                    lda Player_Y_Position     ;get player's vertical coordinate
007C0D  2  C9 99                    cmp #$99                  ;check player's vertical coordinate against preset value
007C0F  2  A0 00                    ldy #$00                  ;load default values to be written to
007C11  2  A9 01                    lda #$01                  ;this value moves player to the right off the vine
007C13  2  90 0A                    bcc OffVine               ;if vertical coordinate < preset value, use defaults
007C15  2  A9 03                    lda #$03
007C17  2  85 1D                    sta Player_State          ;otherwise set player state to climbing
007C19  2  C8                       iny                       ;increment value in Y
007C1A  2  A9 08                    lda #$08                  ;set block in block buffer to cover hole, then
007C1C  2  8D B4 05                 sta Block_Buffer_1+$b4    ;use same value to force player to climb
007C1F  2  8C 16 07     OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
007C22  2  20 3E 7C                 jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
007C25  2  A5 86                    lda Player_X_Position
007C27  2  C9 48                    cmp #$48                  ;check player's horizontal position
007C29  2  90 12                    bcc ExitEntr              ;if not far enough to the right, branch to leave
007C2B  2  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
007C2D  2  85 0E                    sta GameEngineSubroutine
007C2F  2  A9 01                    lda #$01                  ;set to face player to the right
007C31  2  85 33                    sta PlayerFacingDir
007C33  2  4A                       lsr                       ;init A
007C34  2  8D 52 07                 sta AltEntranceControl    ;init mode of entry
007C37  2  8D 16 07                 sta DisableCollisionDet   ;init collision detection disable flag
007C3A  2  8D 58 07                 sta JoypadOverride        ;nullify controller override bits
007C3D  2  60           ExitEntr:   rts                       ;leave!
007C3E  2               
007C3E  2               ;-------------------------------------------------------------------------------------
007C3E  2               ;$07 - used to hold upper limit of high byte when player falls down hole
007C3E  2               
007C3E  2               AutoControlPlayer:
007C3E  2  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
007C41  2               
007C41  2               PlayerCtrlRoutine:
007C41  2  A5 0E                    lda GameEngineSubroutine    ;check task here
007C43  2  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
007C45  2  F0 3C                    beq SizeChk
007C47  2  AD 4E 07                 lda AreaType                ;are we in a water type area?
007C4A  2  D0 10                    bne SaveJoyp                ;if not, branch
007C4C  2  A4 B5                    ldy Player_Y_HighPos
007C4E  2  88                       dey                         ;if not in vertical area between
007C4F  2  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
007C51  2  A5 CE                    lda Player_Y_Position
007C53  2  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
007C55  2  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
007C57  2  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
007C59  2  8D FC 06                 sta SavedJoypadBits
007C5C  2  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
007C5F  2  29 C0                    and #%11000000
007C61  2  85 0A                    sta A_B_Buttons
007C63  2  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
007C66  2  29 03                    and #%00000011
007C68  2  85 0C                    sta Left_Right_Buttons
007C6A  2  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
007C6D  2  29 0C                    and #%00001100
007C6F  2  85 0B                    sta Up_Down_Buttons
007C71  2  29 04                    and #%00000100              ;check for pressing down
007C73  2  F0 0E                    beq SizeChk                 ;if not, branch
007C75  2  A5 1D                    lda Player_State            ;check player's state
007C77  2  D0 0A                    bne SizeChk                 ;if not on the ground, branch
007C79  2  A4 0C                    ldy Left_Right_Buttons      ;check left and right
007C7B  2  F0 06                    beq SizeChk                 ;if neither pressed, branch
007C7D  2  A9 00                    lda #$00
007C7F  2  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
007C81  2  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
007C83  2  20 90 7E     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
007C86  2  A0 01                    ldy #$01                    ;is player small?
007C88  2  AD 54 07                 lda PlayerSize
007C8B  2  D0 09                    bne ChkMoveDir
007C8D  2  A0 00                    ldy #$00                    ;check for if crouching
007C8F  2  AD 14 07                 lda CrouchingFlag
007C92  2  F0 02                    beq ChkMoveDir              ;if not, branch ahead
007C94  2  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
007C96  2  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
007C99  2  A9 01                    lda #$01                    ;set moving direction to right by default
007C9B  2  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
007C9D  2  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
007C9F  2  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
007CA1  2  0A                       asl                         ;otherwise change to move to the left
007CA2  2  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
007CA4  2  20 EF 7A     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
007CA7  2  20 65 BE                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
007CAA  2  20 0F BE                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
007CAD  2  A2 00                    ldx #$00                    ;set offset for player object
007CAF  2  20 3A AF                 jsr BoundingBoxCore         ;get player's bounding box coordinates
007CB2  2  20 D2 A8                 jsr PlayerBGCollision       ;do collision detection and process
007CB5  2  A5 CE                    lda Player_Y_Position
007CB7  2  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
007CB9  2  90 16                    bcc PlayerHole              ;if so, branch ahead
007CBB  2  A5 0E                    lda GameEngineSubroutine
007CBD  2  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
007CBF  2  F0 10                    beq PlayerHole
007CC1  2  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
007CC3  2  F0 0C                    beq PlayerHole
007CC5  2  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
007CC7  2  90 08                    bcc PlayerHole
007CC9  2  AD C4 03                 lda Player_SprAttrib
007CCC  2  29 DF                    and #%11011111              ;otherwise nullify player's
007CCE  2  8D C4 03                 sta Player_SprAttrib        ;background priority flag
007CD1  2  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
007CD3  2  C9 02                    cmp #$02                    ;for below the screen
007CD5  2  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
007CD7  2  A2 01                    ldx #$01
007CD9  2  8E 23 07                 stx ScrollLock              ;set scroll lock
007CDC  2  A0 04                    ldy #$04
007CDE  2  84 07                    sty $07                     ;set value here
007CE0  2  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
007CE2  2  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
007CE5  2  D0 05                    bne HoleDie                 ;if set, branch
007CE7  2  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
007CEA  2  D0 16                    bne ChkHoleX                ;skip to last part if found
007CEC  2  E8           HoleDie:    inx                         ;set flag in X for player death
007CED  2  A4 0E                    ldy GameEngineSubroutine
007CEF  2  C0 0B                    cpy #$0b                    ;check for some other routine running
007CF1  2  F0 0F                    beq ChkHoleX                ;if so, branch ahead
007CF3  2  AC 12 07                 ldy DeathMusicLoaded        ;check value here
007CF6  2  D0 06                    bne HoleBottom              ;if already set, branch to next part
007CF8  2  C8                       iny
007CF9  2  84 FC                    sty EventMusicQueue         ;otherwise play death music
007CFB  2  8C 12 07                 sty DeathMusicLoaded        ;and set value here
007CFE  2  A0 06        HoleBottom: ldy #$06
007D00  2  84 07                    sty $07                     ;change value here
007D02  2  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
007D04  2  30 0C                    bmi ExitCtrl                ;if less, branch to leave
007D06  2  CA                       dex                         ;otherwise decrement flag in X
007D07  2  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
007D09  2  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
007D0C  2  D0 04                    bne ExitCtrl                ;branch to leave if so
007D0E  2  A9 06                    lda #$06                    ;otherwise set to run lose life routine
007D10  2  85 0E                    sta GameEngineSubroutine    ;on next frame
007D12  2  60           ExitCtrl:   rts                         ;leave
007D13  2               
007D13  2               CloudExit:
007D13  2  A9 00              lda #$00
007D15  2  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
007D18  2  20 35 7D           jsr SetEntr             ;do sub to set secondary mode
007D1B  2  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
007D1E  2  60                 rts
007D1F  2               
007D1F  2               ;-------------------------------------------------------------------------------------
007D1F  2               
007D1F  2               Vine_AutoClimb:
007D1F  2  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
007D21  2  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
007D23  2  A5 CE                   lda Player_Y_Position
007D25  2  C9 E4                   cmp #$e4
007D27  2  90 0C                   bcc SetEntr
007D29  2  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
007D2B  2  8D 58 07                sta JoypadOverride
007D2E  2  A0 03                   ldy #$03               ;set player state to climbing
007D30  2  84 1D                   sty Player_State
007D32  2  4C 3E 7C                jmp AutoControlPlayer
007D35  2  A9 02        SetEntr:   lda #$02               ;set starting position to override
007D37  2  8D 52 07                sta AltEntranceControl
007D3A  2  4C 6B 7D                jmp ChgAreaMode        ;set modes
007D3D  2               
007D3D  2               ;-------------------------------------------------------------------------------------
007D3D  2               
007D3D  2               VerticalPipeEntry:
007D3D  2  A9 01              lda #$01             ;set 1 as movement amount
007D3F  2  20 58 7D           jsr MovePlayerYAxis  ;do sub to move player downwards
007D42  2  20 EF 7A           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
007D45  2  A0 00              ldy #$00             ;load default mode of entry
007D47  2  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
007D4A  2  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
007D4C  2  C8                 iny
007D4D  2  AD 4E 07           lda AreaType         ;check for castle level type
007D50  2  C9 03              cmp #$03
007D52  2  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
007D54  2  C8                 iny
007D55  2  4C 63 7D           jmp ChgAreaPipe      ;otherwise use mode 2
007D58  2               
007D58  2               MovePlayerYAxis:
007D58  2  18                 clc
007D59  2  65 CE              adc Player_Y_Position ;add contents of A to player position
007D5B  2  85 CE              sta Player_Y_Position
007D5D  2  60                 rts
007D5E  2               
007D5E  2               ;-------------------------------------------------------------------------------------
007D5E  2               
007D5E  2               SideExitPipeEntry:
007D5E  2  20 77 7D                  jsr EnterSidePipe         ;execute sub to move player to the right
007D61  2  A0 02                     ldy #$02
007D63  2  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
007D66  2  D0 0E                     bne ExitCAPipe
007D68  2  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
007D6B  2  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
007D6E  2  A9 00                     lda #$00
007D70  2  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
007D73  2  8D 22 07                  sta IRQUpdateFlag         ;disable sprite 0 check
007D76  2  60           ExitCAPipe:  rts                       ;leave
007D77  2               
007D77  2               EnterSidePipe:
007D77  2  A9 08                   lda #$08               ;set player's horizontal speed
007D79  2  85 57                   sta Player_X_Speed
007D7B  2  A0 01                   ldy #$01               ;set controller right button by default
007D7D  2  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
007D7F  2  29 0F                   and #%00001111         ;horizontal position
007D81  2  D0 03                   bne RightPipe
007D83  2  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
007D85  2  A8                      tay                    ;and nullify controller bit override here
007D86  2  98           RightPipe: tya                    ;use contents of Y to
007D87  2  20 3E 7C                jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
007D8A  2  60                      rts
007D8B  2               
007D8B  2               ;-------------------------------------------------------------------------------------
007D8B  2               
007D8B  2               PlayerChangeSize:
007D8B  2  AD 47 07                  lda TimerControl    ;check master timer control
007D8E  2  C9 F8                     cmp #$f8            ;for specific moment in time
007D90  2  D0 03                     bne EndChgSize      ;branch if before or after that point
007D92  2  4C AD 7D                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
007D95  2  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
007D97  2  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
007D99  2  20 CB 7D                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
007D9C  2  60           ExitChgSize: rts                 ;and then leave
007D9D  2               
007D9D  2               ;-------------------------------------------------------------------------------------
007D9D  2               
007D9D  2               PlayerInjuryBlink:
007D9D  2  AD 47 07                lda TimerControl       ;check master timer control
007DA0  2  C9 F0                   cmp #$f0               ;for specific moment in time
007DA2  2  B0 07                   bcs ExitBlink          ;branch if before that point
007DA4  2  C9 C8                   cmp #$c8               ;check again for another specific point
007DA6  2  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
007DA8  2  4C 41 7C                jmp PlayerCtrlRoutine  ;otherwise run player control routine
007DAB  2  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
007DAD  2               
007DAD  2               InitChangeSize:
007DAD  2  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
007DB0  2  D0 0E                  bne ExitBoth              ;then branch to leave
007DB2  2  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
007DB5  2  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
007DB8  2  AD 54 07               lda PlayerSize
007DBB  2  49 01                  eor #$01                  ;invert player's size
007DBD  2  8D 54 07               sta PlayerSize
007DC0  2  60           ExitBoth: rts                       ;leave
007DC1  2               
007DC1  2               ;-------------------------------------------------------------------------------------
007DC1  2               ;$00 - used in CyclePlayerPalette to store current palette to cycle
007DC1  2               
007DC1  2               PlayerDeath:
007DC1  2  AD 47 07           lda TimerControl       ;check master timer control
007DC4  2  C9 F0              cmp #$f0               ;for specific moment in time
007DC6  2  B0 32              bcs ExitDeath          ;branch to leave if before that point
007DC8  2  4C 41 7C           jmp PlayerCtrlRoutine  ;otherwise run player control routine
007DCB  2               
007DCB  2               DonePlayerTask:
007DCB  2  A9 00              lda #$00
007DCD  2  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
007DD0  2  A9 08              lda #$08
007DD2  2  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
007DD4  2  60                 rts                       ;leave
007DD5  2               
007DD5  2               PlayerFireFlower:
007DD5  2  AD 47 07           lda TimerControl       ;check master timer control
007DD8  2  C9 C0              cmp #$c0               ;for specific moment in time
007DDA  2  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
007DDC  2  A5 09              lda FrameCounter       ;get frame counter
007DDE  2  4A                 lsr
007DDF  2  4A                 lsr                    ;divide by four to change every four frames
007DE0  2               
007DE0  2               CyclePlayerPalette:
007DE0  2  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
007DE2  2  85 00              sta $00               ;store result here to use as palette bits
007DE4  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
007DE7  2  29 FC              and #%11111100        ;save any other bits but palette bits
007DE9  2  05 00              ora $00               ;add palette bits
007DEB  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
007DEE  2  60                 rts                   ;and leave
007DEF  2               
007DEF  2               ResetPalFireFlower:
007DEF  2  20 CB 7D           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
007DF2  2               
007DF2  2               ResetPalStar:
007DF2  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
007DF5  2  29 FC              and #%11111100        ;mask out palette bits to force palette 0
007DF7  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
007DFA  2               ExitDeath:
007DFA  2  60                 rts                   ;and leave
007DFB  2               
007DFB  2               ;-------------------------------------------------------------------------------------
007DFB  2               
007DFB  2               FlagpoleSlide:
007DFB  2  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
007DFD  2  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
007DFF  2  D0 15                     bne NoFPObj              ;if not found, branch to something residual
007E01  2  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
007E04  2  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
007E06  2  A9 00                     lda #$00
007E08  2  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
007E0B  2  A4 CE                     ldy Player_Y_Position
007E0D  2  C0 9E                     cpy #$9e                 ;check to see if player has slid down
007E0F  2  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
007E11  2  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
007E13  2  4C 3E 7C     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
007E16  2  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
007E18  2  60                        rts                      ;be residual code)
007E19  2               
007E19  2               ;-------------------------------------------------------------------------------------
007E19  2               
007E19  2               PlayerEndLevel:
007E19  2  A9 01                  lda #$01                  ;force player to walk to the right
007E1B  2  20 3E 7C               jsr AutoControlPlayer
007E1E  2  A5 CE                  lda Player_Y_Position     ;check player's vertical position
007E20  2  C9 AE                  cmp #$ae
007E22  2  90 11                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
007E24  2  A9 00                  lda #$00
007E26  2  8D 23 07               sta ScrollLock            ;reactivate scroll
007E29  2  AD F6 07               lda FlagpoleMusicFlag     ;check flag to see if music was already queued
007E2C  2  D0 07                  bne ChkStop               ;if so, skip this
007E2E  2  A9 20                  lda #EndOfLevelMusic
007E30  2  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
007E32  2  EE F6 07               inc FlagpoleMusicFlag     ;set flag to keep music from getting queued more than once
007E35  2  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
007E38  2  4A                     lsr                       ;check for d0 set
007E39  2  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
007E3B  2  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
007E3E  2  D0 03                  bne InCastle              ;go ahead with the rest of the code
007E40  2  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
007E43  2  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
007E45  2  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
007E48  2  AD 46 07     RdyNextA: lda StarFlagTaskControl
007E4B  2  C9 05                  cmp #$05                  ;if star flag task control not yet set
007E4D  2  D0 40                  bne ExitNA                ;beyond last valid task number, branch to leave
007E4F  2  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
007E52  2  AD 5C 07               lda LevelNumber
007E55  2  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
007E57  2  D0 0D                  bne NextArea              ;and skip this last part here if not
007E59  2  AC 5F 07               ldy WorldNumber           ;get world number as offset
007E5C  2  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
007E5F  2  C9 0A                  cmp #$0a                  ;against minimum value, if player has not collected
007E61  2  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
007E63  2  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
007E66  2  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
007E69  2  AD 5F 07               lda WorldNumber
007E6C  2  C9 08                  cmp #$08
007E6E  2  D0 0F                  bne NotW9                 ;if not at end of world 9-4, branch
007E70  2  AD 5C 07               lda LevelNumber           ;otherwise reset level and area numbers properly
007E73  2  C9 04                  cmp #$04
007E75  2  D0 08                  bne NotW9
007E77  2  A9 00                  lda #$00
007E79  2  8D 5C 07               sta LevelNumber
007E7C  2  8D 60 07               sta AreaNumber
007E7F  2  20 A4 C2     NotW9:    jsr LoadAreaPointer       ;get new level pointer
007E82  2  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
007E85  2  20 6B 7D               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
007E88  2  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
007E8B  2  A9 80                  lda #Silence
007E8D  2  85 FC                  sta EventMusicQueue       ;silence music and leave
007E8F  2  60           ExitNA:   rts
007E90  2               
007E90  2               ;-------------------------------------------------------------------------------------
007E90  2               
007E90  2               PlayerMovementSubs:
007E90  2  A9 00                   lda #$00                  ;set A to init crouch flag by default
007E92  2  AC 54 07                ldy PlayerSize            ;is player small?
007E95  2  D0 08                   bne SetCrouch             ;if so, branch
007E97  2  A5 1D                   lda Player_State          ;check state of player
007E99  2  D0 07                   bne ProcMove              ;if not on the ground, branch
007E9B  2  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
007E9D  2  29 04                   and #%00000100            ;single out bit for down button
007E9F  2  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
007EA2  2  20 BC 7F     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
007EA5  2  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
007EA8  2  D0 16                   bne NoMoveSub             ;branch to leave
007EAA  2  A5 1D                   lda Player_State
007EAC  2  C9 03                   cmp #$03                  ;get player state
007EAE  2  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
007EB0  2  A0 18                   ldy #$18
007EB2  2  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
007EB5  2  20 7D 6C     MoveSubs:  jsr JumpEngine
007EB8  2               
007EB8  2  C1 7E              .word OnGroundStateSub
007EBA  2  E5 7E              .word JumpSwimSub
007EBC  2  DC 7E              .word FallingSub
007EBE  2  3B 7F              .word ClimbingSub
007EC0  2               
007EC0  2  60           NoMoveSub: rts
007EC1  2               
007EC1  2               ;-------------------------------------------------------------------------------------
007EC1  2               ;$00 - used by ClimbingSub to store high vertical adder
007EC1  2               
007EC1  2               OnGroundStateSub:
007EC1  2  20 FB 80              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
007EC4  2  A5 0C                 lda Left_Right_Buttons
007EC6  2  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
007EC8  2  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
007ECA  2  20 38 81     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
007ECD  2  20 DA 8A     JmpMove: jsr MovePlayerHorizontally ;do another sub to move player horizontally
007ED0  2  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
007ED3  2  AD F7 07              lda FileListNumber         ;if in worlds 1-4 don't bother checking for wind
007ED6  2  F0 03                 beq ExOGSS
007ED8  2  20 rr rr              jsr BlowPlayerAround
007EDB  2  60           ExOGSS:  rts
007EDC  2               
007EDC  2               ;--------------------------------
007EDC  2               
007EDC  2               FallingSub:
007EDC  2  AD 0A 07           lda VerticalForceDown
007EDF  2  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
007EE2  2  4C 1B 7F           jmp LRAir              ;movement force, then skip ahead to process left/right movement
007EE5  2               
007EE5  2               ;--------------------------------
007EE5  2               
007EE5  2               JumpSwimSub:
007EE5  2  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
007EE7  2  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
007EE9  2  A5 0A                  lda A_B_Buttons
007EEB  2  29 80                  and #A_Button              ;check to see if A button is being pressed
007EED  2  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
007EEF  2  D0 11                  bne ProcSwim               ;if so, branch elsewhere
007EF1  2  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
007EF4  2  38                     sec
007EF5  2  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
007EF7  2  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
007EFA  2  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
007EFC  2  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
007EFF  2  8D 09 07               sta VerticalForce
007F02  2  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
007F05  2  F0 14                  beq LRAir                  ;branch ahead to last part
007F07  2  20 FB 80               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
007F0A  2  A5 CE                  lda Player_Y_Position
007F0C  2  C9 14                  cmp #$14                   ;check vertical position against preset value
007F0E  2  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
007F10  2  A9 18                  lda #$18
007F12  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
007F15  2  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
007F17  2  F0 02                  beq LRAir                  ;if not pressing any, skip
007F19  2  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
007F1B  2  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
007F1D  2  F0 03                  beq JSMove                 ;if not pressing any, skip
007F1F  2  20 38 81               jsr ImposeFriction         ;otherwise process horizontal movement
007F22  2  20 CD 7E     JSMove:   jsr JmpMove
007F25  2  A5 0E                  lda GameEngineSubroutine
007F27  2  C9 0B                  cmp #$0b                   ;check for specific routine selected
007F29  2  D0 05                  bne ExitMov1               ;branch if not set to run
007F2B  2  A9 28                  lda #$28
007F2D  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
007F30  2  4C 1E 8B     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
007F33  2               
007F33  2               ;--------------------------------
007F33  2               
007F33  2               ClimbAdderLow:
007F33  2  0E 04 FC F2        .byte $0e, $04, $fc, $f2
007F37  2               ClimbAdderHigh:
007F37  2  00 00 FF FF        .byte $00, $00, $ff, $ff
007F3B  2               
007F3B  2               ClimbingSub:
007F3B  2  AD 16 04                  lda Player_YMF_Dummy
007F3E  2  18                        clc                      ;add movement force to dummy variable
007F3F  2  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
007F42  2  8D 16 04                  sta Player_YMF_Dummy
007F45  2  A0 00                     ldy #$00                 ;set default adder here
007F47  2  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
007F49  2  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
007F4B  2  88                        dey                      ;otherwise set adder to $ff
007F4C  2  84 00        MoveOnVine:  sty $00                  ;store adder here
007F4E  2  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
007F50  2  85 CE                     sta Player_Y_Position    ;and store to move player up or down
007F52  2  A5 B5                     lda Player_Y_HighPos
007F54  2  65 00                     adc $00                  ;add carry to player's page location
007F56  2  85 B5                     sta Player_Y_HighPos     ;and store
007F58  2  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
007F5A  2  2D 90 04                  and Player_CollisionBits ;to collision flag
007F5D  2  F0 2D                     beq InitCSTimer          ;if not set, skip to end
007F5F  2  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
007F62  2  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
007F64  2  A0 18                     ldy #$18
007F66  2  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
007F69  2  A2 00                     ldx #$00                 ;set default offset here
007F6B  2  A4 33                     ldy PlayerFacingDir      ;get facing direction
007F6D  2  4A                        lsr                      ;move right button controller bit to carry
007F6E  2  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
007F70  2  E8                        inx
007F71  2  E8                        inx                      ;otherwise increment offset by 2 bytes
007F72  2  88           ClimbFD:     dey                      ;check to see if facing right
007F73  2  F0 01                     beq CSetFDir             ;if so, branch, do not increment
007F75  2  E8                        inx                      ;otherwise increment by 1 byte
007F76  2  A5 86        CSetFDir:    lda Player_X_Position
007F78  2  18                        clc                      ;add or subtract from player's horizontal position
007F79  2  7D 33 7F                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
007F7C  2  85 86                     sta Player_X_Position
007F7E  2  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
007F80  2  7D 37 7F                  adc ClimbAdderHigh,x     ;from the player's page location
007F83  2  85 6D                     sta Player_PageLoc
007F85  2  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
007F87  2  49 03                     eor #%00000011           ;invert them and store them while player
007F89  2  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
007F8B  2  60           ExitCSub:    rts                      ;then leave
007F8C  2  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
007F8F  2  60                        rts
007F90  2               
007F90  2               ;-------------------------------------------------------------------------------------
007F90  2               ;$00 - used to store offset to friction data
007F90  2               
007F90  2               JumpMForceData:
007F90  2  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
007F94  2  28 0D 04     
007F97  2               
007F97  2               FallMForceData:
007F97  2  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
007F9B  2  90 0A 09     
007F9E  2               
007F9E  2               FrictionData:
007F9E  2  E4 98 D0           .byte $e4, $98, $d0
007FA1  2               
007FA1  2               PlayerYSpdData:
007FA1  2  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
007FA5  2  FB FE FF     
007FA8  2               
007FA8  2               InitMForceData:
007FA8  2  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
007FAC  2  00 80 00     
007FAF  2               
007FAF  2               MaxLeftXSpdData:
007FAF  2  D8 E8 F0           .byte $d8, $e8, $f0
007FB2  2               
007FB2  2               MaxRightXSpdData:
007FB2  2  28 18 10           .byte $28, $18, $10
007FB5  2  0C                 .byte $0c ;used for pipe intros
007FB6  2               
007FB6  2               Climb_Y_SpeedData:
007FB6  2  00 FF 01           .byte $00, $ff, $01
007FB9  2               
007FB9  2               Climb_Y_MForceData:
007FB9  2  00 20 FF           .byte $00, $20, $ff
007FBC  2               
007FBC  2               PlayerPhysicsSub:
007FBC  2  A5 1D                   lda Player_State          ;check player state
007FBE  2  C9 03                   cmp #$03
007FC0  2  D0 23                   bne CheckForJumping       ;if not climbing, branch
007FC2  2  A0 00                   ldy #$00
007FC4  2  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
007FC6  2  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
007FC9  2  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
007FCB  2  C8                      iny
007FCC  2  29 08                   and #%00001000            ;check for pressing up
007FCE  2  D0 01                   bne ProcClimb
007FD0  2  C8                      iny
007FD1  2  BE B9 7F     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
007FD4  2  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
007FD7  2  A9 08                   lda #$08                  ;load default animation timing
007FD9  2  BE B6 7F                ldx Climb_Y_SpeedData,y   ;load some other value here
007FDC  2  86 9F                   stx Player_Y_Speed        ;store as vertical speed
007FDE  2  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
007FE0  2  4A                      lsr                       ;otherwise divide timer setting by 2
007FE1  2  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
007FE4  2  60                      rts
007FE5  2               
007FE5  2               CheckForJumping:
007FE5  2  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
007FE8  2  D0 0A                bne NoJump                ;skip ahead to something else
007FEA  2  A5 0A                lda A_B_Buttons           ;check for A button press
007FEC  2  29 80                and #A_Button
007FEE  2  F0 04                beq NoJump                ;if not, branch to something else
007FF0  2  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
007FF2  2  F0 03                beq ProcJumping
007FF4  2  4C 88 80     NoJump: jmp X_Physics             ;otherwise, jump to something else
007FF7  2               
007FF7  2               ProcJumping:
007FF7  2  A5 1D                   lda Player_State           ;check player state
007FF9  2  F0 11                   beq InitJS                 ;if on the ground, branch
007FFB  2  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
007FFE  2  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
008000  2  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
008003  2  D0 07                   bne InitJS
008005  2  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
008007  2  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
008009  2  4C 88 80                jmp X_Physics              ;if timer at zero and player still rising, do not swim
00800C  2  A9 20        InitJS:    lda #$20                   ;set jump/swim timer
00800E  2  8D 82 07                sta JumpSwimTimer
008011  2  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
008013  2  8C 16 04                sty Player_YMF_Dummy
008016  2  8C 33 04                sty Player_Y_MoveForce
008019  2  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00801B  2  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
00801E  2  A5 CE                   lda Player_Y_Position
008020  2  8D 08 07                sta JumpOrigin_Y_Position
008023  2  A9 01                   lda #$01                   ;set player state to jumping/swimming
008025  2  85 1D                   sta Player_State
008027  2  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00802A  2  C9 09                   cmp #$09
00802C  2  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
00802E  2  C8                      iny                        ;for each amount equal or exceeded
00802F  2  C9 10                   cmp #$10
008031  2  90 0B                   bcc ChkWtr
008033  2  C8                      iny
008034  2  C9 19                   cmp #$19
008036  2  90 06                   bcc ChkWtr
008038  2  C8                      iny
008039  2  C9 1C                   cmp #$1c
00803B  2  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
00803D  2  C8                      iny
00803E  2  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
008040  2  8D 06 07                sta DiffToHaltJump
008043  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
008046  2  F0 08                   beq GetYPhy
008048  2  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00804A  2  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
00804D  2  F0 01                   beq GetYPhy
00804F  2  C8                      iny                        ;otherwise increment to 6
008050  2  B9 90 7F     GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
008053  2  8D 09 07                sta VerticalForce          ;data here
008056  2  B9 97 7F                lda FallMForceData,y
008059  2  8D 0A 07                sta VerticalForceDown
00805C  2  B9 A8 7F                lda InitMForceData,y
00805F  2  8D 33 04                sta Player_Y_MoveForce
008062  2  B9 A1 7F                lda PlayerYSpdData,y
008065  2  85 9F                   sta Player_Y_Speed
008067  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00806A  2  F0 11                   beq PJumpSnd
00806C  2  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
00806E  2  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
008070  2  A5 CE                   lda Player_Y_Position
008072  2  C9 14                   cmp #$14                   ;check vertical low byte of player position
008074  2  B0 12                   bcs X_Physics              ;if below a certain point, branch
008076  2  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
008078  2  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
00807A  2  4C 88 80                jmp X_Physics              ;from swimming above water level
00807D  2  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
00807F  2  AC 54 07                ldy PlayerSize             ;is mario big?
008082  2  F0 02                   beq SJumpSnd
008084  2  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
008086  2  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
008088  2  A0 00        X_Physics: ldy #$00
00808A  2  84 00                   sty $00                    ;init value here
00808C  2  A5 1D                   lda Player_State           ;if mario is on the ground, branch
00808E  2  F0 09                   beq ProcPRun
008090  2  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
008093  2  C9 19                   cmp #$19                   ;to mario's speed
008095  2  B0 33                   bcs GetXPhy                ;if =>$19 branch here
008097  2  90 18                   bcc ChkRFast               ;if not branch elsewhere
008099  2  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
00809A  2  AD 4E 07                lda AreaType               ;check area type
00809D  2  F0 12                   beq ChkRFast               ;if water type, branch
00809F  2  88                      dey                        ;decrement Y by default for non-water type area
0080A0  2  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
0080A2  2  C5 45                   cmp Player_MovingDir       ;check against moving direction
0080A4  2  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
0080A6  2  A5 0A                   lda A_B_Buttons            ;check for b button pressed
0080A8  2  29 40                   and #B_Button
0080AA  2  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
0080AC  2  AD 83 07                lda RunningTimer           ;check for running timer set
0080AF  2  D0 19                   bne GetXPhy                ;if set, branch
0080B1  2  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
0080B2  2  E6 00                   inc $00                    ;increment Y again and temp variable in memory
0080B4  2  AD 03 07                lda RunningSpeed
0080B7  2  D0 07                   bne FastXSp                ;if running speed set here, branch
0080B9  2  AD 00 07                lda Player_XSpeedAbsolute
0080BC  2  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
0080BE  2  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
0080C0  2  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
0080C2  2  4C CA 80                jmp GetXPhy                ;and jump ahead
0080C5  2  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
0080C7  2  8D 83 07                sta RunningTimer
0080CA  2  B9 AF 7F     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
0080CD  2  8D 50 04                sta MaximumLeftSpeed
0080D0  2  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
0080D2  2  C9 07                   cmp #$07                   ;(player entrance)
0080D4  2  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
0080D6  2  A0 03                   ldy #$03                   ;otherwise set Y to 3
0080D8  2  B9 B2 7F     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
0080DB  2  8D 56 04                sta MaximumRightSpeed
0080DE  2  A4 00                   ldy $00                    ;get other value in memory
0080E0  2  B9 9E 7F                lda FrictionData,y         ;get value using value in memory as offset
0080E3  2  8D 02 07                sta FrictionAdderLow
0080E6  2  A9 00                   lda #$00
0080E8  2  8D 01 07                sta FrictionAdderHigh      ;init something here
0080EB  2  A5 33                   lda PlayerFacingDir
0080ED  2  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
0080EF  2  F0 06                   beq ExitPhy                ;if the same, branch to leave
0080F1  2  0E 02 07     PhyOpcode: asl FrictionAdderLow       ;otherwise multiply friction by 2
0080F4  2  2E 01 07                rol FrictionAdderHigh      ;then leave (or just leave, if code was modified earlier
0080F7  2  60           ExitPhy:   rts
0080F8  2               
0080F8  2               ;-------------------------------------------------------------------------------------
0080F8  2               
0080F8  2               PlayerAnimTmrData:
0080F8  2  02 04 07           .byte $02, $04, $07
0080FB  2               
0080FB  2               GetPlayerAnimSpeed:
0080FB  2  A0 00                    ldy #$00                   ;initialize offset in Y
0080FD  2  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
008100  2  C9 1C                    cmp #$1c                   ;against preset amount
008102  2  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
008104  2  C8                       iny                        ;otherwise increment Y
008105  2  C9 0E                    cmp #$0e                   ;compare against lower amount
008107  2  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
008109  2  C8                       iny                        ;otherwise increment Y again
00810A  2  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
00810D  2  29 7F                    and #%01111111             ;mask out A button
00810F  2  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
008111  2  29 03                    and #$03                   ;mask out all others except left and right
008113  2  C5 45                    cmp Player_MovingDir       ;check against moving direction
008115  2  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
008117  2  A9 00                    lda #$00                   ;otherwise set zero value here
008119  2  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
00811C  2  4C 31 81                 jmp SetAnimSpd
00811F  2  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
008122  2  C9 0B                    cmp #$0b                   ;against one last amount
008124  2  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
008126  2  A5 33                    lda PlayerFacingDir
008128  2  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00812A  2  A9 00                    lda #$00
00812C  2  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
00812E  2  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
008131  2  B9 F8 80     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
008134  2  8D 0C 07                 sta PlayerAnimTimerSet
008137  2  60                       rts
008138  2               
008138  2               ;-------------------------------------------------------------------------------------
008138  2               
008138  2               ImposeFriction:
008138  2  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00813B  2  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
00813D  2  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
00813F  2  A5 57                   lda Player_X_Speed
008141  2  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
008143  2  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
008145  2  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
008147  2  4A           JoypFrict: lsr                       ;put right controller bit into carry
008148  2  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00814A  2  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
00814D  2  18                      clc
00814E  2  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
008151  2  8D 05 07                sta Player_X_MoveForce    ;store here
008154  2  A5 57                   lda Player_X_Speed
008156  2  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
008159  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00815B  2  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
00815E  2  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
008160  2  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
008163  2  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
008165  2  4C 8C 81                jmp SetAbsSpd             ;skip to the end
008168  2  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
00816B  2  38                      sec
00816C  2  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
00816F  2  8D 05 07                sta Player_X_MoveForce    ;store here
008172  2  A5 57                   lda Player_X_Speed
008174  2  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
008177  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
008179  2  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
00817C  2  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
00817E  2  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
008181  2  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
008183  2  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
008185  2  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
008187  2  49 FF                   eor #$ff
008189  2  18                      clc                       ;otherwise get two's compliment to get absolute
00818A  2  69 01                   adc #$01                  ;unsigned walking/running speed
00818C  2  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
00818F  2  60                      rts
008190  2               
008190  2               ;-------------------------------------------------------------------------------------
008190  2               ;$00 - used to store downward movement force in FireballObjCore
008190  2               ;$02 - used to store maximum vertical speed in FireballObjCore
008190  2               ;$07 - used to store pseudorandom bit in BubbleCheck
008190  2               
008190  2               ProcFireball_Bubble:
008190  2  AD 56 07           lda PlayerStatus           ;check player's status
008193  2  C9 02              cmp #$02
008195  2  90 43              bcc ProcAirBubbles         ;if not fiery, branch
008197  2  A5 0A              lda A_B_Buttons
008199  2  29 40              and #B_Button              ;check for b button pressed
00819B  2  F0 33              beq ProcFireballs          ;branch if not pressed
00819D  2  25 0D              and PreviousA_B_Buttons
00819F  2  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
0081A1  2  AD CE 06           lda FireballCounter        ;load fireball counter
0081A4  2  29 01              and #%00000001             ;get LSB and use as offset for buffer
0081A6  2  AA                 tax
0081A7  2  B5 24              lda Fireball_State,x       ;load fireball state
0081A9  2  D0 25              bne ProcFireballs          ;if not inactive, branch
0081AB  2  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
0081AD  2  88                 dey
0081AE  2  D0 20              bne ProcFireballs
0081B0  2  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
0081B3  2  D0 1B              bne ProcFireballs
0081B5  2  A5 1D              lda Player_State           ;if player's state = climbing, branch
0081B7  2  C9 03              cmp #$03
0081B9  2  F0 15              beq ProcFireballs
0081BB  2  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
0081BD  2  85 FF              sta Square1SoundQueue
0081BF  2  A9 02              lda #$02                   ;load state
0081C1  2  95 24              sta Fireball_State,x
0081C3  2  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
0081C6  2  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
0081C9  2  88                 dey
0081CA  2  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
0081CD  2  EE CE 06           inc FireballCounter        ;increment fireball counter
0081D0  2               
0081D0  2               ProcFireballs:
0081D0  2  A2 00              ldx #$00
0081D2  2  20 F5 81           jsr FireballObjCore  ;process first fireball object
0081D5  2  A2 01              ldx #$01
0081D7  2  20 F5 81           jsr FireballObjCore  ;process second fireball object, then do air bubbles
0081DA  2               
0081DA  2               ProcAirBubbles:
0081DA  2  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
0081DD  2  D0 13                  bne BublExit
0081DF  2  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
0081E1  2  86 08        BublLoop: stx ObjectOffset            ;store offset
0081E3  2  20 65 82               jsr BubbleCheck             ;check timers and coordinates, create air bubble
0081E6  2  20 16 BE               jsr RelativeBubblePosition  ;get relative coordinates
0081E9  2  20 76 BE               jsr GetBubbleOffscreenBits  ;get offscreen information
0081EC  2  20 BC BA               jsr DrawBubble              ;draw the air bubble
0081EF  2  CA                     dex
0081F0  2  10 EF                  bpl BublLoop                ;do this until all three are handled
0081F2  2  60           BublExit: rts                         ;then leave
0081F3  2               
0081F3  2               FireballXSpdData:
0081F3  2  40 C0              .byte $40, $c0
0081F5  2               
0081F5  2               FireballObjCore:
0081F5  2  86 08                 stx ObjectOffset             ;store offset as current object
0081F7  2  B5 24                 lda Fireball_State,x         ;check for d7 = 1
0081F9  2  0A                    asl
0081FA  2  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
0081FC  2  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
0081FE  2  F0 5E                 beq NoFBall
008200  2  88                    dey                          ;if fireball state set to 1, skip this part and just run it
008201  2  F0 27                 beq RunFB
008203  2  A5 86                 lda Player_X_Position        ;get player's horizontal position
008205  2  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
008207  2  95 8D                 sta Fireball_X_Position,x
008209  2  A5 6D                 lda Player_PageLoc           ;get player's page location
00820B  2  69 00                 adc #$00                     ;add carry and store as fireball's page location
00820D  2  95 74                 sta Fireball_PageLoc,x
00820F  2  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
008211  2  95 D5                 sta Fireball_Y_Position,x
008213  2  A9 01                 lda #$01                     ;set high byte of vertical position
008215  2  95 BC                 sta Fireball_Y_HighPos,x
008217  2  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
008219  2  88                    dey                          ;decrement to use as offset here
00821A  2  B9 F3 81              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
00821D  2  95 5E                 sta Fireball_X_Speed,x
00821F  2  A9 04                 lda #$04                     ;set vertical speed of fireball
008221  2  95 A6                 sta Fireball_Y_Speed,x
008223  2  A9 07                 lda #$07
008225  2  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
008228  2  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00822A  2  8A           RunFB:   txa                          ;add 7 to offset to use
00822B  2  18                    clc                          ;as fireball offset for next routines
00822C  2  69 07                 adc #$07
00822E  2  AA                    tax
00822F  2  A9 50                 lda #$50                     ;set downward movement force here
008231  2  85 00                 sta $00
008233  2  A9 03                 lda #$03                     ;set maximum speed here
008235  2  85 02                 sta $02
008237  2  A9 00                 lda #$00
008239  2  20 A8 8B              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
00823C  2  20 E0 8A              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
00823F  2  A6 08                 ldx ObjectOffset             ;return fireball offset to X
008241  2  20 20 BE              jsr RelativeFireballPosition ;get relative coordinates
008244  2  20 6C BE              jsr GetFireballOffscreenBits ;get offscreen information
008247  2  20 CB AE              jsr GetFireballBoundBox      ;get bounding box coordinates
00824A  2  20 66 AE              jsr FireballBGCollision      ;do fireball to background collision detection
00824D  2  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
008250  2  29 CC                 and #%11001100               ;mask out certain bits
008252  2  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
008254  2  20 19 A3              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
008257  2  4C B9 B9              jmp DrawFireball             ;draw fireball appropriately and leave
00825A  2  A9 00        EraseFB: lda #$00                     ;erase fireball state
00825C  2  95 24                 sta Fireball_State,x
00825E  2  60           NoFBall: rts                          ;leave
00825F  2               
00825F  2               FireballExplosion:
00825F  2  20 20 BE           jsr RelativeFireballPosition
008262  2  4C E4 B9           jmp DrawExplosion_Fireball
008265  2               
008265  2               BubbleCheck:
008265  2  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
008268  2  29 01              and #$01
00826A  2  85 07              sta $07                     ;store pseudorandom bit here
00826C  2  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
00826E  2  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
008270  2  D0 2C              bne MoveBubl                ;branch to move air bubble
008272  2  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
008275  2  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
008277  2               
008277  2               SetupBubble:
008277  2  A0 00                  ldy #$00                 ;load default value here
008279  2  A5 33                  lda PlayerFacingDir      ;get player's facing direction
00827B  2  4A                     lsr                      ;move d0 to carry
00827C  2  90 02                  bcc PosBubl              ;branch to use default value if facing left
00827E  2  A0 08                  ldy #$08                 ;otherwise load alternate value here
008280  2  98           PosBubl:  tya                      ;use value loaded as adder
008281  2  65 86                  adc Player_X_Position    ;add to player's horizontal position
008283  2  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
008285  2  A5 6D                  lda Player_PageLoc
008287  2  69 00                  adc #$00                 ;add carry to player's page location
008289  2  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
00828B  2  A5 CE                  lda Player_Y_Position
00828D  2  18                     clc                      ;add eight pixels to player's vertical position
00828E  2  69 08                  adc #$08
008290  2  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
008292  2  A9 01                  lda #$01
008294  2  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
008296  2  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
008298  2  B9 B9 82               lda BubbleTimerData,y    ;get data for air bubble timer
00829B  2  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
00829E  2  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
0082A0  2  BD 2C 04               lda Bubble_YMF_Dummy,x
0082A3  2  38                     sec                      ;subtract pseudorandom amount from dummy variable
0082A4  2  F9 B7 82               sbc Bubble_MForceData,y
0082A7  2  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
0082AA  2  B5 E4                  lda Bubble_Y_Position,x
0082AC  2  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
0082AE  2  C9 20                  cmp #$20                 ;if below the status bar,
0082B0  2  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
0082B2  2  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
0082B4  2  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
0082B6  2  60           ExitBubl: rts                      ;leave
0082B7  2               
0082B7  2               Bubble_MForceData:
0082B7  2  FF 50              .byte $ff, $50
0082B9  2               
0082B9  2               BubbleTimerData:
0082B9  2  40 20              .byte $40, $20
0082BB  2               
0082BB  2               ;-------------------------------------------------------------------------------------
0082BB  2               
0082BB  2               RunGameTimer:
0082BB  2  AD 70 07                lda OperMode               ;get primary mode of operation
0082BE  2  F0 4F                   beq ExGTimer               ;branch to leave if in attract mode
0082C0  2  A5 0E                   lda GameEngineSubroutine
0082C2  2  C9 08                   cmp #$08                   ;if routine number less than eight running,
0082C4  2  90 49                   bcc ExGTimer               ;branch to leave
0082C6  2  C9 0B                   cmp #$0b                   ;if running death routine,
0082C8  2  F0 45                   beq ExGTimer               ;branch to leave
0082CA  2  A5 B5                   lda Player_Y_HighPos
0082CC  2  C9 02                   cmp #$02                   ;if player below the screen,
0082CE  2  10 3F                   bpl ExGTimer               ;branch to leave regardless of level type
0082D0  2  AD 87 07                lda GameTimerCtrlTimer     ;if game timer control not yet expired,
0082D3  2  D0 3A                   bne ExGTimer               ;branch to leave
0082D5  2  AD EC 07                lda GameTimerDisplay
0082D8  2  0D ED 07                ora GameTimerDisplay+1     ;otherwise check game timer digits
0082DB  2  0D EE 07                ora GameTimerDisplay+2
0082DE  2  F0 26                   beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
0082E0  2  AC EC 07                ldy GameTimerDisplay       ;otherwise check first digit
0082E3  2  88                      dey                        ;if first digit not on 1,
0082E4  2  D0 0C                   bne ResGTCtrl              ;branch to reset game timer control
0082E6  2  AD ED 07                lda GameTimerDisplay+1     ;otherwise check second and third digits
0082E9  2  0D EE 07                ora GameTimerDisplay+2
0082EC  2  D0 04                   bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
0082EE  2  A9 40                   lda #TimeRunningOutMusic
0082F0  2  85 FC                   sta EventMusicQueue        ;otherwise load time running out music
0082F2  2  A9 18        ResGTCtrl: lda #$18                   ;reset game timer control
0082F4  2  8D 87 07                sta GameTimerCtrlTimer
0082F7  2  A0 17                   ldy #$17                   ;set offset for last digit
0082F9  2  A9 FF                   lda #$ff                   ;set value to decrement game timer digit
0082FB  2  8D 39 01                sta DigitModifier+5
0082FE  2  20 D2 6D                jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
008301  2  A9 A2                   lda #$a2                   ;set status nybbles to update game timer display
008303  2  4C 79 6D                jmp PrintStatusBarNumbers  ;do sub to update the display
008306  2  8D 56 07     TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
008309  2  20 8F A5                jsr ForceInjury            ;do sub to kill the player (note player is small here)
00830C  2  EE 59 07                inc GameTimerExpiredFlag   ;set game timer expiration flag
00830F  2  60           ExGTimer:  rts                        ;leave
008310  2               
008310  2               ;-------------------------------------------------------------------------------------
008310  2               
008310  2               WarpZoneObject:
008310  2  AD 23 07           lda ScrollLock         ;check for scroll lock flag
008313  2  F0 FA              beq ExGTimer           ;branch if not set to leave
008315  2  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
008317  2  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
008319  2  D0 F4              bne ExGTimer           ;if so, branch to leave
00831B  2  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
00831E  2  4C CD 95           jmp EraseEnemyObject   ;kill this object
008321  2               
008321  2               ;-------------------------------------------------------------------------------------
008321  2               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
008321  2               ;and also to store movement force exerted on player
008321  2               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
008321  2               ;and in WhirlpoolActivate to store center of whirlpool
008321  2               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
008321  2               ;WhirlpoolActivate to store maximum vertical speed
008321  2               
008321  2               ProcessWhirlpools:
008321  2  AD 4E 07             lda AreaType                ;check for water type level
008324  2  D0 37                bne ExitWh                  ;branch to leave if not found
008326  2  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
008329  2  AD 47 07             lda TimerControl            ;if master timer control set,
00832C  2  D0 2F                bne ExitWh                  ;branch to leave
00832E  2  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
008330  2  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
008333  2  18                   clc
008334  2  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
008337  2  85 02                sta $02                     ;store result as right extent here
008339  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00833C  2  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
00833E  2  69 00                adc #$00                    ;add carry
008340  2  85 01                sta $01                     ;store result as page location of right extent here
008342  2  A5 86                lda Player_X_Position       ;get player's horizontal position
008344  2  38                   sec
008345  2  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
008348  2  A5 6D                lda Player_PageLoc          ;get player's page location
00834A  2  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
00834D  2  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
00834F  2  A5 02                lda $02                     ;otherwise get right extent
008351  2  38                   sec
008352  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
008354  2  A5 01                lda $01                     ;get right extent's page location
008356  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
008358  2  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
00835A  2  88           NextWh: dey                         ;move onto next whirlpool data
00835B  2  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
00835D  2  60           ExitWh: rts                         ;leave
00835E  2               
00835E  2               WhirlpoolActivate:
00835E  2  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
008361  2  4A                   lsr                         ;divide by 2
008362  2  85 00                sta $00                     ;save here
008364  2  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
008367  2  18                   clc
008368  2  65 00                adc $00                     ;add length divided by 2
00836A  2  85 01                sta $01                     ;save as center of whirlpool
00836C  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00836F  2  69 00                adc #$00                    ;add carry
008371  2  85 00                sta $00                     ;save as page location of whirlpool center
008373  2  A5 09                lda FrameCounter            ;get frame counter
008375  2  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
008376  2  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
008378  2  A5 01                lda $01                     ;get center
00837A  2  38                   sec
00837B  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00837D  2  A5 00                lda $00                     ;get page location of center
00837F  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
008381  2  10 0E                bpl LeftWh                  ;if player to the left of center, branch
008383  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
008385  2  38                   sec
008386  2  E9 01                sbc #$01                    ;subtract one pixel
008388  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00838A  2  A5 6D                lda Player_PageLoc
00838C  2  E9 00                sbc #$00                    ;subtract borrow
00838E  2  4C A2 83             jmp SetPWh                  ;jump to set player's new page location
008391  2  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
008394  2  4A                   lsr                         ;shift d0 into carry
008395  2  90 0D                bcc WhPull                  ;if d0 not set, branch
008397  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
008399  2  18                   clc
00839A  2  69 01                adc #$01                    ;add one pixel
00839C  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00839E  2  A5 6D                lda Player_PageLoc
0083A0  2  69 00                adc #$00                    ;add carry
0083A2  2  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
0083A4  2  A9 10        WhPull: lda #$10
0083A6  2  85 00                sta $00                     ;set vertical movement force
0083A8  2  A9 01                lda #$01
0083AA  2  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
0083AD  2  85 02                sta $02                     ;also set maximum vertical speed
0083AF  2  4A                   lsr
0083B0  2  AA                   tax                         ;set X for player offset
0083B1  2  4C A8 8B             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
0083B4  2               
0083B4  2               ;-------------------------------------------------------------------------------------
0083B4  2               
0083B4  2               FlagpoleScoreMods:
0083B4  2  05 02 08 04        .byte $05, $02, $08, $04, $01
0083B8  2  01           
0083B9  2               
0083B9  2               FlagpoleScoreDigits:
0083B9  2  03 03 04 04        .byte $03, $03, $04, $04, $04
0083BD  2  04           
0083BE  2               
0083BE  2               FlagpoleRoutine:
0083BE  2  A2 05                   ldx #$05                  ;set enemy object offset
0083C0  2  86 08                   stx ObjectOffset          ;to special use slot
0083C2  2  B5 16                   lda Enemy_ID,x
0083C4  2  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
0083C6  2  D0 64                   bne ExitFlagP             ;branch to leave
0083C8  2  A5 0E                   lda GameEngineSubroutine
0083CA  2  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
0083CC  2  D0 31                   bne SkipScore             ;branch to near the end of code
0083CE  2  A5 1D                   lda Player_State
0083D0  2  C9 03                   cmp #$03                  ;if player state not climbing,
0083D2  2  D0 2B                   bne SkipScore             ;branch to near the end of code
0083D4  2  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
0083D6  2  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
0083D8  2  B0 28                   bcs GiveFPScr             ;branch to end the level
0083DA  2  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
0083DC  2  C9 A2                   cmp #$a2                  ;if player down to a certain point,
0083DE  2  B0 22                   bcs GiveFPScr             ;branch to end the level
0083E0  2  BD 17 04                lda Enemy_YMF_Dummy,x
0083E3  2  69 FF                   adc #$ff                  ;add movement amount to dummy variable
0083E5  2  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
0083E8  2  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
0083EA  2  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
0083EC  2  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
0083EE  2  AD 0E 01                lda FlagpoleFNum_YMFDummy
0083F1  2  38                      sec                       ;subtract movement amount from dummy variable
0083F2  2  E9 FF                   sbc #$ff
0083F4  2  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
0083F7  2  AD 0D 01                lda FlagpoleFNum_Y_Pos
0083FA  2  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
0083FC  2  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
0083FF  2  4C 23 84     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
008402  2  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
008405  2  C0 05                   cpy #$05
008407  2  D0 0A                   bne NoEL4F                ;if set to give player an extra life, do so now
008409  2  EE 5A 07                inc NumberofLives
00840C  2  A9 40                   lda #$40
00840E  2  85 FE                   sta $fe
008410  2  4C 1F 84                jmp NoSc4F
008413  2  B9 B4 83     NoEL4F:    lda FlagpoleScoreMods,y   ;get amount to award player points
008416  2  BE B9 83                ldx FlagpoleScoreDigits,y ;get digit with which to award points
008419  2  9D 34 01                sta DigitModifier,x       ;store in digit modifier
00841C  2  20 E8 87                jsr AddToScore            ;do sub to award player points depending on height of collision
00841F  2  A9 05        NoSc4F:    lda #$05
008421  2  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
008423  2  20 94 BE     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
008426  2  20 37 BE                jsr RelativeEnemyPosition ;get relative coordinates
008429  2  20 F1 B1                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
00842C  2  60           ExitFlagP: rts
00842D  2               
00842D  2               ;-------------------------------------------------------------------------------------
00842D  2               
00842D  2               Jumpspring_Y_PosData:
00842D  2  08 10 08 00        .byte $08, $10, $08, $00
008431  2               
008431  2               JumpspringHandler:
008431  2  20 94 BE                jsr GetEnemyOffscreenBits   ;get offscreen information
008434  2  AD 47 07                lda TimerControl            ;check master timer control
008437  2  D0 55                   bne DrawJSpr                ;branch to last section if set
008439  2  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
00843C  2  F0 50                   beq DrawJSpr                ;branch to last section if not set
00843E  2  A8                      tay
00843F  2  88                      dey                         ;subtract one from frame control in A,
008440  2  98                      tya                         ;the only way a poor NMOS 6502 can
008441  2  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
008443  2  D0 07                   bne DownJSpr                ;if set, branch to move player up
008445  2  E6 CE                   inc Player_Y_Position
008447  2  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
008449  2  4C 50 84                jmp PosJSpr                 ;skip to next part
00844C  2  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
00844E  2  C6 CE                   dec Player_Y_Position
008450  2  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
008452  2  18                      clc
008453  2  79 2D 84                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
008456  2  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
008458  2  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
00845A  2  90 24                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
00845C  2  A5 0A                   lda A_B_Buttons
00845E  2  29 80                   and #A_Button               ;check saved controller bits for A button press
008460  2  F0 1E                   beq BounceJS                ;skip to next part if A not pressed
008462  2  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
008464  2  D0 1A                   bne BounceJS                ;skip to next part if so
008466  2  98                      tya
008467  2  48                      pha
008468  2  A9 F4                   lda #$f4                    ;set jumpspring force for red jumpsprings
00846A  2  AC 5F 07                ldy WorldNumber
00846D  2  C0 01                   cpy #World2
00846F  2  F0 08                   beq GreenJS                 ;if world number is 2, 3 or 7
008471  2  C0 02                   cpy #World3                 ;set jumpspring force for green jumpsprings
008473  2  F0 04                   beq GreenJS
008475  2  C0 06                   cpy #World7                 ;otherwise use red jumpspring force
008477  2  D0 02                   bne SetJSF
008479  2  A9 E0        GreenJS:   lda #$e0
00847B  2  8D DB 06     SetJSF:    sta JumpspringForce         ;otherwise write new jumpspring force here
00847E  2  68                      pla
00847F  2  A8                      tay
008480  2  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
008482  2  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
008484  2  AD DB 06                lda JumpspringForce
008487  2  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
008489  2  A9 00                   lda #$00
00848B  2  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
00848E  2  20 37 BE     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
008491  2  20 2C B5                jsr EnemyGfxHandler         ;draw jumpspring
008494  2  20 B4 A2                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
008497  2  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
00849A  2  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
00849C  2  AD 86 07                lda JumpspringTimer
00849F  2  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
0084A1  2  A9 04                   lda #$04
0084A3  2  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
0084A6  2  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
0084A9  2  60           ExJSpring: rts                         ;leave
0084AA  2               
0084AA  2               ;-------------------------------------------------------------------------------------
0084AA  2               
0084AA  2               Setup_Vine:
0084AA  2  A9 2F                lda #VineObject          ;load identifier for vine object
0084AC  2  95 16                sta Enemy_ID,x           ;store in buffer
0084AE  2  A9 01                lda #$01
0084B0  2  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
0084B2  2  B9 76 00             lda Block_PageLoc,y
0084B5  2  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
0084B7  2  B9 8F 00             lda Block_X_Position,y
0084BA  2  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
0084BC  2  B9 D7 00             lda Block_Y_Position,y
0084BF  2  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
0084C1  2  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
0084C4  2  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
0084C6  2  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
0084C9  2  8A           NextVO: txa                      ;store object offset to next available vine slot
0084CA  2  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
0084CD  2  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
0084D0  2  A9 04                lda #Sfx_GrowVine
0084D2  2  85 FE                sta Square2SoundQueue    ;load vine grow sound
0084D4  2  60                   rts
0084D5  2               
0084D5  2               ;-------------------------------------------------------------------------------------
0084D5  2               ;$06-$07 - used as address to block buffer data
0084D5  2               ;$02 - used as vertical high nybble of block buffer offset
0084D5  2               
0084D5  2               VineHeightData:
0084D5  2  30 60              .byte $30, $60
0084D7  2               
0084D7  2               VineObjectHandler:
0084D7  2  E0 05                    cpx #$05                  ;check enemy offset for special use slot
0084D9  2  F0 01                    beq ProcVO                ;if in special use slot, continue
0084DB  2  60                       rts
0084DC  2  AC 98 03     ProcVO:     ldy VineFlagOffset
0084DF  2  88                       dey                       ;decrement vine flag in Y, use as offset
0084E0  2  AD 99 03                 lda VineHeight
0084E3  2  D9 D5 84                 cmp VineHeightData,y      ;if vine has reached certain height,
0084E6  2  F0 0F                    beq RunVSubs              ;branch ahead to skip this part
0084E8  2  A5 09                    lda FrameCounter          ;get frame counter
0084EA  2  4A                       lsr                       ;shift d1 into carry
0084EB  2  4A                       lsr
0084EC  2  90 09                    bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
0084EE  2  A5 D4                    lda Enemy_Y_Position+5
0084F0  2  E9 01                    sbc #$01                  ;subtract vertical position of vine
0084F2  2  85 D4                    sta Enemy_Y_Position+5    ;one pixel every frame it's time
0084F4  2  EE 99 03                 inc VineHeight            ;increment vine height
0084F7  2  AD 99 03     RunVSubs:   lda VineHeight            ;if vine still very small,
0084FA  2  C9 08                    cmp #$08                  ;branch to last part
0084FC  2  90 46                    bcc ChkVOffscr
0084FE  2  20 37 BE                 jsr RelativeEnemyPosition ;get relative coordinates of vine,
008501  2  20 94 BE                 jsr GetEnemyOffscreenBits ;and any offscreen bits
008504  2  A0 00                    ldy #$00                  ;initialize offset used in draw vine sub
008506  2  20 D9 B0     VDrawLoop:  jsr DrawVine              ;draw vine
008509  2  C8                       iny                       ;increment offset
00850A  2  CC 98 03                 cpy VineFlagOffset        ;if offset in Y and offset here
00850D  2  D0 F7                    bne VDrawLoop             ;do not yet match, loop back to draw more vine
00850F  2  AD D1 03                 lda Enemy_OffscreenBits
008512  2  29 0C                    and #%00001100            ;mask offscreen bits
008514  2  F0 10                    beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
008516  2  88                       dey                       ;otherwise decrement Y to get proper offset again
008517  2  BE 9A 03     KillVine:   ldx VineObjOffset,y       ;get enemy object offset for this vine object
00851A  2  20 CD 95                 jsr EraseEnemyObject      ;kill this vine object
00851D  2  88                       dey                       ;decrement Y
00851E  2  10 F7                    bpl KillVine              ;if any vine objects left, loop back to kill it
008520  2  8D 98 03                 sta VineFlagOffset        ;initialize vine flag/offset
008523  2  8D 99 03                 sta VineHeight            ;initialize vine height
008526  2  AD 99 03     WrCMTile:   lda VineHeight            ;check vine height
008529  2  C9 20                    cmp #$20                  ;if vine small (less than 32 pixels tall)
00852B  2  90 17                    bcc ChkVOffscr            ;then branch ahead to last part to skip this
00852D  2  A2 06                    ldx #$06                  ;set offset in X to last enemy slot
00852F  2  A9 01                    lda #$01                  ;set A to obtain horizontal in $04, but we don't care
008531  2  A0 1B                    ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
008533  2  20 8E B0                 jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
008536  2  A4 02                    ldy $02
008538  2  C0 D0                    cpy #$d0                  ;if vertical high nybble offset beyond extent of
00853A  2  B0 08                    bcs ChkVOffscr            ;current block buffer, branch to leave, do not write
00853C  2  B1 06                    lda ($06),y               ;otherwise check contents of block buffer at
00853E  2  D0 04                    bne ChkVOffscr            ;current offset, if not empty, branch to leave
008540  2  A9 23                    lda #$23
008542  2  91 06                    sta ($06),y               ;otherwise, write climbing metatile to block buffer
008544  2  A5 8C        ChkVOffscr: lda Enemy_X_Position+5
008546  2  38                       sec
008547  2  ED 1C 07                 sbc ScreenLeft_X_Pos
00854A  2  A8                       tay
00854B  2  A5 73                    lda Enemy_PageLoc+5       ;compare horizontal position of vine
00854D  2  ED 1A 07                 sbc ScreenLeft_PageLoc    ;to that of the left side of the screen
008550  2  30 04                    bmi VineOffscr            ;if vine isn't within 8 pixels of the edge
008552  2  C0 09                    cpy #$09                  ;or past the left edge, branch to leave
008554  2  B0 2C                    bcs ExitVH
008556  2  A9 00        VineOffscr: lda #$00                  ;erase vine's flag to kill it
008558  2  85 14                    sta Enemy_Flag+5
00855A  2  A5 73                    lda Enemy_PageLoc+5
00855C  2  29 01                    and #$01                  ;fetch the right block buffer address
00855E  2  A8                       tay
00855F  2  B9 1E 7A                 lda BlockBufferAddr,y
008562  2  85 06                    sta $06
008564  2  B9 20 7A                 lda BlockBufferAddr+2,y
008567  2  85 07                    sta $07
008569  2  A5 8C                    lda Enemy_X_Position+5    ;divide upper nybble of X position by 16
00856B  2  4A                       lsr                       ;to get appropriate offset
00856C  2  4A                       lsr
00856D  2  4A                       lsr
00856E  2  4A                       lsr
00856F  2  A8           EraseClM:   tay
008570  2  B1 06                    lda ($06),y               ;check for climbing metatile
008572  2  C9 23                    cmp #$23                  ;if not found, move down a row
008574  2  D0 04                    bne NoClimbM
008576  2  A9 00                    lda #$00                  ;otherwise erase climbing metatile
008578  2  91 06                    sta ($06),y
00857A  2  98           NoClimbM:   tya
00857B  2  18                       clc
00857C  2  69 10                    adc #$10                  ;move 16 bytes (one row) ahead in block buffer
00857E  2  C9 D0                    cmp #$d0                  ;if not at bottom row, loop
008580  2  90 ED                    bcc EraseClM
008582  2  A6 08        ExitVH:     ldx ObjectOffset          ;get enemy object offset and leave
008584  2  60                       rts
008585  2               
008585  2               ;-------------------------------------------------------------------------------------
008585  2               
008585  2               CannonBitmasks:
008585  2  0F 07              .byte %00001111, %00000111
008587  2               
008587  2               ProcessCannons:
008587  2  AD 4E 07                lda AreaType                ;get area type
00858A  2  F0 6F                   beq ExCannon                ;if water type area, branch to leave
00858C  2  A2 02                   ldx #$02
00858E  2  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
008590  2  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
008592  2  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
008594  2  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
008597  2  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
00859A  2  39 85 85                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
00859D  2  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
00859F  2  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
0085A1  2  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
0085A2  2  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
0085A5  2  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
0085A7  2  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
0085AA  2  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
0085AC  2  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
0085AE  2  99 7D 04                sta Cannon_Timer,y          ;to count timer down
0085B1  2  4C E5 85                jmp Chk_BB                  ;then jump ahead to check enemy
0085B4  2               
0085B4  2               FireCannon:
0085B4  2  AD 47 07               lda TimerControl           ;if master timer control set,
0085B7  2  D0 2C                  bne Chk_BB                 ;branch to check enemy
0085B9  2  A9 0E                  lda #$0e                   ;otherwise we start creating one
0085BB  2  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
0085BE  2  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
0085C1  2  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
0085C3  2  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
0085C6  2  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
0085C8  2  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
0085CB  2  38                     sec
0085CC  2  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
0085CE  2  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
0085D0  2  A9 01                  lda #$01
0085D2  2  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
0085D4  2  95 0F                  sta Enemy_Flag,x           ;set buffer flag
0085D6  2  4A                     lsr                        ;shift right once to init A
0085D7  2  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
0085D9  2  A9 09                  lda #$09
0085DB  2  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
0085DE  2  A9 33                  lda #BulletBill_CannonVar
0085E0  2  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
0085E2  2  4C F8 85               jmp Next3Slt               ;move onto next slot
0085E5  2  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
0085E7  2  C9 33                  cmp #BulletBill_CannonVar
0085E9  2  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
0085EB  2  20 B4 A2               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
0085EE  2  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
0085F0  2  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
0085F2  2  20 94 BE               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
0085F5  2  20 FE 85               jsr BulletBillHandler      ;then do sub to handle bullet bill
0085F8  2  CA           Next3Slt: dex                        ;move onto next slot
0085F9  2  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
0085FB  2  60           ExCannon: rts                        ;then leave
0085FC  2               
0085FC  2               ;--------------------------------
0085FC  2               
0085FC  2               BulletBillXSpdData:
0085FC  2  18 E8              .byte $18, $e8
0085FE  2               
0085FE  2               BulletBillHandler:
0085FE  2  AD 47 07                lda TimerControl          ;if master timer control set,
008601  2  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
008603  2  B5 1E                   lda Enemy_State,x
008605  2  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
008607  2  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
00860A  2  29 0C                   and #%00001100            ;mask out bits
00860C  2  C9 0C                   cmp #%00001100            ;check to see if all bits are set
00860E  2  F0 40                   beq KillBB                ;if so, branch to kill this object
008610  2  A0 01                   ldy #$01                  ;set to move right by default
008612  2  20 D9 AD                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
008615  2  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
008617  2  C8                      iny                       ;otherwise increment to move left
008618  2  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
00861A  2  88                      dey                       ;decrement to use as offset
00861B  2  B9 FC 85                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
00861E  2  95 58                   sta Enemy_X_Speed,x       ;and store it
008620  2  A5 00                   lda $00                   ;get horizontal difference
008622  2  69 28                   adc #$28                  ;add 40 pixels
008624  2  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
008626  2  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
008628  2  A9 01                   lda #$01
00862A  2  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
00862C  2  A9 0A                   lda #$0a
00862E  2  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
008631  2  A9 08                   lda #Sfx_Blast
008633  2  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
008635  2  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
008637  2  29 20                   and #%00100000
008639  2  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
00863B  2  20 34 8B                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
00863E  2  20 D3 8A     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
008641  2  20 94 BE     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
008644  2  20 37 BE                jsr RelativeEnemyPosition ;get relative coordinates
008647  2  20 E1 AE                jsr GetEnemyBoundBox      ;get bounding box coordinates
00864A  2  20 AB A4                jsr PlayerEnemyCollision  ;handle player to enemy collisions
00864D  2  4C 2C B5                jmp EnemyGfxHandler       ;draw the bullet bill and leave
008650  2  20 CD 95     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
008653  2  60                      rts
008654  2               
008654  2               ;-------------------------------------------------------------------------------------
008654  2               
008654  2               HammerEnemyOfsData:
008654  2  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
008658  2  05 05        
00865A  2  06 06 06           .byte $06, $06, $06
00865D  2               
00865D  2               HammerXSpdData:
00865D  2  10 F0              .byte $10, $f0
00865F  2               
00865F  2               SpawnHammerObj:
00865F  2  AD A8 07               lda PseudoRandomBitReg+1 ;get a pseudorandom number from 0 to 8
008662  2  29 07                  and #%00000111           ;from the second part of LSFR
008664  2  D0 05                  bne SetMOfs
008666  2  AD A8 07               lda PseudoRandomBitReg+1
008669  2  29 08                  and #%00001000
00866B  2  A8           SetMOfs:  tay                      ;use as misc object offset
00866C  2  B9 2A 00               lda Misc_State,y         ;check for enemy state, if found, branch to leave
00866F  2  D0 19                  bne NoHammer
008671  2  BE 54 86               ldx HammerEnemyOfsData,y ;get enemy slot offset number using misc obj offset
008674  2  B5 0F                  lda Enemy_Flag,x         ;then check enemy buffer flag at that offset
008676  2  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
008678  2  A6 08                  ldx ObjectOffset         ;get original enemy object offset
00867A  2  8A                     txa
00867B  2  99 AE 06               sta HammerEnemyOffset,y  ;save here
00867E  2  A9 90                  lda #$90
008680  2  99 2A 00               sta Misc_State,y         ;save hammer's state here
008683  2  A9 07                  lda #$07
008685  2  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
008688  2  38                     sec                      ;return with carry set
008689  2  60                     rts
00868A  2  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
00868C  2  18                     clc                      ;return with carry clear
00868D  2  60                     rts
00868E  2               
00868E  2               ;--------------------------------
00868E  2               ;$00 - used to set downward force
00868E  2               ;$01 - used to set upward force (residual)
00868E  2               ;$02 - used to set maximum speed
00868E  2               
00868E  2               ProcHammerObj:
00868E  2  AD 47 07               lda TimerControl           ;if master timer control set
008691  2  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
008693  2  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
008695  2  29 7F                  and #%01111111             ;mask out d7
008697  2  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
00869A  2  C9 02                  cmp #$02                   ;check hammer's state
00869C  2  F0 20                  beq SetHSpd                ;if currently at 2, branch
00869E  2  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
0086A0  2  8A                     txa
0086A1  2  18                     clc                        ;add 13 bytes to use
0086A2  2  69 0D                  adc #$0d                   ;proper misc object
0086A4  2  AA                     tax                        ;return offset to X
0086A5  2  A9 10                  lda #$10
0086A7  2  85 00                  sta $00                    ;set downward movement force
0086A9  2  A9 0F                  lda #$0f
0086AB  2  85 01                  sta $01                    ;set upward movement force (not used)
0086AD  2  A9 04                  lda #$04
0086AF  2  85 02                  sta $02                    ;set maximum vertical speed
0086B1  2  A9 00                  lda #$00                   ;set A to impose gravity on hammer
0086B3  2  20 A8 8B               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
0086B6  2  20 E0 8A               jsr MoveObjectHorizontally ;do sub to move it horizontally
0086B9  2  A6 08                  ldx ObjectOffset           ;get original misc object offset
0086BB  2  4C F3 86               jmp RunAllH                ;branch to essential subroutines
0086BE  2  A9 FE        SetHSpd:  lda #$fe
0086C0  2  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
0086C2  2  B9 1E 00               lda Enemy_State,y          ;get enemy object state
0086C5  2  29 F7                  and #%11110111             ;mask out d3
0086C7  2  99 1E 00               sta Enemy_State,y          ;store new state
0086CA  2  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
0086CC  2  CA                     dex                        ;decrement to use as offset
0086CD  2  BD 5D 86               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
0086D0  2  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
0086D2  2  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
0086D4  2  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
0086D6  2  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
0086D9  2  18                     clc
0086DA  2  69 02                  adc #$02                   ;set position 2 pixels to the right
0086DC  2  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
0086DE  2  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
0086E1  2  69 00                  adc #$00                   ;add carry
0086E3  2  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
0086E5  2  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
0086E8  2  38                     sec
0086E9  2  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
0086EB  2  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
0086ED  2  A9 01                  lda #$01
0086EF  2  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
0086F1  2  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
0086F3  2  20 10 A4     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
0086F6  2  20 80 BE     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
0086F9  2  20 2D BE               jsr RelativeMiscPosition   ;get relative coordinates
0086FC  2  20 D4 AE               jsr GetMiscBoundBox        ;get bounding box coordinates
0086FF  2  20 80 B1               jsr DrawHammer             ;draw the hammer
008702  2  60                     rts                        ;and we are done here
008703  2               
008703  2               ;-------------------------------------------------------------------------------------
008703  2               ;$02 - used to store vertical high nybble offset from block buffer routine
008703  2               ;$06 - used to store low byte of block buffer address
008703  2               
008703  2               CoinBlock:
008703  2  20 4F 87           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
008706  2  B5 76              lda Block_PageLoc,x     ;get page location of block object
008708  2  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
00870B  2  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
00870D  2  09 05              ora #$05                ;add 5 pixels
00870F  2  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
008712  2  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
008714  2  E9 10              sbc #$10                ;subtract 16 pixels
008716  2  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
008719  2  4C 37 87           jmp JCoinC              ;jump to rest of code as applies to this misc object
00871C  2               
00871C  2               SetupJumpCoin:
00871C  2  20 4F 87             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00871F  2  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
008722  2  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
008725  2  A5 06                lda $06                ;get low byte of block buffer offset
008727  2  0A                   asl
008728  2  0A                   asl                    ;multiply by 16 to use lower nybble
008729  2  0A                   asl
00872A  2  0A                   asl
00872B  2  09 05                ora #$05               ;add five pixels
00872D  2  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
008730  2  A5 02                lda $02                ;get vertical high nybble offset from earlier
008732  2  69 20                adc #$20               ;add 32 pixels for the status bar
008734  2  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
008737  2  A9 FB        JCoinC: lda #$fb
008739  2  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
00873C  2  A9 01                lda #$01
00873E  2  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
008741  2  99 2A 00             sta Misc_State,y       ;set state for misc object
008744  2  85 FE                sta Square2SoundQueue  ;load coin grab sound
008746  2  86 08                stx ObjectOffset       ;store current control bit as misc object offset
008748  2  20 C3 87             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
00874B  2  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
00874E  2  60                   rts
00874F  2               
00874F  2               FindEmptyMiscSlot:
00874F  2  A0 08                   ldy #$08                ;start at end of misc objects buffer
008751  2  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
008754  2  F0 07                   beq UseMiscS            ;branch if none found to use current offset
008756  2  88                      dey                     ;decrement offset
008757  2  C0 05                   cpy #$05                ;do this for three slots
008759  2  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
00875B  2  A0 08                   ldy #$08                ;if no empty slots found, use last slot
00875D  2  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
008760  2  60                      rts
008761  2               
008761  2               ;-------------------------------------------------------------------------------------
008761  2               
008761  2               MiscObjectsCore:
008761  2  A2 08                  ldx #$08          ;set at end of misc object buffer
008763  2  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
008765  2  B5 2A                  lda Misc_State,x  ;check misc object state
008767  2  F0 56                  beq MiscLoopBack  ;branch to check next slot
008769  2  0A                     asl               ;otherwise shift d7 into carry
00876A  2  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
00876C  2  20 8E 86               jsr ProcHammerObj ;otherwise go to process hammer,
00876F  2  4C BF 87               jmp MiscLoopBack  ;then check next slot
008772  2               
008772  2               ;--------------------------------
008772  2               ;$00 - used to set downward force
008772  2               ;$01 - used to set upward force (residual)
008772  2               ;$02 - used to set maximum speed
008772  2               
008772  2               ProcJumpCoin:
008772  2  B4 2A                   ldy Misc_State,x          ;check misc object state
008774  2  88                      dey                       ;decrement to see if it's set to 1
008775  2  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
008777  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
008779  2  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
00877B  2  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
00877C  2  6D 75 07                adc ScrollAmount          ;add current scroll speed
00877F  2  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
008781  2  B5 7A                   lda Misc_PageLoc,x        ;get page location
008783  2  69 00                   adc #$00                  ;add carry
008785  2  95 7A                   sta Misc_PageLoc,x        ;store as new page location
008787  2  B5 2A                   lda Misc_State,x
008789  2  C9 30                   cmp #$30                  ;check state of object for preset value
00878B  2  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
00878D  2  A9 00                   lda #$00
00878F  2  95 2A                   sta Misc_State,x          ;otherwise nullify object state
008791  2  4C BF 87                jmp MiscLoopBack          ;and move onto next slot
008794  2  8A           JCoinRun:  txa
008795  2  18                      clc                       ;add 13 bytes to offset for next subroutine
008796  2  69 0D                   adc #$0d
008798  2  AA                      tax
008799  2  A9 50                   lda #$50                  ;set downward movement amount
00879B  2  85 00                   sta $00
00879D  2  A9 06                   lda #$06                  ;set maximum vertical speed
00879F  2  85 02                   sta $02
0087A1  2  4A                      lsr                       ;divide by 2 and set
0087A2  2  85 01                   sta $01                   ;as upward movement amount (apparently residual)
0087A4  2  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
0087A6  2  20 A8 8B                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
0087A9  2  A6 08                   ldx ObjectOffset          ;get original misc object offset
0087AB  2  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
0087AD  2  C9 05                   cmp #$05
0087AF  2  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
0087B1  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
0087B3  2  20 2D BE     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
0087B6  2  20 80 BE                jsr GetMiscOffscreenBits  ;get offscreen information
0087B9  2  20 D4 AE                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
0087BC  2  20 2C B3                jsr JCoinGfxHandler       ;draw the coin or floatey number
0087BF  2               
0087BF  2               MiscLoopBack:
0087BF  2  CA                      dex                       ;decrement misc object offset
0087C0  2  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
0087C2  2  60                      rts                       ;then leave
0087C3  2               
0087C3  2               ;-------------------------------------------------------------------------------------
0087C3  2               
0087C3  2               GiveOneCoin:
0087C3  2  A9 01              lda #$01               ;set digit modifier to add 1 coin
0087C5  2  8D 39 01           sta DigitModifier+5    ;to the current player's coin tally
0087C8  2  A0 11              ldy #$11               ;set offset for coin tally
0087CA  2  20 D2 6D           jsr DigitsMathRoutine  ;update the coin tally
0087CD  2  EE 5E 07           inc CoinTally          ;increment onscreen player's coin amount
0087D0  2  AD 5E 07           lda CoinTally
0087D3  2  C9 64              cmp #100               ;does player have 100 coins yet?
0087D5  2  D0 0C              bne CoinPoints         ;if not, skip all of this
0087D7  2  A9 00              lda #$00
0087D9  2  8D 5E 07           sta CoinTally          ;otherwise, reinitialize coin amount
0087DC  2  EE 5A 07           inc NumberofLives      ;give the player an extra life
0087DF  2  A9 40              lda #Sfx_ExtraLife
0087E1  2  85 FE              sta Square2SoundQueue  ;play 1-up sound
0087E3  2               
0087E3  2               CoinPoints:
0087E3  2  A9 02              lda #$02               ;set digit modifier to award
0087E5  2  8D 38 01           sta DigitModifier+4    ;200 points to the player
0087E8  2               
0087E8  2               AddToScore:
0087E8  2  A0 0B              ldy #$0b               ;get offset for player's score
0087EA  2  20 D2 6D           jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
0087ED  2               
0087ED  2               WriteScoreAndCoinTally:
0087ED  2  A9 01                lda #$01
0087EF  2               WriteDigits:
0087EF  2  20 79 6D             jsr PrintStatusBarNumbers ;print status bar numbers
0087F2  2  AC 00 03             ldy VRAM_Buffer1_Offset
0087F5  2  B9 FB 02             lda VRAM_Buffer1-6,y      ;check highest digit of score
0087F8  2  D0 05                bne NoZSup                ;if zero, overwrite with space tile for zero suppression
0087FA  2  A9 24                lda #$24
0087FC  2  99 FB 02             sta VRAM_Buffer1-6,y
0087FF  2  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
008801  2  60                   rts
008802  2               
008802  2               ;-------------------------------------------------------------------------------------
008802  2               
008802  2               SetupPowerUp:
008802  2  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
008804  2  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
008806  2  B5 76                   lda Block_PageLoc,x       ;store page location of block object
008808  2  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
00880A  2  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
00880C  2  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
00880E  2  A9 01                   lda #$01
008810  2  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
008812  2  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
008814  2  38                      sec
008815  2  E9 08                   sbc #$08                  ;subtract 8 pixels
008817  2  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
008819  2  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
00881B  2  85 23                   sta Enemy_State+5         ;set power-up object's state
00881D  2  85 14                   sta Enemy_Flag+5          ;set buffer flag
00881F  2  A9 03                   lda #$03
008821  2  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
008824  2  A5 39                   lda PowerUpType
008826  2  C9 02                   cmp #$02                  ;check currently loaded power-up type
008828  2  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
00882A  2  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
00882D  2  C9 02                   cmp #$02
00882F  2  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
008831  2  4A                      lsr                       ;otherwise shift right to force fire flower type
008832  2  85 39        StrType:   sta PowerUpType           ;store type here
008834  2  A9 20        PutBehind: lda #%00100000
008836  2  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
008839  2  A9 02                   lda #Sfx_GrowPowerUp
00883B  2  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
00883D  2  60                      rts
00883E  2               
00883E  2               ;-------------------------------------------------------------------------------------
00883E  2               
00883E  2               PowerUpObjHandler:
00883E  2  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
008840  2  86 08                 stx ObjectOffset
008842  2  A5 23                 lda Enemy_State+5          ;check power-up object's state
008844  2  F0 65                 beq ExitPUp                ;if not set, branch to leave
008846  2  0A                    asl                        ;shift to check if d7 was set in object state
008847  2  90 2B                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
008849  2  AD 47 07              lda TimerControl           ;if master timer control set,
00884C  2  D0 4B                 bne RunPUSubs              ;branch ahead to enemy object routines
00884E  2  A5 39                 lda PowerUpType            ;check power-up type
008850  2  F0 19                 beq ShroomM                ;if normal mushroom, branch ahead to move it
008852  2  C9 03                 cmp #$03
008854  2  F0 15                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
008856  2  C9 04                 cmp #$04
008858  2  F0 11                 beq ShroomM
00885A  2  C9 05                 cmp #$05
00885C  2  F0 0D                 beq ShroomM
00885E  2  C9 02                 cmp #$02
008860  2  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
008862  2  20 2E 97              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
008865  2  20 F9 AD              jsr EnemyJump              ;note that green paratroopa shares the same code here
008868  2  4C 99 88              jmp RunPUSubs              ;then jump to other power-up subroutines
00886B  2  20 AC 96     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
00886E  2  20 4A AC              jsr EnemyToBGCollisionDet  ;deal with collisions
008871  2  4C 99 88              jmp RunPUSubs              ;run the other subroutines
008874  2               
008874  2               GrowThePowerUp:
008874  2  A5 09                   lda FrameCounter           ;get frame counter
008876  2  29 03                   and #$03                   ;mask out all but 2 LSB
008878  2  D0 19                   bne ChkPUSte               ;if any bits set here, branch
00887A  2  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
00887C  2  A5 23                   lda Enemy_State+5          ;load power-up object state
00887E  2  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
008880  2  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
008882  2  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
008884  2  A9 10                   lda #$10
008886  2  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
008888  2  A9 80                   lda #%10000000
00888A  2  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
00888C  2  0A                      asl                        ;shift once to init A
00888D  2  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
008890  2  2A                      rol                        ;rotate A to set right moving direction
008891  2  95 46                   sta Enemy_MovingDir,x      ;set moving direction
008893  2  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
008895  2  C9 06                   cmp #$06                   ;for if power-up has risen enough
008897  2  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
008899  2  20 37 BE     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
00889C  2  20 94 BE                jsr GetEnemyOffscreenBits  ;get offscreen bits
00889F  2  20 E1 AE                jsr GetEnemyBoundBox       ;get bounding box coordinates
0088A2  2  20 7D B3                jsr DrawPowerUp            ;draw the power-up object
0088A5  2  20 AB A4                jsr PlayerEnemyCollision   ;check for collision with player
0088A8  2  20 B4 A2                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
0088AB  2  60           ExitPUp:   rts                        ;and we're done
0088AC  2               
0088AC  2               ;-------------------------------------------------------------------------------------
0088AC  2               ;These apply to all routines in this section unless otherwise noted:
0088AC  2               ;$00 - used to store metatile from block buffer routine
0088AC  2               ;$02 - used to store vertical high nybble offset from block buffer routine
0088AC  2               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
0088AC  2               ;$06-$07 - used as block buffer address indirect
0088AC  2               
0088AC  2               BlockYPosAdderData:
0088AC  2  04 12              .byte $04, $12
0088AE  2               
0088AE  2               PlayerHeadCollision:
0088AE  2  48                      pha                      ;store metatile number to stack
0088AF  2  A9 11                   lda #$11                 ;load unbreakable block object state by default
0088B1  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
0088B4  2  AC 54 07                ldy PlayerSize           ;check player's size
0088B7  2  D0 02                   bne DBlockSte            ;if small, branch
0088B9  2  A9 12                   lda #$12                 ;otherwise load breakable block object state
0088BB  2  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
0088BD  2  20 48 69                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
0088C0  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
0088C3  2  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
0088C5  2  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
0088C8  2  A8                      tay
0088C9  2  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
0088CB  2  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
0088CE  2  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
0088D0  2  20 C7 89                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
0088D3  2  85 00                   sta $00                  ;store metatile here
0088D5  2  AC 54 07                ldy PlayerSize           ;check player's size
0088D8  2  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
0088DA  2  98                      tya                      ;otherwise init A (note: big = 0)
0088DB  2  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
0088DD  2  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
0088DF  2  94 26                   sty Block_State,x        ;note this applies to both player sizes
0088E1  2  A9 C5                   lda #$c5                 ;load empty block metatile into A for now
0088E3  2  A4 00                   ldy $00                  ;get metatile from before
0088E5  2  C0 56                   cpy #$56                 ;is it brick with coins (with line)?
0088E7  2  F0 04                   beq StartBTmr            ;if so, branch
0088E9  2  C0 5C                   cpy #$5c                 ;is it brick with coins (without line)?
0088EB  2  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
0088ED  2  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
0088F0  2  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
0088F2  2  A9 0B                   lda #$0b
0088F4  2  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
0088F7  2  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
0088FA  2  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
0088FD  2  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
0088FF  2  A0 C5                   ldy #$c5                 ;otherwise use empty block metatile
008901  2  98           PutOldMT:  tya                      ;put metatile into A
008902  2  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
008905  2  20 45 89                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
008908  2  A4 02                   ldy $02                  ;get vertical high nybble offset
00890A  2  A9 20                   lda #$20
00890C  2  91 06                   sta ($06),y              ;write blank metatile $20 to block buffer
00890E  2  A9 10                   lda #$10
008910  2  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
008913  2  68                      pla                      ;pull original metatile from stack
008914  2  85 05                   sta $05                  ;and save here
008916  2  A0 00                   ldy #$00                 ;set default offset
008918  2  AD 14 07                lda CrouchingFlag        ;is player crouching?
00891B  2  D0 05                   bne SmallBP              ;if so, branch to increment offset
00891D  2  AD 54 07                lda PlayerSize           ;is player big?
008920  2  F0 01                   beq BigBP                ;if so, branch to use default offset
008922  2  C8           SmallBP:   iny                      ;increment for small or big and crouching
008923  2  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
008925  2  18                      clc
008926  2  79 AC 88                adc BlockYPosAdderData,y ;add value determined by size
008929  2  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
00892B  2  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
00892D  2  B4 26                   ldy Block_State,x        ;get block object state
00892F  2  C0 11                   cpy #$11
008931  2  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
008933  2  20 D3 89                jsr BrickShatter         ;execute code for breakable brick
008936  2  4C 3C 89                jmp InvOBit              ;skip subroutine to do last part of code here
008939  2  20 5C 89     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
00893C  2  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00893F  2  49 01                   eor #$01                 ;and floatey numbers
008941  2  8D EE 03                sta SprDataOffset_Ctrl
008944  2  60                      rts                      ;leave!
008945  2               
008945  2               ;--------------------------------
008945  2               
008945  2               InitBlock_XY_Pos:
008945  2  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
008947  2  18                 clc
008948  2  69 08              adc #$08                ;add eight pixels
00894A  2  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
00894C  2  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
00894E  2  A5 6D              lda Player_PageLoc
008950  2  69 00              adc #$00                ;add carry to page location of player
008952  2  95 76              sta Block_PageLoc,x     ;save as page location of block object
008954  2  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
008957  2  A5 B5              lda Player_Y_HighPos
008959  2  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
00895B  2  60                 rts                     ;vertical high byte of block object and leave
00895C  2               
00895C  2               ;--------------------------------
00895C  2               
00895C  2               BumpBlock:
00895C  2  20 F0 89                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
00895F  2  A9 02                   lda #Sfx_Bump
008961  2  85 FF                   sta Square1SoundQueue   ;play bump sound
008963  2  A9 00                   lda #$00
008965  2  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
008967  2  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
00896A  2  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
00896C  2  A9 FE                   lda #$fe
00896E  2  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
008970  2  A5 05                   lda $05                 ;get original metatile from stack
008972  2  20 C7 89                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
008975  2  90 3C                   bcc ExitBlockChk        ;if no match was found, branch to leave
008977  2  98                      tya                     ;move block number to A
008978  2  C9 0D                   cmp #$0d                ;if block number was within 0-$c range,
00897A  2  90 02                   bcc BlockCode           ;branch to use current number
00897C  2  E9 06                   sbc #$06                ;otherwise subtract 6 for second set to get proper number
00897E  2  20 7D 6C     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
008981  2               
008981  2  9B 89              .word MushFlowerBlock
008983  2  A1 89              .word PoisonMushBlock
008985  2  03 87              .word CoinBlock
008987  2  03 87              .word CoinBlock
008989  2  A4 89              .word ExtraLifeMushBlock
00898B  2  A1 89              .word PoisonMushBlock
00898D  2  9B 89              .word MushFlowerBlock
00898F  2  9B 89              .word MushFlowerBlock
008991  2  A1 89              .word PoisonMushBlock
008993  2  AB 89              .word VineBlock
008995  2  9E 89              .word StarBlock
008997  2  03 87              .word CoinBlock
008999  2  A4 89              .word ExtraLifeMushBlock
00899B  2               
00899B  2               MushFlowerBlock:
00899B  2  A9 00              lda #$00                ;load mushroom/flower type
00899D  2  2C                 .byte $2c
00899E  2               
00899E  2               StarBlock:
00899E  2  A9 02              lda #$02                ;load star type
0089A0  2  2C                 .byte $2c
0089A1  2               
0089A1  2               PoisonMushBlock:
0089A1  2  A9 04              lda #$04                ;load poison mushroom type
0089A3  2  2C                 .byte $2c
0089A4  2               
0089A4  2               ExtraLifeMushBlock:
0089A4  2  A9 03              lda #$03                ;load 1-up mushroom type
0089A6  2  85 39              sta $39                 ;store correct power-up type
0089A8  2  4C 02 88           jmp SetupPowerUp
0089AB  2               
0089AB  2               VineBlock:
0089AB  2  A2 05              ldx #$05                ;load last slot for enemy object buffer
0089AD  2  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
0089B0  2  20 AA 84           jsr Setup_Vine          ;set up vine object
0089B3  2               
0089B3  2               ExitBlockChk:
0089B3  2  60                 rts                     ;leave
0089B4  2               
0089B4  2               ;--------------------------------
0089B4  2               
0089B4  2               BrickQBlockMetatiles:
0089B4  2  C1 C2 C0 5E        .byte $c1, $c2, $c0, $5e, $5f, $60, $61 ;used by question blocks
0089B8  2  5F 60 61     
0089BB  2               
0089BB  2  52 53 54 55        .byte $52, $53, $54, $55, $56, $57 ;used by ground level bricks
0089BF  2  56 57        
0089C1  2  58 59 5A 5B        .byte $58, $59, $5a, $5b, $5c, $5d ;used by other level bricks
0089C5  2  5C 5D        
0089C7  2               
0089C7  2               BlockBumpedChk:
0089C7  2  A0 12                     ldy #$12                    ;start at end of metatile data
0089C9  2  D9 B4 89     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
0089CC  2  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
0089CE  2  88                        dey                         ;otherwise move onto next metatile
0089CF  2  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
0089D1  2  18                        clc                         ;if none match, return with carry clear
0089D2  2  60           MatchBump:   rts                         ;note carry is set if found match
0089D3  2               
0089D3  2               ;--------------------------------
0089D3  2               
0089D3  2               BrickShatter:
0089D3  2  20 F0 89           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
0089D6  2  A9 01              lda #Sfx_BrickShatter
0089D8  2  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
0089DB  2  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
0089DD  2  20 12 8A           jsr SpawnBrickChunks   ;create brick chunk objects
0089E0  2  A9 FE              lda #$fe
0089E2  2  85 9F              sta Player_Y_Speed     ;set vertical speed for player
0089E4  2  A9 05              lda #$05
0089E6  2  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
0089E9  2  20 E8 87           jsr AddToScore         ;do sub to update the score
0089EC  2  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
0089EF  2  60                 rts
0089F0  2               
0089F0  2               ;--------------------------------
0089F0  2               
0089F0  2               CheckTopOfBlock:
0089F0  2  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
0089F3  2  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
0089F5  2  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
0089F7  2  98                  tya                     ;otherwise set to A
0089F8  2  38                  sec
0089F9  2  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
0089FB  2  85 02               sta $02                 ;store as new vertical high nybble offset
0089FD  2  A8                  tay
0089FE  2  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
008A00  2  C9 C3               cmp #$c3                ;is it a coin? (not underwater)
008A02  2  D0 0D               bne TopEx               ;if not, branch to leave
008A04  2  A9 00               lda #$00
008A06  2  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
008A08  2  20 2A 69            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
008A0B  2  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
008A0E  2  20 1C 87            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
008A11  2  60           TopEx: rts                     ;leave!
008A12  2               
008A12  2               ;--------------------------------
008A12  2               
008A12  2               SpawnBrickChunks:
008A12  2  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
008A14  2  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
008A17  2  A9 F0              lda #$f0
008A19  2  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
008A1B  2  95 62              sta Block_X_Speed+2,x
008A1D  2  A9 FA              lda #$fa
008A1F  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
008A21  2  A9 FC              lda #$fc
008A23  2  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
008A25  2  A9 00              lda #$00
008A27  2  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
008A2A  2  9D 3E 04           sta Block_Y_MoveForce+2,x
008A2D  2  B5 76              lda Block_PageLoc,x
008A2F  2  95 78              sta Block_PageLoc+2,x      ;copy page location
008A31  2  B5 8F              lda Block_X_Position,x
008A33  2  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
008A35  2  B5 D7              lda Block_Y_Position,x
008A37  2  18                 clc                        ;add 8 pixels to vertical coordinate
008A38  2  69 08              adc #$08                   ;and save as vertical coordinate for one of them
008A3A  2  95 D9              sta Block_Y_Position+2,x
008A3C  2  A9 FA              lda #$fa
008A3E  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
008A40  2  60                 rts
008A41  2               
008A41  2               ;-------------------------------------------------------------------------------------
008A41  2               
008A41  2               BlockObjectsCore:
008A41  2  B5 26                lda Block_State,x           ;get state of block object
008A43  2  F0 5D                beq UpdSte                  ;if not set, branch to leave
008A45  2  29 0F                and #$0f                    ;mask out high nybble
008A47  2  48                   pha                         ;push to stack
008A48  2  A8                   tay                         ;put in Y for now
008A49  2  8A                   txa
008A4A  2  18                   clc
008A4B  2  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
008A4D  2  AA                   tax                         ;when using brick chunks, but only one offset for both)
008A4E  2  88                   dey                         ;decrement Y to check for solid block state
008A4F  2  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
008A51  2  20 75 8B             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
008A54  2  20 E0 8A             jsr MoveObjectHorizontally  ;do another sub to move horizontally
008A57  2  8A                   txa
008A58  2  18                   clc                         ;move onto next block object
008A59  2  69 02                adc #$02
008A5B  2  AA                   tax
008A5C  2  20 75 8B             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
008A5F  2  20 E0 8A             jsr MoveObjectHorizontally  ;do another sub to move horizontally
008A62  2  A6 08                ldx ObjectOffset            ;get block object offset used for both
008A64  2  20 3E BE             jsr RelativeBlockPosition   ;get relative coordinates
008A67  2  20 9B BE             jsr GetBlockOffscreenBits   ;get offscreen information
008A6A  2  20 2E B9             jsr DrawBrickChunks         ;draw the brick chunks
008A6D  2  68                   pla                         ;get lower nybble of saved state
008A6E  2  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
008A70  2  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
008A72  2  48                   pha                         ;otherwise save state back into stack
008A73  2  A9 F0                lda #$f0
008A75  2  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
008A77  2  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
008A79  2  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
008A7B  2  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
008A7D  2  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
008A7F  2  68                   pla                         ;pull block object state from stack
008A80  2  90 20                bcc UpdSte                  ;if not, branch to save state
008A82  2  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
008A84  2               
008A84  2               BouncingBlockHandler:
008A84  2  20 75 8B                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
008A87  2  A6 08                   ldx ObjectOffset           ;get block object offset
008A89  2  20 3E BE                jsr RelativeBlockPosition  ;get relative coordinates
008A8C  2  20 9B BE                jsr GetBlockOffscreenBits  ;get offscreen information
008A8F  2  20 AC B8                jsr DrawBlock              ;draw the block
008A92  2  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
008A94  2  29 0F                   and #$0f                   ;mask out high nybble
008A96  2  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
008A98  2  68                      pla                        ;pull state from stack
008A99  2  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
008A9B  2  A9 01                   lda #$01
008A9D  2  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
008AA0  2  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
008AA2  2  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
008AA4  2  60                      rts
008AA5  2               
008AA5  2               ;-------------------------------------------------------------------------------------
008AA5  2               ;$02 - used to store offset to block buffer
008AA5  2               ;$06-$07 - used to store block buffer address
008AA5  2               
008AA5  2               BlockObjMT_Updater:
008AA5  2  A2 01                    ldx #$01                  ;set offset to start with second block object
008AA7  2  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
008AA9  2  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
008AAC  2  D0 21                    bne NextBUpd              ;branch to move onto next block object
008AAE  2  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
008AB1  2  F0 1C                    beq NextBUpd              ;branch to move onto next block object
008AB3  2  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
008AB6  2  85 06                    sta $06                   ;store into block buffer address
008AB8  2  A9 05                    lda #$05
008ABA  2  85 07                    sta $07                   ;set high byte of block buffer address
008ABC  2  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
008ABF  2  85 02                    sta $02                   ;store here and use as offset to block buffer
008AC1  2  A8                       tay
008AC2  2  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
008AC5  2  91 06                    sta ($06),y               ;write it to the block buffer
008AC7  2  20 3E 69                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
008ACA  2  A9 00                    lda #$00
008ACC  2  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
008ACF  2  CA           NextBUpd:   dex                       ;decrement block object offset
008AD0  2  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
008AD2  2  60                       rts                       ;then leave
008AD3  2               
008AD3  2               ;-------------------------------------------------------------------------------------
008AD3  2               ;$00 - used to store high nybble of horizontal speed as adder
008AD3  2               ;$01 - used to store low nybble of horizontal speed
008AD3  2               ;$02 - used to store adder to page location
008AD3  2               
008AD3  2               MoveEnemyHorizontally:
008AD3  2  E8                 inx                         ;increment offset for enemy offset
008AD4  2  20 E0 8A           jsr MoveObjectHorizontally  ;position object horizontally according to
008AD7  2  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
008AD9  2  60                 rts                         ;put enemy offset back in X and leave
008ADA  2               
008ADA  2               MovePlayerHorizontally:
008ADA  2  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
008ADD  2  D0 3E              bne ExXMove             ;branch to leave
008ADF  2  AA                 tax                     ;otherwise set zero for offset to use player's stuff
008AE0  2               
008AE0  2               MoveObjectHorizontally:
008AE0  2  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
008AE2  2  0A                     asl                         ;speed, secondary counter, whatever)
008AE3  2  0A                     asl                         ;and move low nybble to high
008AE4  2  0A                     asl
008AE5  2  0A                     asl
008AE6  2  85 01                  sta $01                     ;store result here
008AE8  2  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
008AEA  2  4A                     lsr                         ;move high nybble to low
008AEB  2  4A                     lsr
008AEC  2  4A                     lsr
008AED  2  4A                     lsr
008AEE  2  C9 08                  cmp #$08                    ;if < 8, branch, do not change
008AF0  2  90 02                  bcc SaveXSpd
008AF2  2  09 F0                  ora #%11110000              ;otherwise alter high nybble
008AF4  2  85 00        SaveXSpd: sta $00                     ;save result here
008AF6  2  A0 00                  ldy #$00                    ;load default Y value here
008AF8  2  C9 00                  cmp #$00                    ;if result positive, leave Y alone
008AFA  2  10 01                  bpl UseAdder
008AFC  2  88                     dey                         ;otherwise decrement Y
008AFD  2  84 02        UseAdder: sty $02                     ;save Y here
008AFF  2  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
008B02  2  18                     clc
008B03  2  65 01                  adc $01                     ;add low nybble moved to high
008B05  2  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
008B08  2  A9 00                  lda #$00                    ;init A
008B0A  2  2A                     rol                         ;rotate carry into d0
008B0B  2  48                     pha                         ;push onto stack
008B0C  2  6A                     ror                         ;rotate d0 back onto carry
008B0D  2  B5 86                  lda SprObject_X_Position,x
008B0F  2  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
008B11  2  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
008B13  2  B5 6D                  lda SprObject_PageLoc,x
008B15  2  65 02                  adc $02                     ;add carry plus other saved value to the
008B17  2  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
008B19  2  68                     pla
008B1A  2  18                     clc                         ;pull old carry from stack and add
008B1B  2  65 00                  adc $00                     ;to high nybble moved to low
008B1D  2  60           ExXMove:  rts                         ;and leave
008B1E  2               
008B1E  2               ;-------------------------------------------------------------------------------------
008B1E  2               ;$00 - used for downward force
008B1E  2               ;$01 - used for upward force
008B1E  2               ;$02 - used for maximum vertical speed
008B1E  2               
008B1E  2               MovePlayerVertically:
008B1E  2  A2 00                 ldx #$00                ;set X for player offset
008B20  2  AD 47 07              lda TimerControl
008B23  2  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
008B25  2  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
008B28  2  D0 F3                 bne ExXMove             ;branch to leave if so
008B2A  2  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
008B2D  2  85 00                 sta $00
008B2F  2  A9 04                 lda #$04                ;set maximum vertical speed here
008B31  2  4C 7E 8B              jmp ImposeGravitySprObj ;then jump to move player vertically
008B34  2               
008B34  2               ;--------------------------------
008B34  2               
008B34  2               MoveD_EnemyVertically:
008B34  2  A0 3D              ldy #$3d           ;set quick movement amount downwards
008B36  2  B5 1E              lda Enemy_State,x  ;then check enemy state
008B38  2  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
008B3A  2  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
008B3C  2               
008B3C  2               MoveFallingPlatform:
008B3C  2  A0 20                   ldy #$20       ;set movement amount
008B3E  2  4C 65 8B     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
008B41  2               
008B41  2               ;--------------------------------
008B41  2               
008B41  2               MoveRedPTroopaDown:
008B41  2  A0 00              ldy #$00            ;set Y to move downwards
008B43  2  4C 48 8B           jmp MoveRedPTroopa  ;skip to movement routine
008B46  2               
008B46  2               MoveRedPTroopaUp:
008B46  2  A0 01              ldy #$01            ;set Y to move upwards
008B48  2               
008B48  2               MoveRedPTroopa:
008B48  2  E8                 inx                 ;increment X for enemy offset
008B49  2  A9 03              lda #$03
008B4B  2  85 00              sta $00             ;set downward movement amount here
008B4D  2  A9 06              lda #$06
008B4F  2  85 01              sta $01             ;set upward movement amount here
008B51  2  A9 02              lda #$02
008B53  2  85 02              sta $02             ;set maximum speed here
008B55  2  98                 tya                 ;set movement direction in A, and
008B56  2  4C A2 8B           jmp RedPTroopaGrav  ;jump to move this thing
008B59  2               
008B59  2               ;--------------------------------
008B59  2               
008B59  2               MoveDropPlatform:
008B59  2  A0 7F              ldy #$7f      ;set movement amount for drop platform
008B5B  2  D0 02              bne SetMdMax  ;skip ahead of other value set here
008B5D  2               
008B5D  2               MoveEnemySlowVert:
008B5D  2  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
008B5F  2  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
008B61  2  D0 04                  bne SetXMoveAmt  ;unconditional branch
008B63  2               
008B63  2               ;--------------------------------
008B63  2               
008B63  2               MoveJ_EnemyVertically:
008B63  2  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
008B65  2  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
008B67  2  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
008B69  2  E8                        inx                     ;increment X for enemy offset
008B6A  2  20 7E 8B                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
008B6D  2  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
008B6F  2  60                        rts
008B70  2               
008B70  2               ;--------------------------------
008B70  2               
008B70  2               MaxSpdBlockData:
008B70  2  06 08              .byte $06, $08
008B72  2               
008B72  2               ResidualGravityCode:
008B72  2  A0 00              ldy #$00       ;this part appears to be residual,
008B74  2  2C                 .byte $2c        ;no code branches or jumps to it...
008B75  2               
008B75  2               ImposeGravityBlock:
008B75  2  A0 01              ldy #$01       ;set offset for maximum speed
008B77  2  A9 50              lda #$50       ;set movement amount here
008B79  2  85 00              sta $00
008B7B  2  B9 70 8B           lda MaxSpdBlockData,y    ;get maximum speed
008B7E  2               
008B7E  2               ImposeGravitySprObj:
008B7E  2  85 02              sta $02            ;set maximum speed here
008B80  2  A9 00              lda #$00           ;set value to move downwards
008B82  2  4C A8 8B           jmp ImposeGravity  ;jump to the code that actually moves it
008B85  2               
008B85  2               ;--------------------------------
008B85  2               
008B85  2               MovePlatformDown:
008B85  2  A9 00              lda #$00    ;save value to stack (if branching here, execute next
008B87  2  2C                 .byte $2c     ;part as BIT instruction)
008B88  2               
008B88  2               MovePlatformUp:
008B88  2  A9 01                   lda #$01        ;save value to stack
008B8A  2  48                      pha
008B8B  2  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
008B8D  2  E8                      inx             ;increment offset for enemy object
008B8E  2  A9 05                   lda #$05        ;load default value here
008B90  2  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
008B92  2  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
008B94  2  A9 09                   lda #$09        ;residual code
008B96  2  85 00        SetDplSpd: sta $00         ;save downward movement amount here
008B98  2  A9 0A                   lda #$0a        ;save upward movement amount here
008B9A  2  85 01                   sta $01
008B9C  2  A9 03                   lda #$03        ;save maximum vertical speed here
008B9E  2  85 02                   sta $02
008BA0  2  68                      pla             ;get value from stack
008BA1  2  A8                      tay             ;use as Y, then move onto code shared by red koopa
008BA2  2               
008BA2  2               RedPTroopaGrav:
008BA2  2  20 A8 8B           jsr ImposeGravity  ;do a sub to move object gradually
008BA5  2  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
008BA7  2  60                 rts
008BA8  2               
008BA8  2               ;-------------------------------------------------------------------------------------
008BA8  2               ;$00 - used for downward force
008BA8  2               ;$01 - used for upward force
008BA8  2               ;$07 - used as adder for vertical position
008BA8  2               
008BA8  2               ImposeGravity:
008BA8  2  48                    pha                          ;push value to stack
008BA9  2  BD 16 04              lda SprObject_YMF_Dummy,x
008BAC  2  18                    clc                          ;add value in movement force to contents of dummy variable
008BAD  2  7D 33 04              adc SprObject_Y_MoveForce,x
008BB0  2  9D 16 04              sta SprObject_YMF_Dummy,x
008BB3  2  A0 00                 ldy #$00                     ;set Y to zero by default
008BB5  2  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
008BB7  2  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
008BB9  2  88                    dey                          ;otherwise decrement Y
008BBA  2  84 07        AlterYP: sty $07                      ;store Y here
008BBC  2  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
008BBE  2  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
008BC0  2  B5 B5                 lda SprObject_Y_HighPos,x
008BC2  2  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
008BC4  2  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
008BC6  2  BD 33 04              lda SprObject_Y_MoveForce,x
008BC9  2  18                    clc
008BCA  2  65 00                 adc $00                      ;add downward movement amount to contents of $0433
008BCC  2  9D 33 04              sta SprObject_Y_MoveForce,x
008BCF  2  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
008BD1  2  69 00                 adc #$00
008BD3  2  95 9F                 sta SprObject_Y_Speed,x
008BD5  2  C5 02                 cmp $02                      ;compare to maximum speed
008BD7  2  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
008BD9  2  BD 33 04              lda SprObject_Y_MoveForce,x
008BDC  2  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
008BDE  2  90 09                 bcc ChkUpM
008BE0  2  A5 02                 lda $02
008BE2  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
008BE4  2  A9 00                 lda #$00
008BE6  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
008BE9  2  68           ChkUpM:  pla                          ;get value from stack
008BEA  2  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
008BEC  2  A5 02                 lda $02
008BEE  2  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
008BF0  2  A8                    tay
008BF1  2  C8                    iny
008BF2  2  84 07                 sty $07                      ;store two's compliment here
008BF4  2  BD 33 04              lda SprObject_Y_MoveForce,x
008BF7  2  38                    sec                          ;subtract upward movement amount from contents
008BF8  2  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
008BFA  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
008BFD  2  B5 9F                 lda SprObject_Y_Speed,x
008BFF  2  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
008C01  2  95 9F                 sta SprObject_Y_Speed,x
008C03  2  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
008C05  2  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
008C07  2  BD 33 04              lda SprObject_Y_MoveForce,x
008C0A  2  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
008C0C  2  B0 09                 bcs ExVMove                  ;and if so, branch to leave
008C0E  2  A5 07                 lda $07
008C10  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
008C12  2  A9 FF                 lda #$ff
008C14  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
008C17  2  60           ExVMove: rts                          ;leave!
008C18  2               
008C18  2               ;-------------------------------------------------------------------------------------
008C18  2               
008C18  2               ;some unused bytes
008C18  2  FF FF FF FF           .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
008C1C  2  FF FF FF FF  
008C20  2  FF FF FF     
008C23  2               
008C23  2               ;-------------------------------------------------------------------------------------
008C23  2               
008C23  2               EnemiesAndLoopsCore:
008C23  2  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
008C25  2  48                       pha                      ;save in stack
008C26  2  0A                       asl
008C27  2  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
008C29  2  68                       pla                      ;get from stack
008C2A  2  F0 03                    beq ChkAreaTsk           ;if data zero, branch
008C2C  2  4C B7 94                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
008C2F  2  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
008C32  2  29 07                    and #$07
008C34  2  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
008C36  2  F0 0E                    beq ExitELCore
008C38  2  4C B7 8C                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
008C3B  2  68           ChkBowserF: pla                      ;get data from stack
008C3C  2  29 0F                    and #%00001111           ;mask out high nybble
008C3E  2  A8                       tay
008C3F  2  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
008C42  2  D0 02                    bne ExitELCore
008C44  2  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
008C46  2  60           ExitELCore: rts
008C47  2               
008C47  2               ;-------------------------------------------------------------------------------------
008C47  2               
008C47  2               ;loop command data
008C47  2               ;note that some data is never used (it may have been
008C47  2               ;used at one point, but the area data that ref'd it
008C47  2               ;is now missing the loop command object)
008C47  2               
008C47  2               LoopCmdWorldNumber:
008C47  2  02 02 02 02    .byte $02, $02, $02, $02, $05, $05, $05, $05, $06, $07, $07, $04
008C4B  2  05 05 05 05  
008C4F  2  06 07 07 04  
008C53  2               
008C53  2               LoopCmdPageNumber:
008C53  2  03 05 08 09    .byte $03, $05, $08, $09, $03, $06, $07, $0a, $05, $05, $0b, $05
008C57  2  03 06 07 0A  
008C5B  2  05 05 0B 05  
008C5F  2               
008C5F  2               LoopCmdYPosition:
008C5F  2  B0 B0 40 30    .byte $b0, $b0, $40, $30, $b0, $30, $b0, $b0, $f0, $f0, $b0, $f0
008C63  2  B0 30 B0 B0  
008C67  2  F0 F0 B0 F0  
008C6B  2               
008C6B  2               MultiLoopCount:
008C6B  2  02 02 02 02    .byte $02, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01
008C6F  2  02 02 02 02  
008C73  2  01 01 01 01  
008C77  2               
008C77  2               ExecGameLoopback:
008C77  2  A5 6D              lda Player_PageLoc        ;send player back four pages
008C79  2  38                 sec
008C7A  2  E9 04              sbc #$04
008C7C  2  85 6D              sta Player_PageLoc
008C7E  2  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
008C81  2  38                 sec
008C82  2  E9 04              sbc #$04
008C84  2  8D 25 07           sta CurrentPageLoc
008C87  2  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
008C8A  2  38                 sec                       ;of screen's left border
008C8B  2  E9 04              sbc #$04
008C8D  2  8D 1A 07           sta ScreenLeft_PageLoc
008C90  2  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
008C93  2  38                 sec                       ;of screen's right border
008C94  2  E9 04              sbc #$04
008C96  2  8D 1B 07           sta ScreenRight_PageLoc
008C99  2  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
008C9C  2  38                 sec                       ;for area objects
008C9D  2  E9 04              sbc #$04
008C9F  2  8D 2A 07           sta AreaObjectPageLoc
008CA2  2  A9 00              lda #$00                  ;initialize page select for both
008CA4  2  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
008CA7  2  8D 2B 07           sta AreaObjectPageSel
008CAA  2  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
008CAD  2  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
008CB0  2  B9 88 C3           lda AreaDataOfsLoopback,y ;adjust area object offset based on
008CB3  2  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
008CB6  2  60                 rts
008CB7  2               
008CB7  2               ProcLoopCommand:
008CB7  2  AD 45 07               lda LoopCommand           ;check if loop command was found
008CBA  2  F0 50                  beq ChkEnemyFrenzy
008CBC  2  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
008CBF  2  D0 4B                  bne ChkEnemyFrenzy        ;if not, do not loop yet
008CC1  2  A0 0C                  ldy #$0c                  ;start at the end of each set of loop data
008CC3  2  88           FindLoop: dey
008CC4  2  30 46                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
008CC6  2  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
008CC9  2  D9 47 8C               cmp LoopCmdWorldNumber,y  ;matches our current world number
008CCC  2  D0 F5                  bne FindLoop
008CCE  2  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
008CD1  2  D9 53 8C               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
008CD4  2  D0 ED                  bne FindLoop
008CD6  2  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
008CD8  2  D9 5F 8C               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
008CDB  2  D0 09                  bne WrongChk
008CDD  2  A5 1D                  lda Player_State          ;check to see if the player is
008CDF  2  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
008CE1  2  D0 03                  bne WrongChk              ;if not, player fails to pass loop, and loopback
008CE3  2  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
008CE6  2  EE DA 06     WrongChk: inc MultiLoopPassCntr     ;increment master multi-part counter
008CE9  2  AD DA 06               lda MultiLoopPassCntr     ;have we done all parts?
008CEC  2  D9 6B 8C               cmp MultiLoopCount,y
008CEF  2  D0 16                  bne InitLCmd              ;if not, skip this part
008CF1  2  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
008CF4  2  D9 6B 8C               cmp MultiLoopCount,y
008CF7  2  F0 06                  beq InitMLp               ;if so, branch past unnecessary check here
008CF9  2  20 77 8C               jsr ExecGameLoopback      ;if player is not in right place, loop back
008CFC  2  20 A6 9C               jsr KillAllEnemies
008CFF  2  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
008D01  2  8D DA 06               sta MultiLoopPassCntr
008D04  2  8D D9 06               sta MultiLoopCorrectCntr
008D07  2  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
008D09  2  8D 45 07               sta LoopCommand
008D0C  2               
008D0C  2               ;--------------------------------
008D0C  2               
008D0C  2               ChkEnemyFrenzy:
008D0C  2  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
008D0F  2  F0 10              beq ProcessEnemyData  ;if not, skip this part
008D11  2  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
008D13  2  A9 01              lda #$01
008D15  2  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
008D17  2  A9 00              lda #$00
008D19  2  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
008D1B  2  8D CD 06           sta EnemyFrenzyQueue
008D1E  2  4C 03 8E           jmp InitEnemyObject   ;and then jump to deal with this enemy
008D21  2               
008D21  2               ;--------------------------------
008D21  2               ;$06 - used to hold page location of extended right boundary
008D21  2               ;$07 - used to hold high nybble of position of extended right boundary
008D21  2               
008D21  2               ProcessEnemyData:
008D21  2  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
008D24  2  B1 E9                lda (EnemyData),y        ;load first byte
008D26  2  C9 FF                cmp #$ff                 ;check for EOD terminator
008D28  2  D0 03                bne CheckEndofBuffer
008D2A  2  4C F3 8D             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
008D2D  2               
008D2D  2               CheckEndofBuffer:
008D2D  2  29 0F                and #%00001111           ;check for special row $0e
008D2F  2  C9 0E                cmp #$0e
008D31  2  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
008D33  2  E0 05                cpx #$05                 ;check for end of buffer
008D35  2  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
008D37  2  C8                   iny
008D38  2  B1 E9                lda (EnemyData),y        ;check for specific value here
008D3A  2  29 3F                and #%00111111           ;not sure what this was intended for, exactly
008D3C  2  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
008D3E  2  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
008D40  2  60                   rts                      ;the sixth slot
008D41  2               
008D41  2               CheckRightBounds:
008D41  2  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
008D44  2  18                   clc
008D45  2  69 30                adc #$30
008D47  2  29 F0                and #%11110000           ;store high nybble
008D49  2  85 07                sta $07
008D4B  2  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
008D4E  2  69 00                adc #$00
008D50  2  85 06                sta $06                  ;store page location + carry
008D52  2  AC 39 07             ldy EnemyDataOffset
008D55  2  C8                   iny
008D56  2  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
008D58  2  0A                   asl
008D59  2  90 0B                bcc CheckPageCtrlRow
008D5B  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
008D5E  2  D0 06                bne CheckPageCtrlRow
008D60  2  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
008D63  2  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
008D66  2               
008D66  2               CheckPageCtrlRow:
008D66  2  88                   dey
008D67  2  B1 E9                lda (EnemyData),y        ;reread first byte
008D69  2  29 0F                and #$0f
008D6B  2  C9 0F                cmp #$0f                 ;check for special row $0f
008D6D  2  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
008D6F  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
008D72  2  D0 14                bne PositionEnemyObj     ;branch without reading second byte
008D74  2  C8                   iny
008D75  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
008D77  2  29 3F                and #%00111111
008D79  2  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
008D7C  2  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
008D7F  2  EE 39 07             inc EnemyDataOffset
008D82  2  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
008D85  2  4C B7 8C             jmp ProcLoopCommand      ;jump back to process loop commands again
008D88  2               
008D88  2               PositionEnemyObj:
008D88  2  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
008D8B  2  95 6E                sta Enemy_PageLoc,x      ;for enemy object
008D8D  2  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
008D8F  2  29 F0                and #%11110000
008D91  2  95 87                sta Enemy_X_Position,x   ;store column position
008D93  2  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
008D96  2  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
008D98  2  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
008D9B  2  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
008D9D  2  B1 E9                lda (EnemyData),y
008D9F  2  29 0F                and #%00001111           ;check for special row $0e
008DA1  2  C9 0E                cmp #$0e                 ;if found, jump elsewhere
008DA3  2  F0 69                beq ParseRow0e
008DA5  2  4C 34 8E             jmp CheckThreeBytes      ;if not found, unconditional jump
008DA8  2               
008DA8  2               CheckRightExtBounds:
008DA8  2  A5 07                lda $07                  ;check right boundary + 48 against
008DAA  2  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
008DAC  2  A5 06                lda $06                  ;then subtract borrow from page control temp
008DAE  2  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
008DB0  2  90 41                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
008DB2  2  A9 01                lda #$01                 ;store value in vertical high byte
008DB4  2  95 B6                sta Enemy_Y_HighPos,x
008DB6  2  B1 E9                lda (EnemyData),y        ;get first byte again
008DB8  2  0A                   asl                      ;multiply by four to get the vertical
008DB9  2  0A                   asl                      ;coordinate
008DBA  2  0A                   asl
008DBB  2  0A                   asl
008DBC  2  95 CF                sta Enemy_Y_Position,x
008DBE  2  C9 E0                cmp #$e0                 ;do one last check for special row $0e
008DC0  2  F0 4C                beq ParseRow0e           ;(necessary if branched to $c1cb)
008DC2  2  C8                   iny
008DC3  2  B1 E9                lda (EnemyData),y        ;get second byte of object
008DC5  2  29 40                and #%01000000           ;check to see if hard mode bit is set
008DC7  2  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
008DC9  2  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
008DCC  2  F0 74                beq Inc2B                ;is on, and if not, branch to skip this object completely
008DCE  2               
008DCE  2               CheckForEnemyGroup:
008DCE  2  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
008DD0  2  29 3F                and #%00111111
008DD2  2  C9 37                cmp #$37               ;check for value below $37
008DD4  2  90 04                bcc BuzzyBeetleMutate
008DD6  2  C9 3F                cmp #$3f               ;if $37 or greater, check for value
008DD8  2  90 31                bcc DoGroup            ;below $3f, branch if below $3f
008DDA  2               
008DDA  2               BuzzyBeetleMutate:
008DDA  2  C9 06                cmp #Goomba          ;if below $37, check for goomba
008DDC  2  D0 07                bne StrID            ;value ($3f or more always fails)
008DDE  2  AC 6A 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
008DE1  2  F0 02                beq StrID            ;and if so, change goomba to buzzy beetle
008DE3  2  A9 02                lda #BuzzyBeetle
008DE5  2  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
008DE7  2  A9 01                lda #$01
008DE9  2  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
008DEB  2  20 03 8E             jsr InitEnemyObject
008DEE  2  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
008DF0  2  D0 50                bne Inc2B            ;if not, leave, otherwise branch
008DF2  2  60                   rts
008DF3  2               
008DF3  2               CheckFrenzyBuffer:
008DF3  2  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
008DF6  2  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
008DF8  2  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
008DFB  2  C9 01                cmp #$01
008DFD  2  D0 0B                bne ExEPar               ;if other value <> 1, leave
008DFF  2  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
008E01  2  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
008E03  2               
008E03  2               InitEnemyObject:
008E03  2  A9 00                lda #$00                 ;initialize enemy state
008E05  2  95 1E                sta Enemy_State,x
008E07  2  20 50 8E             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
008E0A  2  60           ExEPar: rts                      ;then leave
008E0B  2               
008E0B  2               DoGroup:
008E0B  2  4C 2C 93             jmp HandleGroupEnemies   ;handle enemy group objects
008E0E  2               
008E0E  2               ParseRow0e:
008E0E  2  C8                   iny                      ;increment Y to load third byte of object
008E0F  2  C8                   iny
008E10  2  AD 5F 07             lda WorldNumber
008E13  2  C9 08                cmp #World9              ;skip world number check if on world 9
008E15  2  F0 0C                beq W9Skip
008E17  2  B1 E9                lda (EnemyData),y
008E19  2  4A                   lsr                      ;move 3 MSB to the bottom, effectively
008E1A  2  4A                   lsr                      ;making %xxx00000 into %00000xxx
008E1B  2  4A                   lsr
008E1C  2  4A                   lsr
008E1D  2  4A                   lsr
008E1E  2  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
008E21  2  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
008E23  2  88           W9Skip: dey                      ;of the same area, like the underground bonus areas)
008E24  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
008E26  2  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
008E29  2  C8                   iny
008E2A  2  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
008E2C  2  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
008E2E  2  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
008E31  2  4C 3F 8E     NotUse: jmp Inc3B
008E34  2               
008E34  2               CheckThreeBytes:
008E34  2  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
008E37  2  B1 E9                lda (EnemyData),y        ;get first byte
008E39  2  29 0F                and #%00001111           ;check for special row $0e
008E3B  2  C9 0E                cmp #$0e
008E3D  2  D0 03                bne Inc2B
008E3F  2  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
008E42  2  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
008E45  2  EE 39 07             inc EnemyDataOffset
008E48  2  A9 00                lda #$00                 ;init page select for enemy objects
008E4A  2  8D 3B 07             sta EnemyObjectPageSel
008E4D  2  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
008E4F  2  60                   rts                      ;and leave
008E50  2               
008E50  2               CheckpointEnemyID:
008E50  2  B5 16                lda Enemy_ID,x
008E52  2  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
008E54  2  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
008E56  2  A8                   tay                          ;save identifier in Y register for now
008E57  2  B5 CF                lda Enemy_Y_Position,x
008E59  2  69 08                adc #$08                     ;add eight pixels to what will eventually be the
008E5B  2  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
008E5D  2  A9 01                lda #$01
008E5F  2  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
008E62  2  98                   tya                          ;get identifier back and use as offset for jump engine
008E63  2               
008E63  2               InitEnemyRoutines:
008E63  2  20 7D 6C             jsr JumpEngine
008E66  2               
008E66  2  F2 8E                .word InitNormalEnemy
008E68  2  F2 8E                .word InitNormalEnemy
008E6A  2  F2 8E                .word InitNormalEnemy
008E6C  2  02 8F                .word InitRedKoopa
008E6E  2  98 93                .word InitPiranhaPlant
008E70  2  0C 8F                .word InitHammerBro
008E72  2  D5 8E                .word InitGoomba
008E74  2  2D 8F                .word InitBloober
008E76  2  56 8F                .word InitBulletBill
008E78  2  D4 8E                .word NoInitCode
008E7A  2  60 8F                .word InitCheepCheep
008E7C  2  60 8F                .word InitCheepCheep
008E7E  2  DB 8E                .word InitPodoboo
008E80  2  98 93                .word InitPiranhaPlant
008E82  2  06 94                .word InitJumpGPTroopa
008E84  2  35 8F                .word InitRedPTroopa
008E86  2               
008E86  2  28 8F                .word InitHorizFlySwimEnemy
008E88  2  70 8F                .word InitLakitu
008E8A  2  D5 93                .word InitEnemyFrenzy
008E8C  2  D4 8E                .word NoInitCode
008E8E  2  D5 93                .word InitEnemyFrenzy
008E90  2  D5 93                .word InitEnemyFrenzy
008E92  2  D5 93                .word InitEnemyFrenzy
008E94  2  D5 93                .word InitEnemyFrenzy
008E96  2  ED 93                .word EndFrenzy
008E98  2  D4 8E                .word NoInitCode
008E9A  2  D4 8E                .word NoInitCode
008E9C  2  55 90                .word InitShortFirebar
008E9E  2  55 90                .word InitShortFirebar
008EA0  2  55 90                .word InitShortFirebar
008EA2  2  55 90                .word InitShortFirebar
008EA4  2  52 90                .word InitLongFirebar
008EA6  2               
008EA6  2  D4 8E                .word NoInitCode
008EA8  2  D4 8E                .word NoInitCode
008EAA  2  D4 8E                .word NoInitCode
008EAC  2  D4 8E                .word NoInitCode
008EAE  2  14 94                .word InitBalPlatform
008EB0  2  47 94                .word InitVertPlatform
008EB2  2  74 94                .word LargeLiftUp
008EB4  2  7A 94                .word LargeLiftDown
008EB6  2  40 94                .word InitHoriPlatform
008EB8  2  38 94                .word InitDropPlatform
008EBA  2  40 94                .word InitHoriPlatform
008EBC  2  80 94                .word PlatLiftUp
008EBE  2  8C 94                .word PlatLiftDown
008EC0  2  42 91                .word InitBowser
008EC2  2  19 88                .word PwrUpJmp
008EC4  2  AA 84                .word Setup_Vine
008EC6  2               
008EC6  2  D4 8E                .word NoInitCode
008EC8  2  D4 8E                .word NoInitCode
008ECA  2  D4 8E                .word NoInitCode
008ECC  2  D4 8E                .word NoInitCode
008ECE  2  D4 8E                .word NoInitCode
008ED0  2  EB 8E                .word InitRetainerObj
008ED2  2  B6 94                .word EndOfEnemyInitCode
008ED4  2               
008ED4  2               NoInitCode:
008ED4  2  60                   rts
008ED5  2               
008ED5  2               InitGoomba:
008ED5  2  20 F2 8E           jsr InitNormalEnemy  ;set appropriate horizontal speed
008ED8  2  4C 31 8F           jmp SmallBBox        ;set $09 as bounding box control, set other values
008EDB  2               
008EDB  2               InitPodoboo:
008EDB  2  A9 02              lda #$02                  ;set enemy position to below
008EDD  2  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
008EDF  2  95 CF              sta Enemy_Y_Position,x
008EE1  2  4A                 lsr
008EE2  2  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
008EE5  2  4A                 lsr
008EE6  2  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
008EE8  2  4C 31 8F           jmp SmallBBox             ;$09 as bounding box size and set other things
008EEB  2               
008EEB  2               InitRetainerObj:
008EEB  2  A9 B8              lda #$b8                ;set fixed vertical position for
008EED  2  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
008EEF  2  60                 rts
008EF0  2               
008EF0  2               NormalXSpdData:
008EF0  2  F8 F4              .byte $f8, $f4
008EF2  2               
008EF2  2               InitNormalEnemy:
008EF2  2  A0 01                 ldy #$01              ;load offset of 1 by default
008EF4  2  AD 6A 07              lda PrimaryHardMode   ;check for primary hard mode flag set
008EF7  2  D0 01                 bne GetESpd
008EF9  2  88                    dey                   ;if not set, decrement offset
008EFA  2  B9 F0 8E     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
008EFD  2  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
008EFF  2  4C 45 8F              jmp TallBBox          ;branch to set bounding box control and other data
008F02  2               
008F02  2               InitRedKoopa:
008F02  2  20 F2 8E           jsr InitNormalEnemy   ;load appropriate horizontal speed
008F05  2  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
008F07  2  95 1E              sta Enemy_State,x
008F09  2  60                 rts
008F0A  2               
008F0A  2               HBroWalkingTimerData:
008F0A  2  80 50              .byte $80, $50
008F0C  2               
008F0C  2               InitHammerBro:
008F0C  2  A9 00               lda #$00                    ;init horizontal speed and timer used by hammer bro
008F0E  2  9D A2 03            sta HammerThrowingTimer,x   ;apparently to time hammer throwing
008F11  2  95 58               sta Enemy_X_Speed,x
008F13  2  AD 5F 07            lda WorldNumber             ;if on worlds 7-9, branch to skip the walk delay
008F16  2  C9 06               cmp #World7
008F18  2  B0 09               bcs NoHBI
008F1A  2  AC CC 06            ldy SecondaryHardMode       ;get secondary hard mode flag
008F1D  2  B9 0A 8F            lda HBroWalkingTimerData,y
008F20  2  9D 96 07            sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
008F23  2  A9 0B        NoHBI: lda #$0b                    ;set specific value for bounding box size control
008F25  2  4C 47 8F            jmp SetBBox
008F28  2               
008F28  2               ;--------------------------------
008F28  2               
008F28  2               InitHorizFlySwimEnemy:
008F28  2  A9 00              lda #$00        ;initialize horizontal speed
008F2A  2  4C FD 8E           jmp SetESpd
008F2D  2               
008F2D  2               ;--------------------------------
008F2D  2               
008F2D  2               InitBloober:
008F2D  2  A9 00                   lda #$00               ;initialize horizontal speed
008F2F  2  95 58                   sta BlooperMoveSpeed,x
008F31  2  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
008F33  2  D0 12                   bne SetBBox            ;unconditional branch
008F35  2               
008F35  2               InitRedPTroopa:
008F35  2  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
008F37  2  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
008F39  2  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
008F3C  2  10 02                  bpl GetCent                 ;if vertical coordinate < $80
008F3E  2  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
008F40  2  98           GetCent:  tya                         ;send central position adder to A
008F41  2  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
008F43  2  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
008F45  2  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
008F47  2  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
008F4A  2  A9 02                  lda #$02                    ;set moving direction for left
008F4C  2  95 46                  sta Enemy_MovingDir,x
008F4E  2  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
008F50  2  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
008F52  2  9D 34 04               sta Enemy_Y_MoveForce,x
008F55  2  60                     rts
008F56  2               
008F56  2               InitBulletBill:
008F56  2  A9 02              lda #$02                  ;set moving direction for left
008F58  2  95 46              sta Enemy_MovingDir,x
008F5A  2  A9 09              lda #$09                  ;set bounding box control for $09
008F5C  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
008F5F  2  60                 rts
008F60  2               
008F60  2               InitCheepCheep:
008F60  2  20 31 8F           jsr SmallBBox              ;set vertical bounding box, speed, init others
008F63  2  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
008F66  2  29 10              and #%00010000             ;get d4 from it
008F68  2  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
008F6A  2  B5 CF              lda Enemy_Y_Position,x
008F6C  2  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
008F6F  2  60                 rts
008F70  2               
008F70  2               InitLakitu:
008F70  2  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
008F73  2  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
008F75  2               
008F75  2               SetupLakitu:
008F75  2  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
008F77  2  8D D1 06           sta LakituReappearTimer
008F7A  2  20 28 8F           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
008F7D  2  4C 0E 94           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
008F80  2               
008F80  2               KillLakitu:
008F80  2  4C CD 95           jmp EraseEnemyObject
008F83  2               
008F83  2               ;--------------------------------
008F83  2               ;$01-$03 - used to hold pseudorandom difference adjusters
008F83  2               
008F83  2               PRDiffAdjustData:
008F83  2  26 2C 32 38        .byte $26, $2c, $32, $38
008F87  2  20 22 24 26        .byte $20, $22, $24, $26
008F8B  2  13 14 15 16        .byte $13, $14, $15, $16
008F8F  2               
008F8F  2               LakituAndSpinyHandler:
008F8F  2  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
008F92  2  D0 4A                  bne ExLSHand
008F94  2  E0 05                  cpx #$05                ;if we are on the special use slot, leave
008F96  2  B0 46                  bcs ExLSHand
008F98  2  A9 80                  lda #$80                ;set timer
008F9A  2  8D 8F 07               sta FrenzyEnemyTimer
008F9D  2  A0 04                  ldy #$04                ;start with the last enemy slot
008F9F  2  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
008FA2  2  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
008FA4  2  F0 39                  beq CreateSpiny         ;if so, branch out of this loop
008FA6  2  88                     dey                     ;otherwise check another slot
008FA7  2  10 F6                  bpl ChkLak              ;loop until all slots are checked
008FA9  2  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
008FAC  2  AD D1 06               lda LakituReappearTimer
008FAF  2  C9 03                  cmp #$03                ;check to see if we're up to a certain value yet
008FB1  2  90 2B                  bcc ExLSHand            ;if not, leave
008FB3  2  A2 04                  ldx #$04                ;start with the last enemy slot again
008FB5  2  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
008FB7  2  F0 05                  beq CreateL             ;branch out of loop if found
008FB9  2  CA                     dex                     ;otherwise check next slot
008FBA  2  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
008FBC  2  30 1E                  bmi RetEOfs             ;if no empty slots were found, branch to leave
008FBE  2  A9 00        CreateL:  lda #$00                ;initialize enemy state
008FC0  2  95 1E                  sta Enemy_State,x
008FC2  2  A9 11                  lda #Lakitu             ;create lakitu enemy object
008FC4  2  95 16                  sta Enemy_ID,x
008FC6  2  20 75 8F               jsr SetupLakitu         ;do a sub to set up lakitu
008FC9  2  A9 20                  lda #$20
008FCB  2  AC FB 07               ldy HardWorldFlag
008FCE  2  D0 07                  bne SetLowLY            ;if in worlds A-D, put lakitu lower on the screen
008FD0  2  AC 5F 07               ldy WorldNumber
008FD3  2  C0 06                  cpy #$06                ;if in worlds 1-6, branch to use default high position
008FD5  2  90 02                  bcc SetLakXY            ;otherwise put lakitu lower on the screen
008FD7  2  A9 60        SetLowLY: lda #$60
008FD9  2  20 E9 91     SetLakXY: jsr PutAtRightExtent    ;finish setting up lakitu
008FDC  2  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
008FDE  2  60           ExLSHand: rts
008FDF  2               
008FDF  2               CreateSpiny:
008FDF  2  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
008FE1  2  C9 2C                  cmp #$2c
008FE3  2  90 F9                  bcc ExLSHand
008FE5  2  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
008FE8  2  D0 F4                  bne ExLSHand
008FEA  2  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
008FED  2  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
008FEF  2  B9 87 00               lda Enemy_X_Position,y
008FF2  2  95 87                  sta Enemy_X_Position,x
008FF4  2  A9 01                  lda #$01                   ;put spiny within vertical screen unit
008FF6  2  95 B6                  sta Enemy_Y_HighPos,x
008FF8  2  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
008FFB  2  38                     sec
008FFC  2  E9 08                  sbc #$08
008FFE  2  95 CF                  sta Enemy_Y_Position,x
009000  2  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
009003  2  29 03                  and #%00000011
009005  2  A8                     tay
009006  2  A2 02                  ldx #$02
009008  2  B9 83 8F     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00900B  2  95 01                  sta $01,x                  ;to $01-$03
00900D  2  C8                     iny
00900E  2  C8                     iny                        ;increment Y four bytes for each value
00900F  2  C8                     iny
009010  2  C8                     iny
009011  2  CA                     dex                        ;decrement X for each one
009012  2  10 F4                  bpl DifLoop                ;loop until all three are written
009014  2  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
009016  2  20 A1 9B               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
009019  2  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00901B  2  C0 08                  cpy #$08
00901D  2  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
00901F  2  A8                     tay                        ;otherwise save value in A to Y for now
009020  2  BD A8 07               lda PseudoRandomBitReg+1,x
009023  2  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
009025  2  F0 05                  beq UsePosv                ;branch if neither bits are set
009027  2  98                     tya
009028  2  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00902A  2  A8                     tay
00902B  2  C8                     iny
00902C  2  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00902D  2  20 31 8F     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
009030  2  A0 02                  ldy #$02                   ;(putting this call elsewhere will preserve A)
009032  2  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
009034  2  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
009036  2  30 01                  bmi SpinyRte               ;the same reason
009038  2  88                     dey
009039  2  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00903B  2  A9 FD                  lda #$fd
00903D  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
00903F  2  A9 01                  lda #$01
009041  2  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
009043  2  A9 05                  lda #$05
009045  2  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
009047  2  60           ChpChpEx: rts
009048  2               
009048  2               ;--------------------------------
009048  2               
009048  2               FirebarSpinSpdData:
009048  2  28 38 28 38        .byte $28, $38, $28, $38, $28
00904C  2  28           
00904D  2               
00904D  2               FirebarSpinDirData:
00904D  2  00 00 10 10        .byte $00, $00, $10, $10, $00
009051  2  00           
009052  2               
009052  2               InitLongFirebar:
009052  2  20 86 91           jsr DuplicateEnemyObj       ;create enemy object for long firebar
009055  2               
009055  2               InitShortFirebar:
009055  2  A9 00              lda #$00                    ;initialize low byte of spin state
009057  2  95 58              sta FirebarSpinState_Low,x
009059  2  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00905B  2  38                 sec                         ;to get proper offset for firebar data
00905C  2  E9 1B              sbc #$1b
00905E  2  A8                 tay
00905F  2  B9 48 90           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
009062  2  9D 88 03           sta FirebarSpinSpeed,x
009065  2  B9 4D 90           lda FirebarSpinDirData,y    ;get spinning direction of firebar
009068  2  95 34              sta FirebarSpinDirection,x
00906A  2  B5 CF              lda Enemy_Y_Position,x
00906C  2  18                 clc                         ;add four pixels to vertical coordinate
00906D  2  69 04              adc #$04
00906F  2  95 CF              sta Enemy_Y_Position,x
009071  2  B5 87              lda Enemy_X_Position,x
009073  2  18                 clc                         ;add four pixels to horizontal coordinate
009074  2  69 04              adc #$04
009076  2  95 87              sta Enemy_X_Position,x
009078  2  B5 6E              lda Enemy_PageLoc,x
00907A  2  69 00              adc #$00                    ;add carry to page location
00907C  2  95 6E              sta Enemy_PageLoc,x
00907E  2  4C 0E 94           jmp TallBBox2               ;set bounding box control (not used) and leave
009081  2               
009081  2               ;--------------------------------
009081  2               ;$00-$01 - used to hold pseudorandom bits
009081  2               
009081  2               FlyCCXPositionData:
009081  2  80 30 40 80        .byte $80, $30, $40, $80
009085  2  30 50 50 70        .byte $30, $50, $50, $70
009089  2  20 40 80 A0        .byte $20, $40, $80, $a0
00908D  2  70 40 90 68        .byte $70, $40, $90, $68
009091  2               
009091  2               FlyCCXSpeedData:
009091  2  0E 05 06 0E        .byte $0e, $05, $06, $0e
009095  2  1C 20 10 0C        .byte $1c, $20, $10, $0c
009099  2  1E 22 18 14        .byte $1e, $22, $18, $14
00909D  2               
00909D  2               FlyCCTimerData:
00909D  2  10 60 20 48        .byte $10, $60, $20, $48
0090A1  2               
0090A1  2               InitFlyingCheepCheep:
0090A1  2  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
0090A4  2  D0 A1                 bne ChpChpEx
0090A6  2  20 31 8F              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
0090A9  2  BD A8 07              lda PseudoRandomBitReg+1,x
0090AC  2  29 03                 and #%00000011             ;set pseudorandom offset here
0090AE  2  A8                    tay
0090AF  2  B9 9D 90              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
0090B2  2  8D 8F 07              sta FrenzyEnemyTimer
0090B5  2  A0 03                 ldy #$03                   ;load Y with default value
0090B7  2  AD CC 06              lda SecondaryHardMode
0090BA  2  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
0090BC  2  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
0090BD  2  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
0090BF  2  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
0090C1  2  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
0090C3  2  BD A7 07              lda PseudoRandomBitReg,x
0090C6  2  29 03                 and #%00000011             ;get last two bits of LSFR, first part
0090C8  2  85 00                 sta $00                    ;and store in two places
0090CA  2  85 01                 sta $01
0090CC  2  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
0090CE  2  95 A0                 sta Enemy_Y_Speed,x
0090D0  2  A9 00                 lda #$00                   ;load default value
0090D2  2  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
0090D4  2  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
0090D6  2  A9 04                 lda #$04
0090D8  2  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
0090DA  2  90 01                 bcc GSeed                  ;do not change A
0090DC  2  0A                    asl                        ;otherwise, multiply A by 2
0090DD  2  48           GSeed:   pha                        ;save to stack
0090DE  2  18                    clc
0090DF  2  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
0090E1  2  85 00                 sta $00                    ;save it there
0090E3  2  BD A8 07              lda PseudoRandomBitReg+1,x
0090E6  2  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
0090E8  2  F0 07                 beq RSeed                  ;skip this part and save contents of $00
0090EA  2  BD A9 07              lda PseudoRandomBitReg+2,x
0090ED  2  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
0090EF  2  85 00                 sta $00                    ;third LSFR part
0090F1  2  68           RSeed:   pla                        ;get value from stack we saved earlier
0090F2  2  18                    clc
0090F3  2  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
0090F5  2  A8                    tay                        ;use as pseudorandom offset here
0090F6  2  B9 91 90              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
0090F9  2  95 58                 sta Enemy_X_Speed,x
0090FB  2  A9 01                 lda #$01                   ;set to move towards the right
0090FD  2  95 46                 sta Enemy_MovingDir,x
0090FF  2  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
009101  2  D0 12                 bne D2XPos1
009103  2  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
009105  2  98                    tya                        ;and check for d1 set
009106  2  29 02                 and #%00000010
009108  2  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00910A  2  B5 58                 lda Enemy_X_Speed,x
00910C  2  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
00910E  2  18                    clc                        ;into two's compliment, thus moving in the opposite
00910F  2  69 01                 adc #$01                   ;direction
009111  2  95 58                 sta Enemy_X_Speed,x
009113  2  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
009115  2  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
009116  2  29 02                 and #%00000010
009118  2  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00911A  2  A5 86                 lda Player_X_Position      ;get player's horizontal position
00911C  2  18                    clc
00911D  2  79 81 90              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
009120  2  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
009122  2  A5 6D                 lda Player_PageLoc         ;get player's page location
009124  2  69 00                 adc #$00                   ;add carry and jump past this part
009126  2  4C 35 91              jmp FinCCSt
009129  2  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00912B  2  38                    sec
00912C  2  F9 81 90              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
00912F  2  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
009131  2  A5 6D                 lda Player_PageLoc         ;get player's page location
009133  2  E9 00                 sbc #$00                   ;subtract borrow
009135  2  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
009137  2  A9 01                 lda #$01
009139  2  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00913B  2  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00913D  2  A9 F8                 lda #$f8
00913F  2  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
009141  2  60                    rts
009142  2               
009142  2               InitBowser:
009142  2  A0 04                  ldy #$04              ;if the slot about to be checked is the slot
009144  2  C4 08        KKCheck:  cpy ObjectOffset      ;where bowser is being initialized, skip it
009146  2  F0 0F                  beq NoBowser
009148  2  B9 16 00               lda Enemy_ID,y        ;otherwise check to see if a bowser object
00914B  2  C9 2D                  cmp #Bowser           ;exists in another slot
00914D  2  D0 08                  bne NoBowser          ;if not, branch to check another enemy slot
00914F  2  A9 00                  lda #$00
009151  2  99 16 00               sta Enemy_ID,y        ;do this until any previous bowser objects are erased
009154  2  99 0F 00               sta Enemy_Flag,y
009157  2  88           NoBowser: dey                   ;loop until all slots are checked
009158  2  10 EA                  bpl KKCheck           ;except the slot where bowser is being initialized
00915A  2               
00915A  2               CreateBowser:
00915A  2  20 86 91           jsr DuplicateEnemyObj     ;jump to create another bowser object
00915D  2  8E 68 03           stx BowserFront_Offset    ;save offset of first here
009160  2  A9 00              lda #$00
009162  2  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
009165  2  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
009168  2  B5 87              lda Enemy_X_Position,x
00916A  2  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00916D  2  A9 DF              lda #$df
00916F  2  8D 90 07           sta BowserFireBreathTimer ;store something here
009172  2  95 46              sta Enemy_MovingDir,x     ;and in moving direction
009174  2  A9 20              lda #$20
009176  2  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
009179  2  9D 8A 07           sta EnemyFrameTimer,x
00917C  2  A9 05              lda #$05
00917E  2  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
009181  2  4A                 lsr
009182  2  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
009185  2  60                 rts
009186  2               
009186  2               DuplicateEnemyObj:
009186  2  A0 FF                ldy #$ff                ;start at beginning of enemy slots
009188  2  C8           FSLoop: iny                     ;increment one slot
009189  2  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
00918C  2  D0 FA                bne FSLoop              ;if set, branch and keep checking
00918E  2  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
009191  2  8A                   txa                     ;transfer original enemy buffer offset
009192  2  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
009194  2  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
009197  2  B5 6E                lda Enemy_PageLoc,x
009199  2  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
00919C  2  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
00919E  2  99 87 00             sta Enemy_X_Position,y
0091A1  2  A9 01                lda #$01
0091A3  2  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
0091A5  2  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
0091A8  2  B5 CF                lda Enemy_Y_Position,x
0091AA  2  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
0091AD  2  60           FlmEx:  rts                     ;and then leave
0091AE  2               
0091AE  2               ;--------------------------------
0091AE  2               
0091AE  2               FlameYPosData:
0091AE  2  90 80 70 90        .byte $90, $80, $70, $90
0091B2  2               
0091B2  2               FlameYMFAdderData:
0091B2  2  FF 01              .byte $ff, $01
0091B4  2               
0091B4  2               InitBowserFlame:
0091B4  2  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
0091B7  2  D0 F4                bne FlmEx
0091B9  2  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
0091BC  2  A5 FD                lda NoiseSoundQueue
0091BE  2  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
0091C0  2  85 FD                sta NoiseSoundQueue
0091C2  2  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
0091C5  2  B9 16 00             lda Enemy_ID,y              ;check for bowser
0091C8  2  C9 2D                cmp #Bowser
0091CA  2  F0 31                beq SpawnFromMouth          ;branch if found
0091CC  2  20 0E 9E             jsr SetFlameTimer           ;get timer data based on flame counter
0091CF  2  18                   clc
0091D0  2  69 20                adc #$20                    ;add 32 frames by default
0091D2  2  AC CC 06             ldy SecondaryHardMode
0091D5  2  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
0091D7  2  38                   sec
0091D8  2  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
0091DA  2  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
0091DD  2  BD A7 07             lda PseudoRandomBitReg,x
0091E0  2  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
0091E2  2  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
0091E5  2  A8                   tay                         ;use as offset
0091E6  2  B9 AE 91             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
0091E9  2               
0091E9  2               PutAtRightExtent:
0091E9  2  95 CF              sta Enemy_Y_Position,x    ;set vertical position
0091EB  2  AD 1D 07           lda ScreenRight_X_Pos
0091EE  2  18                 clc
0091EF  2  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
0091F1  2  95 87              sta Enemy_X_Position,x
0091F3  2  AD 1B 07           lda ScreenRight_PageLoc
0091F6  2  69 00              adc #$00                  ;add carry
0091F8  2  95 6E              sta Enemy_PageLoc,x
0091FA  2  4C 30 92           jmp FinishFlame           ;skip this part to finish setting values
0091FD  2               
0091FD  2               SpawnFromMouth:
0091FD  2  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
009200  2  38                  sec
009201  2  E9 0E               sbc #$0e                  ;subtract 14 pixels
009203  2  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
009205  2  B9 6E 00            lda Enemy_PageLoc,y
009208  2  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00920A  2  B9 CF 00            lda Enemy_Y_Position,y
00920D  2  18                  clc                       ;add 8 pixels to bowser's vertical position
00920E  2  69 08               adc #$08
009210  2  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
009212  2  BD A7 07            lda PseudoRandomBitReg,x
009215  2  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
009217  2  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00921A  2  A8                  tay                       ;use as offset
00921B  2  B9 AE 91            lda FlameYPosData,y       ;get value here using bits as offset
00921E  2  A0 00               ldy #$00                  ;load default offset
009220  2  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
009222  2  90 01               bcc SetMF                 ;if less, do not increment offset
009224  2  C8                  iny                       ;otherwise increment now
009225  2  B9 B2 91     SetMF: lda FlameYMFAdderData,y   ;get value here and save
009228  2  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00922B  2  A9 00               lda #$00
00922D  2  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
009230  2               
009230  2               FinishFlame:
009230  2  A9 08              lda #$08                 ;set $08 for bounding box control
009232  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
009235  2  A9 01              lda #$01                 ;set high byte of vertical and
009237  2  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
009239  2  95 0F              sta Enemy_Flag,x
00923B  2  4A                 lsr
00923C  2  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
00923F  2  95 1E              sta Enemy_State,x        ;enemy state
009241  2  60                 rts
009242  2               
009242  2               ;--------------------------------
009242  2               
009242  2               FireworksXPosData:
009242  2  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
009246  2  00 20        
009248  2               
009248  2               FireworksYPosData:
009248  2  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00924C  2  60 30        
00924E  2               
00924E  2               InitFireworks:
00924E  2  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
009251  2  D0 47                  bne ExitFWk
009253  2  A9 20                  lda #$20                     ;otherwise reset timer
009255  2  8D 8F 07               sta FrenzyEnemyTimer
009258  2  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00925B  2  A0 06                  ldy #$06                     ;start at last slot
00925D  2  88           StarFChk: dey
00925E  2  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
009261  2  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
009263  2  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
009265  2  B9 87 00               lda Enemy_X_Position,y
009268  2  38                     sec                          ;get horizontal coordinate of star flag object, then
009269  2  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00926B  2  48                     pha                          ;the stack
00926C  2  B9 6E 00               lda Enemy_PageLoc,y
00926F  2  E9 00                  sbc #$00                     ;subtract the carry from the page location
009271  2  85 00                  sta $00                      ;of the star flag object
009273  2  AD D7 06               lda FireworksCounter         ;get fireworks counter
009276  2  18                     clc
009277  2  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00927A  2  A8                     tay                          ;use as offset
00927B  2  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00927C  2  18                     clc
00927D  2  79 42 92               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
009280  2  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
009282  2  A5 00                  lda $00
009284  2  69 00                  adc #$00                     ;add carry and store as page location for
009286  2  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
009288  2  B9 48 92               lda FireworksYPosData,y      ;get vertical position using same offset
00928B  2  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
00928D  2  A9 01                  lda #$01
00928F  2  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
009291  2  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
009293  2  4A                     lsr
009294  2  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
009296  2  A9 08                  lda #$08
009298  2  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
00929A  2  60           ExitFWk:  rts
00929B  2               
00929B  2               ;--------------------------------
00929B  2               
00929B  2               Bitmasks:
00929B  2  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
00929F  2  10 20 40 80  
0092A3  2               
0092A3  2               Enemy17YPosData:
0092A3  2  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
0092A7  2  20 60 A0 70  
0092AB  2               
0092AB  2               SwimCC_IDData:
0092AB  2  0A 0B              .byte $0a, $0b
0092AD  2               
0092AD  2               BulletBillCheepCheep:
0092AD  2  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
0092B0  2  D0 6F                 bne ExF17
0092B2  2  AD 4E 07              lda AreaType              ;are we in a water-type level?
0092B5  2  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
0092B7  2  E0 03                 cpx #$03                  ;are we past third enemy slot?
0092B9  2  B0 66                 bcs ExF17                 ;if so, branch to leave
0092BB  2  A0 00                 ldy #$00                  ;load default offset
0092BD  2  BD A7 07              lda PseudoRandomBitReg,x
0092C0  2  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
0092C2  2  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
0092C4  2  C8                    iny                       ;otherwise increment
0092C5  2  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
0092C8  2  C9 01                 cmp #World2
0092CA  2  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
0092CC  2  C8                    iny                       ;otherwise increment
0092CD  2  98           Get17ID: tya
0092CE  2  29 01                 and #%00000001            ;mask out all but last bit of offset
0092D0  2  A8                    tay
0092D1  2  B9 AB 92              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
0092D4  2  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
0092D6  2  AD DD 06              lda BitMFilter
0092D9  2  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
0092DB  2  D0 05                 bne GetRBit
0092DD  2  A9 00                 lda #$00                  ;initialize vertical position filter
0092DF  2  8D DD 06              sta BitMFilter
0092E2  2  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
0092E5  2  29 07                 and #%00000111            ;mask out all but 3 LSB
0092E7  2  A8           ChkRBit: tay                       ;use as offset
0092E8  2  B9 9B 92              lda Bitmasks,y            ;load bitmask
0092EB  2  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
0092EE  2  F0 07                 beq AddFBit
0092F0  2  C8                    iny                       ;increment offset
0092F1  2  98                    tya
0092F2  2  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
0092F4  2  4C E7 92              jmp ChkRBit               ;do another check
0092F7  2  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
0092FA  2  8D DD 06              sta BitMFilter            ;and store
0092FD  2  B9 A3 92              lda Enemy17YPosData,y     ;load vertical position using offset
009300  2  20 E9 91              jsr PutAtRightExtent      ;set vertical position and other values
009303  2  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
009306  2  A9 20                 lda #$20                  ;set timer
009308  2  8D 8F 07              sta FrenzyEnemyTimer
00930B  2  4C 50 8E              jmp CheckpointEnemyID     ;process our new enemy object
00930E  2               
00930E  2               DoBulletBills:
00930E  2  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
009310  2  C8           BB_SLoop: iny                        ;move onto the next slot
009311  2  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
009313  2  B0 0D                  bcs FireBulletBill
009315  2  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
009318  2  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00931A  2  B9 16 00               lda Enemy_ID,y
00931D  2  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
00931F  2  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
009321  2  60           ExF17:    rts                        ;if found, leave
009322  2               
009322  2               FireBulletBill:
009322  2  A5 FE              lda Square2SoundQueue
009324  2  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
009326  2  85 FE              sta Square2SoundQueue
009328  2  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00932A  2  D0 A8              bne Set17ID               ;unconditional branch
00932C  2               
00932C  2               ;--------------------------------
00932C  2               ;$00 - used to store Y position of group enemies
00932C  2               ;$01 - used to store enemy ID
00932C  2               ;$02 - used to store page location of right side of screen
00932C  2               ;$03 - used to store X position of right side of screen
00932C  2               
00932C  2               HandleGroupEnemies:
00932C  2  A0 00                ldy #$00                  ;load value for green koopa troopa
00932E  2  38                   sec
00932F  2  E9 37                sbc #$37                  ;subtract $37 from second byte read
009331  2  48                   pha                       ;save result in stack for now
009332  2  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
009334  2  B0 0B                bcs SnglID                ;if so, branch
009336  2  48                   pha                       ;save another copy to stack
009337  2  A0 06                ldy #Goomba               ;load value for goomba enemy
009339  2  AD 6A 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00933C  2  F0 02                beq PullID                ;branch, otherwise change to value
00933E  2  A0 02                ldy #BuzzyBeetle          ;for buzzy beetle
009340  2  68           PullID: pla                       ;get second copy from stack
009341  2  84 01        SnglID: sty $01                   ;save enemy id here
009343  2  A0 B0                ldy #$b0                  ;load default y coordinate
009345  2  29 02                and #$02                  ;check to see if d1 was set
009347  2  F0 02                beq SetYGp                ;if so, move y coordinate up,
009349  2  A0 70                ldy #$70                  ;otherwise branch and use default
00934B  2  84 00        SetYGp: sty $00                   ;save y coordinate here
00934D  2  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
009350  2  85 02                sta $02                   ;save here
009352  2  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
009355  2  85 03                sta $03                   ;save here
009357  2  A0 02                ldy #$02                  ;load two enemies by default
009359  2  68                   pla                       ;get first copy from stack
00935A  2  4A                   lsr                       ;check to see if d0 was set
00935B  2  90 01                bcc CntGrp                ;if not, use default value
00935D  2  C8                   iny                       ;otherwise increment to three enemies
00935E  2  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
009361  2  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
009363  2  E8           GSltLp: inx                       ;increment and branch if past
009364  2  E0 05                cpx #$05                  ;end of buffers
009366  2  B0 2D                bcs NextED
009368  2  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
00936A  2  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
00936C  2  A5 01                lda $01
00936E  2  95 16                sta Enemy_ID,x            ;store enemy object identifier
009370  2  A5 02                lda $02
009372  2  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
009374  2  A5 03                lda $03
009376  2  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
009378  2  18                   clc
009379  2  69 18                adc #$18                  ;add 24 pixels for next enemy
00937B  2  85 03                sta $03
00937D  2  A5 02                lda $02                   ;add carry to page location for
00937F  2  69 00                adc #$00                  ;next enemy
009381  2  85 02                sta $02
009383  2  A5 00                lda $00                   ;store y coordinate for enemy object
009385  2  95 CF                sta Enemy_Y_Position,x
009387  2  A9 01                lda #$01                  ;activate flag for buffer, and
009389  2  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
00938B  2  95 0F                sta Enemy_Flag,x
00938D  2  20 50 8E             jsr CheckpointEnemyID     ;process each enemy object separately
009390  2  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
009393  2  D0 CC                bne GrLoop
009395  2  4C 42 8E     NextED: jmp Inc2B                 ;jump to increment data offset and leave
009398  2               
009398  2               ;--------------------------------
009398  2               ;$00 - used to store piranha plant attribute data
009398  2               ;$01 - used to store piranha plant range data for player
009398  2               
009398  2               InitPiranhaPlant:
009398  2  A9 22                 lda #$22                     ;set default attribute and range data here
00939A  2  85 00                 sta $00                      ;range data is used to detect how close player is
00939C  2  A9 13                 lda #$13                     ;to the piranha plant to keep it inside the pipe
00939E  2  85 01                 sta $01                      ;default data makes red piranha plants
0093A0  2  AD FB 07              lda HardWorldFlag
0093A3  2  D0 0D                 bne PatchPP                  ;use default data if in worlds A-D
0093A5  2  AD 5F 07              lda WorldNumber
0093A8  2  C9 03                 cmp #$03
0093AA  2  B0 06                 bcs PatchPP                  ;use default data if in worlds 4-8
0093AC  2  C6 00                 dec $00
0093AE  2  A9 21                 lda #$21                     ;otherwise make green piranha plant instead
0093B0  2  85 01                 sta $01
0093B2  2  A5 00        PatchPP: lda $00
0093B4  2  8D 17 B5              sta EnemyAttributeData+PiranhaPlant  ;patch over attribute and range data
0093B7  2  A5 01                 lda $01
0093B9  2  8D FE 9F              sta ChkPlayerNearPipe+3
0093BC  2  A9 01                 lda #$01                     ;set initial speed
0093BE  2  95 58                 sta PiranhaPlant_Y_Speed,x
0093C0  2  4A                    lsr
0093C1  2  95 1E                 sta Enemy_State,x            ;initialize enemy state and what would normally
0093C3  2  95 A0                 sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
0093C5  2  B5 CF                 lda Enemy_Y_Position,x
0093C7  2  9D 34 04              sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
0093CA  2  38                    sec
0093CB  2  E9 18                 sbc #$18
0093CD  2  9D 17 04              sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
0093D0  2  A9 09                 lda #$09
0093D2  2  4C 10 94              jmp SetBBox2                 ;set specific value for bounding box control
0093D5  2               
0093D5  2               ;--------------------------------
0093D5  2               
0093D5  2               InitEnemyFrenzy:
0093D5  2  B5 16              lda Enemy_ID,x        ;load enemy identifier
0093D7  2  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
0093DA  2  38                 sec
0093DB  2  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
0093DD  2  20 7D 6C           jsr JumpEngine
0093E0  2               
0093E0  2               ;frenzy object jump table
0093E0  2  8F 8F              .word LakituAndSpinyHandler
0093E2  2  EC 93              .word NoFrenzyCode
0093E4  2  A1 90              .word InitFlyingCheepCheep
0093E6  2  B4 91              .word InitBowserFlame
0093E8  2  4E 92              .word InitFireworks
0093EA  2  AD 92              .word BulletBillCheepCheep
0093EC  2               
0093EC  2               NoFrenzyCode:
0093EC  2  60                 rts
0093ED  2               
0093ED  2               EndFrenzy:
0093ED  2  A0 05                   ldy #$05               ;start at last slot
0093EF  2  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
0093F2  2  C9 11                   cmp #Lakitu            ;for lakitu
0093F4  2  D0 05                   bne NextFSlot
0093F6  2  A9 01                   lda #$01               ;if found, set state
0093F8  2  99 1E 00                sta Enemy_State,y
0093FB  2  88           NextFSlot: dey                    ;move onto the next slot
0093FC  2  10 F1                   bpl LakituChk          ;do this until all slots are checked
0093FE  2  A9 00                   lda #$00
009400  2  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
009403  2  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
009405  2  60                      rts
009406  2               
009406  2               ;--------------------------------
009406  2               
009406  2               InitJumpGPTroopa:
009406  2  A9 02                   lda #$02                  ;set for movement to the left
009408  2  95 46                   sta Enemy_MovingDir,x
00940A  2  A9 F4                   lda #$f4                  ;set horizontal speed
00940C  2  95 58                   sta Enemy_X_Speed,x
00940E  2  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
009410  2  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
009413  2  60                      rts
009414  2               
009414  2               ;--------------------------------
009414  2               
009414  2               InitBalPlatform:
009414  2  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
009416  2  D6 CF                dec Enemy_Y_Position,x
009418  2  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00941B  2  D0 05                bne AlignP                ;branch ahead
00941D  2  A0 02                ldy #$02                  ;otherwise set value here
00941F  2  20 A6 94             jsr PosPlatform           ;do a sub to add or subtract pixels
009422  2  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
009424  2  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
009427  2  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
009429  2  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00942B  2  8A                   txa                       ;if old contents already $ff, put
00942C  2  A8                   tay                       ;object offset as alignment to make next positive
00942D  2  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
009430  2  A9 00                lda #$00
009432  2  95 46                sta Enemy_MovingDir,x     ;init moving direction
009434  2  A8                   tay                       ;init Y
009435  2  20 A6 94             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
009438  2               
009438  2               ;--------------------------------
009438  2               
009438  2               InitDropPlatform:
009438  2  A9 FF              lda #$ff
00943A  2  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00943D  2  4C 5D 94           jmp CommonPlatCode           ;then jump ahead to execute more code
009440  2               
009440  2               ;--------------------------------
009440  2               
009440  2               InitHoriPlatform:
009440  2  A9 00              lda #$00
009442  2  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
009444  2  4C 5D 94           jmp CommonPlatCode           ;jump ahead to execute more code
009447  2               
009447  2               ;--------------------------------
009447  2               
009447  2               InitVertPlatform:
009447  2  A0 40               ldy #$40                    ;set default value here
009449  2  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00944B  2  10 07               bpl SetYO                   ;if above a certain point, skip this part
00944D  2  49 FF               eor #$ff
00944F  2  18                  clc                         ;otherwise get two's compliment
009450  2  69 01               adc #$01
009452  2  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
009454  2  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
009457  2  98                  tya
009458  2  18                  clc                         ;load value from earlier, add number of pixels
009459  2  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00945B  2  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00945D  2               
00945D  2               ;--------------------------------
00945D  2               
00945D  2               CommonPlatCode:
00945D  2  20 4E 8F             jsr InitVStf              ;do a sub to init certain other values
009460  2  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
009462  2  AC 4E 07             ldy AreaType
009465  2  C0 03                cpy #$03                  ;check for castle-type level
009467  2  F0 07                beq CasPBB                ;use default value if found
009469  2  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00946C  2  D0 02                bne CasPBB                ;if set, use default value
00946E  2  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
009470  2  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
009473  2  60                   rts
009474  2               
009474  2               ;--------------------------------
009474  2               
009474  2               LargeLiftUp:
009474  2  20 80 94           jsr PlatLiftUp       ;execute code for platforms going up
009477  2  4C 7D 94           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00947A  2               
00947A  2               LargeLiftDown:
00947A  2  20 8C 94           jsr PlatLiftDown     ;execute code for platforms going down
00947D  2               
00947D  2               LargeLiftBBox:
00947D  2  4C 60 94           jmp SPBBox           ;jump to overwrite bounding box size control
009480  2               
009480  2               ;--------------------------------
009480  2               
009480  2               PlatLiftUp:
009480  2  A9 10              lda #$10                 ;set movement amount here
009482  2  9D 34 04           sta Enemy_Y_MoveForce,x
009485  2  A9 FF              lda #$ff                 ;set moving speed for platforms going up
009487  2  95 A0              sta Enemy_Y_Speed,x
009489  2  4C 95 94           jmp CommonSmallLift      ;skip ahead to part we should be executing
00948C  2               
00948C  2               ;--------------------------------
00948C  2               
00948C  2               PlatLiftDown:
00948C  2  A9 F0              lda #$f0                 ;set movement amount here
00948E  2  9D 34 04           sta Enemy_Y_MoveForce,x
009491  2  A9 00              lda #$00                 ;set moving speed for platforms going down
009493  2  95 A0              sta Enemy_Y_Speed,x
009495  2               
009495  2               ;--------------------------------
009495  2               
009495  2               CommonSmallLift:
009495  2  A0 01              ldy #$01
009497  2  20 A6 94           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00949A  2  A9 04              lda #$04
00949C  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
00949F  2  60                 rts
0094A0  2               
0094A0  2               ;--------------------------------
0094A0  2               
0094A0  2               PlatPosDataLow:
0094A0  2  08 0C F8           .byte $08,$0c,$f8
0094A3  2               
0094A3  2               PlatPosDataHigh:
0094A3  2  00 00 FF           .byte $00,$00,$ff
0094A6  2               
0094A6  2               PosPlatform:
0094A6  2  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
0094A8  2  18                 clc
0094A9  2  79 A0 94           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
0094AC  2  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
0094AE  2  B5 6E              lda Enemy_PageLoc,x
0094B0  2  79 A3 94           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
0094B3  2  95 6E              sta Enemy_PageLoc,x     ;store as new page location
0094B5  2  60                 rts                     ;and go back
0094B6  2               
0094B6  2               ;--------------------------------
0094B6  2               
0094B6  2               EndOfEnemyInitCode:
0094B6  2  60                 rts
0094B7  2               
0094B7  2               ;-------------------------------------------------------------------------------------
0094B7  2               
0094B7  2               RunEnemyObjectsCore:
0094B7  2  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
0094B9  2  A9 00               lda #$00          ;load value 0 for jump engine by default
0094BB  2  B4 16               ldy Enemy_ID,x
0094BD  2  C0 15               cpy #$15          ;if enemy object < $15, use default value
0094BF  2  90 03               bcc JmpEO
0094C1  2  98                  tya               ;otherwise subtract $14 from the value and use
0094C2  2  E9 14               sbc #$14          ;as value for jump engine
0094C4  2  20 7D 6C     JmpEO: jsr JumpEngine
0094C7  2               
0094C7  2  15 95              .word RunNormalEnemies  ;for objects $00-$14
0094C9  2               
0094C9  2  6A 95              .word RunBowserFlame    ;for objects $15-$1f
0094CB  2  CA 9E              .word RunFireworks
0094CD  2  0B 95              .word NoRunCode
0094CF  2  0B 95              .word NoRunCode
0094D1  2  0B 95              .word NoRunCode
0094D3  2  0B 95              .word NoRunCode
0094D5  2  7C 95              .word RunFirebarObj
0094D7  2  7C 95              .word RunFirebarObj
0094D9  2  7C 95              .word RunFirebarObj
0094DB  2  7C 95              .word RunFirebarObj
0094DD  2  7C 95              .word RunFirebarObj
0094DF  2               
0094DF  2  7C 95              .word RunFirebarObj     ;for objects $20-$2f
0094E1  2  7C 95              .word RunFirebarObj
0094E3  2  7C 95              .word RunFirebarObj
0094E5  2  0B 95              .word NoRunCode
0094E7  2  9A 95              .word RunLargePlatform
0094E9  2  9A 95              .word RunLargePlatform
0094EB  2  9A 95              .word RunLargePlatform
0094ED  2  9A 95              .word RunLargePlatform
0094EF  2  9A 95              .word RunLargePlatform
0094F1  2  9A 95              .word RunLargePlatform
0094F3  2  9A 95              .word RunLargePlatform
0094F5  2  82 95              .word RunSmallPlatform
0094F7  2  82 95              .word RunSmallPlatform
0094F9  2  9A 9C              .word RunBowser
0094FB  2  3E 88              .word PowerUpObjHandler
0094FD  2  D7 84              .word VineObjectHandler
0094FF  2               
0094FF  2  0B 95              .word NoRunCode         ;for objects $30-$35
009501  2  0E 9F              .word RunStarFlagObj
009503  2  31 84              .word JumpspringHandler
009505  2  0B 95              .word NoRunCode
009507  2  10 83              .word WarpZoneObject
009509  2  0C 95              .word RunRetainerObj
00950B  2               
00950B  2               ;--------------------------------
00950B  2               
00950B  2               NoRunCode:
00950B  2  60                 rts
00950C  2               
00950C  2               ;--------------------------------
00950C  2               
00950C  2               RunRetainerObj:
00950C  2  20 94 BE           jsr GetEnemyOffscreenBits
00950F  2  20 37 BE           jsr RelativeEnemyPosition
009512  2  4C 2C B5           jmp EnemyGfxHandler
009515  2               
009515  2               ;--------------------------------
009515  2               
009515  2               RunNormalEnemies:
009515  2  A9 00                  lda #$00                  ;init sprite attributes
009517  2  9D C5 03               sta Enemy_SprAttrib,x
00951A  2  20 94 BE               jsr GetEnemyOffscreenBits
00951D  2  20 37 BE               jsr RelativeEnemyPosition
009520  2  20 2C B5               jsr EnemyGfxHandler
009523  2  20 E1 AE               jsr GetEnemyBoundBox
009526  2  20 4A AC               jsr EnemyToBGCollisionDet
009529  2  20 9C A6               jsr EnemiesCollision
00952C  2  20 AB A4               jsr PlayerEnemyCollision
00952F  2  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
009532  2  D0 03                  bne SkipMove
009534  2  20 3A 95               jsr EnemyMovementSubs
009537  2  4C B4 A2     SkipMove: jmp OffscreenBoundsCheck
00953A  2               
00953A  2               EnemyMovementSubs:
00953A  2  B5 16              lda Enemy_ID,x
00953C  2  20 7D 6C           jsr JumpEngine
00953F  2               
00953F  2  AC 96              .word MoveNormalEnemy      ;only objects $00-$14 use this table
009541  2  AC 96              .word MoveNormalEnemy
009543  2  AC 96              .word MoveNormalEnemy
009545  2  AC 96              .word MoveNormalEnemy
009547  2  rr rr              .word MoveUpsideDownPiranhaP
009549  2  0D 96              .word ProcHammerBro
00954B  2  AC 96              .word MoveNormalEnemy
00954D  2  BE 97              .word MoveBloober
00954F  2  6B 98              .word MoveBulletBill
009551  2  69 95              .word NoMoveCode
009553  2  7F 98              .word MoveSwimmingCheepCheep
009555  2  7F 98              .word MoveSwimmingCheepCheep
009557  2  E5 95              .word MovePodoboo
009559  2  DC 9F              .word MovePiranhaPlant
00955B  2  2E 97              .word MoveJumpingEnemy
00955D  2  34 97              .word ProcMoveRedPTroopa
00955F  2  5A 97              .word MoveFlyGreenPTroopa
009561  2  5D 9B              .word MoveLakitu
009563  2  AC 96              .word MoveNormalEnemy
009565  2  69 95              .word NoMoveCode            ;dummy
009567  2  14 9B              .word MoveFlyingCheepCheep
009569  2               
009569  2               ;--------------------------------
009569  2               
009569  2               NoMoveCode:
009569  2  60                 rts
00956A  2               
00956A  2               ;--------------------------------
00956A  2               
00956A  2               RunBowserFlame:
00956A  2  20 20 9E           jsr ProcBowserFlame
00956D  2  20 94 BE           jsr GetEnemyOffscreenBits
009570  2  20 37 BE           jsr RelativeEnemyPosition
009573  2  20 E1 AE           jsr GetEnemyBoundBox
009576  2  20 AB A4           jsr PlayerEnemyCollision
009579  2  4C B4 A2           jmp OffscreenBoundsCheck
00957C  2               
00957C  2               ;--------------------------------
00957C  2               
00957C  2               RunFirebarObj:
00957C  2  20 71 99           jsr ProcFirebar
00957F  2  4C B4 A2           jmp OffscreenBoundsCheck
009582  2               
009582  2               ;--------------------------------
009582  2               
009582  2               RunSmallPlatform:
009582  2  20 94 BE           jsr GetEnemyOffscreenBits
009585  2  20 37 BE           jsr RelativeEnemyPosition
009588  2  20 EA AE           jsr SmallPlatformBoundBox
00958B  2  20 F0 A7           jsr SmallPlatformCollision
00958E  2  20 37 BE           jsr RelativeEnemyPosition
009591  2  20 41 BA           jsr DrawSmallPlatform
009594  2  20 8F A2           jsr MoveSmallPlatform
009597  2  4C B4 A2           jmp OffscreenBoundsCheck
00959A  2               
00959A  2               ;--------------------------------
00959A  2               
00959A  2               RunLargePlatform:
00959A  2  20 94 BE             jsr GetEnemyOffscreenBits
00959D  2  20 37 BE             jsr RelativeEnemyPosition
0095A0  2  20 11 AF             jsr LargePlatformBoundBox
0095A3  2  20 BA A7             jsr LargePlatformCollision
0095A6  2  AD 47 07             lda TimerControl             ;if master timer control set,
0095A9  2  D0 03                bne SkipPT                   ;skip subroutine tree
0095AB  2  20 B7 95             jsr LargePlatformSubroutines
0095AE  2  20 37 BE     SkipPT: jsr RelativeEnemyPosition
0095B1  2  20 6E B2             jsr DrawLargePlatform
0095B4  2  4C B4 A2             jmp OffscreenBoundsCheck
0095B7  2               
0095B7  2               ;--------------------------------
0095B7  2               
0095B7  2               LargePlatformSubroutines:
0095B7  2  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
0095B9  2  38                 sec
0095BA  2  E9 24              sbc #$24
0095BC  2  20 7D 6C           jsr JumpEngine
0095BF  2               
0095BF  2  65 A0              .word BalancePlatform   ;table used by objects $24-$2a
0095C1  2  0D A2              .word YMovingPlatform
0095C3  2  89 A2              .word MoveLargeLiftPlat
0095C5  2  89 A2              .word MoveLargeLiftPlat
0095C7  2  41 A2              .word XMovingPlatform
0095C9  2  6B A2              .word DropPlatform
0095CB  2  77 A2              .word RightPlatform
0095CD  2               
0095CD  2               ;-------------------------------------------------------------------------------------
0095CD  2               
0095CD  2               EraseEnemyObject:
0095CD  2  A9 00              lda #$00                 ;clear all enemy object variables
0095CF  2  95 0F              sta Enemy_Flag,x
0095D1  2  95 16              sta Enemy_ID,x
0095D3  2  95 1E              sta Enemy_State,x
0095D5  2  9D 10 01           sta FloateyNum_Control,x
0095D8  2  9D 96 07           sta EnemyIntervalTimer,x
0095DB  2  9D 25 01           sta ShellChainCounter,x
0095DE  2  9D C5 03           sta Enemy_SprAttrib,x
0095E1  2  9D 8A 07           sta EnemyFrameTimer,x
0095E4  2  60                 rts
0095E5  2               
0095E5  2               ;-------------------------------------------------------------------------------------
0095E5  2               
0095E5  2               MovePodoboo:
0095E5  2  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
0095E8  2  D0 16              bne PdbM                   ;branch to move enemy if not expired
0095EA  2  20 DB 8E           jsr InitPodoboo            ;otherwise set up podoboo again
0095ED  2  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
0095F0  2  09 80              ora #%10000000             ;set d7
0095F2  2  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
0095F5  2  29 0F              and #%00001111             ;mask out high nybble
0095F7  2  09 06              ora #$06                   ;set for at least six intervals
0095F9  2  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
0095FC  2  A9 F9              lda #$f9
0095FE  2  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
009600  2  4C 63 8B     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
009603  2               
009603  2               ;--------------------------------
009603  2               ;$00 - used in HammerBroJumpCode as bitmask
009603  2               
009603  2               HammerThrowTmrData:
009603  2  30 1C              .byte $30, $1c
009605  2               
009605  2               XSpeedAdderData:
009605  2  00 E8 00 18        .byte $00, $e8, $00, $18
009609  2               
009609  2               RevivedXSpeed:
009609  2  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00960D  2               
00960D  2               ProcHammerBro:
00960D  2  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00960F  2  29 20               and #%00100000
009611  2  F0 03               beq ChkJH                  ;if not set, go ahead with code
009613  2  4C 1A 97            jmp MoveDefeatedEnemy      ;otherwise jump to something else
009616  2  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
009618  2  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
00961A  2  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00961C  2  AD D1 03            lda Enemy_OffscreenBits
00961F  2  29 0C               and #%00001100             ;check offscreen bits
009621  2  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
009623  2  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
009626  2  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
009628  2  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00962B  2  B9 03 96            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00962E  2  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
009631  2  20 5F 86            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
009634  2  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
009636  2  B5 1E               lda Enemy_State,x
009638  2  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
00963A  2  95 1E               sta Enemy_State,x
00963C  2  4C 8D 96            jmp MoveHammerBroXDir      ;jump to move hammer bro
00963F  2  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
009642  2  4C 8D 96            jmp MoveHammerBroXDir      ;jump to move hammer bro
009645  2               
009645  2               HammerBroJumpLData:
009645  2  20 37              .byte $20, $37
009647  2               
009647  2               HammerBroJumpCode:
009647  2  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
009649  2  29 07               and #%00000111              ;mask out all but 3 LSB
00964B  2  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00964D  2  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00964F  2  A9 00               lda #$00                    ;load default value here
009651  2  85 00               sta $00                     ;save into temp variable for now
009653  2  A0 FA               ldy #$fa                    ;set default vertical speed
009655  2  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
009657  2  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
009659  2  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00965B  2  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00965D  2  E6 00               inc $00                     ;increment preset value to $01
00965F  2  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
009661  2  C6 00               dec $00                     ;otherwise return value to $00
009663  2  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
009666  2  29 01               and #$01
009668  2  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
00966A  2  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00966C  2  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00966E  2  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
009670  2  09 01               ora #$01
009672  2  95 1E               sta Enemy_State,x
009674  2  A5 00               lda $00                     ;load preset value here to use as bitmask
009676  2  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
009679  2  A8                  tay                         ;then use as offset
00967A  2  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00967D  2  D0 01               bne HJump
00967F  2  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
009680  2  B9 45 96     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
009683  2  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
009686  2  BD A8 07            lda PseudoRandomBitReg+1,x
009689  2  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00968B  2  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00968D  2               
00968D  2               MoveHammerBroXDir:
00968D  2  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00968F  2  A5 09                 lda FrameCounter
009691  2  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
009693  2  D0 02                 bne Shimmy
009695  2  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
009697  2  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
009699  2  A0 01                 ldy #$01                  ;set to face right by default
00969B  2  20 D9 AD              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00969E  2  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
0096A0  2  C8                    iny                       ;set to face left
0096A1  2  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
0096A4  2  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
0096A6  2  A9 F8                 lda #$f8
0096A8  2  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
0096AA  2  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
0096AC  2               
0096AC  2               MoveNormalEnemy:
0096AC  2  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
0096AE  2  B5 1E               lda Enemy_State,x
0096B0  2  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
0096B2  2  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
0096B4  2  B5 1E               lda Enemy_State,x
0096B6  2  0A                  asl                        ;check enemy state for d7 set
0096B7  2  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
0096B9  2  B5 1E               lda Enemy_State,x
0096BB  2  29 20               and #%00100000             ;check enemy state for d5 set
0096BD  2  D0 5B               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
0096BF  2  B5 1E               lda Enemy_State,x
0096C1  2  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
0096C3  2  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
0096C5  2  C9 05               cmp #$05
0096C7  2  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
0096C9  2  C9 03               cmp #$03
0096CB  2  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
0096CD  2  20 34 8B     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
0096D0  2  A0 00               ldy #$00
0096D2  2  B5 1E               lda Enemy_State,x          ;check for enemy state $02
0096D4  2  C9 02               cmp #$02
0096D6  2  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
0096D8  2  29 40               and #%01000000             ;check for d6 set
0096DA  2  F0 0D               beq SteadM                 ;if not set, branch to something else
0096DC  2  B5 16               lda Enemy_ID,x
0096DE  2  C9 2E               cmp #PowerUpObject         ;check for power-up object
0096E0  2  F0 07               beq SteadM
0096E2  2  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
0096E4  2  4C D3 8A     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
0096E7  2               
0096E7  2  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
0096E9  2  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
0096EB  2  48                   pha                       ;save to stack
0096EC  2  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
0096EE  2  C8                   iny
0096EF  2  C8                   iny                       ;otherwise increment Y to next data
0096F0  2  18           AddHS:  clc
0096F1  2  79 05 96             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
0096F4  2  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
0096F6  2  20 D3 8A             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
0096F9  2  68                   pla
0096FA  2  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
0096FC  2  60                   rts                       ;original memory location, then leave
0096FD  2               
0096FD  2               ReviveStunned:
0096FD  2  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
009700  2  D0 1E                 bne ChkKillGoomba         ;skip ahead to something else
009702  2  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
009704  2  A5 09                 lda FrameCounter
009706  2  29 01                 and #$01                  ;get d0 of frame counter
009708  2  A8                    tay                       ;use as Y and increment for movement direction
009709  2  C8                    iny
00970A  2  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00970C  2  88                    dey                       ;decrement for use as pointer
00970D  2  AD 6A 07              lda PrimaryHardMode       ;check primary hard mode flag
009710  2  F0 02                 beq SetRSpd               ;if not set, use pointer as-is
009712  2  C8                    iny
009713  2  C8                    iny                       ;otherwise increment 2 bytes to next data
009714  2  B9 09 96     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
009717  2  95 58                 sta Enemy_X_Speed,x       ;and leave
009719  2  60                    rts
00971A  2               
00971A  2               MoveDefeatedEnemy:
00971A  2  20 34 8B           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
00971D  2  4C D3 8A           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
009720  2               
009720  2               ChkKillGoomba:
009720  2  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
009722  2  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
009724  2  B5 16                lda Enemy_ID,x
009726  2  C9 06                cmp #Goomba           ;check for goomba object
009728  2  D0 03                bne NKGmba            ;branch if not found
00972A  2  20 CD 95             jsr EraseEnemyObject  ;otherwise, kill this goomba object
00972D  2  60           NKGmba: rts                   ;leave!
00972E  2               
00972E  2               ;--------------------------------
00972E  2               
00972E  2               MoveJumpingEnemy:
00972E  2  20 63 8B           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
009731  2  4C D3 8A           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
009734  2               
009734  2               ;--------------------------------
009734  2               
009734  2               ProcMoveRedPTroopa:
009734  2  B5 A0                  lda Enemy_Y_Speed,x
009736  2  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
009739  2  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00973B  2  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
00973E  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
009740  2  DD 01 04               cmp RedPTroopaOrigXPos,x
009743  2  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
009745  2  A5 09                  lda FrameCounter            ;get frame counter
009747  2  29 07                  and #%00000111              ;mask out all but 3 LSB
009749  2  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00974B  2  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
00974D  2  60           NoIncPT:  rts                         ;leave
00974E  2               
00974E  2               MoveRedPTUpOrDown:
00974E  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
009750  2  D5 58                  cmp RedPTroopaCenterYPos,x
009752  2  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
009754  2  4C 46 8B               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
009757  2  4C 41 8B     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00975A  2               
00975A  2               ;--------------------------------
00975A  2               ;$00 - used to store adder for movement, also used as adder for platform
00975A  2               ;$01 - used to store maximum value for secondary counter
00975A  2               
00975A  2               MoveFlyGreenPTroopa:
00975A  2  20 7A 97             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
00975D  2  20 9B 97             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
009760  2  A0 01                ldy #$01                   ;set Y to move green paratroopa down
009762  2  A5 09                lda FrameCounter
009764  2  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
009766  2  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
009768  2  A5 09                lda FrameCounter
00976A  2  29 40                and #%01000000             ;check frame counter for d6 set
00976C  2  D0 02                bne YSway                  ;branch to move green paratroopa down if set
00976E  2  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
009770  2  84 00        YSway:  sty $00                    ;store adder here
009772  2  B5 CF                lda Enemy_Y_Position,x
009774  2  18                   clc                        ;add or subtract from vertical position
009775  2  65 00                adc $00                    ;to give green paratroopa a wavy flight
009777  2  95 CF                sta Enemy_Y_Position,x
009779  2  60           NoMGPT: rts                        ;leave!
00977A  2               
00977A  2               XMoveCntr_GreenPTroopa:
00977A  2  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
00977C  2               
00977C  2               XMoveCntr_Platform:
00977C  2  85 01                 sta $01                     ;store value here
00977E  2  A5 09                 lda FrameCounter
009780  2  29 03                 and #%00000011              ;branch to leave if not on
009782  2  D0 0D                 bne NoIncXM                 ;every fourth frame
009784  2  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
009786  2  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
009788  2  4A                    lsr
009789  2  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00978B  2  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
00978D  2  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
00978F  2  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
009791  2  60           NoIncXM: rts
009792  2  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
009794  2  60                    rts
009795  2  98           DecSeXM: tya                         ;put secondary counter in A
009796  2  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
009798  2  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00979A  2  60                    rts
00979B  2               
00979B  2               MoveWithXMCntrs:
00979B  2  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
00979D  2  48                    pha
00979E  2  A0 01                 ldy #$01                     ;set value here by default
0097A0  2  B5 A0                 lda XMovePrimaryCounter,x
0097A2  2  29 02                 and #%00000010               ;if d1 of primary counter is
0097A4  2  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
0097A6  2  B5 58                 lda XMoveSecondaryCounter,x
0097A8  2  49 FF                 eor #$ff                     ;otherwise change secondary
0097AA  2  18                    clc                          ;counter to two's compliment
0097AB  2  69 01                 adc #$01
0097AD  2  95 58                 sta XMoveSecondaryCounter,x
0097AF  2  A0 02                 ldy #$02                     ;load alternate value here
0097B1  2  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
0097B3  2  20 D3 8A              jsr MoveEnemyHorizontally
0097B6  2  85 00                 sta $00                      ;save value obtained from sub here
0097B8  2  68                    pla                          ;get secondary counter from stack
0097B9  2  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
0097BB  2  60                    rts
0097BC  2               
0097BC  2               ;--------------------------------
0097BC  2               
0097BC  2               
0097BC  2               BlooberBitmasks:
0097BC  2  3F 03              .byte %00111111, %00000011
0097BE  2               
0097BE  2               MoveBloober:
0097BE  2  B5 1E                lda Enemy_State,x
0097C0  2  29 20                and #%00100000             ;check enemy state for d5 set
0097C2  2  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
0097C4  2  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
0097C7  2  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
0097CA  2  39 BC 97             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
0097CD  2  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
0097CF  2  8A                   txa
0097D0  2  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
0097D1  2  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
0097D3  2  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
0097D5  2  B0 08                bcs SBMDir                 ;do an unconditional branch to set
0097D7  2  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
0097D9  2  20 D9 AD             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
0097DC  2  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
0097DE  2  88                   dey                        ;otherwise decrement to set right moving direction
0097DF  2  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
0097E1  2               
0097E1  2               BlooberSwim:
0097E1  2  20 14 98            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
0097E4  2  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
0097E6  2  38                  sec
0097E7  2  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
0097EA  2  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
0097EC  2  90 02               bcc SwimX                ;if so, don't do it
0097EE  2  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
0097F0  2  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
0097F2  2  88                  dey
0097F3  2  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
0097F5  2  B5 87               lda Enemy_X_Position,x
0097F7  2  18                  clc                      ;add movement speed to horizontal coordinate
0097F8  2  75 58               adc BlooperMoveSpeed,x
0097FA  2  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
0097FC  2  B5 6E               lda Enemy_PageLoc,x
0097FE  2  69 00               adc #$00                 ;add carry to page location
009800  2  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
009802  2  60                  rts
009803  2               
009803  2               LeftSwim:
009803  2  B5 87              lda Enemy_X_Position,x
009805  2  38                 sec                      ;subtract movement speed from horizontal coordinate
009806  2  F5 58              sbc BlooperMoveSpeed,x
009808  2  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00980A  2  B5 6E              lda Enemy_PageLoc,x
00980C  2  E9 00              sbc #$00                 ;subtract borrow from page location
00980E  2  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
009810  2  60                 rts
009811  2               
009811  2               MoveDefeatedBloober:
009811  2  4C 5D 8B           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
009814  2               
009814  2               ProcSwimmingB:
009814  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
009816  2  29 02                and #%00000010            ;check for d1 set
009818  2  D0 37                bne ChkForFloatdown       ;branch if set
00981A  2  A5 09                lda FrameCounter
00981C  2  29 07                and #%00000111            ;get 3 LSB of frame counter
00981E  2  48                   pha                       ;and save it to the stack
00981F  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
009821  2  4A                   lsr                       ;check for d0 set
009822  2  B0 15                bcs SlowSwim              ;branch if set
009824  2  68                   pla                       ;pull 3 LSB of frame counter from the stack
009825  2  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
009827  2  BD 34 04             lda Enemy_Y_MoveForce,x
00982A  2  18                   clc                       ;add to movement force to speed up swim
00982B  2  69 01                adc #$01
00982D  2  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
009830  2  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
009832  2  C9 02                cmp #$02
009834  2  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
009836  2  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
009838  2  60           BSwimE: rts
009839  2               
009839  2               SlowSwim:
009839  2  68                  pla                      ;pull 3 LSB of frame counter from the stack
00983A  2  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
00983C  2  BD 34 04            lda Enemy_Y_MoveForce,x
00983F  2  38                  sec                      ;subtract from movement force to slow swim
009840  2  E9 01               sbc #$01
009842  2  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
009845  2  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
009847  2  D0 07               bne NoSSw                ;if any speed, branch to leave
009849  2  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00984B  2  A9 02               lda #$02
00984D  2  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
009850  2  60           NoSSw: rts                      ;leave
009851  2               
009851  2               ChkForFloatdown:
009851  2  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
009854  2  F0 08              beq ChkNearPlayer        ;branch if expired
009856  2               
009856  2               Floatdown:
009856  2  A5 09              lda FrameCounter        ;get frame counter
009858  2  4A                 lsr                     ;check for d0 set
009859  2  B0 02              bcs NoFD                ;branch to leave on every other frame
00985B  2  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
00985D  2  60           NoFD: rts                     ;leave
00985E  2               
00985E  2               ChkNearPlayer:
00985E  2  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
009860  2  69 10              adc #$10                  ;add sixteen pixels
009862  2  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
009864  2  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
009866  2  A9 00              lda #$00
009868  2  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00986A  2  60                 rts
00986B  2               
00986B  2               ;--------------------------------
00986B  2               
00986B  2               MoveBulletBill:
00986B  2  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
00986D  2  29 20                 and #%00100000
00986F  2  F0 03                 beq NotDefB                ;if not set, continue with movement code
009871  2  4C 63 8B              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
009874  2  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
009876  2  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
009878  2  4C D3 8A              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00987B  2               
00987B  2               ;--------------------------------
00987B  2               ;$02 - used to hold preset values
00987B  2               ;$03 - used to hold enemy state
00987B  2               
00987B  2               SwimCCXMoveData:
00987B  2  40 80              .byte $40, $80
00987D  2  04 04              .byte $04, $04 ;residual data, not used
00987F  2               
00987F  2               MoveSwimmingCheepCheep:
00987F  2  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
009881  2  29 20                and #%00100000            ;for d5 set
009883  2  F0 03                beq CCSwim                ;if not set, continue with movement code
009885  2  4C 5D 8B             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
009888  2  85 03        CCSwim: sta $03                   ;save enemy state in $03
00988A  2  B5 16                lda Enemy_ID,x            ;get enemy identifier
00988C  2  38                   sec
00988D  2  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
00988F  2  A8                   tay                       ;use as offset
009890  2  B9 7B 98             lda SwimCCXMoveData,y     ;load value here
009893  2  85 02                sta $02
009895  2  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
009898  2  38                   sec
009899  2  E5 02                sbc $02                   ;subtract preset value from horizontal force
00989B  2  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
00989E  2  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
0098A0  2  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
0098A2  2  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
0098A4  2  B5 6E                lda Enemy_PageLoc,x
0098A6  2  E9 00                sbc #$00                  ;subtract borrow again, this time from the
0098A8  2  95 6E                sta Enemy_PageLoc,x       ;page location, then save
0098AA  2  A9 40                lda #$40
0098AC  2  85 02                sta $02                   ;save new value here
0098AE  2  E0 02                cpx #$02                  ;check enemy object offset
0098B0  2  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
0098B2  2  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
0098B4  2  C9 10                cmp #$10                  ;if movement speed set to $00,
0098B6  2  90 16                bcc CCSwimUpwards         ;branch to move upwards
0098B8  2  BD 17 04             lda Enemy_YMF_Dummy,x
0098BB  2  18                   clc
0098BC  2  65 02                adc $02                   ;add preset value to dummy variable to get carry
0098BE  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
0098C1  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098C3  2  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
0098C5  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
0098C7  2  B5 B6                lda Enemy_Y_HighPos,x
0098C9  2  69 00                adc #$00                  ;add carry to page location and
0098CB  2  4C E1 98             jmp ChkSwimYPos           ;jump to end of movement code
0098CE  2               
0098CE  2               CCSwimUpwards:
0098CE  2  BD 17 04             lda Enemy_YMF_Dummy,x
0098D1  2  38                   sec
0098D2  2  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
0098D4  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
0098D7  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098D9  2  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
0098DB  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
0098DD  2  B5 B6                lda Enemy_Y_HighPos,x
0098DF  2  E9 00                sbc #$00                  ;subtract borrow from page location
0098E1  2               
0098E1  2               ChkSwimYPos:
0098E1  2  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
0098E3  2  A0 00                ldy #$00                  ;load movement speed to upwards by default
0098E5  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
0098E7  2  38                   sec
0098E8  2  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
0098EB  2  10 07                bpl YPDiff                ;if result positive, skip to next part
0098ED  2  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
0098EF  2  49 FF                eor #$ff
0098F1  2  18                   clc                       ;get two's compliment of result
0098F2  2  69 01                adc #$01                  ;to obtain total difference of original vs. current
0098F4  2  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
0098F6  2  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
0098F8  2  98                   tya
0098F9  2  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
0098FB  2  60           ExSwCC: rts                       ;leave
0098FC  2               
0098FC  2               ;--------------------------------
0098FC  2               ;$00 - used as counter for firebar parts
0098FC  2               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
0098FC  2               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
0098FC  2               ;$03 - used for mirror data
0098FC  2               ;$04 - used to store player's sprite 1 X coordinate
0098FC  2               ;$05 - used to evaluate mirror data
0098FC  2               ;$06 - used to store either screen X coordinate or sprite data offset
0098FC  2               ;$07 - used to store screen Y coordinate
0098FC  2               ;$ed - used to hold maximum length of firebar
0098FC  2               ;$ef - used to hold high byte of spinstate
0098FC  2               
0098FC  2               ;horizontal adder is at first byte + high byte of spinstate,
0098FC  2               ;vertical adder is same + 8 bytes, two's compliment
0098FC  2               ;if greater than $08 for proper oscillation
0098FC  2               FirebarPosLookupTbl:
0098FC  2  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
009900  2  05 06 07 07  
009904  2  08           
009905  2  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
009909  2  0B 0D 0E 0F  
00990D  2  10           
00990E  2  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
009912  2  10 13 16 17  
009916  2  18           
009917  2  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00991B  2  16 1A 1D 1F  
00991F  2  20           
009920  2  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
009924  2  1C 21 25 27  
009928  2  28           
009929  2  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
00992D  2  21 27 2C 2F  
009931  2  30           
009932  2  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
009936  2  27 2E 33 37  
00993A  2  38           
00993B  2  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
00993F  2  2D 35 3B 3E  
009943  2  40           
009944  2  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
009948  2  32 3B 42 46  
00994C  2  48           
00994D  2  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
009951  2  38 42 4A 4E  
009955  2  50           
009956  2  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00995A  2  3E 49 51 56  
00995E  2  58           
00995F  2               
00995F  2               FirebarMirrorData:
00995F  2  01 03 02 00        .byte $01, $03, $02, $00
009963  2               
009963  2               FirebarTblOffsets:
009963  2  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
009967  2  24 2D        
009969  2  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
00996D  2  5A 63        
00996F  2               
00996F  2               FirebarYPos:
00996F  2  0C 18              .byte $0c, $18
009971  2               
009971  2               ProcFirebar:
009971  2  20 94 BE               jsr GetEnemyOffscreenBits   ;get offscreen information
009974  2  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
009977  2  29 08                  and #%00001000              ;if so, branch to leave
009979  2  D0 74                  bne SkipFBar
00997B  2  AD 47 07               lda TimerControl            ;if master timer control set, branch
00997E  2  D0 0A                  bne SusFbar                 ;ahead of this part
009980  2  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
009983  2  20 43 A0               jsr FirebarSpin             ;modify current spinstate
009986  2  29 1F                  and #%00011111              ;mask out all but 5 LSB
009988  2  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00998A  2  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
00998C  2  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
00998E  2  C0 1F                  cpy #$1f
009990  2  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
009992  2  C9 08                  cmp #$08                    ;check high byte of spinstate
009994  2  F0 04                  beq SkpFSte                 ;if eight, branch to change
009996  2  C9 18                  cmp #$18
009998  2  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00999A  2  18           SkpFSte:  clc
00999B  2  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
00999D  2  95 A0                  sta FirebarSpinState_High,x
00999F  2  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
0099A1  2  20 37 BE               jsr RelativeEnemyPosition   ;get relative coordinates to screen
0099A4  2  20 C3 9A               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
0099A7  2  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
0099AA  2  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
0099AD  2  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
0099B0  2  85 07                  sta $07                     ;also save here
0099B2  2  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
0099B5  2  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
0099B8  2  85 06                  sta $06                     ;also save here
0099BA  2  A9 01                  lda #$01
0099BC  2  85 00                  sta $00                     ;set $01 value here (not necessary)
0099BE  2  20 3D 9A               jsr FirebarCollision        ;draw fireball part and do collision detection
0099C1  2  A0 05                  ldy #$05                    ;load value for short firebars by default
0099C3  2  B5 16                  lda Enemy_ID,x
0099C5  2  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
0099C7  2  90 02                  bcc SetMFbar                ;no, branch then
0099C9  2  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
0099CB  2  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
0099CD  2  A9 00                  lda #$00
0099CF  2  85 00                  sta $00                     ;initialize counter here
0099D1  2  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
0099D3  2  20 C3 9A               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
0099D6  2  20 F0 99               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
0099D9  2  A5 00                  lda $00                     ;check which firebar part
0099DB  2  C9 04                  cmp #$04
0099DD  2  D0 08                  bne NextFbar
0099DF  2  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
0099E2  2  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
0099E5  2  85 06                  sta $06                     ;using long firebar offset, then store as new one here
0099E7  2  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
0099E9  2  A5 00                  lda $00
0099EB  2  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
0099ED  2  90 E2                  bcc DrawFbar                ;otherwise go back and do another
0099EF  2  60           SkipFBar: rts
0099F0  2               
0099F0  2               DrawFirebar_Collision:
0099F0  2  A5 03                 lda $03                  ;store mirror data elsewhere
0099F2  2  85 05                 sta $05
0099F4  2  A4 06                 ldy $06                  ;load OAM data offset for firebar
0099F6  2  A5 01                 lda $01                  ;load horizontal adder we got from position loader
0099F8  2  46 05                 lsr $05                  ;shift LSB of mirror data
0099FA  2  B0 04                 bcs AddHA                ;if carry was set, skip this part
0099FC  2  49 FF                 eor #$ff
0099FE  2  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
009A00  2  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
009A01  2  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
009A04  2  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
009A07  2  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
009A09  2  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
009A0C  2  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
009A0E  2  AD AE 03              lda Enemy_Rel_XPos
009A11  2  38                    sec                      ;otherwise subtract sprite X from the
009A12  2  E5 06                 sbc $06                  ;original one and skip this part
009A14  2  4C 1B 9A              jmp ChkFOfs
009A17  2  38           SubtR1:  sec                      ;subtract original X from the
009A18  2  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
009A1B  2  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
009A1D  2  90 04                 bcc VAHandl              ;continue by handling vertical adder
009A1F  2  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
009A21  2  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
009A23  2  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
009A26  2  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
009A28  2  F0 0E                 beq SetVFbr
009A2A  2  A5 02                 lda $02                  ;load vertical adder we got from position loader
009A2C  2  46 05                 lsr $05                  ;shift LSB of mirror data one more time
009A2E  2  B0 04                 bcs AddVA                ;if carry was set, skip this part
009A30  2  49 FF                 eor #$ff
009A32  2  69 01                 adc #$01                 ;otherwise get two's compliment of second part
009A34  2  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
009A35  2  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
009A38  2  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
009A3B  2  85 07                 sta $07                  ;also store here for now
009A3D  2               
009A3D  2               FirebarCollision:
009A3D  2  20 C8 B9              jsr DrawFirebar          ;run sub here to draw current tile of firebar
009A40  2  98                    tya                      ;return OAM data offset and save
009A41  2  48                    pha                      ;to the stack for now
009A42  2  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
009A45  2  0D 47 07              ora TimerControl         ;or master timer controls set
009A48  2  D0 70                 bne NoColFB              ;then skip all of this
009A4A  2  85 05                 sta $05                  ;otherwise initialize counter
009A4C  2  A4 B5                 ldy Player_Y_HighPos
009A4E  2  88                    dey                      ;if player's vertical high byte offscreen,
009A4F  2  D0 69                 bne NoColFB              ;skip all of this
009A51  2  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
009A53  2  AD 54 07              lda PlayerSize           ;get player's size
009A56  2  D0 05                 bne AdjSm                ;if player small, branch to alter variables
009A58  2  AD 14 07              lda CrouchingFlag
009A5B  2  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
009A5D  2  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
009A5F  2  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
009A61  2  98                    tya
009A62  2  18                    clc                      ;then add 24 pixels to the player's
009A63  2  69 18                 adc #$18                 ;vertical coordinate
009A65  2  A8                    tay
009A66  2  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
009A67  2  38           FBCLoop: sec                      ;subtract vertical position of firebar
009A68  2  E5 07                 sbc $07                  ;from the vertical coordinate of the player
009A6A  2  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
009A6C  2  49 FF                 eor #$ff                 ;skip two's compliment part
009A6E  2  18                    clc                      ;otherwise get two's compliment
009A6F  2  69 01                 adc #$01
009A71  2  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
009A73  2  B0 1C                 bcs Chk2Ofs
009A75  2  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
009A77  2  C9 F0                 cmp #$f0                 ;because, really, what's the point?
009A79  2  B0 16                 bcs Chk2Ofs
009A7B  2  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
009A7E  2  18                    clc
009A7F  2  69 04                 adc #$04                 ;add four pixels
009A81  2  85 04                 sta $04                  ;store here
009A83  2  38                    sec                      ;subtract horizontal coordinate of firebar
009A84  2  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
009A86  2  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
009A88  2  49 FF                 eor #$ff                 ;skip two's compliment part
009A8A  2  18                    clc                      ;otherwise get two's compliment
009A8B  2  69 01                 adc #$01
009A8D  2  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
009A8F  2  90 13                 bcc ChgSDir              ;to process
009A91  2  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
009A93  2  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
009A95  2  F0 23                 beq NoColFB
009A97  2  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
009A99  2  A5 CE                 lda Player_Y_Position
009A9B  2  18                    clc
009A9C  2  79 6F 99              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
009A9F  2  E6 05                 inc $05                  ;then increment temp and jump back
009AA1  2  4C 67 9A              jmp FBCLoop
009AA4  2  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
009AA6  2  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
009AA8  2  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
009AAA  2  B0 01                 bcs SetSDir              ;then do not alter movement direction
009AAC  2  E8                    inx                      ;otherwise increment it
009AAD  2  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
009AAF  2  A2 00                 ldx #$00
009AB1  2  A5 00                 lda $00                  ;save value written to $00 to stack
009AB3  2  48                    pha
009AB4  2  20 87 A5              jsr InjurePlayer         ;perform sub to hurt or kill player
009AB7  2  68                    pla
009AB8  2  85 00                 sta $00                  ;get value of $00 from stack
009ABA  2  68           NoColFB: pla                      ;get OAM data offset
009ABB  2  18                    clc                      ;add four to it and save
009ABC  2  69 04                 adc #$04
009ABE  2  85 06                 sta $06
009AC0  2  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
009AC2  2  60                    rts
009AC3  2               
009AC3  2               GetFirebarPosition:
009AC3  2  48                      pha                        ;save high byte of spinstate to the stack
009AC4  2  29 0F                   and #%00001111             ;mask out low nybble
009AC6  2  C9 09                   cmp #$09
009AC8  2  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
009ACA  2  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
009ACC  2  18                      clc
009ACD  2  69 01                   adc #$01
009ACF  2  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
009AD1  2  A4 00                   ldy $00                    ;load number of firebar ball where we're at
009AD3  2  B9 63 99                lda FirebarTblOffsets,y    ;load offset to firebar position data
009AD6  2  18                      clc
009AD7  2  65 01                   adc $01                    ;add oscillated high byte of spinstate
009AD9  2  A8                      tay                        ;to offset here and use as new offset
009ADA  2  B9 FC 98                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
009ADD  2  85 01                   sta $01
009ADF  2  68                      pla                        ;pull whatever was in A from the stack
009AE0  2  48                      pha                        ;save it again because we still need it
009AE1  2  18                      clc
009AE2  2  69 08                   adc #$08                   ;add eight this time, to get vertical adder
009AE4  2  29 0F                   and #%00001111             ;mask out high nybble
009AE6  2  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
009AE8  2  90 05                   bcc GetVAdder
009AEA  2  49 0F                   eor #%00001111             ;otherwise get two's compliment
009AEC  2  18                      clc
009AED  2  69 01                   adc #$01
009AEF  2  85 02        GetVAdder: sta $02                    ;store result here
009AF1  2  A4 00                   ldy $00
009AF3  2  B9 63 99                lda FirebarTblOffsets,y    ;load offset to firebar position data again
009AF6  2  18                      clc
009AF7  2  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
009AF9  2  A8                      tay
009AFA  2  B9 FC 98                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
009AFD  2  85 02                   sta $02
009AFF  2  68                      pla                        ;pull out whatever was in A one last time
009B00  2  4A                      lsr                        ;divide by eight or shift three to the right
009B01  2  4A                      lsr
009B02  2  4A                      lsr
009B03  2  A8                      tay                        ;use as offset
009B04  2  B9 5F 99                lda FirebarMirrorData,y    ;load mirroring data here
009B07  2  85 03                   sta $03                    ;store
009B09  2  60                      rts
009B0A  2               
009B0A  2               ;--------------------------------
009B0A  2               
009B0A  2               PRandomSubtracter:
009B0A  2  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
009B0E  2  00           
009B0F  2               
009B0F  2               FlyCCBPriority:
009B0F  2  20 20 20 00        .byte $20, $20, $20, $00, $00
009B13  2  00           
009B14  2               
009B14  2               MoveFlyingCheepCheep:
009B14  2  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
009B16  2  29 20                and #%00100000             ;for d5 set
009B18  2  F0 08                beq FlyCC                  ;branch to continue code if not set
009B1A  2  A9 00                lda #$00
009B1C  2  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
009B1F  2  4C 63 8B             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
009B22  2  20 D3 8A     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
009B25  2  A0 0D                ldy #$0d                   ;set vertical movement amount
009B27  2  A9 05                lda #$05                   ;set maximum speed
009B29  2  20 67 8B             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
009B2C  2  BD 34 04             lda Enemy_Y_MoveForce,x
009B2F  2  4A                   lsr                        ;get vertical movement force and
009B30  2  4A                   lsr                        ;move high nybble to low
009B31  2  4A                   lsr
009B32  2  4A                   lsr
009B33  2  A8                   tay                        ;save as offset (note this tends to go into reach of code)
009B34  2  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
009B36  2  38                   sec                        ;subtract pseudorandom value based on offset from position
009B37  2  F9 0A 9B             sbc PRandomSubtracter,y
009B3A  2  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
009B3C  2  49 FF                eor #$ff
009B3E  2  18                   clc                        ;otherwise get two's compliment
009B3F  2  69 01                adc #$01
009B41  2  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
009B43  2  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
009B45  2  BD 34 04             lda Enemy_Y_MoveForce,x
009B48  2  18                   clc
009B49  2  69 10                adc #$10                   ;otherwise add to it
009B4B  2  9D 34 04             sta Enemy_Y_MoveForce,x
009B4E  2  4A                   lsr                        ;move high nybble to low again
009B4F  2  4A                   lsr
009B50  2  4A                   lsr
009B51  2  4A                   lsr
009B52  2  A8                   tay
009B53  2  B9 0F 9B     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
009B56  2  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
009B59  2  60                   rts                        ;drawing it next frame), then leave
009B5A  2               
009B5A  2               ;--------------------------------
009B5A  2               ;$00 - used to hold horizontal difference
009B5A  2               ;$01-$03 - used to hold difference adjusters
009B5A  2               
009B5A  2               LakituDiffAdj:
009B5A  2  15 30 40           .byte $15, $30, $40
009B5D  2               
009B5D  2               MoveLakitu:
009B5D  2  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
009B5F  2  29 20                 and #%00100000             ;for d5 set
009B61  2  F0 03                 beq ChkLS                  ;if not set, continue with code
009B63  2  4C 34 8B              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
009B66  2  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
009B68  2  F0 0B                 beq Fr12S                  ;go ahead and continue with code
009B6A  2  A9 00                 lda #$00
009B6C  2  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
009B6E  2  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
009B71  2  A9 10                 lda #$10
009B73  2  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
009B75  2  A9 12        Fr12S:   lda #Spiny
009B77  2  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
009B7A  2  A0 02                 ldy #$02
009B7C  2  B9 5A 9B     LdLDa:   lda LakituDiffAdj,y        ;load values
009B7F  2  99 01 00              sta $0001,y                ;store in zero page
009B82  2  88                    dey
009B83  2  10 F7                 bpl LdLDa                  ;do this until all values are stired
009B85  2  20 A1 9B              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
009B88  2  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
009B8A  2  A0 01                 ldy #$01                   ;set moving direction to right by default
009B8C  2  B5 A0                 lda LakituMoveDirection,x
009B8E  2  29 01                 and #$01                   ;get LSB of moving direction
009B90  2  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
009B92  2  B5 58                 lda LakituMoveSpeed,x
009B94  2  49 FF                 eor #$ff                   ;get two's compliment of moving speed
009B96  2  18                    clc
009B97  2  69 01                 adc #$01
009B99  2  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
009B9B  2  C8                    iny                        ;increment moving direction to left
009B9C  2  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
009B9E  2  4C D3 8A              jmp MoveEnemyHorizontally  ;move lakitu horizontally
009BA1  2               
009BA1  2               PlayerLakituDiff:
009BA1  2  A0 00                   ldy #$00                   ;set Y for default value
009BA3  2  20 D9 AD                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
009BA6  2  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
009BA8  2  C8                      iny                        ;increment Y for left of player
009BA9  2  A5 00                   lda $00
009BAB  2  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
009BAD  2  18                      clc
009BAE  2  69 01                   adc #$01                   ;store two's compliment as horizontal difference
009BB0  2  85 00                   sta $00
009BB2  2  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
009BB4  2  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
009BB6  2  90 1C                   bcc ChkPSpeed
009BB8  2  A9 3C                   lda #$3c                   ;otherwise set maximum distance
009BBA  2  85 00                   sta $00
009BBC  2  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
009BBE  2  C9 11                   cmp #Lakitu
009BC0  2  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
009BC2  2  98                      tya                        ;compare contents of Y, now in A
009BC3  2  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
009BC5  2  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
009BC7  2  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
009BC9  2  F0 06                   beq SetLMovD               ;branch and alter without delay
009BCB  2  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
009BCD  2  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
009BCF  2  D0 40                   bne ExMoveLak
009BD1  2  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
009BD2  2  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
009BD4  2  A5 00        ChkPSpeed: lda $00
009BD6  2  29 3C                   and #%00111100             ;mask out all but four bits in the middle
009BD8  2  4A                      lsr                        ;divide masked difference by four
009BD9  2  4A                      lsr
009BDA  2  85 00                   sta $00                    ;store as new value
009BDC  2  A0 00                   ldy #$00                   ;init offset
009BDE  2  A5 57                   lda Player_X_Speed
009BE0  2  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
009BE2  2  AD 75 07                lda ScrollAmount
009BE5  2  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
009BE7  2  C8                      iny                        ;otherwise increment offset
009BE8  2  A5 57                   lda Player_X_Speed
009BEA  2  C9 19                   cmp #$19                   ;if player not running, branch
009BEC  2  90 08                   bcc ChkSpinyO
009BEE  2  AD 75 07                lda ScrollAmount
009BF1  2  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
009BF3  2  90 01                   bcc ChkSpinyO              ;to same place
009BF5  2  C8                      iny                        ;otherwise increment once more
009BF6  2  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
009BF8  2  C9 12                   cmp #Spiny
009BFA  2  D0 04                   bne ChkEmySpd              ;branch if not found
009BFC  2  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
009BFE  2  D0 06                   bne SubDifAdj
009C00  2  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
009C02  2  D0 02                   bne SubDifAdj              ;branch if nonzero
009C04  2  A0 00                   ldy #$00                   ;otherwise reinit offset
009C06  2  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
009C09  2  A4 00                   ldy $00                    ;get saved horizontal difference
009C0B  2  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
009C0C  2  E9 01                   sbc #$01                   ;from one of three saved values
009C0E  2  88                      dey
009C0F  2  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
009C11  2  60           ExMoveLak: rts                        ;leave!!!
009C12  2               
009C12  2               ;-------------------------------------------------------------------------------------
009C12  2               ;$04-$05 - used to store name table address in little endian order
009C12  2               
009C12  2               BridgeCollapseData:
009C12  2  1A                 .byte $1a ;axe
009C13  2  58                 .byte $58 ;chain
009C14  2  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
009C18  2  90 8E 8C     
009C1B  2  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
009C1F  2  82 80        
009C21  2               
009C21  2               BridgeCollapse:
009C21  2  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
009C24  2  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
009C26  2  C9 2D               cmp #Bowser               ;if not found, branch ahead,
009C28  2  D0 10               bne SetM2                 ;metatile removal not necessary
009C2A  2  86 08               stx ObjectOffset          ;store as enemy offset here
009C2C  2  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
009C2E  2  F0 1A               beq RemoveBridge
009C30  2  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
009C32  2  F0 06               beq SetM2
009C34  2  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
009C36  2  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
009C38  2  90 0A               bcc MoveD_Bowser
009C3A  2  A9 80        SetM2: lda #Silence              ;silence music
009C3C  2  85 FC               sta EventMusicQueue
009C3E  2  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in victory mode
009C41  2  4C A6 9C            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
009C44  2               
009C44  2               MoveD_Bowser:
009C44  2  20 5D 8B            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
009C47  2  4C B0 9D            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
009C4A  2               
009C4A  2               RemoveBridge:
009C4A  2  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
009C4D  2  D0 44                 bne NoBFall               ;if not expired, skip all of this
009C4F  2  A9 04                 lda #$04
009C51  2  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
009C54  2  AD 63 03              lda BowserBodyControls
009C57  2  49 01                 eor #$01                  ;invert bit to control bowser's feet
009C59  2  8D 63 03              sta BowserBodyControls
009C5C  2  A9 22                 lda #$22                  ;put high byte of name table address here for now
009C5E  2  85 05                 sta $05
009C60  2  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
009C63  2  B9 12 9C              lda BridgeCollapseData,y  ;load low byte of name table address and store here
009C66  2  85 04                 sta $04
009C68  2  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
009C6B  2  C8                    iny
009C6C  2  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
009C6E  2  20 AA 69              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
009C71  2  A6 08                 ldx ObjectOffset          ;get enemy offset
009C73  2  20 6C 69              jsr MoveVOffset           ;set new vram buffer offset
009C76  2  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
009C78  2  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
009C7A  2  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
009C7C  2  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
009C7E  2  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
009C81  2  AD 69 03              lda BridgeCollapseOffset
009C84  2  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
009C86  2  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
009C88  2  20 4E 8F              jsr InitVStf              ;initialize whatever vertical speed bowser has
009C8B  2  A9 40                 lda #%01000000
009C8D  2  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
009C8F  2  A9 80                 lda #Sfx_BowserFall
009C91  2  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
009C93  2  4C B0 9D     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
009C96  2               
009C96  2               ;--------------------------------
009C96  2               
009C96  2               PRandomRange:
009C96  2  21 41 11 31        .byte $21, $41, $11, $31
009C9A  2               
009C9A  2               RunBowser:
009C9A  2  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
009C9C  2  29 20              and #%00100000          ;then branch elsewhere to run bowser
009C9E  2  F0 14              beq BowserControl
009CA0  2  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
009CA2  2  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
009CA4  2  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
009CA6  2               
009CA6  2               KillAllEnemies:
009CA6  2  A2 04                  ldx #$04              ;start with last enemy slot
009CA8  2  20 CD 95     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
009CAB  2  CA                     dex                   ;move onto next enemy slot
009CAC  2  10 FA                  bpl KillLoop          ;do this until all slots are emptied
009CAE  2  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
009CB1  2  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
009CB3  2  60                     rts
009CB4  2               
009CB4  2               BowserControl:
009CB4  2  A9 00                   lda #$00
009CB6  2  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
009CB9  2  AD 47 07                lda TimerControl           ;if master timer control not set,
009CBC  2  F0 03                   beq ChkMouth               ;skip jump and execute code here
009CBE  2  4C 6E 9D                jmp SkipToFB               ;otherwise, jump over a bunch of code
009CC1  2  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
009CC4  2  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
009CC6  2  4C 44 9D                jmp HammerChk              ;otherwise skip a whole section starting here
009CC9  2  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
009CCC  2  D0 0D                   bne ResetMDr               ;if not expired, skip this part
009CCE  2  A9 20                   lda #$20                   ;otherwise, reset timer
009CD0  2  8D 64 03                sta BowserFeetCounter
009CD3  2  AD 63 03                lda BowserBodyControls     ;and invert bit used
009CD6  2  49 01                   eor #%00000001             ;to control bowser's feet
009CD8  2  8D 63 03                sta BowserBodyControls
009CDB  2  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
009CDD  2  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
009CDF  2  D0 04                   bne B_FaceP                ;ahead to continue code
009CE1  2  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
009CE3  2  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
009CE5  2  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
009CE8  2  F0 1C                   beq GetPRCmp               ;branch to next section
009CEA  2  20 D9 AD                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
009CED  2  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
009CEF  2  A9 01                   lda #$01
009CF1  2  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
009CF3  2  A9 02                   lda #$02
009CF5  2  8D 65 03                sta BowserMovementSpeed    ;set movement speed
009CF8  2  A9 20                   lda #$20
009CFA  2  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
009CFD  2  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
009D00  2  B5 87                   lda Enemy_X_Position,x
009D02  2  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
009D04  2  B0 3E                   bcs HammerChk              ;skip ahead to some other section
009D06  2  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
009D08  2  29 03                   and #%00000011
009D0A  2  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
009D0C  2  B5 87                   lda Enemy_X_Position,x
009D0E  2  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
009D11  2  D0 0C                   bne GetDToO                ;branch to skip this part
009D13  2  BD A7 07                lda PseudoRandomBitReg,x
009D16  2  29 03                   and #%00000011             ;get pseudorandom offset
009D18  2  A8                      tay
009D19  2  B9 96 9C                lda PRandomRange,y         ;load value using pseudorandom offset
009D1C  2  8D DC 06                sta MaxRangeFromOrigin     ;and store here
009D1F  2  B5 87        GetDToO:   lda Enemy_X_Position,x
009D21  2  18                      clc                        ;add movement speed to bowser's horizontal
009D22  2  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
009D25  2  95 87                   sta Enemy_X_Position,x
009D27  2  B4 46                   ldy Enemy_MovingDir,x
009D29  2  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
009D2B  2  F0 17                   beq HammerChk
009D2D  2  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
009D2F  2  38                      sec                        ;get difference of current vs. original
009D30  2  ED 66 03                sbc BowserOrigXPos         ;horizontal position
009D33  2  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
009D35  2  49 FF                   eor #$ff
009D37  2  18                      clc                        ;get two's compliment
009D38  2  69 01                   adc #$01
009D3A  2  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
009D3C  2  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
009D3F  2  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
009D41  2  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
009D44  2  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
009D47  2  D0 28                   bne MakeBJump              ;some other section of code
009D49  2  20 5D 8B                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
009D4C  2  AD 5F 07                lda WorldNumber            ;check world number
009D4F  2  C9 05                   cmp #World6
009D51  2  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
009D53  2  A5 09                   lda FrameCounter
009D55  2  29 03                   and #%00000011             ;check to see if it's time to execute sub
009D57  2  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
009D59  2  20 5F 86                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn hammer
009D5C  2  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
009D5E  2  C9 80                   cmp #$80                   ;if still above a certain point
009D60  2  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
009D62  2  BD A7 07                lda PseudoRandomBitReg,x
009D65  2  29 03                   and #%00000011             ;get pseudorandom offset
009D67  2  A8                      tay
009D68  2  B9 96 9C                lda PRandomRange,y         ;get value using pseudorandom offset
009D6B  2  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
009D6E  2  4C 7E 9D     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
009D71  2  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
009D73  2  D0 09                   bne ChkFireB               ;skip ahead to next part
009D75  2  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
009D77  2  20 4E 8F                jsr InitVStf               ;initialize movement amount
009D7A  2  A9 FE                   lda #$fe
009D7C  2  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
009D7E  2  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
009D81  2  C9 07                   cmp #World8                ;world 8?
009D83  2  F0 04                   beq SpawnFBr               ;if so, execute this part here
009D85  2  C9 05                   cmp #World6                ;world 6-7?
009D87  2  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
009D89  2  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
009D8C  2  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
009D8E  2  A9 20                   lda #$20
009D90  2  8D 90 07                sta BowserFireBreathTimer  ;set timer here
009D93  2  AD 63 03                lda BowserBodyControls
009D96  2  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
009D98  2  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
009D9B  2  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
009D9D  2  20 0E 9E                jsr SetFlameTimer          ;get timing for bowser's flame
009DA0  2  AC CC 06                ldy SecondaryHardMode
009DA3  2  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
009DA5  2  38                      sec
009DA6  2  E9 10                   sbc #$10                   ;otherwise subtract from value in A
009DA8  2  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
009DAB  2  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
009DAD  2  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
009DB0  2               
009DB0  2               ;--------------------------------
009DB0  2               
009DB0  2               BowserGfxHandler:
009DB0  2  20 F1 9D               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
009DB3  2  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
009DB5  2  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
009DB7  2  4A                     lsr
009DB8  2  90 02                  bcc CopyFToR             ;if moving left, use default
009DBA  2  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
009DBC  2  98           CopyFToR: tya                      ;move bowser's rear object position value to A
009DBD  2  18                     clc
009DBE  2  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
009DC0  2  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
009DC3  2  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
009DC6  2  B5 CF                  lda Enemy_Y_Position,x
009DC8  2  18                     clc                      ;add eight pixels to bowser's front object
009DC9  2  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
009DCB  2  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
009DCE  2  B5 1E                  lda Enemy_State,x
009DD0  2  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
009DD3  2  B5 46                  lda Enemy_MovingDir,x
009DD5  2  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
009DD8  2  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
009DDA  2  48                     pha
009DDB  2  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
009DDE  2  86 08                  stx ObjectOffset
009DE0  2  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
009DE2  2  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
009DE4  2  20 F1 9D               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
009DE7  2  68                     pla
009DE8  2  85 08                  sta ObjectOffset         ;get original enemy object offset
009DEA  2  AA                     tax
009DEB  2  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
009DED  2  8D 6A 03               sta BowserGfxFlag
009DF0  2  60           ExBGfxH:  rts                      ;leave!
009DF1  2               
009DF1  2               ProcessBowserHalf:
009DF1  2  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
009DF4  2  20 0C 95           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
009DF7  2  B5 1E              lda Enemy_State,x
009DF9  2  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
009DFB  2  A9 0A              lda #$0a
009DFD  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
009E00  2  20 E1 AE           jsr GetEnemyBoundBox      ;get bounding box coordinates
009E03  2  4C AB A4           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
009E06  2               
009E06  2               ;-------------------------------------------------------------------------------------
009E06  2               ;$00 - used to hold movement force and tile number
009E06  2               ;$01 - used to hold sprite attribute data
009E06  2               
009E06  2               FlameTimerData:
009E06  2  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
009E0A  2  BF 40 40 BF  
009E0E  2               
009E0E  2               SetFlameTimer:
009E0E  2  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
009E11  2  EE 67 03           inc BowserFlameTimerCtrl  ;increment
009E14  2  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
009E17  2  29 07              and #%00000111            ;to keep in range of 0-7
009E19  2  8D 67 03           sta BowserFlameTimerCtrl
009E1C  2  B9 06 9E           lda FlameTimerData,y      ;load value to be used then leave
009E1F  2  60           ExFl: rts
009E20  2               
009E20  2               ProcBowserFlame:
009E20  2  AD 47 07              lda TimerControl            ;if master timer control flag set,
009E23  2  D0 30                 bne SetGfxF                 ;skip all of this
009E25  2  A9 40                 lda #$40                    ;load default movement force
009E27  2  AC CC 06              ldy SecondaryHardMode
009E2A  2  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
009E2C  2  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
009E2E  2  85 00        SFlmX:   sta $00                     ;store value here
009E30  2  BD 01 04              lda Enemy_X_MoveForce,x
009E33  2  38                    sec                         ;subtract value from movement force
009E34  2  E5 00                 sbc $00
009E36  2  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
009E39  2  B5 87                 lda Enemy_X_Position,x
009E3B  2  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
009E3D  2  95 87                 sta Enemy_X_Position,x      ;to the left
009E3F  2  B5 6E                 lda Enemy_PageLoc,x
009E41  2  E9 00                 sbc #$00                    ;subtract borrow from page location
009E43  2  95 6E                 sta Enemy_PageLoc,x
009E45  2  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
009E48  2  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
009E4A  2  D9 AE 91              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
009E4D  2  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
009E4F  2  18                    clc
009E50  2  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
009E53  2  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
009E55  2  20 37 BE     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
009E58  2  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
009E5A  2  D0 C3                 bne ExFl                    ;branch to leave
009E5C  2  A9 51                 lda #$51                    ;otherwise, continue
009E5E  2  85 00                 sta $00                     ;write first tile number
009E60  2  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
009E62  2  A5 09                 lda FrameCounter
009E64  2  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
009E66  2  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
009E68  2  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
009E6A  2  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
009E6C  2  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
009E6F  2  A2 00                 ldx #$00
009E71  2               
009E71  2               DrawFlameLoop:
009E71  2  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
009E74  2  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
009E77  2  A5 00                 lda $00
009E79  2  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
009E7C  2  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
009E7E  2  A5 01                 lda $01
009E80  2  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
009E83  2  AD AE 03              lda Enemy_Rel_XPos
009E86  2  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
009E89  2  18                    clc
009E8A  2  69 08                 adc #$08
009E8C  2  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
009E8F  2  C8                    iny
009E90  2  C8                    iny
009E91  2  C8                    iny
009E92  2  C8                    iny                        ;increment Y four times to move onto the next OAM
009E93  2  E8                    inx                        ;move onto the next OAM, and branch if three
009E94  2  E0 03                 cpx #$03                   ;have not yet been done
009E96  2  90 D9                 bcc DrawFlameLoop
009E98  2  A6 08                 ldx ObjectOffset           ;reload original enemy offset
009E9A  2  20 94 BE              jsr GetEnemyOffscreenBits  ;get offscreen information
009E9D  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
009EA0  2  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
009EA3  2  4A                    lsr                        ;move d0 to carry and result to stack
009EA4  2  48                    pha
009EA5  2  90 05                 bcc M3FOfs                 ;branch if carry not set
009EA7  2  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
009EA9  2  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
009EAC  2  68           M3FOfs:  pla                        ;get bits from stack
009EAD  2  4A                    lsr                        ;move d1 to carry and move bits back to stack
009EAE  2  48                    pha
009EAF  2  90 05                 bcc M2FOfs                 ;branch if carry not set again
009EB1  2  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
009EB3  2  99 08 02              sta Sprite_Y_Position+8,y
009EB6  2  68           M2FOfs:  pla                        ;get bits from stack again
009EB7  2  4A                    lsr                        ;move d2 to carry and move bits back to stack again
009EB8  2  48                    pha
009EB9  2  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
009EBB  2  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
009EBD  2  99 04 02              sta Sprite_Y_Position+4,y
009EC0  2  68           M1FOfs:  pla                        ;get bits from stack one last time
009EC1  2  4A                    lsr                        ;move d3 to carry
009EC2  2  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
009EC4  2  A9 F8                 lda #$f8
009EC6  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
009EC9  2  60           ExFlmeD: rts                        ;leave
009ECA  2               
009ECA  2               ;--------------------------------
009ECA  2               
009ECA  2               RunFireworks:
009ECA  2  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
009ECC  2  D0 0C                   bne SetupExpl               ;if not expired, skip this part
009ECE  2  A9 08                   lda #$08
009ED0  2  95 A0                   sta ExplosionTimerCounter,x ;reset counter
009ED2  2  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
009ED4  2  B5 58                   lda ExplosionGfxCounter,x
009ED6  2  C9 03                   cmp #$03                    ;check explosion graphics counter
009ED8  2  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
009EDA  2  20 37 BE     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
009EDD  2  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
009EE0  2  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
009EE3  2  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
009EE6  2  8D AF 03                sta Fireball_Rel_XPos
009EE9  2  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
009EEC  2  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
009EEE  2  20 F2 B9                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
009EF1  2  60                      rts
009EF2  2               
009EF2  2               FireworksSoundScore:
009EF2  2  A9 00              lda #$00               ;disable enemy buffer flag
009EF4  2  95 0F              sta Enemy_Flag,x
009EF6  2  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
009EF8  2  85 FE              sta Square2SoundQueue
009EFA  2  A9 05              lda #$05               ;set part of score modifier for 500 points
009EFC  2  8D 38 01           sta DigitModifier+4
009EFF  2  4C 70 9F           jmp EndAreaPoints     ;jump to award points accordingly then leave
009F02  2               
009F02  2               ;--------------------------------
009F02  2               
009F02  2               StarFlagYPosAdder:
009F02  2  00 00 08 08        .byte $00, $00, $08, $08
009F06  2               
009F06  2               StarFlagXPosAdder:
009F06  2  00 08 00 08        .byte $00, $08, $00, $08
009F0A  2               
009F0A  2               StarFlagTileData:
009F0A  2  54 55 56 57        .byte $54, $55, $56, $57
009F0E  2               
009F0E  2               RunStarFlagObj:
009F0E  2  A9 00              lda #$00                 ;initialize enemy frenzy buffer
009F10  2  8D CB 06           sta EnemyFrenzyBuffer
009F13  2  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
009F16  2  C9 05              cmp #$05                 ;if greater than 5, branch to exit
009F18  2  B0 31              bcs StarFlagExit
009F1A  2  20 7D 6C           jsr JumpEngine           ;otherwise jump to appropriate sub
009F1D  2               
009F1D  2  4B 9F              .word StarFlagExit
009F1F  2  27 9F              .word GameTimerFireworks
009F21  2  4C 9F              .word AwardGameTimerPoints
009F23  2  7A 9F              .word RaiseFlagSetoffFWorks
009F25  2  CE 9F              .word DelayToAreaEnd
009F27  2               
009F27  2               GameTimerFireworks:
009F27  2  AD EE 07              lda GameTimerDisplay+2 ;check to see if last digit of timer matches
009F2A  2  CD E8 07              cmp CoinDisplay+1      ;the last digit in the coin tally
009F2D  2  D0 10                 bne NoFWks             ;if not, skip the fireworks
009F2F  2  29 01                 and #$01
009F31  2  F0 06                 beq EvenDgs            ;if so, check to see if they are both odd or even
009F33  2  A0 03                 ldy #$03
009F35  2  A9 03                 lda #$03               ;if they are both odd, set state and counter
009F37  2  D0 0A                 bne SetFWC             ;for 3 fireworks to go off
009F39  2  A0 00        EvenDgs: ldy #$00               ;if they are both even, set state and counter
009F3B  2  A9 06                 lda #$06               ;for 6 fireworks to go off
009F3D  2  D0 04                 bne SetFWC
009F3F  2  A0 00        NoFWks:  ldy #$00
009F41  2  A9 FF                 lda #$ff               ;otherwise set value for no fireworks
009F43  2  8D D7 06     SetFWC:  sta FireworksCounter   ;set fireworks counter here
009F46  2  94 1E                 sty Enemy_State,x      ;set whatever state we have in star flag object
009F48  2               
009F48  2               IncrementSFTask1:
009F48  2  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
009F4B  2               
009F4B  2               StarFlagExit:
009F4B  2  60                 rts                      ;leave
009F4C  2               
009F4C  2               AwardGameTimerPoints:
009F4C  2  AD EC 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
009F4F  2  0D ED 07              ora GameTimerDisplay+1
009F52  2  0D EE 07              ora GameTimerDisplay+2
009F55  2  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
009F57  2               AwardTimerCastle:
009F57  2  A5 09                 lda FrameCounter
009F59  2  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
009F5B  2  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
009F5D  2  A9 10                 lda #Sfx_TimerTick
009F5F  2  85 FE                 sta Square2SoundQueue  ;load timer tick sound
009F61  2  A0 17        NoTTick: ldy #$17               ;set offset here to subtract from game timer's last digit
009F63  2  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
009F65  2  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
009F68  2  20 D2 6D              jsr DigitsMathRoutine  ;subtract digit
009F6B  2  A9 05                 lda #$05               ;set now to add 50 points
009F6D  2  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
009F70  2               
009F70  2               EndAreaPoints:
009F70  2  A0 0B                 ldy #$0b               ;load offset for score, then jump to handle the awarding
009F72  2  20 D2 6D              jsr DigitsMathRoutine
009F75  2  A9 02                 lda #$02               ;now update the score on the screen
009F77  2  4C EF 87              jmp WriteDigits
009F7A  2               
009F7A  2               RaiseFlagSetoffFWorks:
009F7A  2  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
009F7C  2  C9 72                 cmp #$72                ;against preset value
009F7E  2  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
009F80  2  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
009F82  2  4C 91 9F              jmp DrawStarFlag        ;and skip this part here
009F85  2  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
009F88  2  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
009F8A  2  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
009F8C  2  A9 16                 lda #Fireworks
009F8E  2  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
009F91  2               
009F91  2               DrawStarFlag:
009F91  2  20 37 BE              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
009F94  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
009F97  2  A2 03                 ldx #$03                   ;do four sprites
009F99  2  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
009F9C  2  18                    clc
009F9D  2  7D 02 9F              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
009FA0  2  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
009FA3  2  BD 0A 9F              lda StarFlagTileData,x     ;get tile number
009FA6  2  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
009FA9  2  A9 22                 lda #$22                   ;set palette and background priority bits
009FAB  2  99 02 02              sta Sprite_Attributes,y    ;store as attributes
009FAE  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
009FB1  2  18                    clc
009FB2  2  7D 06 9F              adc StarFlagXPosAdder,x    ;add X coordinate adder data
009FB5  2  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
009FB8  2  C8                    iny
009FB9  2  C8                    iny                        ;increment OAM data offset four bytes
009FBA  2  C8                    iny                        ;for next sprite
009FBB  2  C8                    iny
009FBC  2  CA                    dex                        ;move onto next sprite
009FBD  2  10 DA                 bpl DSFLoop                ;do this until all sprites are done
009FBF  2  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
009FC1  2  60                    rts
009FC2  2               
009FC2  2               DrawFlagSetTimer:
009FC2  2  20 91 9F           jsr DrawStarFlag          ;do sub to draw star flag
009FC5  2  A9 06              lda #$06
009FC7  2  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
009FCA  2               
009FCA  2               IncrementSFTask2:
009FCA  2  EE 46 07           inc StarFlagTaskControl   ;move onto next task
009FCD  2  60                 rts
009FCE  2               
009FCE  2               DelayToAreaEnd:
009FCE  2  20 91 9F           jsr DrawStarFlag          ;do sub to draw star flag
009FD1  2  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
009FD4  2  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
009FD6  2  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
009FD9  2  F0 EF              beq IncrementSFTask2      ;branch to increment task
009FDB  2               
009FDB  2               StarFlagExit2:
009FDB  2  60                 rts                       ;otherwise leave
009FDC  2               
009FDC  2               ;--------------------------------
009FDC  2               ;$00 - used to store horizontal difference between player and piranha plant
009FDC  2               
009FDC  2               MovePiranhaPlant:
009FDC  2  B5 1E              lda Enemy_State,x           ;check enemy state
009FDE  2  D0 5D              bne PutinPipe               ;if set at all, branch to leave
009FE0  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
009FE3  2  D0 58              bne PutinPipe               ;branch to end if not yet expired
009FE5  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
009FE7  2  D0 23              bne SetupToMovePPlant       ;if moving, skip to part ahead
009FE9  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
009FEB  2  30 14              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
009FED  2  20 D9 AD           jsr PlayerEnemyDiff         ;get horizontal difference between player and
009FF0  2  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
009FF2  2  A5 00              lda $00                     ;otherwise get saved horizontal difference
009FF4  2  49 FF              eor #$ff
009FF6  2  18                 clc                         ;and change to two's compliment
009FF7  2  69 01              adc #$01
009FF9  2  85 00              sta $00                     ;save as new horizontal difference
009FFB  2               
009FFB  2               ChkPlayerNearPipe:
009FFB  2  A5 00              lda $00                     ;get saved horizontal difference
009FFD  2  C9 21              cmp #$21
009FFF  2  90 3C              bcc PutinPipe               ;if player within a certain distance, branch to leave
00A001  2               
00A001  2               ReversePlantSpeed:
00A001  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00A003  2  49 FF              eor #$ff
00A005  2  18                 clc                         ;change to two's compliment
00A006  2  69 01              adc #$01
00A008  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00A00A  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00A00C  2               
00A00C  2               SetupToMovePPlant:
00A00C  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00A00F  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00A011  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00A013  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00A016  2               
00A016  2               RiseFallPiranhaPlant:
00A016  2  85 00               sta $00                     ;save vertical coordinate here
00A018  2  AD 17 B5            lda EnemyAttributeData+PiranhaPlant
00A01B  2  C9 22               cmp #$22                    ;check for red piranha plants
00A01D  2  F0 05               beq RedPP                   ;if found, skip to next part to execute code on every frame
00A01F  2  A5 09               lda FrameCounter            ;get frame counter
00A021  2  4A                  lsr
00A022  2  90 19               bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00A024  2  AD 47 07     RedPP: lda TimerControl            ;get master timer control
00A027  2  D0 14               bne PutinPipe               ;branch to leave if set (likely not necessary)
00A029  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00A02B  2  18                  clc
00A02C  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00A02E  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00A030  2  C5 00               cmp $00                     ;compare against low or high coordinate
00A032  2  D0 09               bne PutinPipe               ;branch to leave if not yet reached
00A034  2  A9 00               lda #$00
00A036  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00A038  2  A9 40               lda #$40
00A03A  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00A03D  2               
00A03D  2               PutinPipe:
00A03D  2  A9 20              lda #%00100000              ;set background priority bit in sprite
00A03F  2  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00A042  2  60                 rts                         ;then leave
00A043  2               
00A043  2               ;-------------------------------------------------------------------------------------
00A043  2               ;$07 - spinning speed
00A043  2               
00A043  2               FirebarSpin:
00A043  2  85 07              sta $07                     ;save spinning speed here
00A045  2  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00A047  2  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00A049  2  A0 18              ldy #$18                    ;possibly residual ldy
00A04B  2  B5 58              lda FirebarSpinState_Low,x
00A04D  2  18                 clc                         ;add spinning speed to what would normally be
00A04E  2  65 07              adc $07                     ;the horizontal speed
00A050  2  95 58              sta FirebarSpinState_Low,x
00A052  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00A054  2  69 00              adc #$00
00A056  2  60                 rts
00A057  2               
00A057  2               SpinCounterClockwise:
00A057  2  A0 08              ldy #$08                    ;possibly residual ldy
00A059  2  B5 58              lda FirebarSpinState_Low,x
00A05B  2  38                 sec                         ;subtract spinning speed to what would normally be
00A05C  2  E5 07              sbc $07                     ;the horizontal speed
00A05E  2  95 58              sta FirebarSpinState_Low,x
00A060  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00A062  2  E9 00              sbc #$00
00A064  2  60                 rts
00A065  2               
00A065  2               
00A065  2               ;-------------------------------------------------------------------------------------
00A065  2               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00A065  2               ;$01 - used to hold high byte of name table for rope
00A065  2               ;$02 - used to hold page location of rope
00A065  2               
00A065  2               BalancePlatform:
00A065  2  B5 B6                lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00A067  2  C9 03                cmp #$03
00A069  2  D0 03                bne DoBPl
00A06B  2  4C CD 95             jmp EraseEnemyObject        ;if far below screen, kill the object
00A06E  2  B5 1E        DoBPl:  lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00A070  2  10 01                bpl CheckBalPlatform        ;if doing other balance platform, branch to handle it
00A072  2  60           ExBalP: rts
00A073  2               
00A073  2               
00A073  2               CheckBalPlatform:
00A073  2  A8                  tay                         ;save offset from state as Y
00A074  2  B9 16 00            lda Enemy_ID,y
00A077  2  C9 24               cmp #$24                    ;check to see if other object is balance platform
00A079  2  D0 F7               bne ExBalP                  ;if not, branch to leave
00A07B  2  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00A07E  2  85 00               sta $00                     ;store here
00A080  2  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00A082  2  F0 03               beq ChkForFall
00A084  2  4C F5 A1            jmp PlatformFall            ;if set, jump here
00A087  2               
00A087  2               ChkForFall:
00A087  2  A9 2D               lda #$2d                    ;check if platform is above a certain point
00A089  2  D5 CF               cmp Enemy_Y_Position,x
00A08B  2  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00A08D  2  C4 00               cpy $00                     ;if collision flag is set to same value as
00A08F  2  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00A091  2  18                  clc
00A092  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00A094  2  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00A096  2  4C EB A1            jmp StopPlatforms           ;to make platforms stop
00A099  2               
00A099  2               MakePlatformFall:
00A099  2  4C D2 A1            jmp InitPlatformFall        ;make platforms fall
00A09C  2               
00A09C  2               ChkOtherForFall:
00A09C  2  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00A09F  2  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00A0A1  2  E4 00               cpx $00                     ;if collision flag is set to same value as
00A0A3  2  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00A0A5  2  18                  clc
00A0A6  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00A0A8  2  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00A0AB  2  4C EB A1            jmp StopPlatforms           ;jump to stop movement and do not return
00A0AE  2               
00A0AE  2               ChkToMoveBalPlat:
00A0AE  2  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00A0B0  2  48                   pha
00A0B1  2  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00A0B4  2  10 18                bpl ColFlg                  ;branch if collision
00A0B6  2  BD 34 04             lda Enemy_Y_MoveForce,x
00A0B9  2  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00A0BA  2  69 05                adc #$05
00A0BC  2  85 00                sta $00                     ;store here
00A0BE  2  B5 A0                lda Enemy_Y_Speed,x
00A0C0  2  69 00                adc #$00                    ;add carry to vertical speed
00A0C2  2  30 1A                bmi PlatDn                  ;branch if moving downwards
00A0C4  2  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00A0C6  2  A5 00                lda $00
00A0C8  2  C9 0B                cmp #$0b                    ;check if there's still a little force left
00A0CA  2  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00A0CC  2  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00A0CE  2  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00A0D0  2  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00A0D2  2  20 88 8B     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00A0D5  2  4C E1 A0             jmp DoOtherPlatform         ;jump ahead to remaining code
00A0D8  2  20 EB A1     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00A0DB  2  4C E1 A0             jmp DoOtherPlatform         ;jump ahead to remaining code
00A0DE  2  20 85 8B     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00A0E1  2               
00A0E1  2               DoOtherPlatform:
00A0E1  2  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00A0E3  2  68                  pla                         ;get old vertical coordinate from stack
00A0E4  2  38                  sec
00A0E5  2  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00A0E7  2  18                  clc
00A0E8  2  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00A0EB  2  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00A0EE  2  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00A0F1  2  30 04               bmi DrawEraseRope
00A0F3  2  AA                  tax                         ;put offset which collision occurred here
00A0F4  2  20 96 A8            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00A0F7  2               
00A0F7  2               DrawEraseRope:
00A0F7  2  A4 08                 ldy ObjectOffset            ;get enemy object offset
00A0F9  2  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00A0FC  2  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00A0FF  2  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00A101  2  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00A104  2  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00A106  2  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00A108  2  B9 A0 00              lda Enemy_Y_Speed,y
00A10B  2  48                    pha                         ;save two copies of vertical speed to stack
00A10C  2  48                    pha
00A10D  2  20 7B A1              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00A110  2  A5 01                 lda $01                     ;write name table address to vram buffer
00A112  2  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00A115  2  A5 00                 lda $00
00A117  2  9D 02 03              sta VRAM_Buffer1+1,x
00A11A  2  A9 02                 lda #$02                    ;set length for 2 bytes
00A11C  2  9D 03 03              sta VRAM_Buffer1+2,x
00A11F  2  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00A122  2  30 0D                 bmi EraseR1                 ;to do something else
00A124  2  A9 A2                 lda #$a2
00A126  2  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00A129  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00A12B  2  9D 05 03              sta VRAM_Buffer1+4,x
00A12E  2  4C 39 A1              jmp OtherRope               ;jump to skip this part
00A131  2  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00A133  2  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00A136  2  9D 05 03              sta VRAM_Buffer1+4,x
00A139  2               
00A139  2               OtherRope:
00A139  2  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00A13C  2  A8                    tay                         ;use as Y here
00A13D  2  68                    pla                         ;pull second copy of vertical speed from stack
00A13E  2  49 FF                 eor #$ff                    ;invert bits to reverse speed
00A140  2  20 7B A1              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00A143  2  A5 01                 lda $01                     ;write name table address to vram buffer
00A145  2  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00A148  2  A5 00                 lda $00                     ;the other platform
00A14A  2  9D 07 03              sta VRAM_Buffer1+6,x
00A14D  2  A9 02                 lda #$02
00A14F  2  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00A152  2  68                    pla                         ;pull first copy of vertical speed from stack
00A153  2  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00A155  2  A9 A2                 lda #$a2
00A157  2  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00A15A  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00A15C  2  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00A15F  2  4C 6A A1              jmp EndRp                   ;jump to skip this part
00A162  2  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00A164  2  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00A167  2  9D 0A 03              sta VRAM_Buffer1+9,x
00A16A  2  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00A16C  2  9D 0B 03              sta VRAM_Buffer1+10,x
00A16F  2  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00A172  2  18                    clc                         ;and store
00A173  2  69 0A                 adc #10
00A175  2  8D 00 03              sta VRAM_Buffer1_Offset
00A178  2  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00A17A  2  60                    rts
00A17B  2               
00A17B  2               SetupPlatformRope:
00A17B  2  48                   pha                     ;save second/third copy to stack
00A17C  2  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00A17F  2  18                   clc
00A180  2  69 08                adc #$08                ;add eight pixels
00A182  2  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00A185  2  D0 03                bne GetLRp              ;use coordinate as-is
00A187  2  18                   clc
00A188  2  69 10                adc #$10                ;otherwise add sixteen more pixels
00A18A  2  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00A18B  2  B9 6E 00             lda Enemy_PageLoc,y
00A18E  2  69 00                adc #$00                ;add carry to page location
00A190  2  85 02                sta $02                 ;and save here
00A192  2  68                   pla                     ;pull modified horizontal coordinate
00A193  2  29 F0                and #%11110000          ;from the stack, mask out low nybble
00A195  2  4A                   lsr                     ;and shift three bits to the right
00A196  2  4A                   lsr
00A197  2  4A                   lsr
00A198  2  85 00                sta $00                 ;store result here as part of name table low byte
00A19A  2  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00A19C  2  68                   pla                     ;get second/third copy of vertical speed from stack
00A19D  2  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00A19F  2  8A                   txa
00A1A0  2  18                   clc
00A1A1  2  69 08                adc #$08                ;add eight to vertical coordinate and
00A1A3  2  AA                   tax                     ;save as X
00A1A4  2  8A           GetHRp: txa                     ;move vertical coordinate to A
00A1A5  2  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00A1A8  2  0A                   asl
00A1A9  2  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00A1AA  2  48                   pha                     ;save modified vertical coordinate to stack
00A1AB  2  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00A1AC  2  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00A1AE  2  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00A1B0  2  85 01                sta $01                 ;address, then store
00A1B2  2  A5 02                lda $02                 ;get saved page location from earlier
00A1B4  2  29 01                and #$01                ;mask out all but LSB
00A1B6  2  0A                   asl
00A1B7  2  0A                   asl                     ;shift twice to the left and save with the
00A1B8  2  05 01                ora $01                 ;rest of the bits of the high byte, to get
00A1BA  2  85 01                sta $01                 ;the proper name table and the right place on it
00A1BC  2  68                   pla                     ;get modified vertical coordinate from stack
00A1BD  2  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00A1BF  2  18                   clc
00A1C0  2  65 00                adc $00                 ;add to horizontal part saved here
00A1C2  2  85 00                sta $00                 ;save as name table low byte
00A1C4  2  B9 CF 00             lda Enemy_Y_Position,y
00A1C7  2  C9 E8                cmp #$e8                ;if vertical position not below the
00A1C9  2  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00A1CB  2  A5 00                lda $00
00A1CD  2  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00A1CF  2  85 00                sta $00
00A1D1  2  60           ExPRp:  rts                     ;leave!
00A1D2  2               
00A1D2  2               InitPlatformFall:
00A1D2  2  98                 tya                        ;move offset of other platform from Y to X
00A1D3  2  AA                 tax
00A1D4  2  20 94 BE           jsr GetEnemyOffscreenBits  ;get offscreen bits
00A1D7  2  A9 06              lda #$06
00A1D9  2  20 7A A6           jsr SetupFloateyNumber     ;award 1000 points to player
00A1DC  2  AD AD 03           lda Player_Rel_XPos
00A1DF  2  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00A1E2  2  A5 CE              lda Player_Y_Position
00A1E4  2  9D 1E 01           sta FloateyNum_Y_Pos,x
00A1E7  2  A9 01              lda #$01                   ;set moving direction as flag for
00A1E9  2  95 46              sta Enemy_MovingDir,x      ;falling platforms
00A1EB  2               
00A1EB  2               StopPlatforms:
00A1EB  2  20 4E 8F           jsr InitVStf             ;initialize vertical speed and low byte
00A1EE  2  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00A1F1  2  99 34 04           sta Enemy_Y_MoveForce,y
00A1F4  2  60                 rts
00A1F5  2               
00A1F5  2               PlatformFall:
00A1F5  2  98                 tya                         ;save offset for other platform to stack
00A1F6  2  48                 pha
00A1F7  2  20 3C 8B           jsr MoveFallingPlatform     ;make current platform fall
00A1FA  2  68                 pla
00A1FB  2  AA                 tax                         ;pull offset from stack and save to X
00A1FC  2  20 3C 8B           jsr MoveFallingPlatform     ;make other platform fall
00A1FF  2  A6 08              ldx ObjectOffset
00A201  2  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00A204  2  30 04              bmi ExPF                    ;skip this part
00A206  2  AA                 tax                         ;transfer collision flag offset as offset to X
00A207  2  20 96 A8           jsr PositionPlayerOnVPlat   ;and position player appropriately
00A20A  2  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00A20C  2  60                 rts
00A20D  2               
00A20D  2               ;--------------------------------
00A20D  2               
00A20D  2               YMovingPlatform:
00A20D  2  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00A20F  2  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00A212  2  D0 15                bne ChkYCenterPos
00A214  2  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00A217  2  B5 CF                lda Enemy_Y_Position,x
00A219  2  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00A21C  2  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00A21E  2  A5 09                lda FrameCounter
00A220  2  29 07                and #%00000111               ;check for every eighth frame
00A222  2  D0 02                bne SkipIY
00A224  2  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00A226  2  4C 38 A2     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00A229  2               
00A229  2               ChkYCenterPos:
00A229  2  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00A22B  2  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00A22D  2  90 06                bcc YMDown
00A22F  2  20 88 8B             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00A232  2  4C 38 A2             jmp ChkYPCollision
00A235  2  20 85 8B     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00A238  2               
00A238  2               ChkYPCollision:
00A238  2  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00A23B  2  30 03               bmi ExYPl                    ;to leave
00A23D  2  20 96 A8            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00A240  2  60           ExYPl: rts                          ;leave
00A241  2               
00A241  2               ;--------------------------------
00A241  2               ;$00 - used as adder to position player hotizontally
00A241  2               
00A241  2               XMovingPlatform:
00A241  2  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00A243  2  20 7C 97           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00A246  2  20 9B 97           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00A249  2  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00A24C  2  30 1C              bmi ExXMP                    ;branch ahead to leave
00A24E  2               
00A24E  2               PositionPlayerOnHPlat:
00A24E  2  A5 86                 lda Player_X_Position
00A250  2  18                    clc                       ;add saved value from second subroutine to
00A251  2  65 00                 adc $00                   ;current player's position to position
00A253  2  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00A255  2  A5 6D                 lda Player_PageLoc        ;get player's page location
00A257  2  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00A259  2  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00A25B  2  69 00                 adc #$00                  ;otherwise add carry to page location
00A25D  2  4C 62 A2              jmp SetPVar               ;jump to skip subtraction
00A260  2  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00A262  2  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00A264  2  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00A267  2  20 96 A8              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00A26A  2  60           ExXMP:   rts                       ;and we are done here
00A26B  2               
00A26B  2               ;--------------------------------
00A26B  2               
00A26B  2               DropPlatform:
00A26B  2  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00A26E  2  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00A270  2  20 59 8B            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00A273  2  20 96 A8            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00A276  2  60           ExDPl: rts                          ;leave
00A277  2               
00A277  2               ;--------------------------------
00A277  2               ;$00 - residual value from sub
00A277  2               
00A277  2               RightPlatform:
00A277  2  20 D3 8A            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00A27A  2  85 00               sta $00                       ;store saved value here (residual code)
00A27C  2  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00A27F  2  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00A281  2  A9 10               lda #$10
00A283  2  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00A285  2  20 4E A2            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00A288  2  60           ExRPl: rts                           ;then leave
00A289  2               
00A289  2               ;--------------------------------
00A289  2               
00A289  2               MoveLargeLiftPlat:
00A289  2  20 95 A2           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00A28C  2  4C 38 A2           jmp ChkYPCollision     ;branch to position player correctly
00A28F  2               
00A28F  2               MoveSmallPlatform:
00A28F  2  20 95 A2           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00A292  2  4C AB A2           jmp ChkSmallPlatCollision  ;branch to position player correctly
00A295  2               
00A295  2               MoveLiftPlatforms:
00A295  2  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00A298  2  D0 19              bne ExLiftP              ;and branch to leave
00A29A  2  BD 17 04           lda Enemy_YMF_Dummy,x
00A29D  2  18                 clc                      ;add contents of movement amount to whatever's here
00A29E  2  7D 34 04           adc Enemy_Y_MoveForce,x
00A2A1  2  9D 17 04           sta Enemy_YMF_Dummy,x
00A2A4  2  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00A2A6  2  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00A2A8  2  95 CF              sta Enemy_Y_Position,x   ;and then leave
00A2AA  2  60                 rts
00A2AB  2               
00A2AB  2               ChkSmallPlatCollision:
00A2AB  2  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00A2AE  2  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00A2B0  2  20 8E A8              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00A2B3  2  60           ExLiftP: rts                         ;then leave
00A2B4  2               
00A2B4  2               ;-------------------------------------------------------------------------------------
00A2B4  2               ;$00 - page location of extended left boundary
00A2B4  2               ;$01 - extended left boundary position
00A2B4  2               ;$02 - page location of extended right boundary
00A2B4  2               ;$03 - extended right boundary position
00A2B4  2               
00A2B4  2               OffscreenBoundsCheck:
00A2B4  2  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00A2B6  2  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00A2B8  2  F0 5D                  beq ExScrnBd
00A2BA  2  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00A2BD  2  B4 16                  ldy Enemy_ID,x
00A2BF  2  C0 05                  cpy #HammerBro          ;check for hammer bro object
00A2C1  2  F0 08                  beq LimitB
00A2C3  2  C0 04                  cpy #UpsideDownPiranhaP ;check for upside-down piranha plant object
00A2C5  2  F0 04                  beq LimitB
00A2C7  2  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00A2C9  2  D0 02                  bne ExtendLB            ;these three will be erased sooner than others if too far left
00A2CB  2  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00A2CD  2  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00A2CF  2  85 01                  sta $01                 ;store result here
00A2D1  2  AD 1A 07               lda ScreenLeft_PageLoc
00A2D4  2  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00A2D6  2  85 00                  sta $00                 ;store result here
00A2D8  2  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00A2DB  2  69 48                  adc #$48
00A2DD  2  85 03                  sta $03                 ;store result here
00A2DF  2  AD 1B 07               lda ScreenRight_PageLoc
00A2E2  2  69 00                  adc #$00                ;then add the carry to the page location
00A2E4  2  85 02                  sta $02                 ;and store result here
00A2E6  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00A2E8  2  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00A2EA  2  B5 6E                  lda Enemy_PageLoc,x
00A2EC  2  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00A2EE  2  30 24                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00A2F0  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00A2F2  2  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00A2F4  2  B5 6E                  lda Enemy_PageLoc,x
00A2F6  2  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00A2F8  2  30 1D                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00A2FA  2  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00A2FC  2  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00A2FE  2  F0 17                  beq ExScrnBd
00A300  2  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00A302  2  F0 13                  beq ExScrnBd
00A304  2  C0 04                  cpy #UpsideDownPiranhaP ;if upside-down piranha plant, do not erase
00A306  2  F0 0F                  beq ExScrnBd
00A308  2  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00A30A  2  F0 0B                  beq ExScrnBd
00A30C  2  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00A30E  2  F0 07                  beq ExScrnBd
00A310  2  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00A312  2  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00A314  2  20 CD 95     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00A317  2  60           ExScrnBd: rts                     ;leave
00A318  2               
00A318  2               ;unused space
00A318  2  FF            .byte $ff
00A319  2               
00A319  2               ;-------------------------------------------------------------------------------------
00A319  2               ;$01 - enemy buffer offset
00A319  2               
00A319  2               FireballEnemyCollision:
00A319  2  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00A31B  2  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00A31D  2  0A                 asl
00A31E  2  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00A320  2  A5 09              lda FrameCounter
00A322  2  4A                 lsr                   ;get LSB of frame counter
00A323  2  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00A325  2  8A                 txa
00A326  2  0A                 asl                   ;multiply fireball offset by four
00A327  2  0A                 asl
00A328  2  18                 clc
00A329  2  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00A32B  2  A8                 tay                   ;to use fireball's bounding box coordinates
00A32C  2  A2 04              ldx #$04
00A32E  2               
00A32E  2               FireballEnemyCDLoop:
00A32E  2  86 01                   stx $01                     ;store enemy object offset here
00A330  2  98                      tya
00A331  2  48                      pha                         ;push fireball offset to the stack
00A332  2  B5 1E                   lda Enemy_State,x
00A334  2  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00A336  2  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00A338  2  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00A33A  2  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00A33C  2  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00A33E  2  C9 24                   cmp #$24
00A340  2  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00A342  2  C9 2B                   cmp #$2b
00A344  2  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00A346  2  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00A348  2  D0 06                   bne NotGoomba               ;if not found, continue with code
00A34A  2  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00A34C  2  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00A34E  2  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00A350  2  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00A353  2  D0 17                   bne NoFToECol               ;skip to next enemy slot
00A355  2  8A                      txa
00A356  2  0A                      asl                         ;otherwise multiply enemy offset by four
00A357  2  0A                      asl
00A358  2  18                      clc
00A359  2  69 04                   adc #$04                    ;add 4 bytes to it
00A35B  2  AA                      tax                         ;to use enemy's bounding box coordinates
00A35C  2  20 C5 AF                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00A35F  2  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00A361  2  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00A363  2  A9 80                   lda #%10000000
00A365  2  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00A367  2  A6 01                   ldx $01                     ;get enemy offset
00A369  2  20 7F A3                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00A36C  2  68           NoFToECol: pla                         ;pull fireball offset from stack
00A36D  2  A8                      tay                         ;put it in Y
00A36E  2  A6 01                   ldx $01                     ;get enemy object offset
00A370  2  CA                      dex                         ;decrement it
00A371  2  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00A373  2               
00A373  2               ExitFBallEnemy:
00A373  2  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00A375  2  60                 rts
00A376  2               
00A376  2               BowserIdentities:
00A376  2  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser, Bowser
00A37A  2  11 07 05 2D  
00A37E  2  2D           
00A37F  2               
00A37F  2               HandleEnemyFBallCol:
00A37F  2  20 37 BE           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00A382  2  A6 01              ldx $01                    ;get current enemy object offset
00A384  2  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00A386  2  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00A388  2  29 0F              and #%00001111             ;otherwise mask out high nybble and
00A38A  2  AA                 tax                        ;use low nybble as enemy offset
00A38B  2  B5 16              lda Enemy_ID,x
00A38D  2  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00A38F  2  F0 0C              beq HurtBowser             ;branch if found
00A391  2  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00A393  2               
00A393  2               ChkBuzzyBeetle:
00A393  2  B5 16              lda Enemy_ID,x
00A395  2  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00A397  2  F0 76              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00A399  2  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00A39B  2  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00A39D  2               
00A39D  2               HurtBowser:
00A39D  2  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00A3A0  2  D0 6D                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00A3A2  2  20 4E 8F               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00A3A5  2  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00A3A7  2  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00A3AA  2  A9 FE                  lda #$fe
00A3AC  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00A3AE  2  AC 5F 07               ldy WorldNumber            ;use world number as offset
00A3B1  2  B9 76 A3               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00A3B4  2  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00A3B6  2  A9 20                  lda #$20                   ;set A to use starting value for state
00A3B8  2  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00A3BA  2  B0 02                  bcs SetDBSte               ;branch if so
00A3BC  2  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00A3BE  2  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00A3C0  2  A9 80                  lda #Sfx_BowserFall
00A3C2  2  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00A3C4  2  A6 01                  ldx $01                    ;get enemy offset
00A3C6  2  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00A3C8  2  D0 3E                  bne EnemySmackScore        ;unconditional branch to award points
00A3CA  2               
00A3CA  2               ChkOtherEnemies:
00A3CA  2  C9 08              cmp #BulletBill_FrenzyVar
00A3CC  2  F0 41              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00A3CE  2  C9 0C              cmp #Podoboo
00A3D0  2  F0 3D              beq ExHCF                 ;branch to leave if podoboo
00A3D2  2  C9 15              cmp #$15
00A3D4  2  B0 39              bcs ExHCF                 ;branch to leave if identifier => $15
00A3D6  2               
00A3D6  2               ShellOrBlockDefeat:
00A3D6  2  B5 16               lda Enemy_ID,x            ;check for both kinds of piranha plant
00A3D8  2  C9 04               cmp #UpsideDownPiranhaP
00A3DA  2  F0 04               beq DinP
00A3DC  2  C9 0D               cmp #PiranhaPlant
00A3DE  2  D0 0D               bne StnE                  ;branch if not found
00A3E0  2  A8           DinP:  tay
00A3E1  2  B5 CF               lda Enemy_Y_Position,x
00A3E3  2  69 18               adc #$18                  ;add 24 pixels to enemy object's vertical position
00A3E5  2  C0 04               cpy #UpsideDownPiranhaP   ;to put defeated piranha plant back in pipe
00A3E7  2  D0 02               bne SetDY
00A3E9  2  E9 31               sbc #$31                  ;subtract 49 pixels to vertical position to put
00A3EB  2  95 CF        SetDY: sta Enemy_Y_Position,x    ;defeated upside down piranha plant back in pipe
00A3ED  2  20 A3 AC     StnE:  jsr ChkToStunEnemies      ;do yet another sub
00A3F0  2  B5 1E               lda Enemy_State,x
00A3F2  2  29 1F               and #%00011111            ;mask out 2 MSB of enemy object's state
00A3F4  2  09 20               ora #%00100000            ;set d5 to defeat enemy and save as new state
00A3F6  2  95 1E               sta Enemy_State,x
00A3F8  2  A9 02               lda #$02                  ;award 200 points by default
00A3FA  2  B4 16               ldy Enemy_ID,x            ;check for hammer bro
00A3FC  2  C0 05               cpy #HammerBro
00A3FE  2  D0 02               bne GoombaPoints          ;branch if not found
00A400  2  A9 06               lda #$06                  ;award 1000 points for hammer bro
00A402  2               
00A402  2               GoombaPoints:
00A402  2  C0 06              cpy #Goomba               ;check for goomba
00A404  2  D0 02              bne EnemySmackScore       ;branch if not found
00A406  2  A9 01              lda #$01                  ;award 100 points for goomba
00A408  2               
00A408  2               EnemySmackScore:
00A408  2  20 7A A6            jsr SetupFloateyNumber   ;update necessary score variables
00A40B  2  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00A40D  2  85 FF               sta Square1SoundQueue
00A40F  2  60           ExHCF: rts                      ;and now let's leave
00A410  2               
00A410  2               ;-------------------------------------------------------------------------------------
00A410  2               
00A410  2               PlayerHammerCollision:
00A410  2  A5 09                lda FrameCounter          ;get frame counter
00A412  2  4A                   lsr                       ;shift d0 into carry
00A413  2  90 39                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00A415  2  AD D0 03             lda Player_OffscreenBits  ;if player offscreen bits, master timer control
00A418  2  0D 47 07             ora TimerControl          ;or any offscreen bits for hammer are set
00A41B  2  0D D6 03             ora Misc_OffscreenBits    ;then branch to leave
00A41E  2  D0 2E                bne ExPHC
00A420  2  8A                   txa
00A421  2  0A                   asl                       ;multiply misc object offset by four
00A422  2  0A                   asl
00A423  2  18                   clc
00A424  2  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00A426  2  A8                   tay                       ;for misc object bounding box coordinates
00A427  2  20 C3 AF             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00A42A  2  A6 08                ldx ObjectOffset          ;get misc object offset
00A42C  2  90 1B                bcc ClHCol                ;if no collision, then branch
00A42E  2  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00A431  2  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00A433  2  A9 01                lda #$01
00A435  2  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00A438  2  B5 64                lda Misc_X_Speed,x
00A43A  2  49 FF                eor #$ff                  ;get two's compliment of
00A43C  2  18                   clc                       ;hammer's horizontal speed
00A43D  2  69 01                adc #$01
00A43F  2  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00A441  2  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00A444  2  D0 08                bne ExPHC                 ;branch to leave
00A446  2  4C 87 A5             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00A449  2  A9 00        ClHCol: lda #$00                  ;clear collision flag
00A44B  2  9D BE 06             sta Misc_Collision_Flag,x
00A44E  2  60           ExPHC:  rts
00A44F  2               
00A44F  2               ;-------------------------------------------------------------------------------------
00A44F  2               
00A44F  2               HandlePowerUpCollision:
00A44F  2  20 CD 95           jsr EraseEnemyObject    ;erase the power-up object
00A452  2  A5 39              lda PowerUpType
00A454  2  C9 04              cmp #$04                ;check power-up type
00A456  2  D0 03              bne Safe                ;if not a poison shroom, branch
00A458  2  4C 87 A5           jmp InjurePlayer        ;otherwise injure the player properly
00A45B  2  A9 06        Safe: lda #$06
00A45D  2  20 7A A6           jsr SetupFloateyNumber  ;award 1000 points to player by default
00A460  2  A9 20              lda #Sfx_PowerUpGrab
00A462  2  85 FE              sta Square2SoundQueue   ;play the power-up sound
00A464  2  A5 39              lda PowerUpType         ;check power-up type
00A466  2  C9 02              cmp #$02
00A468  2  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00A46A  2  C9 03              cmp #$03
00A46C  2  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00A46E  2  A9 23              lda #$23                ;otherwise set star mario invincibility
00A470  2  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00A473  2  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00A475  2  85 FB              sta AreaMusicQueue
00A477  2  60                 rts
00A478  2               
00A478  2               Shroom_Flower_PUp:
00A478  2  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00A47B  2  F0 1B              beq UpToSuper
00A47D  2  C9 01              cmp #$01            ;if player status not super, leave
00A47F  2  D0 23              bne NoPUp
00A481  2  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00A483  2  A9 02              lda #$02            ;set player status to fiery
00A485  2  8D 56 07           sta PlayerStatus
00A488  2  20 4D 65           jsr GetPlayerColors ;run sub to change colors of player
00A48B  2  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00A48D  2  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00A48F  2  4C 9F A4           jmp UpToFiery       ;jump to set values accordingly
00A492  2               
00A492  2               SetFor1Up:
00A492  2  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00A494  2  9D 10 01           sta FloateyNum_Control,x ;and then leave
00A497  2  60                 rts
00A498  2               
00A498  2               UpToSuper:
00A498  2  A9 01               lda #$01         ;set player status to super
00A49A  2  8D 56 07            sta PlayerStatus
00A49D  2  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00A49F  2               
00A49F  2               UpToFiery:
00A49F  2  A0 00               ldy #$00         ;set value to be used as new player state
00A4A1  2  20 A6 A5            jsr SetPRout     ;set values to stop certain things in motion
00A4A4  2  60           NoPUp: rts
00A4A5  2               
00A4A5  2               ;--------------------------------
00A4A5  2               
00A4A5  2               ResidualXSpdData:
00A4A5  2  18 E8              .byte $18, $e8
00A4A7  2               
00A4A7  2               KickedShellXSpdData:
00A4A7  2  30 D0              .byte $30, $d0
00A4A9  2               
00A4A9  2               DemotedKoopaXSpdData:
00A4A9  2  08 F8              .byte $08, $f8
00A4AB  2               
00A4AB  2               PlayerEnemyCollision:
00A4AB  2  A5 09                 lda FrameCounter            ;check counter for d0 set
00A4AD  2  4A                    lsr
00A4AE  2  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00A4B0  2  20 B6 A8              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00A4B3  2  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00A4B5  2  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00A4B8  2  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00A4BA  2  A5 0E                 lda GameEngineSubroutine
00A4BC  2  C9 08                 cmp #$08                    ;if not set to run player control routine
00A4BE  2  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00A4C0  2  B5 1E                 lda Enemy_State,x
00A4C2  2  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00A4C4  2  D0 12                 bne NoPECol
00A4C6  2  20 C0 A8              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00A4C9  2  20 C3 AF              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00A4CC  2  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00A4CE  2  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00A4D0  2  BD 91 04              lda Enemy_CollisionBits,x
00A4D3  2  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00A4D5  2  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00A4D8  2  60           NoPECol: rts
00A4D9  2               
00A4D9  2               CheckForPUpCollision:
00A4D9  2  B4 16               ldy Enemy_ID,x
00A4DB  2  C0 2E               cpy #PowerUpObject            ;check for power-up object
00A4DD  2  D0 03               bne EColl                     ;if not found, branch to next part
00A4DF  2  4C 4F A4            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00A4E2  2  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00A4E5  2  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00A4E7  2  4C D6 A3            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00A4EA  2               
00A4EA  2               KickedShellPtsData:
00A4EA  2  0A 06 04           .byte $0a, $06, $04
00A4ED  2               
00A4ED  2               HandlePECollisions:
00A4ED  2  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00A4F0  2  29 01               and #%00000001               ;or for being offscreen at all
00A4F2  2  1D D8 03            ora EnemyOffscrBitsMasked,x
00A4F5  2  D0 5D               bne ExPEC                    ;branch to leave if either is true
00A4F7  2  A9 01               lda #$01
00A4F9  2  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00A4FC  2  9D 91 04            sta Enemy_CollisionBits,x
00A4FF  2  C0 12               cpy #Spiny                   ;branch if spiny
00A501  2  F0 52               beq ChkForPlayerInjury
00A503  2  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00A505  2  F0 4E               beq ChkForPlayerInjury
00A507  2  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00A509  2  F0 7C               beq InjurePlayer
00A50B  2  C0 04               cpy #UpsideDownPiranhaP      ;branch if upside-down piranha plant
00A50D  2  F0 78               beq InjurePlayer
00A50F  2  C0 0C               cpy #Podoboo                 ;branch if podoboo
00A511  2  F0 74               beq InjurePlayer
00A513  2  C0 15               cpy #$15                     ;branch if object => $15
00A515  2  B0 70               bcs InjurePlayer
00A517  2  AD 4E 07            lda AreaType                 ;branch if water type level
00A51A  2  F0 6B               beq InjurePlayer
00A51C  2  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00A51E  2  0A                  asl
00A51F  2  B0 34               bcs ChkForPlayerInjury
00A521  2  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00A523  2  29 07               and #%00000111
00A525  2  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00A527  2  90 2C               bcc ChkForPlayerInjury
00A529  2  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00A52B  2  C9 06               cmp #Goomba
00A52D  2  F0 25               beq ExPEC
00A52F  2  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00A531  2  85 FF               sta Square1SoundQueue
00A533  2  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00A535  2  09 80               ora #%10000000
00A537  2  95 1E               sta Enemy_State,x
00A539  2  20 6E A6            jsr EnemyFacePlayer          ;set moving direction and get offset
00A53C  2  B9 A7 A4            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00A53F  2  95 58               sta Enemy_X_Speed,x
00A541  2  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00A543  2  18                  clc                          ;to give points for kicking the shell
00A544  2  6D 84 04            adc StompChainCounter
00A547  2  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00A54A  2  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00A54C  2  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00A54E  2  B9 EA A4            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00A551  2  20 7A A6     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00A554  2  60           ExPEC: rts                          ;leave!!!
00A555  2               
00A555  2               ChkForPlayerInjury:
00A555  2  A4 9F                  ldy Player_Y_Speed     ;check player's vertical speed
00A557  2  88                     dey                    ;branch elsewhere if player is not moving downwards
00A558  2  10 6D                  bpl EnemyStomped
00A55A  2  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00A55C  2  C9 07                  cmp #Bloober
00A55E  2  90 09                  bcc ChkETmrs
00A560  2  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00A562  2  18                     clc
00A563  2  69 0C                  adc #$0c
00A565  2  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00A567  2  90 5E                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00A569  2  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00A56C  2  D0 59                  bne EnemyStomped       ;branch if set
00A56E  2  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00A571  2  D0 40                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00A573  2  AD AD 03               lda Player_Rel_XPos
00A576  2  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00A579  2  90 03                  bcc TInjE              ;relative position, branch here
00A57B  2  4C 5F A6               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00A57E  2  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00A580  2  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00A582  2  D0 03                  bne InjurePlayer       ;to turn the enemy around
00A584  2  4C 68 A6               jmp LInj
00A587  2               
00A587  2               InjurePlayer:
00A587  2  AD 9E 07           lda InjuryTimer          ;check again to see if either of the two
00A58A  2  0D 9F 07           ora StarInvincibleTimer  ;invincibility timers have expired, branch if not
00A58D  2  D0 24              bne ExInjColRoutines
00A58F  2               
00A58F  2               ForceInjury:
00A58F  2  AE 56 07               ldx PlayerStatus          ;check player's status
00A592  2  F0 22                  beq KillPlayer            ;branch if small
00A594  2  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00A597  2  A9 08                  lda #$08
00A599  2  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00A59C  2  0A                     asl
00A59D  2  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00A59F  2  20 4D 65               jsr GetPlayerColors       ;change player's palette if necessary
00A5A2  2  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00A5A4  2  A0 01        SetKRout: ldy #$01                  ;set new player state
00A5A6  2  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00A5A8  2  84 1D                  sty Player_State          ;store new player state
00A5AA  2  A0 FF                  ldy #$ff
00A5AC  2  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00A5AF  2  C8                     iny
00A5B0  2  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00A5B3  2               
00A5B3  2               ExInjColRoutines:
00A5B3  2  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00A5B5  2  60                 rts
00A5B6  2               
00A5B6  2               KillPlayer:
00A5B6  2  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00A5B8  2  E8                 inx
00A5B9  2  86 FC              stx EventMusicQueue  ;set event music queue to death music
00A5BB  2  A9 FC              lda #$fc
00A5BD  2  85 9F              sta Player_Y_Speed   ;set new vertical speed
00A5BF  2  A9 0B              lda #$0b             ;set subroutine to run on next frame
00A5C1  2  D0 E1              bne SetKRout         ;branch to set player's state and other things
00A5C3  2               
00A5C3  2               StompedEnemyPtsData:
00A5C3  2  02 06 05 06        .byte $02, $06, $05, $06
00A5C7  2               
00A5C7  2               EnemyStomped:
00A5C7  2  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00A5C9  2  C9 12              cmp #Spiny                 ;if found
00A5CB  2  F0 BA              beq InjurePlayer
00A5CD  2  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00A5CF  2  85 FF              sta Square1SoundQueue
00A5D1  2  B5 16              lda Enemy_ID,x
00A5D3  2  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00A5D5  2  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00A5D7  2  F0 1B              beq EnemyStompedPts
00A5D9  2  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00A5DB  2  F0 17              beq EnemyStompedPts
00A5DD  2  C9 33              cmp #BulletBill_CannonVar
00A5DF  2  F0 13              beq EnemyStompedPts
00A5E1  2  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00A5E3  2  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00A5E5  2  C8                 iny                        ;increment points data offset
00A5E6  2  C9 05              cmp #HammerBro             ;branch for hammer bro
00A5E8  2  F0 0A              beq EnemyStompedPts
00A5EA  2  C8                 iny                        ;increment points data offset
00A5EB  2  C9 11              cmp #Lakitu                ;branch for lakitu
00A5ED  2  F0 05              beq EnemyStompedPts
00A5EF  2  C8                 iny                        ;increment points data offset
00A5F0  2  C9 07              cmp #Bloober               ;branch if NOT bloober
00A5F2  2  D0 1B              bne ChkForDemoteKoopa
00A5F4  2               
00A5F4  2               EnemyStompedPts:
00A5F4  2  B9 C3 A5           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00A5F7  2  20 7A A6           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00A5FA  2  B5 46              lda Enemy_MovingDir,x
00A5FC  2  48                 pha                        ;save enemy movement direction to stack
00A5FD  2  20 C1 AC           jsr NoDemote               ;run sub to kill enemy
00A600  2  68                 pla
00A601  2  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00A603  2  A9 20              lda #%00100000
00A605  2  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00A607  2  20 4E 8F           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00A60A  2  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00A60C  2  4C 4E A6           jmp SetBounce
00A60F  2               
00A60F  2               ChkForDemoteKoopa:
00A60F  2  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00A611  2  90 1E              bcc HandleStompedShellE
00A613  2  20 4E A6           jsr SetBounce
00A616  2  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00A618  2  95 16              sta Enemy_ID,x
00A61A  2  A9 00              lda #$00                   ;return enemy to normal state
00A61C  2  95 1E              sta Enemy_State,x
00A61E  2  A9 03              lda #$03                   ;award 400 points to the player
00A620  2  20 7A A6           jsr SetupFloateyNumber
00A623  2  20 4E 8F           jsr InitVStf               ;nullify physics-related thing and vertical speed
00A626  2  20 6E A6           jsr EnemyFacePlayer        ;turn enemy around if necessary
00A629  2  B9 A9 A4           lda DemotedKoopaXSpdData,y
00A62C  2  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00A62E  2  60                 rts
00A62F  2               
00A62F  2               RevivalRateData:
00A62F  2  10 0B              .byte $10, $0b
00A631  2               
00A631  2               HandleStompedShellE:
00A631  2  A9 04               lda #$04                   ;set defeated state for enemy
00A633  2  95 1E               sta Enemy_State,x
00A635  2  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00A638  2  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00A63B  2  18                  clc                        ;to whatever is in the stomp timer
00A63C  2  6D 91 07            adc StompTimer
00A63F  2  20 7A A6            jsr SetupFloateyNumber     ;award points accordingly
00A642  2  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00A645  2  AC 6A 07            ldy PrimaryHardMode        ;check primary hard mode flag
00A648  2  B9 2F A6            lda RevivalRateData,y      ;load timer setting according to flag
00A64B  2  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00A64E  2               SetBounce:
00A64E  2  A0 FA               ldy #$fa                   ;set a regular bounce rate for all other enemies
00A650  2  B5 16               lda Enemy_ID,x
00A652  2  C9 0F               cmp #RedParatroopa         ;set a higher bounce rate for red paratroopas
00A654  2  F0 04               beq BnceH                  ;and green paratroopas that fly
00A656  2  C9 10               cmp #GreenParatroopaFly
00A658  2  D0 02               bne BnceL
00A65A  2  A0 F8        BnceH: ldy #$f8                   ;set player's vertical speed for bounce
00A65C  2  84 9F        BnceL: sty Player_Y_Speed         ;and then leave!!!
00A65E  2  60                  rts
00A65F  2               
00A65F  2               ChkEnemyFaceRight:
00A65F  2  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00A661  2  C9 01               cmp #$01
00A663  2  D0 03               bne LInj              ;if not, branch
00A665  2  4C 87 A5            jmp InjurePlayer      ;otherwise go back to hurt player
00A668  2  20 8D A7     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00A66B  2  4C 87 A5            jmp InjurePlayer      ;go back to hurt player
00A66E  2               
00A66E  2               EnemyFacePlayer:
00A66E  2  A0 01               ldy #$01               ;set to move right by default
00A670  2  20 D9 AD            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00A673  2  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00A675  2  C8                  iny                    ;otherwise, increment to set to move to the left
00A676  2  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00A678  2  88                  dey                    ;then decrement to use as a proper offset
00A679  2  60                  rts
00A67A  2               
00A67A  2               SetupFloateyNumber:
00A67A  2  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00A67D  2  A9 30               lda #$30
00A67F  2  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00A682  2  B5 CF               lda Enemy_Y_Position,x
00A684  2  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00A687  2  AD AE 03            lda Enemy_Rel_XPos
00A68A  2  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00A68D  2  60           ExSFN: rts
00A68E  2               
00A68E  2               ;-------------------------------------------------------------------------------------
00A68E  2               ;$01 - used to hold enemy offset for second enemy
00A68E  2               
00A68E  2               SetBitsMask:
00A68E  2  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00A692  2  08 04 02     
00A695  2               
00A695  2               ClearBitsMask:
00A695  2  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00A699  2  F7 FB FD     
00A69C  2               
00A69C  2               EnemiesCollision:
00A69C  2  A5 09                lda FrameCounter            ;check counter for d0 set
00A69E  2  4A                   lsr
00A69F  2  90 EC                bcc ExSFN                   ;if d0 not set, leave
00A6A1  2  AD 4E 07             lda AreaType
00A6A4  2  F0 E7                beq ExSFN                   ;if water area type, leave
00A6A6  2  B5 16                lda Enemy_ID,x
00A6A8  2  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00A6AA  2  B0 76                bcs ExitECRoutine
00A6AC  2  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00A6AE  2  F0 72                beq ExitECRoutine
00A6B0  2  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00A6B2  2  F0 6E                beq ExitECRoutine
00A6B4  2  C9 04                cmp #UpsideDownPiranhaP     ;if upside-down piranha plant, branch to leave
00A6B6  2  F0 6A                beq ExitECRoutine
00A6B8  2  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00A6BB  2  D0 65                bne ExitECRoutine
00A6BD  2  20 C0 A8             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00A6C0  2  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00A6C1  2  30 5F                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00A6C3  2  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00A6C5  2  98                   tya                         ;save first enemy's bounding box offset to stack
00A6C6  2  48                   pha
00A6C7  2  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00A6C9  2  F0 50                beq ReadyNextEnemy          ;branch if flag not set
00A6CB  2  B5 16                lda Enemy_ID,x
00A6CD  2  C9 15                cmp #$15                    ;check for enemy object => $15
00A6CF  2  B0 4A                bcs ReadyNextEnemy          ;branch if true
00A6D1  2  C9 11                cmp #Lakitu
00A6D3  2  F0 46                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00A6D5  2  C9 0D                cmp #PiranhaPlant
00A6D7  2  F0 42                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00A6D9  2  C9 04                cmp #UpsideDownPiranhaP
00A6DB  2  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is upside-down piranha plant
00A6DD  2  BD D8 03             lda EnemyOffscrBitsMasked,x
00A6E0  2  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00A6E2  2  8A                   txa                         ;get second enemy object's bounding box offset
00A6E3  2  0A                   asl                         ;multiply by four, then add four
00A6E4  2  0A                   asl
00A6E5  2  18                   clc
00A6E6  2  69 04                adc #$04
00A6E8  2  AA                   tax                         ;use as new contents of X
00A6E9  2  20 C5 AF             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00A6EC  2  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00A6EE  2  A4 01                ldy $01                     ;use second enemy offset for Y
00A6F0  2  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00A6F2  2  B5 1E                lda Enemy_State,x
00A6F4  2  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00A6F7  2  29 80                and #%10000000
00A6F9  2  D0 11                bne YesEC                   ;branch if at least one of them is set
00A6FB  2  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00A6FE  2  3D 8E A6             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00A701  2  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00A703  2  B9 91 04             lda Enemy_CollisionBits,y
00A706  2  1D 8E A6             ora SetBitsMask,x           ;if the bit is not set, set it now
00A709  2  99 91 04             sta Enemy_CollisionBits,y
00A70C  2  20 25 A7     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00A70F  2  4C 1B A7             jmp ReadyNextEnemy          ;move onto next enemy slot
00A712  2               
00A712  2               NoEnemyCollision:
00A712  2  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00A715  2  3D 95 A6           and ClearBitsMask,x           ;clear bit connected to second enemy
00A718  2  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00A71B  2               
00A71B  2               ReadyNextEnemy:
00A71B  2  68                 pla              ;get first enemy's bounding box offset from the stack
00A71C  2  A8                 tay              ;use as Y again
00A71D  2  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00A71F  2  CA                 dex
00A720  2  10 A1              bpl ECLoop       ;loop until all enemy slots have been checked
00A722  2               
00A722  2               ExitECRoutine:
00A722  2  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00A724  2  60                 rts              ;leave
00A725  2               
00A725  2               ProcEnemyCollisions:
00A725  2  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00A728  2  15 1E              ora Enemy_State,x
00A72A  2  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00A72C  2  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00A72E  2  B5 1E              lda Enemy_State,x
00A730  2  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00A732  2  90 2E              bcc ProcSecondEnemyColl
00A734  2  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00A736  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00A738  2  F0 27              beq ExitProcessEColl
00A73A  2  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00A73D  2  0A                 asl
00A73E  2  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00A740  2  A9 06              lda #$06
00A742  2  20 7A A6           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00A745  2  20 D6 A3           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00A748  2  A4 01              ldy $01                  ;original offset of second enemy
00A74A  2               
00A74A  2               ShellCollisions:
00A74A  2  98                 tya                      ;move Y to X
00A74B  2  AA                 tax
00A74C  2  20 D6 A3           jsr ShellOrBlockDefeat   ;kill second enemy
00A74F  2  A6 08              ldx ObjectOffset
00A751  2  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00A754  2  18                 clc
00A755  2  69 04              adc #$04                 ;add four to get appropriate point offset
00A757  2  A6 01              ldx $01
00A759  2  20 7A A6           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00A75C  2  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00A75E  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00A761  2               
00A761  2               ExitProcessEColl:
00A761  2  60                 rts                      ;leave!!!
00A762  2               
00A762  2               ProcSecondEnemyColl:
00A762  2  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00A765  2  C9 06              cmp #$06
00A767  2  90 1D              bcc MoveEOfs
00A769  2  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00A76C  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00A76E  2  F0 F1              beq ExitProcessEColl
00A770  2  20 D6 A3           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00A773  2  A4 01              ldy $01
00A775  2  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00A778  2  18                 clc
00A779  2  69 04              adc #$04                 ;add four to get appropriate point offset
00A77B  2  A6 08              ldx ObjectOffset
00A77D  2  20 7A A6           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00A780  2  A6 01              ldx $01                  ;load original offset of second enemy
00A782  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00A785  2  60                 rts                      ;leave!!!
00A786  2               
00A786  2               MoveEOfs:
00A786  2  98                 tya                      ;move Y ($01) to X
00A787  2  AA                 tax
00A788  2  20 8D A7           jsr EnemyTurnAround      ;do the sub here using value from $01
00A78B  2  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00A78D  2               
00A78D  2               EnemyTurnAround:
00A78D  2  B5 16               lda Enemy_ID,x           ;check for specific enemies
00A78F  2  C9 0D               cmp #PiranhaPlant
00A791  2  F0 26               beq ExTA                 ;if piranha plant, leave
00A793  2  C9 04               cmp #UpsideDownPiranhaP
00A795  2  F0 22               beq ExTA                 ;if upside-down piranha plant, leave
00A797  2  C9 11               cmp #Lakitu
00A799  2  F0 1E               beq ExTA                 ;if lakitu, leave
00A79B  2  C9 05               cmp #HammerBro
00A79D  2  F0 1A               beq ExTA                 ;if hammer bro, leave
00A79F  2  C9 12               cmp #Spiny
00A7A1  2  F0 08               beq RXSpd                ;if spiny, turn it around
00A7A3  2  C9 0E               cmp #GreenParatroopaJump
00A7A5  2  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00A7A7  2  C9 07               cmp #$07
00A7A9  2  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00A7AB  2  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00A7AD  2  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00A7AF  2  A8                  tay
00A7B0  2  C8                  iny
00A7B1  2  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00A7B3  2  B5 46               lda Enemy_MovingDir,x
00A7B5  2  49 03               eor #%00000011           ;invert moving direction and store, then leave
00A7B7  2  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00A7B9  2  60           ExTA:  rts                      ;leave!!!
00A7BA  2               
00A7BA  2               ;-------------------------------------------------------------------------------------
00A7BA  2               ;$00 - vertical position of platform
00A7BA  2               
00A7BA  2               LargePlatformCollision:
00A7BA  2  A9 FF               lda #$ff                     ;save value here
00A7BC  2  9D A2 03            sta PlatformCollisionFlag,x
00A7BF  2  AD 47 07            lda TimerControl             ;check master timer control
00A7C2  2  D0 29               bne ExLPC                    ;if set, branch to leave
00A7C4  2  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00A7C6  2  30 25               bmi ExLPC                    ;branch to leave
00A7C8  2  B5 16               lda Enemy_ID,x
00A7CA  2  C9 24               cmp #$24                     ;check enemy object identifier for
00A7CC  2  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00A7CE  2  B5 1E               lda Enemy_State,x
00A7D0  2  AA                  tax                          ;set state as enemy offset here
00A7D1  2  20 D4 A7            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00A7D4  2               
00A7D4  2               ChkForPlayerC_LargeP:
00A7D4  2  20 B6 A8            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00A7D7  2  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00A7D9  2  8A                  txa
00A7DA  2  20 C2 A8            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00A7DD  2  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00A7DF  2  85 00               sta $00                      ;temp variable for now
00A7E1  2  8A                  txa                          ;send offset we're on to the stack
00A7E2  2  48                  pha
00A7E3  2  20 C3 AF            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00A7E6  2  68                  pla                          ;retrieve offset from the stack
00A7E7  2  AA                  tax
00A7E8  2  90 03               bcc ExLPC                    ;if no collision, branch to leave
00A7EA  2  20 31 A8            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00A7ED  2  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00A7EF  2  60                  rts
00A7F0  2               
00A7F0  2               ;--------------------------------
00A7F0  2               ;$00 - counter for bounding boxes
00A7F0  2               
00A7F0  2               SmallPlatformCollision:
00A7F0  2  AD 47 07           lda TimerControl             ;if master timer control set,
00A7F3  2  D0 37              bne ExSPC                    ;branch to leave
00A7F5  2  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00A7F8  2  20 B6 A8           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00A7FB  2  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00A7FD  2  A9 02              lda #$02
00A7FF  2  85 00              sta $00                      ;load counter here for 2 bounding boxes
00A801  2               
00A801  2               ChkSmallPlatLoop:
00A801  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00A803  2  20 C0 A8           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00A806  2  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00A808  2  D0 22              bne ExSPC                  ;then branch to leave
00A80A  2  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00A80D  2  C9 20              cmp #$20                   ;above a specific point
00A80F  2  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00A811  2  20 C3 AF           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00A814  2  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00A816  2               
00A816  2               MoveBoundBox:
00A816  2  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00A819  2  18                  clc                        ;128 pixels downwards
00A81A  2  69 80               adc #$80
00A81C  2  99 AD 04            sta BoundingBox_UL_YPos,y
00A81F  2  B9 AF 04            lda BoundingBox_DR_YPos,y
00A822  2  18                  clc
00A823  2  69 80               adc #$80
00A825  2  99 AF 04            sta BoundingBox_DR_YPos,y
00A828  2  C6 00               dec $00                    ;decrement counter we set earlier
00A82A  2  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00A82C  2  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00A82E  2  60                  rts
00A82F  2               
00A82F  2               ;--------------------------------
00A82F  2               
00A82F  2               ProcSPlatCollisions:
00A82F  2  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00A831  2               
00A831  2               ProcLPlatCollisions:
00A831  2  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00A834  2  38                 sec                          ;of the player's bounding box from the bottom
00A835  2  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00A838  2  C9 04              cmp #$04                     ;if difference too large or negative,
00A83A  2  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00A83C  2  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00A83E  2  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00A840  2  A9 01              lda #$01                     ;otherwise, set vertical
00A842  2  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00A844  2               
00A844  2               ChkForTopCollision:
00A844  2  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00A847  2  38                 sec                          ;of the platform's bounding box from the bottom
00A848  2  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00A84B  2  C9 06              cmp #$06
00A84D  2  B0 1B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00A84F  2  A5 9F              lda Player_Y_Speed
00A851  2  30 17              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00A853  2  A5 00              lda $00                      ;get saved bounding box counter from earlier
00A855  2  B4 16              ldy Enemy_ID,x
00A857  2  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00A859  2  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00A85B  2  C0 2C              cpy #$2c                     ;as contents of collision flag
00A85D  2  F0 01              beq SetCollisionFlag
00A85F  2  8A                 txa                          ;otherwise use enemy object buffer offset
00A860  2               
00A860  2               SetCollisionFlag:
00A860  2  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00A862  2  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00A865  2  A9 00              lda #$00
00A867  2  85 1D              sta Player_State             ;set player state to normal then leave
00A869  2  60                 rts
00A86A  2               
00A86A  2               PlatformSideCollisions:
00A86A  2  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00A86C  2  85 00                 sta $00                    ;collision on left side of platform
00A86E  2  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00A871  2  38                    sec                        ;from player's right edge
00A872  2  F9 AC 04              sbc BoundingBox_UL_XPos,y
00A875  2  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00A877  2  90 0D                 bcc SideC
00A879  2  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00A87B  2  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00A87E  2  18                    clc                        ;from platform's right edge
00A87F  2  ED AC 04              sbc BoundingBox_UL_XPos
00A882  2  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00A884  2  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00A886  2  20 D4 AB     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00A889  2  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00A88B  2  60                    rts
00A88C  2               
00A88C  2               ;-------------------------------------------------------------------------------------
00A88C  2               
00A88C  2               PlayerPosSPlatData:
00A88C  2  80 00              .byte $80, $00
00A88E  2               
00A88E  2               PositionPlayerOnS_Plat:
00A88E  2  A8                 tay                        ;use bounding box counter saved in collision flag
00A88F  2  B5 CF              lda Enemy_Y_Position,x     ;for offset
00A891  2  18                 clc                        ;add positioning data using offset to the vertical
00A892  2  79 8B A8           adc PlayerPosSPlatData-1,y ;coordinate
00A895  2  2C                 .byte $2c                    ;BIT instruction opcode
00A896  2               
00A896  2               PositionPlayerOnVPlat:
00A896  2  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00A898  2  A4 0E                 ldy GameEngineSubroutine
00A89A  2  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00A89C  2  F0 17                 beq ExPlPos               ;skip all of this
00A89E  2  B4 B6                 ldy Enemy_Y_HighPos,x
00A8A0  2  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00A8A2  2  D0 11                 bne ExPlPos
00A8A4  2  38                    sec                       ;subtract 32 pixels from vertical coordinate
00A8A5  2  E9 20                 sbc #$20                  ;for the player object's height
00A8A7  2  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00A8A9  2  98                    tya
00A8AA  2  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00A8AC  2  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00A8AE  2  A9 00                 lda #$00
00A8B0  2  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00A8B2  2  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00A8B5  2  60           ExPlPos: rts
00A8B6  2               
00A8B6  2               ;-------------------------------------------------------------------------------------
00A8B6  2               
00A8B6  2               CheckPlayerVertical:
00A8B6  2  AD D0 03            lda Player_OffscreenBits  ;if player object is not offscreen
00A8B9  2  29 F0               and #$f0                  ;then branch with clear carry flag
00A8BB  2  18                  clc
00A8BC  2  F0 01               beq ExCPV                 ;otherwise fall through and set carry flag
00A8BE  2  38                  sec                       ;to symbolize that player is offscreen
00A8BF  2  60           ExCPV: rts
00A8C0  2               
00A8C0  2               ;-------------------------------------------------------------------------------------
00A8C0  2               
00A8C0  2               GetEnemyBoundBoxOfs:
00A8C0  2  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00A8C2  2               
00A8C2  2               GetEnemyBoundBoxOfsArg:
00A8C2  2  0A                 asl                      ;multiply A by four, then add four
00A8C3  2  0A                 asl                      ;to skip player's bounding box
00A8C4  2  18                 clc
00A8C5  2  69 04              adc #$04
00A8C7  2  A8                 tay                      ;send to Y
00A8C8  2  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00A8CB  2  29 0F              and #%00001111           ;save low nybble
00A8CD  2  C9 0F              cmp #%00001111           ;check for all bits set
00A8CF  2  60                 rts
00A8D0  2               
00A8D0  2               ;-------------------------------------------------------------------------------------
00A8D0  2               ;$00-$01 - used to hold many values, essentially temp variables
00A8D0  2               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00A8D0  2               ;$eb - used to hold block buffer adder
00A8D0  2               
00A8D0  2               PlayerBGUpperExtent:
00A8D0  2  20 10              .byte $20, $10
00A8D2  2               
00A8D2  2               PlayerBGCollision:
00A8D2  2  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00A8D5  2  D0 2E                  bne ExPBGCol              ;branch to leave
00A8D7  2  A5 0E                  lda GameEngineSubroutine
00A8D9  2  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00A8DB  2  F0 28                  beq ExPBGCol              ;branch to leave
00A8DD  2  C9 04                  cmp #$04
00A8DF  2  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00A8E1  2  A9 01                  lda #$01                  ;load default player state for swimming
00A8E3  2  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00A8E6  2  D0 0A                  bne SetPSte               ;branch ahead to set default state
00A8E8  2  A5 1D                  lda Player_State          ;if player in normal state,
00A8EA  2  F0 04                  beq SetFallS              ;branch to set default state for falling
00A8EC  2  C9 03                  cmp #$03
00A8EE  2  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00A8F0  2  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00A8F2  2  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00A8F4  2  A5 B5        ChkOnScr: lda Player_Y_HighPos
00A8F6  2  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00A8F8  2  D0 0B                  bne ExPBGCol              ;branch to leave if not
00A8FA  2  A9 FF                  lda #$ff
00A8FC  2  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00A8FF  2  A5 CE                  lda Player_Y_Position
00A901  2  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00A903  2  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00A905  2  60           ExPBGCol: rts                       ;otherwise leave
00A906  2               
00A906  2               ChkCollSize:
00A906  2  A0 02                 ldy #$02                    ;load default offset
00A908  2  AD 14 07              lda CrouchingFlag
00A90B  2  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00A90D  2  AD 54 07              lda PlayerSize
00A910  2  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00A912  2  88                    dey                         ;otherwise decrement offset for big player not crouching
00A913  2  AD 04 07              lda SwimmingFlag
00A916  2  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00A918  2  88                    dey                         ;otherwise decrement offset
00A919  2  B9 4B B0     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00A91C  2  85 EB                 sta $eb                     ;store value here
00A91E  2  A8                    tay                         ;put value into Y, as offset for block buffer routine
00A91F  2  AE 54 07              ldx PlayerSize              ;get player's size as offset
00A922  2  AD 14 07              lda CrouchingFlag
00A925  2  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00A927  2  E8                    inx                         ;otherwise increment size as offset
00A928  2  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00A92A  2  DD D0 A8              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00A92D  2  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00A92F  2  20 87 B0              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00A932  2  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00A934  2  20 2A AC              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00A937  2  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00A939  2  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00A93B  2  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00A93D  2  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00A93F  2  C0 04                 cpy #$04                    ;from collision detection routine
00A941  2  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00A943  2  20 18 AC              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00A946  2  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00A948  2  AC 4E 07              ldy AreaType                ;otherwise check area type
00A94B  2  F0 13                 beq NYSpd                   ;if water level, branch ahead
00A94D  2  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00A950  2  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00A952  2  20 AE 88              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00A955  2  4C 64 A9              jmp DoFootCheck             ;jump ahead to skip these other parts here
00A958  2               
00A958  2               SolidOrClimb:
00A958  2  C9 23               cmp #$23               ;if climbing metatile,
00A95A  2  F0 04               beq NYSpd              ;branch ahead and do not play sound
00A95C  2  A9 02               lda #Sfx_Bump
00A95E  2  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00A960  2  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00A962  2  85 9F               sta Player_Y_Speed     ;jump or swim
00A964  2               
00A964  2               DoFootCheck:
00A964  2  A4 EB              ldy $eb                    ;get block buffer adder offset
00A966  2  A5 CE              lda Player_Y_Position
00A968  2  C9 CF              cmp #$cf                   ;check to see how low player is
00A96A  2  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00A96C  2  20 86 B0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00A96F  2  20 2A AC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00A972  2  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00A974  2  48                 pha                        ;save bottom left metatile to stack
00A975  2  20 86 B0           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00A978  2  85 00              sta $00                    ;save bottom right metatile here
00A97A  2  68                 pla
00A97B  2  85 01              sta $01                    ;pull bottom left metatile and save here
00A97D  2  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00A97F  2  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00A981  2  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00A983  2  20 2A AC           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00A986  2  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00A988  2               
00A988  2               AwardTouchedCoin:
00A988  2  4C 73 AA           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00A98B  2               
00A98B  2               ChkFootMTile:
00A98B  2  20 23 AC               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00A98E  2  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00A990  2  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00A992  2  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00A994  2  C9 C6                  cmp #$c6
00A996  2  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00A998  2  4C 7C AA               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00A99B  2  20 40 AB     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00A99E  2  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00A9A0  2  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00A9A3  2  D0 23                  bne InitSteP               ;branch ahead
00A9A5  2  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00A9A7  2  C0 05                  cpy #$05                   ;from collision detection routine
00A9A9  2  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00A9AB  2  A5 45                  lda Player_MovingDir
00A9AD  2  85 00                  sta $00                    ;use player's moving direction as temp variable
00A9AF  2  4C D4 AB               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00A9B2  2  20 4F AB     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00A9B5  2  A9 F0                  lda #$f0
00A9B7  2  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00A9B9  2  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00A9BB  2  20 76 AB               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00A9BE  2  A9 00                  lda #$00
00A9C0  2  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00A9C2  2  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00A9C5  2  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00A9C8  2  A9 00        InitSteP: lda #$00
00A9CA  2  85 1D                  sta Player_State           ;set player's state to normal
00A9CC  2               
00A9CC  2               DoPlayerSideCheck:
00A9CC  2  A4 EB              ldy $eb       ;get block buffer adder offset
00A9CE  2  C8                 iny
00A9CF  2  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00A9D0  2  A9 02              lda #$02      ;set value here to be used as counter
00A9D2  2  85 00              sta $00
00A9D4  2               
00A9D4  2               SideCheckLoop:
00A9D4  2  C8                  iny                       ;move onto the next one
00A9D5  2  84 EB               sty $eb                   ;store it
00A9D7  2  A5 CE               lda Player_Y_Position
00A9D9  2  C9 20               cmp #$20                  ;check player's vertical position
00A9DB  2  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00A9DD  2  C9 E4               cmp #$e4
00A9DF  2  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00A9E1  2  20 8A B0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00A9E4  2  F0 0D               beq BHalf                 ;branch ahead if nothing found
00A9E6  2  C9 19               cmp #$19                  ;otherwise check for pipe metatiles
00A9E8  2  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00A9EA  2  C9 6D               cmp #$6d
00A9EC  2  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00A9EE  2  20 23 AC            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00A9F1  2  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00A9F3  2  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00A9F5  2  C8                  iny                       ;increment it
00A9F6  2  A5 CE               lda Player_Y_Position     ;get player's vertical position
00A9F8  2  C9 08               cmp #$08
00A9FA  2  90 0D               bcc ExSCH                 ;if too high, branch to leave
00A9FC  2  C9 D0               cmp #$d0
00A9FE  2  B0 09               bcs ExSCH                 ;if too low, branch to leave
00AA00  2  20 8A B0            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00AA03  2  D0 05               bne CheckSideMTiles       ;if something found, branch
00AA05  2  C6 00               dec $00                   ;otherwise decrement counter
00AA07  2  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00AA09  2  60           ExSCH: rts                       ;leave
00AA0A  2               
00AA0A  2               CheckSideMTiles:
00AA0A  2  20 40 AB               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00AA0D  2  F0 61                  beq ExCSM                  ;branch to leave if either found
00AA0F  2  20 23 AC               jsr CheckForClimbMTiles    ;check for climbable metatiles
00AA12  2  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00AA14  2  4C 9F AA               jmp HandleClimbing         ;otherwise jump to handle climbing
00AA17  2  20 2A AC     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00AA1A  2  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00AA1C  2  20 6B AB               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00AA1F  2  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00AA21  2  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00AA24  2  D0 4A                  bne ExCSM                  ;branch to leave if set
00AA26  2  4C 6D AA               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00AA29  2  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00AA2B  2  C0 00                  cpy #$00                   ;check for player's state set to normal
00AA2D  2  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00AA2F  2  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00AA31  2  88                     dey
00AA32  2  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00AA34  2  C9 6E                  cmp #$6e                   ;otherwise check for pipe metatiles
00AA36  2  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00AA38  2  C9 1C                  cmp #$1c                   ;if collided with water pipe (bottom), continue
00AA3A  2  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00AA3C  2  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00AA3F  2  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00AA41  2  A0 10                  ldy #Sfx_PipeDown_Injury
00AA43  2  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00AA45  2  09 20        PlyrPipe: ora #%00100000
00AA47  2  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00AA4A  2  A5 86                  lda Player_X_Position
00AA4C  2  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00AA4E  2  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00AA50  2  A0 00                  ldy #$00                   ;set default offset for timer setting data
00AA52  2  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00AA55  2  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00AA57  2  C8                     iny                        ;otherwise increment offset
00AA58  2  B9 71 AA     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00AA5B  2  8D DE 06               sta ChangeAreaTimer
00AA5E  2  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00AA60  2  C9 07                  cmp #$07
00AA62  2  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00AA64  2  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00AA66  2  D0 08                  bne ExCSM
00AA68  2  A9 02                  lda #$02
00AA6A  2  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00AA6C  2  60                     rts                        ;and leave
00AA6D  2               
00AA6D  2               ;--------------------------------
00AA6D  2               ;$02 - high nybble of vertical coordinate from block buffer
00AA6D  2               ;$04 - low nybble of horizontal coordinate from block buffer
00AA6D  2               ;$06-$07 - block buffer address
00AA6D  2               
00AA6D  2               StopPlayerMove:
00AA6D  2  20 D4 AB            jsr ImpedePlayerMove      ;stop player's movement
00AA70  2  60           ExCSM: rts                       ;leave
00AA71  2               
00AA71  2               AreaChangeTimerData:
00AA71  2  A0 34              .byte $a0, $34
00AA73  2               
00AA73  2               HandleCoinMetatile:
00AA73  2  20 8D AA           jsr ErACM             ;do sub to erase coin metatile from block buffer
00AA76  2  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00AA79  2  4C C3 87           jmp GiveOneCoin       ;update coin amount and tally on the screen
00AA7C  2               
00AA7C  2               HandleAxeMetatile:
00AA7C  2  A9 00               lda #$00
00AA7E  2  8D 72 07            sta OperMode_Task   ;reset secondary mode
00AA81  2  A9 02               lda #$02
00AA83  2  8D 70 07            sta OperMode        ;set primary mode to victory mode
00AA86  2  20 4A C2            jsr LoadMarioPhysics
00AA89  2  A9 18               lda #$18
00AA8B  2  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00AA8D  2  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00AA8F  2  A9 00               lda #$00            ;load blank metatile
00AA91  2  91 06               sta ($06),y         ;store to remove old contents from block buffer
00AA93  2  4C 2A 69            jmp RemoveCoin_Axe  ;update the screen accordingly
00AA96  2               
00AA96  2               ;--------------------------------
00AA96  2               ;$02 - high nybble of vertical coordinate from block buffer
00AA96  2               ;$04 - low nybble of horizontal coordinate from block buffer
00AA96  2               ;$06-$07 - block buffer address
00AA96  2               
00AA96  2               ClimbXPosAdder:
00AA96  2  F9 07              .byte $f9, $07
00AA98  2               
00AA98  2               ClimbPLocAdder:
00AA98  2  FF 00              .byte $ff, $00
00AA9A  2               
00AA9A  2               FlagpoleYPosData:
00AA9A  2  18 22 50 68        .byte $18, $22, $50, $68, $90
00AA9E  2  90           
00AA9F  2               
00AA9F  2               HandleClimbing:
00AA9F  2  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00AAA1  2  C0 06              cpy #$06           ;collision detection routine against certain values, this
00AAA3  2  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00AAA5  2  C0 0A              cpy #$0a           ;than 16 pixels
00AAA7  2  90 01              bcc ChkForFlagpole
00AAA9  2  60           ExHC: rts                ;leave if too far left or too far right
00AAAA  2               
00AAAA  2               ChkForFlagpole:
00AAAA  2  C9 21              cmp #$21               ;check climbing metatiles
00AAAC  2  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00AAAE  2  C9 22              cmp #$22
00AAB0  2  D0 4B              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00AAB2  2               
00AAB2  2               FlagpoleCollision:
00AAB2  2  A5 0E              lda GameEngineSubroutine
00AAB4  2  C9 05              cmp #$05                  ;check for end-of-level routine running
00AAB6  2  F0 53              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00AAB8  2  A9 01              lda #$01
00AABA  2  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00AABC  2  EE 23 07           inc ScrollLock            ;set scroll lock flag
00AABF  2  A5 0E              lda GameEngineSubroutine
00AAC1  2  C9 04              cmp #$04                  ;check for flagpole slide routine running
00AAC3  2  F0 31              beq RunFR                 ;if running, branch to end of flagpole code here
00AAC5  2  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00AAC7  2  20 6D 75           jsr KillEnemies           ;get rid of them
00AACA  2  A9 80              lda #Silence
00AACC  2  85 FC              sta EventMusicQueue       ;silence music
00AACE  2  4A                 lsr
00AACF  2  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00AAD2  2  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00AAD4  2  A5 CE              lda Player_Y_Position
00AAD6  2  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00AAD9  2               
00AAD9  2               ChkFlagpoleYPosLoop:
00AAD9  2  DD 9A AA            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00AADC  2  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00AADE  2  CA                  dex                       ;otherwise decrement offset to use
00AADF  2  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00AAE1  2  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00AAE4  2  AD E7 07            lda CoinDisplay
00AAE7  2  CD E8 07            cmp CoinDisplay+1         ;check to see if coin tally digits are the same
00AAEA  2  D0 0A               bne RunFR                 ;if not, branch to use flagpole score data as-is
00AAEC  2  CD EE 07            cmp GameTimerDisplay+2    ;check to see if the last digit of game timer matches
00AAEF  2  D0 05               bne RunFR                 ;the two digits, if not, branch to use data as-is
00AAF1  2  A9 05               lda #$05
00AAF3  2  8D 0F 01            sta FlagpoleScore         ;otherwise, set to give player an extra life
00AAF6  2  A9 04        RunFR: lda #$04
00AAF8  2  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00AAFA  2  4C 0B AB            jmp PutPlayerOnVine       ;jump to end of climbing code
00AAFD  2               
00AAFD  2               VineCollision:
00AAFD  2  C9 23              cmp #$23                  ;check for climbing metatile used on vines
00AAFF  2  D0 0A              bne PutPlayerOnVine
00AB01  2  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00AB03  2  C9 20              cmp #$20                  ;for being in status bar area
00AB05  2  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00AB07  2  A9 01              lda #$01
00AB09  2  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00AB0B  2               
00AB0B  2               PutPlayerOnVine:
00AB0B  2  A9 03                 lda #$03                ;set player state to climbing
00AB0D  2  85 1D                 sta Player_State
00AB0F  2  A9 00                 lda #$00                ;nullify player's horizontal speed
00AB11  2  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00AB13  2  8D 05 07              sta Player_X_MoveForce
00AB16  2  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00AB18  2  38                    sec
00AB19  2  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00AB1C  2  C9 10                 cmp #$10
00AB1E  2  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00AB20  2  A9 02                 lda #$02
00AB22  2  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00AB24  2  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00AB26  2  A5 06                 lda $06                 ;get low byte of block buffer address
00AB28  2  0A                    asl
00AB29  2  0A                    asl                     ;move low nybble to high
00AB2A  2  0A                    asl
00AB2B  2  0A                    asl
00AB2C  2  18                    clc
00AB2D  2  79 95 AA              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00AB30  2  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00AB32  2  A5 06                 lda $06                 ;get low byte of block buffer address again
00AB34  2  D0 09                 bne ExPVne              ;if not zero, branch
00AB36  2  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00AB39  2  18                    clc
00AB3A  2  79 97 AA              adc ClimbPLocAdder-1,y  ;add depending on facing location
00AB3D  2  85 6D                 sta Player_PageLoc      ;store as player's page location
00AB3F  2  60           ExPVne:  rts                     ;finally, we're done!
00AB40  2               
00AB40  2               ;--------------------------------
00AB40  2               
00AB40  2               ChkInvisibleMTiles:
00AB40  2  C9 5E                 cmp #$5e       ;check for hidden coin block
00AB42  2  F0 0A                 beq ExCInvT
00AB44  2  C9 5F                 cmp #$5f       ;check for hidden 1-up block
00AB46  2  F0 06                 beq ExCInvT
00AB48  2  C9 60                 cmp #$60       ;check for hidden poison shroom block
00AB4A  2  F0 02                 beq ExCInvT
00AB4C  2  C9 61                 cmp #$61       ;check for hidden power-up block
00AB4E  2  60           ExCInvT: rts            ;leave with zero flag set if any of these found
00AB4F  2               
00AB4F  2               ;--------------------------------
00AB4F  2               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00AB4F  2               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00AB4F  2               
00AB4F  2               ChkForLandJumpSpring:
00AB4F  2  20 6B AB             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00AB52  2  90 16                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00AB54  2  A9 70                lda #$70
00AB56  2  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00AB59  2  8D 0A 07             sta VerticalForceDown
00AB5C  2  A9 F9                lda #$f9
00AB5E  2  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00AB61  2  A9 03                lda #$03
00AB63  2  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00AB66  2  4A                   lsr
00AB67  2  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00AB6A  2  60           ExCJSp: rts                         ;and leave
00AB6B  2               
00AB6B  2               ChkJumpspringMetatiles:
00AB6B  2  C9 68                 cmp #$68      ;check for top jumpspring metatile
00AB6D  2  F0 05                 beq JSFnd     ;branch to set carry if found
00AB6F  2  C9 69                 cmp #$69      ;check for bottom jumpspring metatile
00AB71  2  18                    clc           ;clear carry flag
00AB72  2  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00AB74  2  38           JSFnd:   sec           ;set carry if found
00AB75  2  60           NoJSFnd: rts           ;leave
00AB76  2               
00AB76  2               HandlePipeEntry:
00AB76  2  A5 0B                  lda Up_Down_Buttons       ;check saved controller bits from earlier
00AB78  2  29 04                  and #%00000100            ;for pressing down
00AB7A  2  F0 57                  beq ExPipeE               ;if not pressing down, branch to leave
00AB7C  2  A5 00                  lda $00
00AB7E  2  C9 11                  cmp #$11                  ;check right foot metatile for warp pipe right metatile
00AB80  2  D0 51                  bne ExPipeE               ;branch to leave if not found
00AB82  2  A5 01                  lda $01
00AB84  2  C9 10                  cmp #$10                  ;check left foot metatile for warp pipe left metatile
00AB86  2  D0 4B                  bne ExPipeE               ;branch to leave if not found
00AB88  2  A9 30                  lda #$30
00AB8A  2  8D DE 06               sta ChangeAreaTimer       ;set timer for change of area
00AB8D  2  A9 03                  lda #$03
00AB8F  2  85 0E                  sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00AB91  2  A9 10                  lda #Sfx_PipeDown_Injury
00AB93  2  85 FF                  sta Square1SoundQueue     ;load pipedown/injury sound
00AB95  2  A9 20                  lda #%00100000
00AB97  2  8D C4 03               sta Player_SprAttrib      ;set background priority bit in player's attributes
00AB9A  2  AD D6 06               lda WarpZoneControl       ;check warp zone control
00AB9D  2  F0 34                  beq ExPipeE               ;branch to leave if none found
00AB9F  2  29 0F                  and #%00001111            ;mask out all but lower nybble
00ABA1  2  AA                     tax                       ;save as offset, then use to load warp zone destination
00ABA2  2  BD 0C 67               lda WarpZoneNumbers,x
00ABA5  2  AC FB 07               ldy HardWorldFlag         ;if playing worlds A-D, branch to skip this part
00ABA8  2  F0 03                  beq SetWDest
00ABAA  2  38                     sec
00ABAB  2  E9 09                  sbc #$09                  ;otherwise subtract 9 to get correct world number
00ABAD  2  A8           SetWDest: tay
00ABAE  2  88                     dey                       ;decrement for use as world number
00ABAF  2  8C 5F 07               sty WorldNumber           ;store as world number and offset
00ABB2  2  BE 57 C3               ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
00ABB5  2  BD 60 C3               lda AreaAddrOffsets,x     ;get area offset based on world offset
00ABB8  2  8D 50 07               sta AreaPointer           ;store area offset here to be used to change areas
00ABBB  2  A9 80                  lda #Silence
00ABBD  2  85 FC                  sta EventMusicQueue       ;silence music
00ABBF  2  A9 00                  lda #$00
00ABC1  2  8D 51 07               sta EntrancePage          ;initialize starting page number
00ABC4  2  8D 60 07               sta AreaNumber            ;initialize area number used for area address offset
00ABC7  2  8D 5C 07               sta LevelNumber           ;initialize level number used for world display
00ABCA  2  8D 52 07               sta AltEntranceControl    ;initialize mode of entry
00ABCD  2  EE 5D 07               inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00ABD0  2  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00ABD3  2  60           ExPipeE:  rts                       ;leave!!!
00ABD4  2               
00ABD4  2               ImpedePlayerMove:
00ABD4  2  A9 00               lda #$00                  ;initialize value here
00ABD6  2  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00ABD8  2  A6 00               ldx $00                   ;check value set earlier for
00ABDA  2  CA                  dex                       ;left side collision
00ABDB  2  D0 0A               bne RImpd                 ;if right side collision, skip this part
00ABDD  2  E8                  inx                       ;return value to X
00ABDE  2  C0 00               cpy #$00                  ;if player moving to the left,
00ABE0  2  30 28               bmi ExIPM                 ;branch to invert bit and leave
00ABE2  2  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00ABE4  2  4C EF AB            jmp NXSpd                 ;and jump to affect movement
00ABE7  2  A2 02        RImpd: ldx #$02                  ;return $02 to X
00ABE9  2  C0 01               cpy #$01                  ;if player moving to the right,
00ABEB  2  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00ABED  2  A9 01               lda #$01                  ;otherwise load A with value to be used here
00ABEF  2  A0 10        NXSpd: ldy #$10
00ABF1  2  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00ABF4  2  A0 00               ldy #$00
00ABF6  2  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00ABF8  2  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00ABFA  2  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00ABFC  2  88                  dey                       ;otherwise decrement Y now
00ABFD  2  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00ABFF  2  18                  clc
00AC00  2  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00AC02  2  85 86               sta Player_X_Position     ;position to move player left or right
00AC04  2  A5 6D               lda Player_PageLoc
00AC06  2  65 00               adc $00                   ;add high bits and carry to
00AC08  2  85 6D               sta Player_PageLoc        ;page location if necessary
00AC0A  2  8A           ExIPM: txa                       ;invert contents of X
00AC0B  2  49 FF               eor #$ff
00AC0D  2  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00AC10  2  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00AC13  2  60                  rts
00AC14  2               
00AC14  2               ;--------------------------------
00AC14  2               
00AC14  2               SolidMTileUpperExt:
00AC14  2  10 62 88 C5        .byte $10, $62, $88, $c5
00AC18  2               
00AC18  2               CheckForSolidMTiles:
00AC18  2  20 39 AC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00AC1B  2  DD 14 AC           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00AC1E  2  60                 rts
00AC1F  2               
00AC1F  2               ClimbMTileUpperExt:
00AC1F  2  21 6F 8D C7        .byte $21, $6f, $8d, $c7
00AC23  2               
00AC23  2               CheckForClimbMTiles:
00AC23  2  20 39 AC           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00AC26  2  DD 1F AC           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00AC29  2  60                 rts
00AC2A  2               
00AC2A  2               CheckForCoinMTiles:
00AC2A  2  C9 C3                 cmp #$c3              ;check for regular coin
00AC2C  2  F0 06                 beq CoinSd            ;branch if found
00AC2E  2  C9 C4                 cmp #$c4              ;check for underwater coin
00AC30  2  F0 02                 beq CoinSd            ;branch if found
00AC32  2  18                    clc                   ;otherwise clear carry and leave
00AC33  2  60                    rts
00AC34  2  A9 01        CoinSd:  lda #Sfx_CoinGrab
00AC36  2  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00AC38  2  60                    rts
00AC39  2               
00AC39  2               GetMTileAttrib:
00AC39  2  A8                  tay            ;save metatile value into Y
00AC3A  2  29 C0               and #%11000000 ;mask out all but 2 MSB
00AC3C  2  0A                  asl
00AC3D  2  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00AC3E  2  2A                  rol
00AC3F  2  AA                  tax            ;use as offset for metatile data
00AC40  2  98                  tya            ;get original metatile value back
00AC41  2  60           ExEBG: rts            ;leave
00AC42  2               
00AC42  2               ;-------------------------------------------------------------------------------------
00AC42  2               ;$06-$07 - address from block buffer routine
00AC42  2               
00AC42  2               EnemyBGCStateData:
00AC42  2  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00AC46  2  02 05        
00AC48  2               
00AC48  2               EnemyBGCXSpdData:
00AC48  2  10 F0              .byte $10, $f0
00AC4A  2               
00AC4A  2               EnemyToBGCollisionDet:
00AC4A  2  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00AC4C  2  29 20              and #%00100000
00AC4E  2  D0 F1              bne ExEBG                ;if set, branch to leave
00AC50  2  20 F1 AD           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00AC53  2  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00AC55  2  B4 16              ldy Enemy_ID,x
00AC57  2  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00AC59  2  D0 06              bne DoIDCheckBGColl
00AC5B  2  B5 CF              lda Enemy_Y_Position,x
00AC5D  2  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00AC5F  2  90 E0              bcc ExEBG
00AC61  2               
00AC61  2               DoIDCheckBGColl:
00AC61  2  C0 0E                  cpy #GreenParatroopaJump ;check for some other enemy object
00AC63  2  D0 03                  bne HBChk                ;branch if not found
00AC65  2  4C F9 AD               jmp EnemyJump            ;otherwise jump elsewhere
00AC68  2  C0 05        HBChk:    cpy #HammerBro           ;check for hammer bro
00AC6A  2  D0 04                  bne CInvu                ;branch if not found
00AC6C  2  4C 1B AE               jmp HammerBroBGColl      ;otherwise jump elsewhere
00AC6F  2  60           ExIDBChk: rts
00AC70  2  C0 12        CInvu:    cpy #Spiny               ;if enemy object is spiny, branch
00AC72  2  F0 0C                  beq YesIn
00AC74  2  C0 2E                  cpy #PowerUpObject       ;if special power-up object, branch
00AC76  2  F0 08                  beq YesIn
00AC78  2  C0 04                  cpy #UpsideDownPiranhaP  ;if enemy object is upside-down piranha plant
00AC7A  2  F0 F3                  beq ExIDBChk             ;then branch to leave
00AC7C  2  C0 07                  cpy #$07                 ;if enemy object =>$07, branch to leave
00AC7E  2  B0 EF                  bcs ExIDBChk
00AC80  2  20 44 AE     YesIn:    jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00AC83  2  D0 03                  bne HandleEToBGCollision ;if block underneath enemy, branch
00AC85  2               
00AC85  2               NoEToBGCollision:
00AC85  2  4C 78 AD            jmp ChkForRedKoopa       ;otherwise skip and do something else
00AC88  2               
00AC88  2               ;--------------------------------
00AC88  2               ;$02 - vertical coordinate from block buffer routine
00AC88  2               
00AC88  2               HandleEToBGCollision:
00AC88  2  20 4B AE           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00AC8B  2  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00AC8D  2  C9 20              cmp #$20
00AC8F  2  D0 6C              bne LandEnemyProperly     ;check for blank metatile $20 and branch if not found
00AC91  2  B5 16              lda Enemy_ID,x
00AC93  2  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00AC95  2  B0 0C              bcs ChkToStunEnemies
00AC97  2  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00AC99  2  D0 03              bne GiveOEPoints
00AC9B  2  20 24 AE           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00AC9E  2               
00AC9E  2               GiveOEPoints:
00AC9E  2  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00ACA0  2  20 7A A6           jsr SetupFloateyNumber
00ACA3  2               
00ACA3  2               ChkToStunEnemies:
00ACA3  2  B5 16                   lda Enemy_ID,x
00ACA5  2  C9 09                   cmp #$09                   ;perform many comparisons on enemy object identifier
00ACA7  2  90 18                   bcc NoDemote               ;if the enemy object identifier is equal to the values
00ACA9  2  C9 11                   cmp #$11                   ;$0e-$10 it will be demoted, in practice $0e and $10
00ACAB  2  B0 14                   bcs NoDemote               ;are values used by green paratroopas
00ACAD  2  C9 0D                   cmp #PiranhaPlant
00ACAF  2  F0 10                   beq NoDemote               ;enemy objects $0a-$0d will not be demoted
00ACB1  2  C9 04                   cmp #UpsideDownPiranhaP
00ACB3  2  F0 0C                   beq NoDemote
00ACB5  2  C9 0A                   cmp #$0a                   ;demote enemy object $09 even though it is not used
00ACB7  2  90 04                   bcc Demote
00ACB9  2  C9 0D                   cmp #PiranhaPlant
00ACBB  2  90 04                   bcc NoDemote
00ACBD  2  29 01        Demote:    and #%00000001             ;erase all but LSB, essentially turning enemy object
00ACBF  2  95 16                   sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00ACC1  2  C9 2E        NoDemote:  cmp #PowerUpObject
00ACC3  2  F0 08                   beq BounceOff              ;if power-up object, branch to bounce it
00ACC5  2  C9 06                   cmp #Goomba
00ACC7  2  F0 04                   beq BounceOff              ;redundant, already checked for goomba
00ACC9  2  A9 02                   lda #$02
00ACCB  2  95 1E                   sta Enemy_State,x          ;set enemy state to 2 (stunned)
00ACCD  2  D6 CF        BounceOff: dec Enemy_Y_Position,x
00ACCF  2  D6 CF                   dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00ACD1  2  B5 16                   lda Enemy_ID,x
00ACD3  2  C9 07                   cmp #Bloober               ;check for bloober object
00ACD5  2  F0 07                   beq SetWYSpd
00ACD7  2  A9 FD                   lda #$fd                   ;set default vertical speed
00ACD9  2  AC 4E 07                ldy AreaType
00ACDC  2  D0 02                   bne SetNotW                ;if area type not water, set as speed, otherwise
00ACDE  2  A9 FF        SetWYSpd:  lda #$ff                   ;change the vertical speed
00ACE0  2  95 A0        SetNotW:   sta Enemy_Y_Speed,x        ;set vertical speed now
00ACE2  2  A0 01                   ldy #$01
00ACE4  2  20 D9 AD                jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00ACE7  2  10 01                   bpl ChkBBill               ;branch if enemy is to the right of player
00ACE9  2  C8                      iny                        ;increment Y if not
00ACEA  2  B5 16        ChkBBill:  lda Enemy_ID,x
00ACEC  2  C9 33                   cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00ACEE  2  F0 06                   beq NoCDirF
00ACF0  2  C9 08                   cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00ACF2  2  F0 02                   beq NoCDirF                ;branch if either found, direction does not change
00ACF4  2  94 46                   sty Enemy_MovingDir,x      ;store as moving direction
00ACF6  2  88           NoCDirF:   dey                        ;decrement and use as offset
00ACF7  2  B9 48 AC                lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00ACFA  2  95 58                   sta Enemy_X_Speed,x        ;and store, then leave
00ACFC  2  60           ExEBGChk:  rts
00ACFD  2               
00ACFD  2               ;--------------------------------
00ACFD  2               ;$04 - low nybble of vertical coordinate from block buffer routine
00ACFD  2               
00ACFD  2               LandEnemyProperly:
00ACFD  2  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00ACFF  2  38                  sec
00AD00  2  E9 08               sbc #$08                ;subtract eight pixels
00AD02  2  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00AD04  2  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00AD06  2  B5 1E               lda Enemy_State,x
00AD08  2  29 40               and #%01000000          ;branch if d6 in enemy state is set
00AD0A  2  D0 57               bne LandEnemyInitState
00AD0C  2  B5 1E               lda Enemy_State,x
00AD0E  2  0A                  asl                     ;branch if d7 in enemy state is not set
00AD0F  2  90 03               bcc ChkLandedEnemyState
00AD11  2  4C 94 AD     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00AD14  2               
00AD14  2               ChkLandedEnemyState:
00AD14  2  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00AD16  2  F0 F9                   beq SChkA
00AD18  2  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00AD1A  2  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00AD1C  2  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00AD1E  2  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00AD20  2  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00AD22  2  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00AD24  2  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00AD26  2  A9 10                   lda #$10                  ;load default timer here
00AD28  2  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00AD2A  2  C0 12                   cpy #Spiny
00AD2C  2  D0 02                   bne SetForStn             ;branch if not found
00AD2E  2  A9 00                   lda #$00                  ;set timer for $00 if spiny
00AD30  2  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00AD33  2  A9 03                   lda #$03                  ;set state here, apparently used to render
00AD35  2  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00AD37  2  20 E5 AD                jsr EnemyLanding          ;then land it properly
00AD3A  2  60           ExSteChk:  rts                       ;then leave
00AD3B  2               
00AD3B  2               ProcEnemyDirection:
00AD3B  2  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00AD3D  2  C9 06                 cmp #Goomba               ;branch if found
00AD3F  2  F0 22                 beq LandEnemyInitState
00AD41  2  C9 12                 cmp #Spiny                ;check for spiny
00AD43  2  D0 0E                 bne InvtD                 ;branch if not found
00AD45  2  A9 01                 lda #$01
00AD47  2  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00AD49  2  A9 08                 lda #$08
00AD4B  2  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00AD4D  2  A5 09                 lda FrameCounter
00AD4F  2  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00AD51  2  F0 10                 beq LandEnemyInitState    ;trying to face the player
00AD53  2  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00AD55  2  20 D9 AD              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00AD58  2  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00AD5A  2  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00AD5B  2  98           CNwCDir: tya
00AD5C  2  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00AD5E  2  D0 03                 bne LandEnemyInitState
00AD60  2  20 BA AD              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00AD63  2               
00AD63  2               LandEnemyInitState:
00AD63  2  20 E5 AD           jsr EnemyLanding       ;land enemy properly
00AD66  2  B5 1E              lda Enemy_State,x
00AD68  2  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00AD6A  2  D0 05              bne NMovShellFallBit
00AD6C  2  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00AD6E  2  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00AD70  2  60                 rts
00AD71  2               
00AD71  2               NMovShellFallBit:
00AD71  2  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00AD73  2  29 BF              and #%10111111      ;and store, then leave
00AD75  2  95 1E              sta Enemy_State,x
00AD77  2  60                 rts
00AD78  2               
00AD78  2               ;--------------------------------
00AD78  2               
00AD78  2               ChkForRedKoopa:
00AD78  2  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00AD7A  2  C9 03                     cmp #RedKoopa
00AD7C  2  D0 04                     bne Chk2MSBSt             ;branch if not found
00AD7E  2  B5 1E                     lda Enemy_State,x
00AD80  2  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00AD82  2  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00AD84  2  A8                        tay
00AD85  2  0A                        asl                       ;check for d7 set
00AD86  2  90 07                     bcc GetSteFromD           ;branch if not set
00AD88  2  B5 1E                     lda Enemy_State,x
00AD8A  2  09 40                     ora #%01000000            ;set d6
00AD8C  2  4C 92 AD                  jmp SetD6Ste              ;jump ahead of this part
00AD8F  2  B9 42 AC     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00AD92  2  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00AD94  2               
00AD94  2               ;--------------------------------
00AD94  2               ;$00 - used to store bitmask (not used but initialized here)
00AD94  2               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00AD94  2               
00AD94  2               DoEnemySideCheck:
00AD94  2  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00AD96  2  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00AD98  2  90 1F                  bcc ExESdeC
00AD9A  2  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00AD9C  2  A9 02                  lda #$02                   ;set value here in what is also used as
00AD9E  2  85 EB                  sta $eb                    ;OAM data offset
00ADA0  2  A5 EB        SdeCLoop: lda $eb                    ;check value
00ADA2  2  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00ADA4  2  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00ADA6  2  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00ADA8  2  20 26 B0               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00ADAB  2  F0 05                  beq NextSdeC               ;if nothing found, branch
00ADAD  2  20 4B AE               jsr ChkForNonSolids        ;check for non-solid blocks
00ADB0  2  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00ADB2  2  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00ADB4  2  C8                     iny
00ADB5  2  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00ADB7  2  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00ADB9  2  60           ExESdeC:  rts
00ADBA  2               
00ADBA  2               ChkForBump_HammerBroJ:
00ADBA  2  E0 05                cpx #$05               ;check if we're on the special use slot
00ADBC  2  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00ADBE  2  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00ADC0  2  0A                   asl                    ;ahead and do not play sound
00ADC1  2  90 04                bcc NoBump
00ADC3  2  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00ADC5  2  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00ADC7  2  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00ADC9  2  C9 05                cmp #$05
00ADCB  2  D0 09                bne InvEnemyDir        ;branch if not found
00ADCD  2  A9 00                lda #$00
00ADCF  2  85 00                sta $00                ;initialize value here for bitmask
00ADD1  2  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00ADD3  2  4C 6C 96             jmp SetHJ              ;jump to code that makes hammer bro jump
00ADD6  2               
00ADD6  2               InvEnemyDir:
00ADD6  2  4C AB A7           jmp RXSpd     ;jump to turn the enemy around
00ADD9  2               
00ADD9  2               ;--------------------------------
00ADD9  2               ;$00 - used to hold horizontal difference between player and enemy
00ADD9  2               
00ADD9  2               PlayerEnemyDiff:
00ADD9  2  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00ADDB  2  38                 sec                     ;horizontal coordinate and the player's
00ADDC  2  E5 86              sbc Player_X_Position   ;horizontal coordinate
00ADDE  2  85 00              sta $00                 ;and store here
00ADE0  2  B5 6E              lda Enemy_PageLoc,x
00ADE2  2  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00ADE4  2  60                 rts
00ADE5  2               
00ADE5  2               ;--------------------------------
00ADE5  2               
00ADE5  2               EnemyLanding:
00ADE5  2  20 4E 8F           jsr InitVStf            ;do something here to vertical speed and something else
00ADE8  2  B5 CF              lda Enemy_Y_Position,x
00ADEA  2  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00ADEC  2  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00ADEE  2  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00ADF0  2  60                 rts
00ADF1  2               
00ADF1  2               SubtEnemyYPos:
00ADF1  2  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00ADF3  2  18                 clc                     ;vertical coordinate
00ADF4  2  69 3E              adc #$3e
00ADF6  2  C9 44              cmp #$44                ;compare against a certain range
00ADF8  2  60                 rts                     ;and leave with flags set for conditional branch
00ADF9  2               
00ADF9  2               EnemyJump:
00ADF9  2  20 F1 AD             jsr SubtEnemyYPos     ;do a sub here
00ADFC  2  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00ADFE  2  B5 A0                lda Enemy_Y_Speed,x
00AE00  2  18                   clc                   ;add two to vertical speed
00AE01  2  69 02                adc #$02
00AE03  2  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00AE05  2  90 11                bcc DoSide
00AE07  2  20 44 AE             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00AE0A  2  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00AE0C  2  20 4B AE             jsr ChkForNonSolids   ;check for non-solid blocks
00AE0F  2  F0 07                beq DoSide            ;branch if found
00AE11  2  20 E5 AD             jsr EnemyLanding      ;change vertical coordinate and speed
00AE14  2  A9 FD                lda #$fd
00AE16  2  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00AE18  2  4C 94 AD     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00AE1B  2               
00AE1B  2               ;--------------------------------
00AE1B  2               
00AE1B  2               HammerBroBGColl:
00AE1B  2  20 44 AE           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00AE1E  2  F0 1D              beq NoUnderHammerBro
00AE20  2  C9 20              cmp #$20             ;check for blank metatile $20 and branch if not found
00AE22  2  D0 08              bne UnderHammerBro
00AE24  2               
00AE24  2               KillEnemyAboveBlock:
00AE24  2  20 D6 A3           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00AE27  2  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00AE29  2  95 A0              sta Enemy_Y_Speed,x
00AE2B  2  60                 rts
00AE2C  2               
00AE2C  2               UnderHammerBro:
00AE2C  2  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00AE2F  2  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00AE31  2  B5 1E              lda Enemy_State,x
00AE33  2  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00AE35  2  95 1E              sta Enemy_State,x     ;and store
00AE37  2  20 E5 AD           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00AE3A  2  4C 94 AD           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00AE3D  2               
00AE3D  2               NoUnderHammerBro:
00AE3D  2  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00AE3F  2  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00AE41  2  95 1E              sta Enemy_State,x
00AE43  2  60                 rts
00AE44  2               
00AE44  2               ChkUnderEnemy:
00AE44  2  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00AE46  2  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00AE48  2  4C 26 B0           jmp BlockBufferChk_Enemy  ;hop to it!
00AE4B  2               
00AE4B  2               ChkForNonSolids:
00AE4B  2  C9 23               cmp #$23       ;blank metatile used for vines?
00AE4D  2  F0 16               beq NSFnd
00AE4F  2  C9 C3               cmp #$c3       ;regular coin?
00AE51  2  F0 12               beq NSFnd
00AE53  2  C9 C4               cmp #$c4       ;underwater coin?
00AE55  2  F0 0E               beq NSFnd
00AE57  2  C9 5E               cmp #$5e       ;hidden coin block?
00AE59  2  F0 0A               beq NSFnd
00AE5B  2  C9 5F               cmp #$5f       ;hidden 1-up block?
00AE5D  2  F0 06               beq NSFnd
00AE5F  2  C9 60               cmp #$60       ;hidden poison shroom block?
00AE61  2  F0 02               beq NSFnd
00AE63  2  C9 61               cmp #$61       ;hidden power-up block?
00AE65  2  60           NSFnd: rts
00AE66  2               
00AE66  2               ;-------------------------------------------------------------------------------------
00AE66  2               
00AE66  2               FireballBGCollision:
00AE66  2  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00AE68  2  C9 18              cmp #$18
00AE6A  2  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00AE6C  2  20 3A B0           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00AE6F  2  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00AE71  2  20 4B AE           jsr ChkForNonSolids         ;check for non-solid metatiles
00AE74  2  F0 17              beq ClearBounceFlag         ;branch if any found
00AE76  2  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00AE78  2  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00AE7A  2  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00AE7C  2  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00AE7E  2  A9 FD              lda #$fd
00AE80  2  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00AE82  2  A9 01              lda #$01
00AE84  2  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00AE86  2  B5 D5              lda Fireball_Y_Position,x
00AE88  2  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00AE8A  2  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00AE8C  2  60                 rts                         ;leave
00AE8D  2               
00AE8D  2               ClearBounceFlag:
00AE8D  2  A9 00              lda #$00
00AE8F  2  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00AE91  2  60                 rts                         ;leave
00AE92  2               
00AE92  2               InitFireballExplode:
00AE92  2  A9 80              lda #$80
00AE94  2  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00AE96  2  A9 02              lda #Sfx_Bump
00AE98  2  85 FF              sta Square1SoundQueue       ;load bump sound
00AE9A  2  60                 rts                         ;leave
00AE9B  2               
00AE9B  2               ;-------------------------------------------------------------------------------------
00AE9B  2               ;$00 - used to hold one of bitmasks, or offset
00AE9B  2               ;$01 - used for relative X coordinate, also used to store middle screen page location
00AE9B  2               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00AE9B  2               
00AE9B  2               ;this data added to relative coordinates of sprite objects
00AE9B  2               ;stored in order: left edge, top edge, right edge, bottom edge
00AE9B  2               BoundBoxCtrlData:
00AE9B  2  02 08 0E 20        .byte $02, $08, $0e, $20
00AE9F  2  03 14 0D 20        .byte $03, $14, $0d, $20
00AEA3  2  02 14 0E 20        .byte $02, $14, $0e, $20
00AEA7  2  02 09 0E 15        .byte $02, $09, $0e, $15
00AEAB  2  00 00 18 06        .byte $00, $00, $18, $06
00AEAF  2  00 00 20 0D        .byte $00, $00, $20, $0d
00AEB3  2  00 00 30 0D        .byte $00, $00, $30, $0d
00AEB7  2  00 00 08 08        .byte $00, $00, $08, $08
00AEBB  2  06 04 0A 08        .byte $06, $04, $0a, $08
00AEBF  2  03 0E 0D 16        .byte $03, $0e, $0d, $16
00AEC3  2  00 02 10 15        .byte $00, $02, $10, $15
00AEC7  2  04 04 0C 1C        .byte $04, $04, $0c, $1c
00AECB  2               
00AECB  2               GetFireballBoundBox:
00AECB  2  8A                 txa         ;add seven bytes to offset
00AECC  2  18                 clc         ;to use in routines as offset for fireball
00AECD  2  69 07              adc #$07
00AECF  2  AA                 tax
00AED0  2  A0 02              ldy #$02    ;set offset for relative coordinates
00AED2  2  D0 07              bne FBallB  ;unconditional branch
00AED4  2               
00AED4  2               GetMiscBoundBox:
00AED4  2  8A                   txa                       ;add nine bytes to offset
00AED5  2  18                   clc                       ;to use in routines as offset for misc object
00AED6  2  69 09                adc #$09
00AED8  2  AA                   tax
00AED9  2  A0 06                ldy #$06                  ;set offset for relative coordinates
00AEDB  2  20 3A AF     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00AEDE  2  4C 7C AF             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00AEE1  2               
00AEE1  2               GetEnemyBoundBox:
00AEE1  2  A0 48              ldy #$48                 ;store bitmask here for now
00AEE3  2  84 00              sty $00
00AEE5  2  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00AEE7  2  4C F0 AE           jmp GetMaskedOffScrBits
00AEEA  2               
00AEEA  2               SmallPlatformBoundBox:
00AEEA  2  A0 08              ldy #$08                 ;store bitmask here for now
00AEEC  2  84 00              sty $00
00AEEE  2  A0 04              ldy #$04                 ;store another bitmask here for now
00AEF0  2               
00AEF0  2               GetMaskedOffScrBits:
00AEF0  2  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00AEF2  2  38                   sec                         ;to the left side of the screen
00AEF3  2  ED 1C 07             sbc ScreenLeft_X_Pos
00AEF6  2  85 01                sta $01                     ;store here
00AEF8  2  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00AEFA  2  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00AEFD  2  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00AEFF  2  05 01                ora $01
00AF01  2  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00AF03  2  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00AF05  2  98           CMBits: tya                         ;otherwise use contents of Y
00AF06  2  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00AF09  2  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00AF0C  2  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00AF0E  2  4C 1A AF             jmp SetupEOffsetFBBox       ;otherwise, do something else
00AF11  2               
00AF11  2               LargePlatformBoundBox:
00AF11  2  E8                 inx                        ;increment X to get the proper offset
00AF12  2  20 DB BE           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00AF15  2  CA                 dex                        ;decrement to return to original offset
00AF16  2  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00AF18  2  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00AF1A  2               
00AF1A  2               SetupEOffsetFBBox:
00AF1A  2  8A                 txa                        ;add 1 to offset to properly address
00AF1B  2  18                 clc                        ;the enemy object memory locations
00AF1C  2  69 01              adc #$01
00AF1E  2  AA                 tax
00AF1F  2  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00AF21  2  20 3A AF           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00AF24  2  4C 7C AF           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00AF27  2               
00AF27  2               MoveBoundBoxOffscreen:
00AF27  2  8A                 txa                            ;multiply offset by 4
00AF28  2  0A                 asl
00AF29  2  0A                 asl
00AF2A  2  A8                 tay                            ;use as offset here
00AF2B  2  A9 FF              lda #$ff
00AF2D  2  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00AF30  2  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00AF33  2  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00AF36  2  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00AF39  2  60                 rts
00AF3A  2               
00AF3A  2               BoundingBoxCore:
00AF3A  2  86 00              stx $00                     ;save offset here
00AF3C  2  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00AF3F  2  85 02              sta $02                     ;vertically and horizontally, respectively
00AF41  2  B9 AD 03           lda SprObject_Rel_XPos,y
00AF44  2  85 01              sta $01
00AF46  2  8A                 txa                         ;multiply offset by four and save to stack
00AF47  2  0A                 asl
00AF48  2  0A                 asl
00AF49  2  48                 pha
00AF4A  2  A8                 tay                         ;use as offset for Y, X is left alone
00AF4B  2  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00AF4E  2  0A                 asl                         ;multiply that by four and use as X
00AF4F  2  0A                 asl
00AF50  2  AA                 tax
00AF51  2  A5 01              lda $01                     ;add the first number in the bounding box data to the
00AF53  2  18                 clc                         ;relative horizontal coordinate using enemy object offset
00AF54  2  7D 9B AE           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00AF57  2  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00AF5A  2  A5 01              lda $01
00AF5C  2  18                 clc
00AF5D  2  7D 9D AE           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00AF60  2  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00AF63  2  E8                 inx                         ;increment both offsets
00AF64  2  C8                 iny
00AF65  2  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00AF67  2  18                 clc                         ;using incremented offset and store using the other
00AF68  2  7D 9B AE           adc BoundBoxCtrlData,x      ;incremented offset
00AF6B  2  99 AC 04           sta BoundingBox_UL_Corner,y
00AF6E  2  A5 02              lda $02
00AF70  2  18                 clc
00AF71  2  7D 9D AE           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00AF74  2  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00AF77  2  68                 pla                         ;get original offset loaded into $00 * y from stack
00AF78  2  A8                 tay                         ;use as Y
00AF79  2  A6 00              ldx $00                     ;get original offset and use as X again
00AF7B  2  60                 rts
00AF7C  2               
00AF7C  2               CheckRightScreenBBox:
00AF7C  2  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00AF7F  2  18                  clc                        ;and store as horizontal coordinate of middle
00AF80  2  69 80               adc #$80
00AF82  2  85 02               sta $02
00AF84  2  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00AF87  2  69 00               adc #$00                   ;and store as page location of middle
00AF89  2  85 01               sta $01
00AF8B  2  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00AF8D  2  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00AF8F  2  B5 6D               lda SprObject_PageLoc,x    ;get page location
00AF91  2  E5 01               sbc $01                    ;subtract from middle page location
00AF93  2  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00AF95  2  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00AF98  2  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00AF9A  2  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00AF9C  2  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00AF9F  2  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00AFA1  2  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00AFA4  2  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00AFA7  2  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00AFA9  2  60                  rts
00AFAA  2               
00AFAA  2               CheckLeftScreenBBox:
00AFAA  2  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00AFAD  2  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00AFAF  2  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00AFB1  2  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00AFB3  2  A9 00                lda #$00
00AFB5  2  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00AFB8  2  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00AFBA  2  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00AFBD  2  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00AFC0  2  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00AFC2  2  60                   rts
00AFC3  2               
00AFC3  2               ;-------------------------------------------------------------------------------------
00AFC3  2               ;$06 - second object's offset
00AFC3  2               ;$07 - counter
00AFC3  2               
00AFC3  2               PlayerCollisionCore:
00AFC3  2  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00AFC5  2               
00AFC5  2               SprObjectCollisionCore:
00AFC5  2  84 06              sty $06      ;save contents of Y here
00AFC7  2  A9 01              lda #$01
00AFC9  2  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00AFCB  2               
00AFCB  2               CollisionCoreLoop:
00AFCB  2  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00AFCE  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00AFD1  2  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00AFD3  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00AFD6  2  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00AFD8  2  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00AFDA  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00AFDD  2  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00AFE0  2  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00AFE2  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00AFE5  2  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00AFE7  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00AFE9  2  60                 rts                          ;note horizontal wrapping never occurs
00AFEA  2               
00AFEA  2               SecondBoxVerticalChk:
00AFEA  2  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00AFED  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00AFF0  2  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00AFF2  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00AFF5  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00AFF8  2  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00AFFA  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00AFFC  2  60                 rts
00AFFD  2               
00AFFD  2               FirstBoxGreater:
00AFFD  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00B000  2  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00B002  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00B005  2  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00B007  2  F0 13              beq CollisionFound           ;then collision, thus branch
00B009  2  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00B00C  2  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00B00E  2  F0 08              beq NoCollisionFound
00B010  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00B013  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00B016  2  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00B018  2               
00B018  2               NoCollisionFound:
00B018  2  18                 clc          ;clear carry, then load value set earlier, then leave
00B019  2  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00B01B  2  60                 rts          ;not bother checking vertical ones, because what's the point?
00B01C  2               
00B01C  2               CollisionFound:
00B01C  2  E8                 inx                    ;increment offsets on both objects to check
00B01D  2  C8                 iny                    ;the vertical coordinates
00B01E  2  C6 07              dec $07                ;decrement counter to reflect this
00B020  2  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00B022  2  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00B023  2  A4 06              ldy $06                ;load original value set here earlier, then leave
00B025  2  60                 rts
00B026  2               
00B026  2               ;-------------------------------------------------------------------------------------
00B026  2               ;$02 - modified y coordinate
00B026  2               ;$03 - stores metatile involved in block buffer collisions
00B026  2               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00B026  2               ;$05 - modified x coordinate
00B026  2               ;$06-$07 - block buffer address
00B026  2               
00B026  2               BlockBufferChk_Enemy:
00B026  2  48                 pha        ;save contents of A to stack
00B027  2  8A                 txa
00B028  2  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00B029  2  69 01              adc #$01
00B02B  2  AA                 tax
00B02C  2  68                 pla        ;pull A from stack and jump elsewhere
00B02D  2  4C 43 B0           jmp BBChk_E
00B030  2               
00B030  2               ResidualMiscObjectCode:
00B030  2  8A                 txa
00B031  2  18                 clc           ;supposedly used once to set offset for
00B032  2  69 0D              adc #$0d      ;miscellaneous objects
00B034  2  AA                 tax
00B035  2  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00B037  2  4C 41 B0           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00B03A  2               
00B03A  2               BlockBufferChk_FBall:
00B03A  2  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00B03C  2  8A                    txa
00B03D  2  18                    clc
00B03E  2  69 07                 adc #$07                  ;add seven bytes to use
00B040  2  AA                    tax
00B041  2  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00B043  2  20 8E B0     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00B046  2  A6 08                 ldx ObjectOffset          ;get object offset
00B048  2  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00B04A  2  60                    rts
00B04B  2               
00B04B  2               BlockBufferAdderData:
00B04B  2  00 07 0E           .byte $00, $07, $0e
00B04E  2               
00B04E  2               BlockBuffer_X_Adder:
00B04E  2  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00B052  2  02 0D 0D 08  
00B056  2  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00B05A  2  0D 0D 08 03  
00B05E  2  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00B062  2  0D 08 00 10  
00B066  2  04 14 04 04        .byte $04, $14, $04, $04
00B06A  2               
00B06A  2               BlockBuffer_Y_Adder:
00B06A  2  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00B06E  2  18 08 18 02  
00B072  2  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00B076  2  08 18 12 20  
00B07A  2  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00B07E  2  18 18 14 14  
00B082  2  06 06 08 10        .byte $06, $06, $08, $10
00B086  2               
00B086  2               BlockBufferColli_Feet:
00B086  2  C8                  iny            ;if branched here, increment to next set of adders
00B087  2               
00B087  2               BlockBufferColli_Head:
00B087  2  A9 00               lda #$00       ;set flag to return vertical coordinate
00B089  2  2C                  .byte $2c        ;BIT instruction opcode
00B08A  2               
00B08A  2               BlockBufferColli_Side:
00B08A  2  A9 01               lda #$01       ;set flag to return horizontal coordinate
00B08C  2  A2 00               ldx #$00       ;set offset for player object
00B08E  2               
00B08E  2               BlockBufferCollision:
00B08E  2  48                  pha                         ;save contents of A to stack
00B08F  2  84 04               sty $04                     ;save contents of Y here
00B091  2  B9 4E B0            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00B094  2  18                  clc                         ;of object to value obtained using Y as offset
00B095  2  75 86               adc SprObject_X_Position,x
00B097  2  85 05               sta $05                     ;store here
00B099  2  B5 6D               lda SprObject_PageLoc,x
00B09B  2  69 00               adc #$00                    ;add carry to page location
00B09D  2  29 01               and #$01                    ;get LSB, mask out all other bits
00B09F  2  4A                  lsr                         ;move to carry
00B0A0  2  05 05               ora $05                     ;get stored value
00B0A2  2  6A                  ror                         ;rotate carry to MSB of A
00B0A3  2  4A                  lsr                         ;and effectively move high nybble to
00B0A4  2  4A                  lsr                         ;lower, LSB which became MSB will be
00B0A5  2  4A                  lsr                         ;d4 at this point
00B0A6  2  20 22 7A            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00B0A9  2  A4 04               ldy $04                     ;get old contents of Y
00B0AB  2  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00B0AD  2  18                  clc
00B0AE  2  79 6A B0            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00B0B1  2  29 F0               and #%11110000              ;mask out low nybble
00B0B3  2  38                  sec
00B0B4  2  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00B0B6  2  85 02               sta $02                     ;store result here
00B0B8  2  A8                  tay                         ;use as offset for block buffer
00B0B9  2  B1 06               lda ($06),y                 ;check current content of block buffer
00B0BB  2  85 03               sta $03                     ;and store here
00B0BD  2  A4 04               ldy $04                     ;get old contents of Y again
00B0BF  2  68                  pla                         ;pull A from stack
00B0C0  2  D0 05               bne RetXC                   ;if A = 1, branch
00B0C2  2  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00B0C4  2  4C C9 B0            jmp RetYC                   ;and jump
00B0C7  2  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00B0C9  2  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00B0CB  2  85 04               sta $04                     ;store masked out result here
00B0CD  2  A5 03               lda $03                     ;get saved content of block buffer
00B0CF  2  60                  rts                         ;and leave
00B0D0  2               
00B0D0  2               ;-------------------------------------------------------------------------------------
00B0D0  2               
00B0D0  2               ;unused bytes
00B0D0  2  FF FF FF FF        .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff
00B0D4  2  FF FF FF     
00B0D7  2               
00B0D7  2               ;-------------------------------------------------------------------------------------
00B0D7  2               ;$00 - offset to vine Y coordinate adder
00B0D7  2               ;$02 - offset to sprite data
00B0D7  2               
00B0D7  2               VineYPosAdder:
00B0D7  2  00 30              .byte $00, $30
00B0D9  2               
00B0D9  2               DrawVine:
00B0D9  2  84 00                 sty $00                    ;save offset here
00B0DB  2  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00B0DE  2  18                    clc
00B0DF  2  79 D7 B0              adc VineYPosAdder,y        ;add value using offset in Y to get value
00B0E2  2  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00B0E5  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00B0E8  2  84 02                 sty $02                    ;store sprite data offset here
00B0EA  2  20 52 B1              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00B0ED  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00B0F0  2  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00B0F3  2  99 0B 02              sta Sprite_X_Position+8,y
00B0F6  2  99 13 02              sta Sprite_X_Position+16,y
00B0F9  2  18                    clc
00B0FA  2  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00B0FC  2  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00B0FF  2  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00B102  2  99 17 02              sta Sprite_X_Position+20,y
00B105  2  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00B107  2  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00B10A  2  99 0A 02              sta Sprite_Attributes+8,y
00B10D  2  99 12 02              sta Sprite_Attributes+16,y
00B110  2  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00B112  2  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00B115  2  99 0E 02              sta Sprite_Attributes+12,y
00B118  2  99 16 02              sta Sprite_Attributes+20,y
00B11B  2  A2 05                 ldx #$05                   ;set tiles for six sprites
00B11D  2  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00B11F  2  99 01 02              sta Sprite_Tilenumber,y
00B122  2  C8                    iny                        ;move offset to next sprite data
00B123  2  C8                    iny
00B124  2  C8                    iny
00B125  2  C8                    iny
00B126  2  CA                    dex                        ;move onto next sprite
00B127  2  10 F4                 bpl VineTL                 ;loop until all sprites are done
00B129  2  A4 02                 ldy $02                    ;get original offset
00B12B  2  A5 00                 lda $00                    ;get offset to vine adding data
00B12D  2  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00B12F  2  A9 E0                 lda #$e0
00B131  2  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00B134  2  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00B136  2  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00B139  2  38                    sec
00B13A  2  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00B13D  2  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00B13F  2  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00B141  2  A9 F8                 lda #$f8
00B143  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00B146  2  C8           NextVSp: iny                        ;move offset to next OAM data
00B147  2  C8                    iny
00B148  2  C8                    iny
00B149  2  C8                    iny
00B14A  2  E8                    inx                        ;move onto next sprite
00B14B  2  E0 06                 cpx #$06                   ;do this until all sprites are checked
00B14D  2  D0 E7                 bne ChkFTop
00B14F  2  A4 00                 ldy $00                    ;return offset set earlier
00B151  2  60                    rts
00B152  2               
00B152  2               SixSpriteStacker:
00B152  2  A2 06               ldx #$06           ;do six sprites
00B154  2  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00B157  2  18                  clc
00B158  2  69 08               adc #$08           ;add eight pixels
00B15A  2  C8                  iny
00B15B  2  C8                  iny                ;move offset four bytes forward
00B15C  2  C8                  iny
00B15D  2  C8                  iny
00B15E  2  CA                  dex                ;do another sprite
00B15F  2  D0 F3               bne StkLp          ;do this until all sprites are done
00B161  2  A4 02               ldy $02            ;get saved OAM data offset and leave
00B163  2  60                  rts
00B164  2               
00B164  2               ;-------------------------------------------------------------------------------------
00B164  2               
00B164  2               FirstSprXPos:
00B164  2  04 00 04 00        .byte $04, $00, $04, $00
00B168  2               
00B168  2               FirstSprYPos:
00B168  2  00 04 00 04        .byte $00, $04, $00, $04
00B16C  2               
00B16C  2               SecondSprXPos:
00B16C  2  00 08 00 08        .byte $00, $08, $00, $08
00B170  2               
00B170  2               SecondSprYPos:
00B170  2  08 00 08 00        .byte $08, $00, $08, $00
00B174  2               
00B174  2               FirstSprTilenum:
00B174  2  80 82 81 83        .byte $80, $82, $81, $83
00B178  2               
00B178  2               SecondSprTilenum:
00B178  2  81 83 80 82        .byte $81, $83, $80, $82
00B17C  2               
00B17C  2               HammerSprAttrib:
00B17C  2  03 03 C3 C3        .byte $03, $03, $c3, $c3
00B180  2               
00B180  2               DrawHammer:
00B180  2  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00B183  2  AD 47 07                 lda TimerControl
00B186  2  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00B188  2  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00B18A  2  29 7F                    and #%01111111              ;mask out d7
00B18C  2  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00B18E  2  F0 04                    beq GetHPose                ;if so, branch
00B190  2  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00B192  2  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00B194  2  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00B196  2  4A                       lsr                         ;move d3-d2 to d1-d0
00B197  2  4A                       lsr
00B198  2  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00B19A  2  AA                       tax                         ;use as timing offset
00B19B  2  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00B19E  2  18                       clc
00B19F  2  7D 68 B1                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00B1A2  2  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00B1A5  2  18                       clc
00B1A6  2  7D 70 B1                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00B1A9  2  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00B1AC  2  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00B1AF  2  18                       clc
00B1B0  2  7D 64 B1                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00B1B3  2  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00B1B6  2  18                       clc
00B1B7  2  7D 6C B1                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00B1BA  2  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00B1BD  2  BD 74 B1                 lda FirstSprTilenum,x
00B1C0  2  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00B1C3  2  BD 78 B1                 lda SecondSprTilenum,x
00B1C6  2  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00B1C9  2  BD 7C B1                 lda HammerSprAttrib,x
00B1CC  2  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00B1CF  2  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00B1D2  2  A6 08                    ldx ObjectOffset            ;get misc object offset
00B1D4  2  AD D6 03                 lda Misc_OffscreenBits
00B1D7  2  29 FC                    and #%11111100              ;check offscreen bits
00B1D9  2  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00B1DB  2  A9 00                    lda #$00
00B1DD  2  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00B1DF  2  A9 F8                    lda #$f8
00B1E1  2  20 67 B2                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00B1E4  2  60           NoHOffscr:  rts                         ;leave
00B1E5  2               
00B1E5  2               ;-------------------------------------------------------------------------------------
00B1E5  2               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00B1E5  2               ;$02 - used to hold Y coordinate for floatey number
00B1E5  2               ;$03 - residual byte used for flip (but value set here affects nothing)
00B1E5  2               ;$04 - attribute byte for floatey number
00B1E5  2               ;$05 - used as X coordinate for floatey number
00B1E5  2               
00B1E5  2               FlagpoleScoreNumTiles:
00B1E5  2  F9 50              .byte $f9, $50
00B1E7  2  F7 50              .byte $f7, $50
00B1E9  2  FA FB              .byte $fa, $fb
00B1EB  2  F8 FB              .byte $f8, $fb
00B1ED  2  F6 FB              .byte $f6, $fb
00B1EF  2  FD FE              .byte $fd, $fe
00B1F1  2               
00B1F1  2               FlagpoleGfxHandler:
00B1F1  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00B1F4  2  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00B1F7  2  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00B1FA  2  18                 clc
00B1FB  2  69 08              adc #$08                       ;add eight pixels and store
00B1FD  2  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00B200  2  99 0B 02           sta Sprite_X_Position+8,y
00B203  2  18                 clc
00B204  2  69 0C              adc #$0c                       ;add twelve more pixels and
00B206  2  85 05              sta $05                        ;store here to be used later by floatey number
00B208  2  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00B20A  2  20 67 B2           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00B20D  2  69 08              adc #$08                       ;add eight pixels
00B20F  2  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00B212  2  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00B215  2  85 02              sta $02                        ;store it here
00B217  2  A9 01              lda #$01
00B219  2  85 03              sta $03                        ;set value for flip which will not be used, and
00B21B  2  85 04              sta $04                        ;attribute byte for floatey number
00B21D  2  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00B220  2  99 06 02           sta Sprite_Attributes+4,y
00B223  2  99 0A 02           sta Sprite_Attributes+8,y
00B226  2  A9 7E              lda #$7e
00B228  2  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00B22B  2  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00B22E  2  A9 7F              lda #$7f
00B230  2  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00B233  2  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00B236  2  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00B238  2  98                 tya
00B239  2  18                 clc                            ;add 12 bytes to sprite data offset
00B23A  2  69 0C              adc #$0c
00B23C  2  A8                 tay                            ;put back in Y
00B23D  2  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00B240  2  0A                 asl                            ;multiply by 2 to get proper offset here
00B241  2  AA                 tax
00B242  2  BD E5 B1           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00B245  2  85 00              sta $00
00B247  2  BD E6 B1           lda FlagpoleScoreNumTiles+1,x
00B24A  2  20 8D B8           jsr DrawOneSpriteRow           ;use it to render floatey number
00B24D  2               
00B24D  2               ChkFlagOffscreen:
00B24D  2  A6 08              ldx ObjectOffset               ;get object offset for flag
00B24F  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00B252  2  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00B255  2  29 0E              and #%00001110                 ;mask out all but d3-d1
00B257  2  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00B259  2               
00B259  2               ;-------------------------------------------------------------------------------------
00B259  2               
00B259  2               MoveSixSpritesOffscreen:
00B259  2  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00B25B  2               
00B25B  2               DumpSixSpr:
00B25B  2  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00B25E  2  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00B261  2               
00B261  2               DumpFourSpr:
00B261  2  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00B264  2               
00B264  2               DumpThreeSpr:
00B264  2  99 08 02           sta Sprite_Data+8,y
00B267  2               
00B267  2               DumpTwoSpr:
00B267  2  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00B26A  2  99 00 02           sta Sprite_Data,y
00B26D  2               
00B26D  2               ExitDumpSpr:
00B26D  2  60                 rts
00B26E  2               
00B26E  2               ;-------------------------------------------------------------------------------------
00B26E  2               
00B26E  2               DrawLargePlatform:
00B26E  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B271  2  84 02              sty $02                     ;store here
00B273  2  C8                 iny                         ;add 3 to it for offset
00B274  2  C8                 iny                         ;to X coordinate
00B275  2  C8                 iny
00B276  2  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00B279  2  20 52 B1           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00B27C  2  A6 08              ldx ObjectOffset
00B27E  2  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00B280  2  20 61 B2           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00B283  2  AC 4E 07           ldy AreaType
00B286  2  C0 03              cpy #$03                    ;check for castle-type level
00B288  2  F0 05              beq ShrinkPlatform
00B28A  2  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00B28D  2  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00B28F  2               
00B28F  2               ShrinkPlatform:
00B28F  2  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00B291  2               
00B291  2               SetLast2Platform:
00B291  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B294  2  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00B297  2  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00B29A  2  A9 5B              lda #$5b                    ;load default tile for platform (mushroom)
00B29C  2  AE 43 07           ldx CloudTypeOverride
00B29F  2  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00B2A1  2  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00B2A3  2               
00B2A3  2               SetPlatformTilenum:
00B2A3  2  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00B2A5  2  C8                   iny                         ;increment Y for tile offset
00B2A6  2  20 5B B2             jsr DumpSixSpr              ;dump tile number into all six sprites
00B2A9  2  A9 02                lda #$02                    ;set palette controls
00B2AB  2  C8                   iny                         ;increment Y for sprite attributes
00B2AC  2  20 5B B2             jsr DumpSixSpr              ;dump attributes into all six sprites
00B2AF  2  E8                   inx                         ;increment X for enemy objects
00B2B0  2  20 DB BE             jsr GetXOffscreenBits       ;get offscreen bits again
00B2B3  2  CA                   dex
00B2B4  2  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00B2B7  2  0A                   asl                         ;rotate d7 into carry, save remaining
00B2B8  2  48                   pha                         ;bits to the stack
00B2B9  2  90 05                bcc SChk2
00B2BB  2  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00B2BD  2  99 00 02             sta Sprite_Y_Position,y
00B2C0  2  68           SChk2:  pla                         ;get bits from stack
00B2C1  2  0A                   asl                         ;rotate d6 into carry
00B2C2  2  48                   pha                         ;save to stack
00B2C3  2  90 05                bcc SChk3
00B2C5  2  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00B2C7  2  99 04 02             sta Sprite_Y_Position+4,y
00B2CA  2  68           SChk3:  pla                         ;get bits from stack
00B2CB  2  0A                   asl                         ;rotate d5 into carry
00B2CC  2  48                   pha                         ;save to stack
00B2CD  2  90 05                bcc SChk4
00B2CF  2  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00B2D1  2  99 08 02             sta Sprite_Y_Position+8,y
00B2D4  2  68           SChk4:  pla                         ;get bits from stack
00B2D5  2  0A                   asl                         ;rotate d4 into carry
00B2D6  2  48                   pha                         ;save to stack
00B2D7  2  90 05                bcc SChk5
00B2D9  2  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00B2DB  2  99 0C 02             sta Sprite_Y_Position+12,y
00B2DE  2  68           SChk5:  pla                         ;get bits from stack
00B2DF  2  0A                   asl                         ;rotate d3 into carry
00B2E0  2  48                   pha                         ;save to stack
00B2E1  2  90 05                bcc SChk6
00B2E3  2  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00B2E5  2  99 10 02             sta Sprite_Y_Position+16,y
00B2E8  2  68           SChk6:  pla                         ;get bits from stack
00B2E9  2  0A                   asl                         ;rotate d2 into carry
00B2EA  2  90 05                bcc SLChk                   ;save to stack
00B2EC  2  A9 F8                lda #$f8
00B2EE  2  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00B2F1  2  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00B2F4  2  0A                   asl                         ;and if d7 is not set, skip sub
00B2F5  2  90 03                bcc ExDLPl
00B2F7  2  20 59 B2             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00B2FA  2  60           ExDLPl: rts
00B2FB  2               
00B2FB  2               ;-------------------------------------------------------------------------------------
00B2FB  2               
00B2FB  2               DrawFloateyNumber_Coin:
00B2FB  2  A5 09                  lda FrameCounter          ;get frame counter
00B2FD  2  4A                     lsr                       ;divide by 2
00B2FE  2  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00B300  2  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00B302  2  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00B304  2  20 67 B2               jsr DumpTwoSpr            ;dump into both sprites
00B307  2  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00B30A  2  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00B30D  2  18                     clc
00B30E  2  69 08                  adc #$08                  ;add eight pixels
00B310  2  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00B313  2  A9 02                  lda #$02
00B315  2  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00B318  2  99 06 02               sta Sprite_Attributes+4,y
00B31B  2  A9 F7                  lda #$f7
00B31D  2  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00B320  2  A9 FB                  lda #$fb                  ;that resemble "200"
00B322  2  99 05 02               sta Sprite_Tilenumber+4,y
00B325  2  4C 63 B3               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00B328  2               
00B328  2               JumpingCoinTiles:
00B328  2  60 61 62 63        .byte $60, $61, $62, $63
00B32C  2               
00B32C  2               JCoinGfxHandler:
00B32C  2  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00B32F  2  B5 2A                 lda Misc_State,x            ;get state of misc object
00B331  2  C9 02                 cmp #$02                    ;if 2 or greater,
00B333  2  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00B335  2  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00B337  2  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00B33A  2  18                    clc
00B33B  2  69 08                 adc #$08                    ;add eight pixels
00B33D  2  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00B340  2  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00B343  2  99 03 02              sta Sprite_X_Position,y
00B346  2  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00B349  2  A5 09                 lda FrameCounter            ;get frame counter
00B34B  2  4A                    lsr                         ;divide by 2 to alter every other frame
00B34C  2  29 03                 and #%00000011              ;mask out d2-d1
00B34E  2  AA                    tax                         ;use as graphical offset
00B34F  2  BD 28 B3              lda JumpingCoinTiles,x      ;load tile number
00B352  2  C8                    iny                         ;increment OAM data offset to write tile numbers
00B353  2  20 67 B2              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00B356  2  88                    dey                         ;decrement to get old offset
00B357  2  A9 02                 lda #$02
00B359  2  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00B35C  2  A9 82                 lda #$82
00B35E  2  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00B361  2  A6 08                 ldx ObjectOffset            ;get misc object offset
00B363  2  60           ExJCGfx: rts                         ;leave
00B364  2               
00B364  2               ;-------------------------------------------------------------------------------------
00B364  2               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00B364  2               ;$02 - used to hold bottom row Y position
00B364  2               ;$03 - used to hold flip control (not used here)
00B364  2               ;$04 - used to hold sprite attributes
00B364  2               ;$05 - used to hold X position
00B364  2               ;$07 - counter
00B364  2               
00B364  2               ;tiles arranged in top left, right, bottom left, right order
00B364  2               PowerUpGfxTable:
00B364  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;regular mushroom
00B368  2  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00B36C  2  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00B370  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;1-up mushroom
00B374  2  D8 DA DB FF        .byte $d8, $da, $db, $ff ;poison mushroom
00B378  2               
00B378  2               PowerUpAttributes:
00B378  2  02 01 02 01        .byte $02, $01, $02, $01, $03
00B37C  2  03           
00B37D  2               
00B37D  2               DrawPowerUp:
00B37D  2  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00B380  2  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00B383  2  18                 clc
00B384  2  69 08              adc #$08                   ;add eight pixels
00B386  2  85 02              sta $02                    ;store result here
00B388  2  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00B38B  2  85 05              sta $05                    ;store here
00B38D  2  A6 39              ldx PowerUpType            ;get power-up type
00B38F  2  BD 78 B3           lda PowerUpAttributes,x    ;get attribute data for power-up type
00B392  2  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00B395  2  85 04              sta $04                    ;store attributes here
00B397  2  8A                 txa
00B398  2  48                 pha                        ;save power-up type to the stack
00B399  2  0A                 asl
00B39A  2  0A                 asl                        ;multiply by four to get proper offset
00B39B  2  AA                 tax                        ;use as X
00B39C  2  A9 01              lda #$01
00B39E  2  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00B3A0  2  85 03              sta $03                    ;init d1 of flip control
00B3A2  2               
00B3A2  2               PUpDrawLoop:
00B3A2  2  BD 64 B3             lda PowerUpGfxTable,x      ;load left tile of power-up object
00B3A5  2  85 00                sta $00
00B3A7  2  BD 65 B3             lda PowerUpGfxTable+1,x    ;load right tile
00B3AA  2  20 8D B8             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00B3AD  2  C6 07                dec $07                    ;decrement counter
00B3AF  2  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00B3B1  2  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00B3B4  2  68                   pla                        ;pull saved power-up type from the stack
00B3B5  2  F0 33                beq PUpOfs                 ;if regular mushroom, 1-up mushroom
00B3B7  2  C9 03                cmp #$03                   ;or poison mushroom, branch
00B3B9  2  F0 2F                beq PUpOfs                 ;do not change colors or flip them
00B3BB  2  C9 04                cmp #$04
00B3BD  2  F0 2B                beq PUpOfs
00B3BF  2  85 00                sta $00                    ;store power-up type here now
00B3C1  2  A5 09                lda FrameCounter           ;get frame counter
00B3C3  2  4A                   lsr                        ;divide by 2 to change colors every two frames
00B3C4  2  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00B3C6  2  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00B3C9  2  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00B3CC  2  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00B3CF  2  A6 00                ldx $00
00B3D1  2  CA                   dex                        ;check power-up type for fire flower
00B3D2  2  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00B3D4  2  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits for bottom left
00B3D7  2  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00B3DA  2               
00B3DA  2               FlipPUpRightSide:
00B3DA  2  B9 06 02             lda Sprite_Attributes+4,y
00B3DD  2  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00B3DF  2  99 06 02             sta Sprite_Attributes+4,y
00B3E2  2  B9 0E 02             lda Sprite_Attributes+12,y
00B3E5  2  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00B3E7  2  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00B3EA  2  4C 3F B8     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00B3ED  2               
00B3ED  2               
00B3ED  2               ;-------------------------------------------------------------------------------------
00B3ED  2               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00B3ED  2               ;$02 - used to store Y position
00B3ED  2               ;$03 - used to store moving direction, used to flip enemies horizontally
00B3ED  2               ;$04 - used to store enemy's sprite attributes
00B3ED  2               ;$05 - used to store X position
00B3ED  2               ;$eb - used to hold sprite data offset
00B3ED  2               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00B3ED  2               ;$ed - used to hold enemy state from buffer
00B3ED  2               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00B3ED  2               
00B3ED  2               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00B3ED  2               ;most enemies use more than one frame, thus have more than 6 tiles
00B3ED  2               EnemyGraphicsTable:
00B3ED  2  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad ;buzzy beetle
00B3F1  2  AC AD        
00B3F3  2  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1
00B3F7  2  B0 B1        
00B3F9  2  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9 ;koopa troopa
00B3FD  2  A8 A9        
00B3FF  2  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4
00B403  2  A3 A4        
00B405  2  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9 ;koopa paratroopa
00B409  2  A8 A9        
00B40B  2  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4
00B40F  2  A3 A4        
00B411  2  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99 ;spiny
00B415  2  98 99        
00B417  2  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d
00B41B  2  9C 9D        
00B41D  2  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f ;spiny egg
00B421  2  8E 8F        
00B423  2  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95
00B427  2  94 95        
00B429  2  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df ;bloober
00B42D  2  DF DF        
00B42F  2  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de
00B433  2  DE DE        
00B435  2  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5 ;cheep-cheep
00B439  2  B4 B5        
00B43B  2  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5
00B43F  2  B7 B5        
00B441  2  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73 ;goomba
00B445  2  72 73        
00B447  2  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f ;koopa shell (upside-down)
00B44B  2  6F 6F        
00B44D  2  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f
00B451  2  6F 6F        
00B453  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e ;koopa shell
00B457  2  6E 6E        
00B459  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d
00B45D  2  6D 6D        
00B45F  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5 ;buzzy beetle shell (upside-down)
00B463  2  F5 F5        
00B465  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5
00B469  2  F5 F5        
00B46B  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4 ;buzzy beetle
00B46F  2  F4 F4        
00B471  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4
00B475  2  F4 F4        
00B477  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef ;defeated goomba
00B47B  2  EF EF        
00B47D  2  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc ;lakitu
00B481  2  BC BC        
00B483  2  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc
00B487  2  BC BC        
00B489  2  76 79 77 77        .byte $76, $79, $77, $77, $78, $78 ;princess/door to princess's room
00B48D  2  78 78        
00B48F  2  CD CD CE CE        .byte $cd, $cd, $ce, $ce, $cf, $cf ;mushroom retainer
00B493  2  CF CF        
00B495  2  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2 ;hammer bro
00B499  2  D3 D2        
00B49B  2  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a
00B49F  2  8B 8A        
00B4A1  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2
00B4A5  2  D3 D2        
00B4A7  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a
00B4AB  2  8B 8A        
00B4AD  2  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb ;piranha plant
00B4B1  2  EB EB        
00B4B3  2  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $ee, $ee
00B4B7  2  EE EE        
00B4B9  2  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7 ;podoboo
00B4BD  2  D7 D7        
00B4BF  2  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc ;bowser front
00B4C3  2  C2 FC        
00B4C5  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7 ;bowser rear
00B4C9  2  C8 C7        
00B4CB  2  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc ;front frame 2
00B4CF  2  C2 FC        
00B4D1  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb ;rear frame 2
00B4D5  2  CC CB        
00B4D7  2  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9 ;bullet bill
00B4DB  2  EA E9        
00B4DD  2  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2 ;jumpspring
00B4E1  2  F2 F2        
00B4E3  2  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc
00B4E7  2  FC FC        
00B4E9  2  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc
00B4ED  2  FC FC        
00B4EF  2               
00B4EF  2               EnemyGfxTableOffsets:
00B4EF  2  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $c0, $a8, $54, $3c
00B4F3  2  C0 A8 54 3C  
00B4F7  2  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00B4FB  2  CC C0 18 18  
00B4FF  2  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00B503  2  48 9C D2 D8  
00B507  2  F0 F6 FC           .byte $f0, $f6, $fc
00B50A  2               
00B50A  2               EnemyAttributeData:
00B50A  2  01 02 03 02        .byte $01, $02, $03, $02, $22, $01, $03, $03
00B50E  2  22 01 03 03  
00B512  2  03 01 01 02        .byte $03, $01, $01, $02, $02, $21, $01, $02
00B516  2  02 21 01 02  
00B51A  2  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00B51E  2  02 02 01 01  
00B522  2  02 02 02           .byte $02, $02, $02
00B525  2               
00B525  2               EnemyAnimTimingBMask:
00B525  2  08 18              .byte $08, $18
00B527  2               
00B527  2               JumpspringFrameOffsets:
00B527  2  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00B52B  2  18           
00B52C  2               
00B52C  2               EnemyGfxHandler:
00B52C  2  A9 02               lda #$02
00B52E  2  AC 5F 07            ldy WorldNumber             ;if the world number is not 2, 3 or 7
00B531  2  C0 01               cpy #$01                    ;then use regular attributes for jumpsprings
00B533  2  F0 08               beq GrnJS                   ;which will paint them red
00B535  2  C0 02               cpy #$02
00B537  2  F0 04               beq GrnJS                   ;otherwise use alternate attributes
00B539  2  C0 06               cpy #$06                    ;to get the green superhigh jumpsprings
00B53B  2  D0 01               bne RedJS
00B53D  2  4A           GrnJS: lsr
00B53E  2  8D 22 B5     RedJS: sta EnemyAttributeData+$18  ;set jumpspring gfx attributes in the lookup table
00B541  2  8D 23 B5            sta EnemyAttributeData+$19
00B544  2  8D 24 B5            sta EnemyAttributeData+$1a
00B547  2  B5 CF               lda Enemy_Y_Position,x      ;get enemy object vertical position
00B549  2  85 02               sta $02
00B54B  2  AD AE 03            lda Enemy_Rel_XPos          ;get enemy object horizontal position
00B54E  2  85 05               sta $05                     ;relative to screen
00B550  2  BC E5 06            ldy Enemy_SprDataOffset,x
00B553  2  84 EB               sty $eb                     ;get sprite data offset
00B555  2  A9 00               lda #$00
00B557  2  8D 09 01            sta VerticalFlipFlag        ;initialize vertical flip flag by default
00B55A  2  B5 46               lda Enemy_MovingDir,x
00B55C  2  85 03               sta $03                     ;get enemy object moving direction
00B55E  2  BD C5 03            lda Enemy_SprAttrib,x
00B561  2  85 04               sta $04                     ;get enemy object sprite attributes
00B563  2  B5 16               lda Enemy_ID,x
00B565  2  C9 0D               cmp #PiranhaPlant           ;is enemy object piranha plant?
00B567  2  D0 0A               bne CheckForRetainerObj     ;if not, branch
00B569  2  B4 58               ldy PiranhaPlant_Y_Speed,x
00B56B  2  30 06               bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00B56D  2  BC 8A 07            ldy EnemyFrameTimer,x
00B570  2  F0 01               beq CheckForRetainerObj     ;if timer for movement expired, branch
00B572  2  60                  rts                         ;if all conditions fail, leave
00B573  2               
00B573  2               CheckForRetainerObj:
00B573  2  B5 1E              lda Enemy_State,x           ;store enemy state
00B575  2  85 ED              sta $ed
00B577  2  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00B579  2  A8                 tay
00B57A  2  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00B57C  2  C9 35              cmp #RetainerObject
00B57E  2  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00B580  2  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00B582  2  A9 01              lda #$01                    ;set value that will not be used
00B584  2  85 03              sta $03
00B586  2  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00B588  2               
00B588  2               CheckForBulletBillCV:
00B588  2  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00B58A  2  D0 13               bne CheckForJumpspring      ;if not found, branch again
00B58C  2  C6 02               dec $02                     ;decrement saved vertical position
00B58E  2  A9 03               lda #$03
00B590  2  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00B593  2  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00B595  2  09 20               ora #%00100000              ;otherwise do so
00B597  2  85 04        SBBAt: sta $04                     ;set new sprite attributes
00B599  2  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00B59B  2  84 ED               sty $ed                     ;memory location here
00B59D  2  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00B59F  2               
00B59F  2               CheckForJumpspring:
00B59F  2  C9 32              cmp #JumpspringObject        ;check for jumpspring object
00B5A1  2  D0 08              bne CheckForPodoboo
00B5A3  2  A0 03              ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00B5A5  2  AE 0E 07           ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00B5A8  2  BD 27 B5           lda JumpspringFrameOffsets,x ;load data using frame number as offset
00B5AB  2               
00B5AB  2               CheckForPodoboo:
00B5AB  2  85 EF              sta $ef                 ;store saved enemy object value here
00B5AD  2  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00B5AF  2  A6 08              ldx ObjectOffset        ;get enemy object offset
00B5B1  2  C9 0C              cmp #$0c                ;check for podoboo object
00B5B3  2  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00B5B5  2  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00B5B7  2  30 03              bmi CheckBowserGfxFlag
00B5B9  2  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00B5BC  2               
00B5BC  2               CheckBowserGfxFlag:
00B5BC  2  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00B5BF  2  F0 09                     beq CheckForGoomba
00B5C1  2  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00B5C3  2  C9 01                     cmp #$01
00B5C5  2  F0 01                     beq SBwsrGfxOfs
00B5C7  2  C8                        iny                 ;otherwise draw bowser's rear
00B5C8  2  84 EF        SBwsrGfxOfs: sty $ef
00B5CA  2               
00B5CA  2               CheckForGoomba:
00B5CA  2  A4 EF                  ldy $ef               ;check value for goomba object
00B5CC  2  C0 06                  cpy #Goomba
00B5CE  2  D0 1D                  bne CheckBowserFront  ;branch if not found
00B5D0  2  B5 1E                  lda Enemy_State,x
00B5D2  2  C9 02                  cmp #$02              ;check for defeated state
00B5D4  2  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00B5D6  2  A2 04                  ldx #$04              ;if defeated, write new value here
00B5D8  2  86 EC                  stx $ec
00B5DA  2  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00B5DC  2  0D 47 07               ora TimerControl      ;or timer disable flag set
00B5DF  2  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00B5E1  2  A5 09                  lda FrameCounter
00B5E3  2  29 08                  and #%00001000        ;check for every eighth frame
00B5E5  2  D0 06                  bne CheckBowserFront
00B5E7  2  A5 03                  lda $03
00B5E9  2  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00B5EB  2  85 03                  sta $03               ;leave alone otherwise
00B5ED  2               
00B5ED  2               CheckBowserFront:
00B5ED  2  B9 0A B5                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00B5F0  2  05 04                     ora $04                     ;as offset, and add to bits already loaded
00B5F2  2  85 04                     sta $04
00B5F4  2  B9 EF B4                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00B5F7  2  AA                        tax                         ;save as X
00B5F8  2  A4 EC                     ldy $ec                     ;get previously saved value
00B5FA  2  AD 6A 03                  lda BowserGfxFlag
00B5FD  2  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00B5FF  2  C9 01                     cmp #$01
00B601  2  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00B603  2  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00B606  2  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00B608  2  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00B60A  2  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00B60C  2  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00B60E  2  F0 03                     beq DrawBowser
00B610  2               
00B610  2               FlipBowserOver:
00B610  2  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00B613  2               
00B613  2               DrawBowser:
00B613  2  4C 1B B7           jmp DrawEnemyObject   ;draw bowser's graphics now
00B616  2               
00B616  2               
00B616  2               CheckBowserRear:
00B616  2  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00B619  2  29 01                    and #$01
00B61B  2  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00B61D  2  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00B61F  2  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00B621  2  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00B623  2  F0 EE                    beq DrawBowser
00B625  2  A5 02                    lda $02                 ;subtract 16 pixels from
00B627  2  38                       sec                     ;saved vertical coordinate
00B628  2  E9 10                    sbc #$10
00B62A  2  85 02                    sta $02
00B62C  2  4C 10 B6                 jmp FlipBowserOver      ;jump to set vertical flip flag
00B62F  2               
00B62F  2               CheckForSpiny:
00B62F  2  E0 24                cpx #$24               ;check if value loaded is for spiny
00B631  2  D0 11                bne CheckForLakitu     ;if not found, branch
00B633  2  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00B635  2  D0 0A                bne NotEgg             ;otherwise branch
00B637  2  A2 30                ldx #$30               ;set to spiny egg offset
00B639  2  A9 02                lda #$02
00B63B  2  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00B63D  2  A9 05                lda #$05
00B63F  2  85 EC                sta $ec                ;set enemy state
00B641  2  4C 94 B6     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00B644  2               
00B644  2               CheckForLakitu:
00B644  2  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00B646  2  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00B648  2  A5 ED                lda $ed
00B64A  2  29 20                and #%00100000            ;check for d5 set in enemy state
00B64C  2  D0 09                bne NoLAFr                ;branch if set
00B64E  2  AD 8F 07             lda FrenzyEnemyTimer
00B651  2  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00B653  2  B0 02                bcs NoLAFr                ;branch if not
00B655  2  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00B657  2  4C 01 B7     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00B65A  2               
00B65A  2               CheckUpsideDownShell:
00B65A  2  A5 EF              lda $ef                    ;check for enemy object => $04
00B65C  2  C9 04              cmp #$04
00B65E  2  B0 10              bcs CheckRightSideUpShell  ;branch if true
00B660  2  C0 02              cpy #$02
00B662  2  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00B664  2  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00B666  2  A4 EF              ldy $ef
00B668  2  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00B66A  2  D0 04              bne CheckRightSideUpShell
00B66C  2  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00B66E  2  E6 02              inc $02                    ;increment vertical position by one pixel
00B670  2               
00B670  2               CheckRightSideUpShell:
00B670  2  A5 EC              lda $ec                ;check for value set here
00B672  2  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00B674  2  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00B676  2  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00B678  2  E6 02              inc $02                ;increment saved vertical position by one pixel
00B67A  2  A4 EF              ldy $ef
00B67C  2  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00B67E  2  F0 04              beq CheckForDefdGoomba ;branch if found
00B680  2  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00B682  2  E6 02              inc $02                ;and increment saved vertical position again
00B684  2               
00B684  2               CheckForDefdGoomba:
00B684  2  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00B686  2  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00B688  2  A2 54              ldx #$54               ;load for regular goomba
00B68A  2  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00B68C  2  29 20              and #%00100000         ;check saved enemy state for d5 set
00B68E  2  D0 04              bne CheckForHammerBro  ;branch if set
00B690  2  A2 8A              ldx #$8a               ;load offset for defeated goomba
00B692  2  C6 02              dec $02                ;set different value and decrement saved vertical position
00B694  2               
00B694  2               CheckForHammerBro:
00B694  2  A4 08              ldy ObjectOffset
00B696  2  A5 EF              lda $ef                  ;check for hammer bro object
00B698  2  C9 05              cmp #HammerBro
00B69A  2  D0 0C              bne CheckForBloober      ;branch if not found
00B69C  2  A5 ED              lda $ed
00B69E  2  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00B6A0  2  29 08              and #%00001000
00B6A2  2  F0 5D              beq CheckDefeatedState   ;if d3 not set, branch further away
00B6A4  2  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00B6A6  2  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00B6A8  2               
00B6A8  2               CheckForBloober:
00B6A8  2  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00B6AA  2  F0 18              beq CheckToAnimateEnemy  ;branch if found
00B6AC  2  B9 96 07           lda EnemyIntervalTimer,y
00B6AF  2  C9 05              cmp #$05
00B6B1  2  B0 4E              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00B6B3  2  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00B6B5  2  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00B6B7  2  C9 01              cmp #$01
00B6B9  2  F0 46              beq CheckDefeatedState   ;branch if timer is set to certain point
00B6BB  2  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00B6BD  2  E6 02              inc $02
00B6BF  2  E6 02              inc $02
00B6C1  2  4C F3 B6           jmp CheckAnimationStop   ;and do something else
00B6C4  2               
00B6C4  2               CheckToAnimateEnemy:
00B6C4  2  A5 EF              lda $ef                  ;check for specific enemy objects
00B6C6  2  C9 06              cmp #Goomba
00B6C8  2  F0 37              beq CheckDefeatedState   ;branch if goomba
00B6CA  2  C9 08              cmp #$08
00B6CC  2  F0 33              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00B6CE  2  C9 0C              cmp #Podoboo
00B6D0  2  F0 2F              beq CheckDefeatedState   ;branch if podoboo
00B6D2  2  C9 18              cmp #$18                 ;branch if => $18
00B6D4  2  B0 2B              bcs CheckDefeatedState
00B6D6  2  A0 00              ldy #$00
00B6D8  2  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00B6DA  2  D0 10              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00B6DC  2  C8                 iny                      ;residual instruction
00B6DD  2  A9 03              lda #$03                 ;set state for mushroom retainer/princess object
00B6DF  2  85 EC              sta $ec
00B6E1  2  AD 5F 07           lda WorldNumber          ;are we on world 8?
00B6E4  2  C9 07              cmp #World8
00B6E6  2  B0 19              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00B6E8  2  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00B6EA  2  D0 15              bne CheckDefeatedState   ;unconditional branch
00B6EC  2               
00B6EC  2               CheckForSecondFrame:
00B6EC  2  A5 09              lda FrameCounter            ;load frame counter
00B6EE  2  39 25 B5           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00B6F1  2  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00B6F3  2               
00B6F3  2               CheckAnimationStop:
00B6F3  2  A5 ED              lda $ed                 ;check saved enemy state
00B6F5  2  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00B6F7  2  0D 47 07           ora TimerControl
00B6FA  2  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00B6FC  2  8A                 txa
00B6FD  2  18                 clc
00B6FE  2  69 06              adc #$06                ;add $06 to current enemy offset
00B700  2  AA                 tax                     ;to animate various enemy objects
00B701  2               
00B701  2               CheckDefeatedState:
00B701  2  A5 EF               lda $ef               ;check for upside-down piranha plant
00B703  2  C9 04               cmp #$04              ;if found, branch to draw it upside-down
00B705  2  F0 0C               beq FlipV
00B707  2  A5 ED               lda $ed               ;check saved enemy state
00B709  2  29 20               and #%00100000        ;for d5 set
00B70B  2  F0 0E               beq DrawEnemyObject   ;branch if not set
00B70D  2  A5 EF               lda $ef
00B70F  2  C9 04               cmp #$04              ;check for saved enemy object => $04
00B711  2  90 08               bcc DrawEnemyObject   ;branch if less
00B713  2  A0 01        FlipV: ldy #$01
00B715  2  8C 09 01            sty VerticalFlipFlag  ;set vertical flip flag
00B718  2  88                  dey
00B719  2  84 EC               sty $ec               ;init saved value here
00B71B  2               
00B71B  2               DrawEnemyObject:
00B71B  2  A4 EB              ldy $eb                    ;load sprite data offset
00B71D  2  20 85 B8           jsr DrawEnemyObjRow        ;draw six tiles of data
00B720  2  20 85 B8           jsr DrawEnemyObjRow        ;into sprite data
00B723  2  20 85 B8           jsr DrawEnemyObjRow
00B726  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00B728  2  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00B72B  2  A5 EF              lda $ef
00B72D  2  C9 08              cmp #$08                   ;get saved enemy object and check
00B72F  2  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00B731  2               
00B731  2               SkipToOffScrChk:
00B731  2  4C 3F B8           jmp SprObjectOffscrChk     ;jump if found
00B734  2               
00B734  2               CheckForVerticalFlip:
00B734  2  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00B737  2  F0 41              beq CheckForESymmetry      ;branch if not
00B739  2  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00B73C  2  09 80              ora #%10000000             ;set bit for vertical flip
00B73E  2  C8                 iny
00B73F  2  C8                 iny                        ;increment two bytes so that we store the vertical flip
00B740  2  20 5B B2           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00B743  2  88                 dey
00B744  2  88                 dey                        ;now go back to the Y coordinate offset
00B745  2  98                 tya
00B746  2  AA                 tax                        ;give offset to X
00B747  2  A5 EF              lda $ef
00B749  2  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00B74B  2  F0 11              beq FlipEnemyVertically
00B74D  2  C9 04              cmp #UpsideDownPiranhaP    ;check saved enemy object for upside-down piranha plant
00B74F  2  F0 0D              beq FlipEnemyVertically
00B751  2  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00B753  2  F0 09              beq FlipEnemyVertically    ;branch for any of these objects
00B755  2  C9 15              cmp #$15
00B757  2  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00B759  2  8A                 txa
00B75A  2  18                 clc
00B75B  2  69 08              adc #$08                   ;if not selected objects or => $15, set
00B75D  2  AA                 tax                        ;offset in X for next row
00B75E  2               
00B75E  2               FlipEnemyVertically:
00B75E  2  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00B761  2  48                 pha                         ;and save tiles to the stack
00B762  2  BD 05 02           lda Sprite_Tilenumber+4,x
00B765  2  48                 pha
00B766  2  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00B769  2  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00B76C  2  B9 15 02           lda Sprite_Tilenumber+20,y
00B76F  2  9D 05 02           sta Sprite_Tilenumber+4,x
00B772  2  68                 pla                         ;pull first or second row tiles from stack
00B773  2  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00B776  2  68                 pla
00B777  2  99 11 02           sta Sprite_Tilenumber+16,y
00B77A  2               
00B77A  2               CheckForESymmetry:
00B77A  2  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00B77D  2  D0 B2                bne SkipToOffScrChk         ;branch if so
00B77F  2  A5 EF                lda $ef
00B781  2  A6 EC                ldx $ec                     ;get alternate enemy state
00B783  2  C9 05                cmp #$05                    ;check for hammer bro object
00B785  2  D0 03                bne ContES
00B787  2  4C 3F B8             jmp SprObjectOffscrChk      ;jump if found
00B78A  2  C9 07        ContES: cmp #Bloober                ;check for bloober object
00B78C  2  F0 21                beq MirrorEnemyGfx
00B78E  2  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00B790  2  F0 1D                beq MirrorEnemyGfx
00B792  2  C9 04                cmp #UpsideDownPiranhaP     ;check for upside-down piranha plant object
00B794  2  F0 19                beq MirrorEnemyGfx
00B796  2  C9 0C                cmp #Podoboo                ;check for podoboo object
00B798  2  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00B79A  2  C9 12                cmp #Spiny                  ;check for spiny object
00B79C  2  D0 04                bne ESRtnr                  ;branch closer if not found
00B79E  2  E0 05                cpx #$05                    ;check spiny's state
00B7A0  2  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00B7A2  2  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00B7A4  2  D0 05                bne SpnySC
00B7A6  2  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00B7A8  2  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00B7AB  2  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00B7AD  2  90 3B                bcc CheckToMirrorLakitu
00B7AF  2               
00B7AF  2               MirrorEnemyGfx:
00B7AF  2  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00B7B2  2  D0 36                bne CheckToMirrorLakitu
00B7B4  2  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00B7B7  2  29 A3                and #%10100011
00B7B9  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00B7BC  2  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00B7BF  2  99 12 02             sta Sprite_Attributes+16,y
00B7C2  2  09 40                ora #%01000000              ;set horizontal flip
00B7C4  2  E0 05                cpx #$05                    ;check for state used by spiny's egg
00B7C6  2  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00B7C8  2  09 80                ora #%10000000              ;otherwise set vertical flip
00B7CA  2  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00B7CD  2  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00B7D0  2  99 16 02             sta Sprite_Attributes+20,y
00B7D3  2  E0 04                cpx #$04                    ;check alternate enemy state
00B7D5  2  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00B7D7  2  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00B7DA  2  09 80                ora #%10000000
00B7DC  2  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00B7DF  2  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00B7E2  2  09 40                ora #%01000000
00B7E4  2  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00B7E7  2  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00B7EA  2               
00B7EA  2               CheckToMirrorLakitu:
00B7EA  2  A5 EF                lda $ef                     ;check for lakitu enemy object
00B7EC  2  C9 11                cmp #Lakitu
00B7EE  2  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00B7F0  2  AD 09 01             lda VerticalFlipFlag
00B7F3  2  D0 21                bne NVFLak                  ;branch if vertical flip flag set
00B7F5  2  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00B7F8  2  29 81                and #%10000001              ;in third row left sprite
00B7FA  2  99 12 02             sta Sprite_Attributes+16,y
00B7FD  2  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00B800  2  09 41                ora #%01000001              ;in third row right sprite
00B802  2  99 16 02             sta Sprite_Attributes+20,y
00B805  2  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00B808  2  E0 10                cpx #$10
00B80A  2  B0 33                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00B80C  2  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00B80F  2  29 81                and #%10000001
00B811  2  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00B814  2  90 29                bcc SprObjectOffscrChk      ;unconditional branch
00B816  2  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00B819  2  29 81                and #%10000001
00B81B  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00B81E  2  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00B821  2  09 41                ora #%01000001              ;set horizontal flip and palette bits
00B823  2  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00B826  2               
00B826  2               CheckToMirrorJSpring:
00B826  2  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00B828  2  C9 18              cmp #$18
00B82A  2  90 13              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00B82C  2  A9 80              lda #$80
00B82E  2  0D 22 B5           ora EnemyAttributeData+$18
00B831  2  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00B834  2  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00B837  2  09 40              ora #%01000000
00B839  2  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00B83C  2  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00B83F  2               
00B83F  2               SprObjectOffscrChk:
00B83F  2  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00B841  2  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00B844  2  4A                    lsr
00B845  2  4A                    lsr                       ;shift three times to the right
00B846  2  4A                    lsr                       ;which puts d2 into carry
00B847  2  48                    pha                       ;save to stack
00B848  2  90 05                 bcc LcChk                 ;branch if not set
00B84A  2  A9 04                 lda #$04                  ;set for right column sprites
00B84C  2  20 9C B8              jsr MoveESprColOffscreen  ;and move them offscreen
00B84F  2  68           LcChk:   pla                       ;get from stack
00B850  2  4A                    lsr                       ;move d3 to carry
00B851  2  48                    pha                       ;save to stack
00B852  2  90 05                 bcc Row3C                 ;branch if not set
00B854  2  A9 00                 lda #$00                  ;set for left column sprites,
00B856  2  20 9C B8              jsr MoveESprColOffscreen  ;move them offscreen
00B859  2  68           Row3C:   pla                       ;get from stack again
00B85A  2  4A                    lsr                       ;move d5 to carry this time
00B85B  2  4A                    lsr
00B85C  2  48                    pha                       ;save to stack again
00B85D  2  90 05                 bcc Row23C                ;branch if carry not set
00B85F  2  A9 10                 lda #$10                  ;set for third row of sprites
00B861  2  20 92 B8              jsr MoveESprRowOffscreen  ;and move them offscreen
00B864  2  68           Row23C:  pla                       ;get from stack
00B865  2  4A                    lsr                       ;move d6 into carry
00B866  2  48                    pha                       ;save to stack
00B867  2  90 05                 bcc AllRowC
00B869  2  A9 08                 lda #$08                  ;set for second and third rows
00B86B  2  20 92 B8              jsr MoveESprRowOffscreen  ;move them offscreen
00B86E  2  68           AllRowC: pla                       ;get from stack once more
00B86F  2  4A                    lsr                       ;move d7 into carry
00B870  2  90 12                 bcc ExEGHandler
00B872  2  20 92 B8              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00B875  2  B5 16                 lda Enemy_ID,x
00B877  2  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00B879  2  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00B87B  2  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00B87D  2  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00B87F  2  D0 03                 bne ExEGHandler
00B881  2  20 CD 95              jsr EraseEnemyObject      ;what it says
00B884  2               
00B884  2               ExEGHandler:
00B884  2  60                 rts
00B885  2               
00B885  2               DrawEnemyObjRow:
00B885  2  BD ED B3           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00B888  2  85 00              sta $00
00B88A  2  BD EE B3           lda EnemyGraphicsTable+1,x
00B88D  2               
00B88D  2               DrawOneSpriteRow:
00B88D  2  85 01              sta $01
00B88F  2  4C 67 BF           jmp DrawSpriteObject        ;draw them
00B892  2               
00B892  2               MoveESprRowOffscreen:
00B892  2  18                 clc                         ;add A to enemy object OAM data offset
00B893  2  7D E5 06           adc Enemy_SprDataOffset,x
00B896  2  A8                 tay                         ;use as offset
00B897  2  A9 F8              lda #$f8
00B899  2  4C 67 B2           jmp DumpTwoSpr              ;move first row of sprites offscreen
00B89C  2               
00B89C  2               MoveESprColOffscreen:
00B89C  2  18                 clc                         ;add A to enemy object OAM data offset
00B89D  2  7D E5 06           adc Enemy_SprDataOffset,x
00B8A0  2  A8                 tay                         ;use as offset
00B8A1  2  20 25 B9           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00B8A4  2  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00B8A7  2  60                 rts
00B8A8  2               
00B8A8  2               ;-------------------------------------------------------------------------------------
00B8A8  2               ;$00-$01 - tile numbers
00B8A8  2               ;$02 - relative Y position
00B8A8  2               ;$03 - horizontal flip flag (not used here)
00B8A8  2               ;$04 - attributes
00B8A8  2               ;$05 - relative X position
00B8A8  2               
00B8A8  2               DefaultBlockObjTiles:
00B8A8  2  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00B8AC  2               
00B8AC  2               DrawBlock:
00B8AC  2  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00B8AF  2  85 02                   sta $02                       ;store here
00B8B1  2  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00B8B4  2  85 05                   sta $05                       ;store here
00B8B6  2  A9 03                   lda #$03
00B8B8  2  85 04                   sta $04                       ;set attribute byte here
00B8BA  2  4A                      lsr
00B8BB  2  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00B8BD  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00B8C0  2  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00B8C2  2  BD A8 B8     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00B8C5  2  85 00                   sta $00                       ;set here
00B8C7  2  BD A9 B8                lda DefaultBlockObjTiles+1,x  ;get right tile number
00B8CA  2  20 8D B8                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00B8CD  2  E0 04                   cpx #$04                      ;check incremented offset
00B8CF  2  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00B8D1  2  A6 08                   ldx ObjectOffset              ;get block object offset
00B8D3  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00B8D6  2  AD 4E 07                lda AreaType
00B8D9  2  C9 01                   cmp #$01                      ;check for ground level type area
00B8DB  2  F0 08                   beq ChkRep                    ;if found, branch to next part
00B8DD  2  A9 86                   lda #$86
00B8DF  2  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00B8E2  2  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00B8E5  2  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00B8E8  2  C9 C5                   cmp #$c5                      ;if not used block metatile, then
00B8EA  2  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00B8EC  2  A9 87                   lda #$87                      ;set A for used block tile
00B8EE  2  C8                      iny                           ;increment Y to write to tile bytes
00B8EF  2  20 61 B2                jsr DumpFourSpr               ;do sub to dump into all four sprites
00B8F2  2  88                      dey                           ;return Y to original offset
00B8F3  2  A9 03                   lda #$03                      ;set palette bits
00B8F5  2  AE 4E 07                ldx AreaType
00B8F8  2  CA                      dex                           ;check for ground level type area again
00B8F9  2  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00B8FB  2  4A                      lsr                           ;otherwise set to $01
00B8FC  2  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00B8FE  2  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00B901  2  09 40                   ora #%01000000
00B903  2  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00B906  2  09 80                   ora #%10000000
00B908  2  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00B90B  2  29 83                   and #%10000011
00B90D  2  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00B910  2  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00B913  2  48                      pha                           ;save to stack
00B914  2  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00B916  2  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00B918  2  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00B91A  2  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00B91D  2  99 0C 02                sta Sprite_Y_Position+12,y
00B920  2  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00B921  2  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00B923  2  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00B925  2               
00B925  2               MoveColOffscreen:
00B925  2  A9 F8                lda #$f8                   ;move offscreen two OAMs
00B927  2  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00B92A  2  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00B92D  2  60           ExDBlk: rts
00B92E  2               
00B92E  2               ;-------------------------------------------------------------------------------------
00B92E  2               ;$00 - used to hold palette bits for attribute byte or relative X position
00B92E  2               
00B92E  2               DrawBrickChunks:
00B92E  2  A9 02                 lda #$02                   ;set palette bits here
00B930  2  85 00                 sta $00
00B932  2  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00B934  2  A4 0E                 ldy GameEngineSubroutine
00B936  2  C0 05                 cpy #$05                   ;if end-of-level routine running,
00B938  2  F0 06                 beq DChunks                ;use palette and tile number assigned
00B93A  2  A9 03                 lda #$03                   ;otherwise set different palette bits
00B93C  2  85 00                 sta $00
00B93E  2  A9 84                 lda #$84                   ;and set tile number for brick chunks
00B940  2  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00B943  2  C8                    iny                        ;increment to start with tile bytes in OAM
00B944  2  20 61 B2              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00B947  2  A5 09                 lda FrameCounter           ;get frame counter
00B949  2  0A                    asl
00B94A  2  0A                    asl
00B94B  2  0A                    asl                        ;move low nybble to high
00B94C  2  0A                    asl
00B94D  2  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00B94F  2  05 00                 ora $00                    ;add palette bits
00B951  2  C8                    iny                        ;increment offset for attribute bytes
00B952  2  20 61 B2              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00B955  2  88                    dey
00B956  2  88                    dey                        ;decrement offset to Y coordinate
00B957  2  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00B95A  2  20 67 B2              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00B95D  2  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00B960  2  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00B963  2  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00B966  2  38                    sec
00B967  2  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00B96A  2  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00B96C  2  38                    sec
00B96D  2  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00B970  2  65 00                 adc $00                    ;add original relative position to result
00B972  2  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00B974  2  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00B977  2  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00B97A  2  99 08 02              sta Sprite_Y_Position+8,y
00B97D  2  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00B980  2  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00B983  2  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00B986  2  A5 00                 lda $00                    ;use original relative horizontal position
00B988  2  38                    sec
00B989  2  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00B98C  2  65 00                 adc $00                    ;add original relative position to result
00B98E  2  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00B990  2  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00B993  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00B996  2  20 21 B9              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00B999  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00B99C  2  0A                    asl                        ;shift d7 into carry
00B99D  2  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00B99F  2  A9 F8                 lda #$f8
00B9A1  2  20 67 B2              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00B9A4  2  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00B9A6  2  10 10                 bpl ExBCDr                 ;go ahead and leave
00B9A8  2  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00B9AB  2  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00B9AE  2  90 08                 bcc ExBCDr                 ;branch to leave if less
00B9B0  2  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00B9B2  2  99 04 02              sta Sprite_Y_Position+4,y
00B9B5  2  99 0C 02              sta Sprite_Y_Position+12,y
00B9B8  2  60           ExBCDr:  rts                        ;leave
00B9B9  2               
00B9B9  2               ;-------------------------------------------------------------------------------------
00B9B9  2               
00B9B9  2               DrawFireball:
00B9B9  2  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00B9BC  2  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00B9BF  2  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00B9C2  2  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00B9C5  2  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00B9C8  2               
00B9C8  2               DrawFirebar:
00B9C8  2  A5 09               lda FrameCounter         ;get frame counter
00B9CA  2  4A                  lsr                      ;divide by four
00B9CB  2  4A                  lsr
00B9CC  2  48                  pha                      ;save result to stack
00B9CD  2  29 01               and #$01                 ;mask out all but last bit
00B9CF  2  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00B9D1  2  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00B9D4  2  68                  pla                      ;get from stack
00B9D5  2  4A                  lsr                      ;divide by four again
00B9D6  2  4A                  lsr
00B9D7  2  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00B9D9  2  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00B9DB  2  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00B9DD  2  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00B9E0  2  60                  rts
00B9E1  2               
00B9E1  2               ;-------------------------------------------------------------------------------------
00B9E1  2               
00B9E1  2               ExplosionTiles:
00B9E1  2  68 67 66           .byte $68, $67, $66
00B9E4  2               
00B9E4  2               DrawExplosion_Fireball:
00B9E4  2  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00B9E7  2  B5 24              lda Fireball_State,x     ;load fireball state
00B9E9  2  F6 24              inc Fireball_State,x     ;increment state for next frame
00B9EB  2  4A                 lsr                      ;divide by 2
00B9EC  2  29 07              and #%00000111           ;mask out all but d3-d1
00B9EE  2  C9 03              cmp #$03                 ;check to see if time to kill fireball
00B9F0  2  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00B9F2  2               
00B9F2  2               DrawExplosion_Fireworks:
00B9F2  2  AA                 tax                         ;use whatever's in A for offset
00B9F3  2  BD E1 B9           lda ExplosionTiles,x        ;get tile number using offset
00B9F6  2  C8                 iny                         ;increment Y (contains sprite data offset)
00B9F7  2  20 61 B2           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00B9FA  2  88                 dey                         ;decrement Y so we have the proper offset again
00B9FB  2  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00B9FD  2  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00BA00  2  38                 sec                         ;subtract four pixels vertically
00BA01  2  E9 04              sbc #$04                    ;for first and third sprites
00BA03  2  99 00 02           sta Sprite_Y_Position,y
00BA06  2  99 08 02           sta Sprite_Y_Position+8,y
00BA09  2  18                 clc                         ;add eight pixels vertically
00BA0A  2  69 08              adc #$08                    ;for second and fourth sprites
00BA0C  2  99 04 02           sta Sprite_Y_Position+4,y
00BA0F  2  99 0C 02           sta Sprite_Y_Position+12,y
00BA12  2  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00BA15  2  38                 sec                         ;subtract four pixels horizontally
00BA16  2  E9 04              sbc #$04                    ;for first and second sprites
00BA18  2  99 03 02           sta Sprite_X_Position,y
00BA1B  2  99 07 02           sta Sprite_X_Position+4,y
00BA1E  2  18                 clc                         ;add eight pixels horizontally
00BA1F  2  69 08              adc #$08                    ;for third and fourth sprites
00BA21  2  99 0B 02           sta Sprite_X_Position+8,y
00BA24  2  99 0F 02           sta Sprite_X_Position+12,y
00BA27  2  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00BA29  2  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00BA2C  2  A9 82              lda #$82
00BA2E  2  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00BA31  2  A9 42              lda #$42
00BA33  2  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00BA36  2  A9 C2              lda #$c2
00BA38  2  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00BA3B  2  60                 rts                         ;we are done
00BA3C  2               
00BA3C  2               KillFireBall:
00BA3C  2  A9 00              lda #$00                    ;clear fireball state to kill it
00BA3E  2  95 24              sta Fireball_State,x
00BA40  2  60                 rts
00BA41  2               
00BA41  2               ;-------------------------------------------------------------------------------------
00BA41  2               
00BA41  2               DrawSmallPlatform:
00BA41  2  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00BA44  2  A9 5B               lda #$5b                    ;load tile number for small platforms
00BA46  2  C8                  iny                         ;increment offset for tile numbers
00BA47  2  20 5B B2            jsr DumpSixSpr              ;dump tile number into all six sprites
00BA4A  2  C8                  iny                         ;increment offset for attributes
00BA4B  2  A9 02               lda #$02                    ;load palette controls
00BA4D  2  20 5B B2            jsr DumpSixSpr              ;dump attributes into all six sprites
00BA50  2  88                  dey                         ;decrement for original offset
00BA51  2  88                  dey
00BA52  2  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00BA55  2  99 03 02            sta Sprite_X_Position,y
00BA58  2  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00BA5B  2  18                  clc
00BA5C  2  69 08               adc #$08                    ;add eight pixels
00BA5E  2  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00BA61  2  99 13 02            sta Sprite_X_Position+16,y
00BA64  2  18                  clc
00BA65  2  69 08               adc #$08                    ;add eight more pixels
00BA67  2  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00BA6A  2  99 17 02            sta Sprite_X_Position+20,y
00BA6D  2  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00BA6F  2  AA                  tax
00BA70  2  48                  pha                         ;save to stack
00BA71  2  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00BA73  2  B0 02               bcs TopSP                   ;do not mess with it
00BA75  2  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00BA77  2  20 64 B2     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00BA7A  2  68                  pla                         ;pull from stack
00BA7B  2  18                  clc
00BA7C  2  69 80               adc #$80                    ;add 128 pixels
00BA7E  2  AA                  tax
00BA7F  2  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00BA81  2  B0 02               bcs BotSP                   ;then do not change altered coordinate
00BA83  2  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00BA85  2  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00BA88  2  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00BA8B  2  99 14 02            sta Sprite_Y_Position+20,y
00BA8E  2  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00BA91  2  48                  pha                         ;save to stack
00BA92  2  29 08               and #%00001000              ;check d3
00BA94  2  F0 08               beq SOfs
00BA96  2  A9 F8               lda #$f8                    ;if d3 was set, move first and
00BA98  2  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00BA9B  2  99 0C 02            sta Sprite_Y_Position+12,y
00BA9E  2  68           SOfs:  pla                         ;move out and back into stack
00BA9F  2  48                  pha
00BAA0  2  29 04               and #%00000100              ;check d2
00BAA2  2  F0 08               beq SOfs2
00BAA4  2  A9 F8               lda #$f8                    ;if d2 was set, move second and
00BAA6  2  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00BAA9  2  99 10 02            sta Sprite_Y_Position+16,y
00BAAC  2  68           SOfs2: pla                         ;get from stack
00BAAD  2  29 02               and #%00000010              ;check d1
00BAAF  2  F0 08               beq ExSPl
00BAB1  2  A9 F8               lda #$f8                    ;if d1 was set, move third and
00BAB3  2  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00BAB6  2  99 14 02            sta Sprite_Y_Position+20,y
00BAB9  2  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00BABB  2  60                  rts
00BABC  2               
00BABC  2               ;-------------------------------------------------------------------------------------
00BABC  2               
00BABC  2               DrawBubble:
00BABC  2  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00BABE  2  88                   dey                         ;not within screen, skip all of this
00BABF  2  D0 20                bne ExDBub
00BAC1  2  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00BAC4  2  29 08                and #%00001000
00BAC6  2  D0 19                bne ExDBub                  ;if bit set, branch to leave
00BAC8  2  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00BACB  2  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00BACE  2  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00BAD1  2  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00BAD4  2  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00BAD7  2  A9 74                lda #$74
00BAD9  2  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00BADC  2  A9 02                lda #$02
00BADE  2  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00BAE1  2  60           ExDBub: rts                         ;leave
00BAE2  2               
00BAE2  2               ;-------------------------------------------------------------------------------------
00BAE2  2               ;$00 - used to store player's vertical offscreen bits
00BAE2  2               
00BAE2  2               PlayerGfxTblOffsets:
00BAE2  2  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00BAE6  2  00 40 50 58  
00BAEA  2  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00BAEE  2  60 A0 B0 B8  
00BAF2  2               
00BAF2  2               ;tiles arranged in order, 2 tiles per row, top to bottom
00BAF2  2               
00BAF2  2               PlayerGraphicsTable:
00BAF2  2               ;big player table
00BAF2  2  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00BAF6  2  04 05 06 07  
00BAFA  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00BAFE  2  0C 0D 0E 0F  
00BB02  2  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00BB06  2  14 15 16 17  
00BB0A  2  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00BB0E  2  1C 1D 1E 1F  
00BB12  2  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00BB16  2  24 25 26 27  
00BB1A  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00BB1E  2  2A 2B 2C 2D  
00BB22  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00BB26  2  0C 30 2C 2D  
00BB2A  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00BB2E  2  2E 2F 2C 2D  
00BB32  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00BB36  2  2A 2B 5C 5D  
00BB3A  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00BB3E  2  0C 0D 5E 5F  
00BB42  2  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00BB46  2  58 59 5A 5A  
00BB4A  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00BB4E  2  2A 2B 0E 0F  
00BB52  2               
00BB52  2               ;small player table
00BB52  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00BB56  2  32 33 34 35  
00BB5A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00BB5E  2  36 37 38 39  
00BB62  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00BB66  2  3A 37 3B 3C  
00BB6A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00BB6E  2  3D 3E 3F 40  
00BB72  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00BB76  2  32 41 42 43  
00BB7A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00BB7E  2  32 33 44 45  
00BB82  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00BB86  2  32 33 44 47  
00BB8A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00BB8E  2  32 33 48 49  
00BB92  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00BB96  2  32 33 90 91  
00BB9A  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00BB9E  2  3A 37 92 93  
00BBA2  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00BBA6  2  9E 9E 9F 9F  
00BBAA  2               
00BBAA  2               ;used by both player sizes
00BBAA  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00BBAE  2  3A 37 4F 4F  
00BBB2  2  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00BBB6  2  4C 4D 4E 4E  
00BBBA  2  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00BBBE  2  4A 4A 4B 4B  
00BBC2  2               
00BBC2  2               SwimKickTileNum:
00BBC2  2  31 46              .byte $31, $46
00BBC4  2               
00BBC4  2               PlayerGfxHandler:
00BBC4  2  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00BBC7  2  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00BBC9  2  A5 09                lda FrameCounter
00BBCB  2  4A                   lsr                         ;otherwise check frame counter and branch
00BBCC  2  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00BBCE  2  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00BBD0  2  C9 0B                cmp #$0b                    ;branch ahead to some other part
00BBD2  2  F0 47                beq PlayerKilled
00BBD4  2  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00BBD7  2  D0 3C                bne DoChangeSize            ;then branch to some other code
00BBD9  2  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00BBDC  2  F0 31                beq FindPlayerAction        ;different part, do not return
00BBDE  2  A5 1D                lda Player_State
00BBE0  2  C9 00                cmp #$00                    ;if player status normal,
00BBE2  2  F0 2B                beq FindPlayerAction        ;branch and do not return
00BBE4  2  20 0F BC             jsr FindPlayerAction        ;otherwise jump and return
00BBE7  2  A5 09                lda FrameCounter
00BBE9  2  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00BBEB  2  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00BBED  2  AA                   tax                         ;initialize X to zero
00BBEE  2  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00BBF1  2  A5 33                lda PlayerFacingDir         ;get player's facing direction
00BBF3  2  4A                   lsr
00BBF4  2  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00BBF6  2  C8                   iny
00BBF7  2  C8                   iny                         ;otherwise move to next OAM data
00BBF8  2  C8                   iny
00BBF9  2  C8                   iny
00BBFA  2  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00BBFD  2  F0 09                beq BigKTS                  ;if big, use first tile
00BBFF  2  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00BC02  2  CD 90 BB             cmp SwimTileRepOffset       ;against tile number in player graphics table
00BC05  2  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00BC07  2  E8                   inx                         ;otherwise increment X for second tile
00BC08  2  BD C2 BB     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00BC0B  2  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00BC0E  2  60           ExPGH:  rts                         ;then leave
00BC0F  2               
00BC0F  2               FindPlayerAction:
00BC0F  2  20 C7 BC           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00BC12  2  4C 20 BC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00BC15  2               
00BC15  2               DoChangeSize:
00BC15  2  20 95 BD           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00BC18  2  4C 20 BC           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00BC1B  2               
00BC1B  2               PlayerKilled:
00BC1B  2  A0 0E              ldy #$0e                      ;load offset for player killed
00BC1D  2  B9 E2 BA           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00BC20  2               
00BC20  2               PlayerGfxProcessing:
00BC20  2  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00BC23  2  A9 04               lda #$04
00BC25  2  20 99 BC            jsr RenderPlayerSub           ;draw player based on offset loaded
00BC28  2  20 CE BD            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00BC2B  2  AD 11 07            lda FireballThrowingTimer
00BC2E  2  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00BC30  2  A0 00               ldy #$00                      ;set value to initialize by default
00BC32  2  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00BC35  2  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00BC38  2  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00BC3B  2  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00BC3D  2  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00BC40  2  A0 07               ldy #$07                      ;load offset for throwing
00BC42  2  B9 E2 BA            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00BC45  2  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00BC48  2  A0 04               ldy #$04                      ;set to update four sprite rows by default
00BC4A  2  A5 57               lda Player_X_Speed
00BC4C  2  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00BC4E  2  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00BC50  2  88                  dey                           ;otherwise set to update only three sprite rows
00BC51  2  98           SUpdR: tya                           ;save in A for use
00BC52  2  20 99 BC            jsr RenderPlayerSub           ;in sub, draw player object again
00BC55  2               
00BC55  2               PlayerOffscreenChk:
00BC55  2  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00BC58  2  4A                      lsr
00BC59  2  4A                      lsr                           ;move vertical bits to low nybble
00BC5A  2  4A                      lsr
00BC5B  2  4A                      lsr
00BC5C  2  85 00                   sta $00                       ;store here
00BC5E  2  A2 03                   ldx #$03                      ;check all four rows of player sprites
00BC60  2  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00BC63  2  18                      clc
00BC64  2  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00BC66  2  A8                      tay                           ;set as offset here
00BC67  2  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00BC69  2  46 00                   lsr $00                       ;shift bit into carry
00BC6B  2  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00BC6D  2  20 67 B2                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00BC70  2  98           NPROffscr: tya
00BC71  2  38                      sec                           ;subtract eight bytes to do
00BC72  2  E9 08                   sbc #$08                      ;next row up
00BC74  2  A8                      tay
00BC75  2  CA                      dex                           ;decrement row counter
00BC76  2  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00BC78  2  60                      rts                           ;then we are done!
00BC79  2               
00BC79  2               IntermediatePlayerData:
00BC79  2  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00BC7D  2  FF 04        
00BC7F  2               
00BC7F  2               DrawPlayer_Intermediate:
00BC7F  2  A2 05                  ldx #$05                       ;store data into zero page memory
00BC81  2  BD 79 BC     PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
00BC84  2  95 02                  sta $02,x                      ;appears on world/lives display
00BC86  2  CA                     dex
00BC87  2  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00BC89  2  A2 B8                  ldx #$b8                       ;load offset for small standing
00BC8B  2  A0 04                  ldy #$04                       ;load sprite data offset
00BC8D  2  20 B7 BC               jsr DrawPlayerLoop             ;draw player accordingly
00BC90  2  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00BC93  2  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00BC95  2  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00BC98  2  60                     rts
00BC99  2               
00BC99  2               ;-------------------------------------------------------------------------------------
00BC99  2               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00BC99  2               ;$02 - vertical position
00BC99  2               ;$03 - facing direction, used as horizontal flip control
00BC99  2               ;$04 - attributes
00BC99  2               ;$05 - horizontal position
00BC99  2               ;$07 - number of rows to draw
00BC99  2               ;these also used in IntermediatePlayerData
00BC99  2               
00BC99  2               RenderPlayerSub:
00BC99  2  85 07                sta $07                      ;store number of rows of sprites to draw
00BC9B  2  AD AD 03             lda Player_Rel_XPos
00BC9E  2  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00BCA1  2  85 05                sta $05                      ;store it here also
00BCA3  2  AD B8 03             lda Player_Rel_YPos
00BCA6  2  85 02                sta $02                      ;store player's vertical position
00BCA8  2  A5 33                lda PlayerFacingDir
00BCAA  2  85 03                sta $03                      ;store player's facing direction
00BCAC  2  AD C4 03             lda Player_SprAttrib
00BCAF  2  85 04                sta $04                      ;store player's sprite attributes
00BCB1  2  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00BCB4  2  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00BCB7  2               
00BCB7  2               DrawPlayerLoop:
00BCB7  2  BD F2 BA             lda PlayerGraphicsTable,x    ;load player's left side
00BCBA  2  85 00                sta $00
00BCBC  2  BD F3 BA             lda PlayerGraphicsTable+1,x  ;now load right side
00BCBF  2  20 8D B8             jsr DrawOneSpriteRow
00BCC2  2  C6 07                dec $07                      ;decrement rows of sprites to draw
00BCC4  2  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00BCC6  2  60                   rts
00BCC7  2               
00BCC7  2               ProcessPlayerAction:
00BCC7  2  A5 1D                lda Player_State      ;get player's state
00BCC9  2  C9 03                cmp #$03
00BCCB  2  F0 5C                beq ActionClimbing    ;if climbing, branch here
00BCCD  2  C9 02                cmp #$02
00BCCF  2  F0 48                beq ActionFalling     ;if falling, branch here
00BCD1  2  C9 01                cmp #$01
00BCD3  2  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00BCD5  2  AD 04 07             lda SwimmingFlag
00BCD8  2  D0 5B                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00BCDA  2  A0 06                ldy #$06              ;load offset for crouching
00BCDC  2  AD 14 07             lda CrouchingFlag     ;get crouching flag
00BCDF  2  D0 2C                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00BCE1  2  A0 00                ldy #$00              ;otherwise load offset for jumping
00BCE3  2  4C 0D BD             jmp NonAnimatedActs   ;go to get offset to graphics table
00BCE6  2               
00BCE6  2               ProcOnGroundActs:
00BCE6  2  A0 06                 ldy #$06                   ;load offset for crouching
00BCE8  2  AD 14 07              lda CrouchingFlag          ;get crouching flag
00BCEB  2  D0 20                 bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00BCED  2  A0 02                 ldy #$02                   ;load offset for standing
00BCEF  2  A5 57                 lda Player_X_Speed         ;check player's horizontal speed
00BCF1  2  05 0C                 ora Left_Right_Buttons     ;and left/right controller bits
00BCF3  2  F0 18                 beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00BCF5  2  AD 00 07              lda Player_XSpeedAbsolute  ;load walking/running speed
00BCF8  2  C9 09                 cmp #$09
00BCFA  2  90 25                 bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00BCFC  2  A5 45                 lda Player_MovingDir       ;otherwise check to see if moving direction
00BCFE  2  25 33                 and PlayerFacingDir        ;and facing direction are the same
00BD00  2  D0 1F                 bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00BD02  2  A5 0E                 lda GameEngineSubroutine
00BD04  2  C9 09                 cmp #$09                   ;if running the change size, fire flower, injure
00BD06  2  B0 04                 bcs NoSkidS                ;or death game engine subroutines, skip this
00BD08  2  A9 80                 lda #$80                   ;otherwise play skid sound
00BD0A  2  85 FD                 sta NoiseSoundQueue
00BD0C  2  C8           NoSkidS: iny                        ;increment to skid offset ($03)
00BD0D  2               
00BD0D  2               NonAnimatedActs:
00BD0D  2  20 76 BD             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00BD10  2  A9 00                lda #$00
00BD12  2  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00BD15  2  B9 E2 BA             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00BD18  2  60                   rts
00BD19  2               
00BD19  2               ActionFalling:
00BD19  2  A0 04                ldy #$04                  ;load offset for walking/running
00BD1B  2  20 76 BD             jsr GetGfxOffsetAdder     ;get offset to graphics table
00BD1E  2  4C 47 BD             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00BD21  2               
00BD21  2               ActionWalkRun:
00BD21  2  A0 04                ldy #$04               ;load offset for walking/running
00BD23  2  20 76 BD             jsr GetGfxOffsetAdder  ;get offset to graphics table
00BD26  2  4C 4D BD             jmp FourFrameExtent    ;execute instructions for normal state
00BD29  2               
00BD29  2               ActionClimbing:
00BD29  2  A0 05                ldy #$05               ;load offset for climbing
00BD2B  2  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00BD2D  2  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00BD2F  2  20 76 BD             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00BD32  2  4C 52 BD             jmp ThreeFrameExtent   ;then skip ahead to more code
00BD35  2               
00BD35  2               ActionSwimming:
00BD35  2  A0 01                ldy #$01               ;load offset for swimming
00BD37  2  20 76 BD             jsr GetGfxOffsetAdder
00BD3A  2  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00BD3D  2  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00BD40  2  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00BD42  2  A5 0A                lda A_B_Buttons
00BD44  2  0A                   asl                    ;check for A button pressed
00BD45  2  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00BD47  2               
00BD47  2               GetCurrentAnimOffset:
00BD47  2  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00BD4A  2  4C B5 BD             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00BD4D  2               
00BD4D  2               FourFrameExtent:
00BD4D  2  A9 03                lda #$03              ;load upper extent for frame control
00BD4F  2  4C 54 BD             jmp AnimationControl  ;jump to get offset and animate player object
00BD52  2               
00BD52  2               ThreeFrameExtent:
00BD52  2  A9 02                lda #$02              ;load upper extent for frame control for climbing
00BD54  2               
00BD54  2               AnimationControl:
00BD54  2  85 00                  sta $00                   ;store upper extent here
00BD56  2  20 47 BD               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00BD59  2  48                     pha                       ;save offset to stack
00BD5A  2  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00BD5D  2  D0 15                  bne ExAnimC               ;branch if not expired
00BD5F  2  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00BD62  2  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00BD65  2  AD 0D 07               lda PlayerAnimCtrl
00BD68  2  18                     clc                       ;add one to animation frame control
00BD69  2  69 01                  adc #$01
00BD6B  2  C5 00                  cmp $00                   ;compare to upper extent
00BD6D  2  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00BD6F  2  A9 00                  lda #$00                  ;otherwise initialize frame control
00BD71  2  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00BD74  2  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00BD75  2  60                     rts
00BD76  2               
00BD76  2               GetGfxOffsetAdder:
00BD76  2  AD 54 07             lda PlayerSize  ;get player's size
00BD79  2  F0 05                beq SzOfs       ;if player big, use current offset as-is
00BD7B  2  98                   tya             ;for big player
00BD7C  2  18                   clc             ;otherwise add eight bytes to offset
00BD7D  2  69 08                adc #$08        ;for small player
00BD7F  2  A8                   tay
00BD80  2  60           SzOfs:  rts             ;go back
00BD81  2               
00BD81  2               ChangeSizeOffsetAdder:
00BD81  2  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00BD85  2  00 01 02 00  
00BD89  2  01 02        
00BD8B  2  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00BD8F  2  02 00 02 00  
00BD93  2  02 00        
00BD95  2               
00BD95  2               HandleChangeSize:
00BD95  2  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00BD98  2  A5 09                 lda FrameCounter
00BD9A  2  29 03                 and #%00000011               ;get frame counter and execute this code every
00BD9C  2  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00BD9E  2  C8                    iny                          ;increment frame control
00BD9F  2  C0 0A                 cpy #$0a                     ;check for preset upper extent
00BDA1  2  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00BDA3  2  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00BDA5  2  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00BDA8  2  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00BDAB  2  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00BDAE  2  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00BDB0  2  B9 81 BD              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00BDB3  2  A0 0F                 ldy #$0f                     ;load offset for player growing
00BDB5  2               
00BDB5  2               GetOffsetFromAnimCtrl:
00BDB5  2  0A                   asl                        ;multiply animation frame control
00BDB6  2  0A                   asl                        ;by eight to get proper amount
00BDB7  2  0A                   asl                        ;to add to our offset
00BDB8  2  79 E2 BA             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00BDBB  2  60                   rts                        ;and return with result in A
00BDBC  2               
00BDBC  2               ShrinkPlayer:
00BDBC  2  98                   tya                          ;add ten bytes to frame control as offset
00BDBD  2  18                   clc
00BDBE  2  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00BDC0  2  AA                   tax                          ;to draw the player shrinking
00BDC1  2  A0 09                ldy #$09                     ;load offset for small player swimming
00BDC3  2  BD 81 BD             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00BDC6  2  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00BDC8  2  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00BDCA  2  B9 E2 BA     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00BDCD  2  60                   rts                          ;and leave
00BDCE  2               
00BDCE  2               ChkForPlayerAttrib:
00BDCE  2  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00BDD1  2  A5 0E                   lda GameEngineSubroutine
00BDD3  2  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00BDD5  2  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00BDD7  2  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00BDDA  2  C9 50                   cmp #$50
00BDDC  2  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00BDDE  2  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00BDE0  2  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00BDE2  2  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00BDE4  2  F0 16                   beq C_S_IGAtt
00BDE6  2  C9 C8                   cmp #$c8
00BDE8  2  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00BDEA  2  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00BDED  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00BDEF  2  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00BDF2  2  B9 16 02                lda Sprite_Attributes+20,y
00BDF5  2  29 3F                   and #%00111111
00BDF7  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00BDF9  2  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00BDFC  2  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00BDFF  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00BE01  2  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00BE04  2  B9 1E 02                lda Sprite_Attributes+28,y
00BE07  2  29 3F                   and #%00111111
00BE09  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00BE0B  2  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00BE0E  2  60           ExPlyrAt:  rts                         ;leave
00BE0F  2               
00BE0F  2               ;-------------------------------------------------------------------------------------
00BE0F  2               ;$00 - used in adding to get proper offset
00BE0F  2               
00BE0F  2               RelativePlayerPosition:
00BE0F  2  A2 00                ldx #$00      ;set offsets for relative cooordinates
00BE11  2  A0 00                ldy #$00      ;routine to correspond to player object
00BE13  2  4C 27 BE             jmp RelWOfs   ;get the coordinates
00BE16  2               
00BE16  2               RelativeBubblePosition:
00BE16  2  A0 01                ldy #$01                ;set for air bubble offsets
00BE18  2  20 8D BE             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00BE1B  2  A0 03                ldy #$03
00BE1D  2  4C 27 BE             jmp RelWOfs             ;get the coordinates
00BE20  2               
00BE20  2               RelativeFireballPosition:
00BE20  2  A0 00                 ldy #$00                    ;set for fireball offsets
00BE22  2  20 8D BE              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00BE25  2  A0 02                 ldy #$02
00BE27  2  20 56 BE     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00BE2A  2  A6 08                 ldx ObjectOffset            ;return original offset
00BE2C  2  60                    rts                         ;leave
00BE2D  2               
00BE2D  2               RelativeMiscPosition:
00BE2D  2  A0 02                ldy #$02                ;set for misc object offsets
00BE2F  2  20 8D BE             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00BE32  2  A0 06                ldy #$06
00BE34  2  4C 27 BE             jmp RelWOfs             ;get the coordinates
00BE37  2               
00BE37  2               RelativeEnemyPosition:
00BE37  2  A9 01                lda #$01                     ;get coordinates of enemy object
00BE39  2  A0 01                ldy #$01                     ;relative to the screen
00BE3B  2  4C 4A BE             jmp VariableObjOfsRelPos
00BE3E  2               
00BE3E  2               RelativeBlockPosition:
00BE3E  2  A9 09                lda #$09                     ;get coordinates of one block object
00BE40  2  A0 04                ldy #$04                     ;relative to the screen
00BE42  2  20 4A BE             jsr VariableObjOfsRelPos
00BE45  2  E8                   inx                          ;adjust offset for other block object if any
00BE46  2  E8                   inx
00BE47  2  A9 09                lda #$09
00BE49  2  C8                   iny                          ;adjust other and get coordinates for other one
00BE4A  2               
00BE4A  2               VariableObjOfsRelPos:
00BE4A  2  86 00                stx $00                     ;store value to add to A here
00BE4C  2  18                   clc
00BE4D  2  65 00                adc $00                     ;add A to value stored
00BE4F  2  AA                   tax                         ;use as enemy offset
00BE50  2  20 56 BE             jsr GetObjRelativePosition
00BE53  2  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00BE55  2  60                   rts
00BE56  2               
00BE56  2               GetObjRelativePosition:
00BE56  2  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00BE58  2  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00BE5B  2  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00BE5D  2  38                   sec                         ;subtract left edge coordinate
00BE5E  2  ED 1C 07             sbc ScreenLeft_X_Pos
00BE61  2  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00BE64  2  60                   rts
00BE65  2               
00BE65  2               ;-------------------------------------------------------------------------------------
00BE65  2               ;$00 - used as temp variable to hold offscreen bits
00BE65  2               
00BE65  2               GetPlayerOffscreenBits:
00BE65  2  A2 00                ldx #$00                 ;set offsets for player-specific variables
00BE67  2  A0 00                ldy #$00                 ;and get offscreen information about player
00BE69  2  4C A5 BE             jmp GetOffScreenBitsSet
00BE6C  2               
00BE6C  2               GetFireballOffscreenBits:
00BE6C  2  A0 00                ldy #$00                 ;set for fireball offsets
00BE6E  2  20 8D BE             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00BE71  2  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00BE73  2  4C A5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00BE76  2               
00BE76  2               GetBubbleOffscreenBits:
00BE76  2  A0 01                ldy #$01                 ;set for air bubble offsets
00BE78  2  20 8D BE             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00BE7B  2  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00BE7D  2  4C A5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00BE80  2               
00BE80  2               GetMiscOffscreenBits:
00BE80  2  A0 02                ldy #$02                 ;set for misc object offsets
00BE82  2  20 8D BE             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00BE85  2  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00BE87  2  4C A5 BE             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00BE8A  2               
00BE8A  2               ObjOffsetData:
00BE8A  2  07 16 0D             .byte $07, $16, $0d
00BE8D  2               
00BE8D  2               GetProperObjOffset:
00BE8D  2  8A                   txa                  ;move offset to A
00BE8E  2  18                   clc
00BE8F  2  79 8A BE             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00BE92  2  AA                   tax                  ;put back in X and leave
00BE93  2  60                   rts
00BE94  2               
00BE94  2               GetEnemyOffscreenBits:
00BE94  2  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00BE96  2  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00BE98  2  4C 9F BE             jmp SetOffscrBitsOffset
00BE9B  2               
00BE9B  2               GetBlockOffscreenBits:
00BE9B  2  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00BE9D  2  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00BE9F  2               
00BE9F  2               SetOffscrBitsOffset:
00BE9F  2  86 00                stx $00
00BEA1  2  18                   clc           ;add contents of X to A to get
00BEA2  2  65 00                adc $00       ;appropriate offset, then give back to X
00BEA4  2  AA                   tax
00BEA5  2               
00BEA5  2               GetOffScreenBitsSet:
00BEA5  2  98                   tya                         ;save offscreen bits offset to stack for now
00BEA6  2  48                   pha
00BEA7  2  20 BC BE             jsr RunOffscrBitsSubs
00BEAA  2  0A                   asl                         ;move low nybble to high nybble
00BEAB  2  0A                   asl
00BEAC  2  0A                   asl
00BEAD  2  0A                   asl
00BEAE  2  05 00                ora $00                     ;mask together with previously saved low nybble
00BEB0  2  85 00                sta $00                     ;store both here
00BEB2  2  68                   pla                         ;get offscreen bits offset from stack
00BEB3  2  A8                   tay
00BEB4  2  A5 00                lda $00                     ;get value here and store elsewhere
00BEB6  2  99 D0 03             sta SprObject_OffscrBits,y
00BEB9  2  A6 08                ldx ObjectOffset
00BEBB  2  60                   rts
00BEBC  2               
00BEBC  2               RunOffscrBitsSubs:
00BEBC  2  20 DB BE             jsr GetXOffscreenBits  ;do subroutine here
00BEBF  2  4A                   lsr                    ;move high nybble to low
00BEC0  2  4A                   lsr
00BEC1  2  4A                   lsr
00BEC2  2  4A                   lsr
00BEC3  2  85 00                sta $00                ;store here
00BEC5  2  4C 1E BF             jmp GetYOffscreenBits
00BEC8  2               
00BEC8  2               ;--------------------------------
00BEC8  2               ;(these apply to these three subsections)
00BEC8  2               ;$04 - used to store proper offset
00BEC8  2               ;$05 - used as adder in DividePDiff
00BEC8  2               ;$06 - used to store preset value used to compare to pixel difference in $07
00BEC8  2               ;$07 - used to store difference between coordinates of object and screen edges
00BEC8  2               
00BEC8  2               XOffscreenBitsData:
00BEC8  2  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00BECC  2  07 03 01 00  
00BED0  2  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00BED4  2  F8 FC FE FF  
00BED8  2               
00BED8  2               DefaultXOnscreenOfs:
00BED8  2  07 0F 07             .byte $07, $0f, $07
00BEDB  2               
00BEDB  2               GetXOffscreenBits:
00BEDB  2  86 04                  stx $04                     ;save position in buffer to here
00BEDD  2  A0 01                  ldy #$01                    ;start with right side of screen
00BEDF  2  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00BEE2  2  38                     sec                         ;get difference between pixel coordinate of edge
00BEE3  2  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00BEE5  2  85 07                  sta $07                     ;store here
00BEE7  2  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00BEEA  2  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00BEEC  2  BE D8 BE               ldx DefaultXOnscreenOfs,y   ;load offset value here
00BEEF  2  C9 00                  cmp #$00
00BEF1  2  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00BEF3  2  BE D9 BE               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00BEF6  2  C9 01                  cmp #$01
00BEF8  2  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00BEFA  2  A9 38                  lda #$38                    ;if no branching, load value here and store
00BEFC  2  85 06                  sta $06
00BEFE  2  A9 08                  lda #$08                    ;load some other value and execute subroutine
00BF00  2  20 52 BF               jsr DividePDiff
00BF03  2  BD C8 BE     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00BF06  2  A6 04                  ldx $04                     ;reobtain position in buffer
00BF08  2  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00BF0A  2  D0 03                  bne ExXOfsBS
00BF0C  2  88                     dey                         ;otherwise, do left side of screen now
00BF0D  2  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00BF0F  2  60           ExXOfsBS: rts
00BF10  2               
00BF10  2               ;--------------------------------
00BF10  2               
00BF10  2               YOffscreenBitsData:
00BF10  2  0F 07 03 01          .byte $0f, $07, $03, $01
00BF14  2  00 08 0C 0E          .byte $00, $08, $0c, $0e
00BF18  2  00                   .byte $00
00BF19  2               
00BF19  2               DefaultYOnscreenOfs:
00BF19  2  04 00 04             .byte $04, $00, $04
00BF1C  2               
00BF1C  2               HighPosUnitData:
00BF1C  2  00 FF                .byte $00, $ff
00BF1E  2               
00BF1E  2               GetYOffscreenBits:
00BF1E  2  86 04                  stx $04                      ;save position in buffer to here
00BF20  2  A0 01                  ldy #$01                     ;start with bottom of screen
00BF22  2  B9 1C BF     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00BF25  2  38                     sec
00BF26  2  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00BF28  2  85 07                  sta $07                      ;store here
00BF2A  2  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00BF2C  2  F5 B5                  sbc SprObject_Y_HighPos,x
00BF2E  2  BE 19 BF               ldx DefaultYOnscreenOfs,y    ;load offset value here
00BF31  2  C9 00                  cmp #$00
00BF33  2  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00BF35  2  BE 1A BF               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00BF38  2  C9 01                  cmp #$01
00BF3A  2  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00BF3C  2  A9 20                  lda #$20                     ;if no branching, load value here and store
00BF3E  2  85 06                  sta $06
00BF40  2  A9 04                  lda #$04                     ;load some other value and execute subroutine
00BF42  2  20 52 BF               jsr DividePDiff
00BF45  2  BD 10 BF     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00BF48  2  A6 04                  ldx $04                      ;reobtain position in buffer
00BF4A  2  C9 00                  cmp #$00
00BF4C  2  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00BF4E  2  88                     dey                          ;otherwise, do top of the screen now
00BF4F  2  10 D1                  bpl YOfsLoop
00BF51  2  60           ExYOfsBS: rts
00BF52  2               
00BF52  2               ;--------------------------------
00BF52  2               
00BF52  2               DividePDiff:
00BF52  2  85 05                  sta $05       ;store current value in A here
00BF54  2  A5 07                  lda $07       ;get pixel difference
00BF56  2  C5 06                  cmp $06       ;compare to preset value
00BF58  2  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00BF5A  2  4A                     lsr           ;divide by eight
00BF5B  2  4A                     lsr
00BF5C  2  4A                     lsr
00BF5D  2  29 07                  and #$07      ;mask out all but 3 LSB
00BF5F  2  C0 01                  cpy #$01      ;right side of the screen or top?
00BF61  2  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00BF63  2  65 05                  adc $05       ;if not, add value to difference / 8
00BF65  2  AA           SetOscrO: tax           ;use as offset
00BF66  2  60           ExDivPD:  rts           ;leave
00BF67  2               
00BF67  2               ;-------------------------------------------------------------------------------------
00BF67  2               ;$00-$01 - tile numbers
00BF67  2               ;$02 - Y coordinate
00BF67  2               ;$03 - flip control
00BF67  2               ;$04 - sprite attributes
00BF67  2               ;$05 - X coordinate
00BF67  2               
00BF67  2               DrawSpriteObject:
00BF67  2  A5 03                 lda $03                    ;get saved flip control bits
00BF69  2  4A                    lsr
00BF6A  2  4A                    lsr                        ;move d1 into carry
00BF6B  2  A5 00                 lda $00
00BF6D  2  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00BF6F  2  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00BF72  2  A5 01                 lda $01                    ;and second into first sprite
00BF74  2  99 01 02              sta Sprite_Tilenumber,y
00BF77  2  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00BF79  2  D0 0A                 bne SetHFAt                ;and unconditionally branch
00BF7B  2  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00BF7E  2  A5 01                 lda $01                    ;and second into second sprite
00BF80  2  99 05 02              sta Sprite_Tilenumber+4,y
00BF83  2  A9 00                 lda #$00                   ;clear bit for horizontal flip
00BF85  2  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00BF87  2  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00BF8A  2  99 06 02              sta Sprite_Attributes+4,y
00BF8D  2  A5 02                 lda $02                    ;now the y coordinates
00BF8F  2  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00BF92  2  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00BF95  2  A5 05                 lda $05
00BF97  2  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00BF9A  2  18                    clc                        ;add 8 pixels and store another to
00BF9B  2  69 08                 adc #$08                   ;put them side by side
00BF9D  2  99 07 02              sta Sprite_X_Position+4,y
00BFA0  2  A5 02                 lda $02                    ;add eight pixels to the next y
00BFA2  2  18                    clc                        ;coordinate
00BFA3  2  69 08                 adc #$08
00BFA5  2  85 02                 sta $02
00BFA7  2  98                    tya                        ;add eight to the offset in Y to
00BFA8  2  18                    clc                        ;move to the next two sprites
00BFA9  2  69 08                 adc #$08
00BFAB  2  A8                    tay
00BFAC  2  E8                    inx                        ;increment offset to return it to the
00BFAD  2  E8                    inx                        ;routine that called this subroutine
00BFAE  2  60                    rts
00BFAF  2               
00BFAF  2               ;-------------------------------------------------------------------------------------
00BFAF  2               
00BFAF  2               ;unused byte
00BFAF  2  FF            .byte $ff
00BFB0  2               
00BFB0  2               ;-------------------------------------------------------------------------------------
00BFB0  2               
00BFB0  2               AttractModeSubs:
00BFB0  2  AD 72 07           lda OperMode_Task
00BFB3  2  20 7D 6C           jsr JumpEngine
00BFB6  2               
00BFB6  2  06 C0              .word AttractModeDiskRoutines
00BFB8  2  92 C5              .word InitializeGame
00BFBA  2  C5 64              .word ScreenRoutines
00BFBC  2  DB C5              .word PrimaryGameSetup
00BFBE  2  6E C4              .word GameMenuRoutine
00BFC0  2  C2 BF              .word HardWorldsCheckpoint
00BFC2  2               
00BFC2  2               HardWorldsCheckpoint:
00BFC2  2  AD FC 07           lda DiskIOTask
00BFC5  2  20 7D 6C           jsr JumpEngine
00BFC8  2               
00BFC8  2  13 C1              .word DiskScreen
00BFCA  2  D2 BF              .word LoadHardWorlds
00BFCC  2  26 C1              .word WaitForEject
00BFCE  2  38 C1              .word WaitForReinsert
00BFD0  2  40 C1              .word ResetDiskVars
00BFD2  2               
00BFD2  2               LoadHardWorlds:
00BFD2  2  AD FB 07              lda HardWorldFlag         ;if this is not set, skip this
00BFD5  2  F0 0F                 beq NoLoadHW
00BFD7  2  A9 03                 lda #$03
00BFD9  2  8D F7 07              sta FileListNumber        ;set filelist number to load SM2DATA4
00BFDC  2  20 F4 C0              jsr LoadFiles
00BFDF  2  D0 57                 bne ReturnedError         ;if returned with error number, branch
00BFE1  2  20 CA C0              jsr CheckFileCount        ;check to see if loaded the correct number of files
00BFE4  2  D0 50                 bne BadFileCount          ;if not, branch to set error code
00BFE6  2               NoLoadHW:
00BFE6  2  20 A4 C2              jsr LoadAreaPointer       ;update area pointer to get world 1 or A
00BFE9  2  AD FB 07              lda HardWorldFlag         ;if this is not set, skip this
00BFEC  2  F0 03                 beq NoCHWP                ;otherwise run sub in SM2DATA4 to change halfway pages
00BFEE  2  20 rr rr              jsr ChangeHalfwayPages    ;for worlds A thru D
00BFF1  2  EE 5D 07     NoCHWP:  inc Hidden1UpFlag
00BFF4  2  EE 57 07              inc FetchNewGameTimerFlag
00BFF7  2  EE 70 07              inc OperMode
00BFFA  2  A9 00                 lda #$00
00BFFC  2  8D FC 07              sta DiskIOTask
00BFFF  2  8D 72 07              sta OperMode_Task
00C002  2  8D A2 07              sta DemoTimer
00C005  2  60                    rts
00C006  2               
00C006  2               AttractModeDiskRoutines:
00C006  2  AD FC 07           lda DiskIOTask
00C009  2  20 7D 6C           jsr JumpEngine
00C00C  2               
00C00C  2  13 C1              .word DiskScreen
00C00E  2  16 C0              .word LoadWorlds1Thru4
00C010  2  26 C1              .word WaitForEject
00C012  2  38 C1              .word WaitForReinsert
00C014  2  40 C1              .word ResetDiskVars
00C016  2               
00C016  2               LoadWorlds1Thru4:
00C016  2  AD FD 07                lda NotColdFlag       ;if not set, just cold booted, thus no need to check world info
00C019  2  F0 23                   beq InitWorldPos
00C01B  2  AD FB 07                lda HardWorldFlag     ;if player was playing worlds A-D, skip ahead
00C01E  2  D0 07                   bne LW14Files         ;otherwise check the world number
00C020  2  AD 5F 07                lda WorldNumber
00C023  2  C9 04                   cmp #World5           ;if world number was less than 5, files still in memory
00C025  2  90 17                   bcc InitWorldPos      ;thus skip to the end, no need to load them again
00C027  2  A9 00        LW14Files: lda #$00              ;set filelist number to reload SM2MAIN, SM2CHAR1 and SM2SAVE
00C029  2  8D F7 07                sta FileListNumber
00C02C  2  20 F4 C0                jsr LoadFiles         ;now reload those files
00C02F  2  D0 07                   bne ReturnedError     ;if returned with error number, branch
00C031  2  20 CA C0                jsr CheckFileCount    ;check to see if loaded the correct number of files
00C034  2  F0 08                   beq InitWorldPos      ;if so, branch to init player's world info
00C036  2               
00C036  2               BadFileCount:
00C036  2  A9 40              lda #$40              ;otherwise, set error number
00C038  2               
00C038  2               ReturnedError:
00C038  2  EE FC 07           inc DiskIOTask        ;move on to next subtask
00C03B  2  4C 82 C1           jmp DiskErrorHandler
00C03E  2               
00C03E  2               InitWorldPos:
00C03E  2  A9 01              lda #$01              ;set flag to check player's world info
00C040  2  8D FD 07           sta NotColdFlag       ;before erasing it
00C043  2  4A                 lsr
00C044  2  8D 5F 07           sta WorldNumber       ;reset world number
00C047  2  8D FB 07           sta HardWorldFlag     ;force worlds 1-8 by default
00C04A  2  4C 78 C0           jmp ResetDiskIOTask   ;end disk subroutines
00C04D  2               
00C04D  2               
00C04D  2               GameModeDiskRoutines:
00C04D  2  AD FC 07           lda DiskIOTask
00C050  2  20 7D 6C           jsr JumpEngine
00C053  2               
00C053  2  13 C1              .word DiskScreen
00C055  2  5D C0              .word LoadWorlds5Thru8
00C057  2  26 C1              .word WaitForEject
00C059  2  38 C1              .word WaitForReinsert
00C05B  2  40 C1              .word ResetDiskVars
00C05D  2               
00C05D  2               LoadWorlds5Thru8:
00C05D  2  AD 5F 07           lda WorldNumber       ;if in worlds 1-4 or A-D
00C060  2  C9 04              cmp #World5           ;then leave without loading anything
00C062  2  90 14              bcc ResetDiskIOTask
00C064  2  AD F7 07           lda FileListNumber    ;if worlds 5-8 were already loaded, leave
00C067  2  D0 0F              bne ResetDiskIOTask   ;as there's no need to load anything
00C069  2  A9 01              lda #$01
00C06B  2  8D F7 07           sta FileListNumber    ;otherwise set filelist number to load SM2DATA2
00C06E  2  20 F4 C0           jsr LoadFiles         ;and load it
00C071  2  D0 C5              bne ReturnedError     ;if returned with error number, branch
00C073  2  20 CA C0           jsr CheckFileCount    ;check to see if loaded the correct number of files
00C076  2  D0 BE              bne BadFileCount      ;if not, branch to return error 40/$32
00C078  2               
00C078  2               ResetDiskIOTask:
00C078  2  A9 00              lda #$00              ;reset disk-related task number for next time
00C07A  2  8D FC 07           sta DiskIOTask
00C07D  2               VMDelay:
00C07D  2  EE 72 07           inc OperMode_Task     ;move on to next task in the current mode
00C080  2  60                 rts
00C081  2               
00C081  2               StartVMDelay:
00C081  2  A9 10              lda #$10           ;start world end delay
00C083  2  8D A1 07           sta WorldEndTimer
00C086  2  D0 F5              bne VMDelay
00C088  2               
00C088  2               ContinueVMDelay:
00C088  2  AD A1 07           lda WorldEndTimer  ;wait for delay to end, then move on
00C08B  2  F0 F0              beq VMDelay
00C08D  2  60                 rts
00C08E  2               
00C08E  2               VictoryModeDiskRoutines:
00C08E  2  AD FC 07           lda DiskIOTask
00C091  2  20 7D 6C           jsr JumpEngine
00C094  2               
00C094  2  13 C1              .word DiskScreen
00C096  2  9E C0              .word LoadEnding
00C098  2  26 C1              .word WaitForEject
00C09A  2  38 C1              .word WaitForReinsert
00C09C  2  40 C1              .word ResetDiskVars
00C09E  2               
00C09E  2               LoadEnding:
00C09E  2  A9 02                lda #$02                 ;set filelist number to load SM2DATA3, SM2CHAR2 and SM2SAVE
00C0A0  2  8D F7 07             sta FileListNumber
00C0A3  2  20 F4 C0             jsr LoadFiles            ;load them now
00C0A6  2  D0 90                bne ReturnedError
00C0A8  2  20 CA C0             jsr CheckFileCount       ;check to see if loaded the correct number of files
00C0AB  2  F0 05                beq AddBeatenGame        ;if so, continue
00C0AD  2  A9 00                lda #$00                 ;otherwise reset count of games beaten
00C0AF  2  8D 9F D2             sta GamesBeatenCount
00C0B2  2               AddBeatenGame:
00C0B2  2  AD 9F D2             lda GamesBeatenCount     ;get the new count of games beaten we loaded (or reset)
00C0B5  2  18                   clc                      ;add one to it, to a maximum of 24/$18
00C0B6  2  69 01                adc #$01
00C0B8  2  C9 19                cmp #25
00C0BA  2  90 02                bcc SetS2S
00C0BC  2  A9 18                lda #24                  ;sorry, only 24 stars allowed
00C0BE  2  8D 9F D2     SetS2S: sta GamesBeatenCount
00C0C1  2  20 92 6C             jsr InitializeNameTables
00C0C4  2  20 78 C0             jsr ResetDiskIOTask      ;end disk subroutines
00C0C7  2  4C rr rr             jmp WriteNameToVictoryMsg
00C0CA  2               
00C0CA  2               CheckFileCount:
00C0CA  2  98                 tya                      ;save number of files loaded to A
00C0CB  2  AC F7 07           ldy FileListNumber       ;use file list number as offset
00C0CE  2  D9 F0 C0           cmp FileCount,y          ;compare to number of files supposed to be loaded
00C0D1  2  60                 rts
00C0D2  2               
00C0D2  2               ;disk ID string copy used in FDS BIOS load routine
00C0D2  2               ;to compare to original at the disk info block
00C0D2  2               DiskIDString:
00C0D2  2  01 53 4D 42        .byte $01, $53, $4d, $42, $20
00C0D6  2  20           
00C0D7  2  00 00 00 00        .byte $00, $00, $00, $00, $00
00C0DB  2  00           
00C0DC  2               
00C0DC  2               FileListAddrLow:
00C0DC  2  E4 E8 EA EE        .byte <World14List, <World58List, <EndingList, <WorldADList
00C0E0  2               FileListAddrHigh:
00C0E0  2  C0 C0 C0 C0        .byte >World14List, >World58List, >EndingList, >WorldADList
00C0E4  2               
00C0E4  2               ;file lists used by FDS bios to load files
00C0E4  2               ;value $ff is end terminator
00C0E4  2               World14List:
00C0E4  2  01 05 0F FF        .byte $01, $05, $0f, $ff
00C0E8  2               World58List:
00C0E8  2  20 FF              .byte $20, $ff
00C0EA  2               EndingList:
00C0EA  2  10 30 0F FF        .byte $10, $30, $0f, $ff
00C0EE  2               WorldADList:
00C0EE  2  40 FF              .byte $40, $ff
00C0F0  2               
00C0F0  2               FileCount:
00C0F0  2  03 01 03 01        .byte $03, $01, $03, $01
00C0F4  2               
00C0F4  2               LoadFiles:
00C0F4  2  AE F7 07           ldx FileListNumber      ;get address to file list
00C0F7  2  BD DC C0           lda FileListAddrLow,x
00C0FA  2  8D 08 C1           sta ListPointer
00C0FD  2  BD E0 C0           lda FileListAddrHigh,x
00C100  2  8D 09 C1           sta ListPointer+1
00C103  2  20 F8 E1           jsr FDSBIOS_LOADFILES   ;now load the files
00C106  2               
00C106  2               ;used by FDS BIOS routine
00C106  2  D2 C0                     .word DiskIDString
00C108  2  E4 C0        ListPointer: .word World14List  ;overwritten in RAM
00C10A  2               
00C10A  2               ;execution continues here
00C10A  2  60                 rts
00C10B  2               
00C10B  2               DiskScreenPalette:
00C10B  2  3F 00 04       .byte $3f, $00, $04
00C10E  2  0F 30 30 0F    .byte $0f, $30, $30, $0f
00C112  2  00             .byte $00
00C113  2               
00C113  2               DiskScreen:
00C113  2  A9 00              lda #$00
00C115  2  8D 79 07           sta Mirror_PPU_MASK
00C118  2  8D 01 20           sta PPU_MASK
00C11B  2  EE 74 07           inc DisableScreenFlag
00C11E  2  A9 1A              lda #$1a
00C120  2  8D 73 07           sta VRAM_Buffer_AddrCtrl
00C123  2  4C 34 C1           jmp NextDiskIOTask
00C126  2               
00C126  2               WaitForEject:
00C126  2  A9 00              lda #$00
00C128  2  8D 7A 07           sta NameTableSelect
00C12B  2  8D 74 07           sta DisableScreenFlag
00C12E  2  AD 32 40           lda FDS_DRIVE_STATUS  ;check disk inserted flag
00C131  2  4A                 lsr                   ;execute this routine until disk is ejected
00C132  2  90 03              bcc ThisDiskIOTask    ;note this routine is run on an error
00C134  2               
00C134  2               NextDiskIOTask:
00C134  2  EE FC 07           inc DiskIOTask        ;move on to next subtask involving the disk drive
00C137  2               ThisDiskIOTask:
00C137  2  60                 rts                   ;or not, if branched here
00C138  2               
00C138  2               WaitForReinsert:
00C138  2  AD 32 40           lda FDS_DRIVE_STATUS  ;check disk inserted flag
00C13B  2  4A                 lsr                   ;execute this routine until disk is reinserted
00C13C  2  90 F6              bcc NextDiskIOTask    ;note this routine is run after the one
00C13E  2  B0 F7              bcs ThisDiskIOTask    ;that checks for an ejected disk
00C140  2               
00C140  2               ResetDiskVars:
00C140  2  A9 00              lda #$00
00C142  2  8D FC 07           sta DiskIOTask        ;reset disk-related variables
00C145  2  8D F7 07           sta FileListNumber
00C148  2  60                 rts
00C149  2               
00C149  2               DiskErrorMainMsg:
00C149  2  21 E6 08       .byte $21, $e6, $08
00C14C  2  24 24 24 24    .byte $24, $24, $24, $24, $24, $24, $24, $24
00C150  2  24 24 24 24  
00C154  2  21 F4 06       .byte $21, $f4, $06
00C157  2  0E 1B 1B 24    .byte $0e, $1b, $1b, $24, $00, $01
00C15B  2  00 01        
00C15D  2  00             .byte $00
00C15E  2               
00C15E  2               ;disk error message offsets
00C15E  2               ;note these actually point to the last byte
00C15E  2               DiskErrorMsgOffsets:
00C15E  2  07 0F 17 1F    .byte $07, $0f, $17, $1f
00C162  2               
00C162  2               DiskErrorMsgs:
00C162  2               ;"        "
00C162  2  24 24 24 24    .byte $24, $24, $24, $24, $24, $24, $24, $24
00C166  2  24 24 24 24  
00C16A  2               ;"DISK SET"
00C16A  2  0D 12 1C 14    .byte $0d, $12, $1c, $14, $24, $1c, $0e, $1d
00C16E  2  24 1C 0E 1D  
00C172  2               ;"BATTERY "
00C172  2  0B 0A 1D 1D    .byte $0b, $0a, $1d, $1d, $0e, $1b, $22, $24
00C176  2  0E 1B 22 24  
00C17A  2               ;"A B SIDE"
00C17A  2  0A 24 0B 24    .byte $0a, $24, $0b, $24, $1c, $12, $0d, $0e
00C17E  2  1C 12 0D 0E  
00C182  2               
00C182  2               DiskErrorHandler:
00C182  2  48             pha
00C183  2  29 0F          and #$0f
00C185  2  8D 5C C1       sta DiskErrorMainMsg+$13  ;write lower nybble of error number as digit
00C188  2  68             pla
00C189  2  48             pha
00C18A  2  4A             lsr
00C18B  2  4A             lsr
00C18C  2  4A             lsr
00C18D  2  4A             lsr
00C18E  2  8D 5B C1       sta DiskErrorMainMsg+$12  ;now write the upper nybble of error number
00C191  2  A0 03          ldy #$03
00C193  2  68             pla
00C194  2  C9 07          cmp #$07                  ;if a/b side error was found, branch
00C196  2  F0 0B          beq LoadError
00C198  2  88             dey
00C199  2  C9 02          cmp #$02                  ;if battery low error was found, branch
00C19B  2  F0 06          beq LoadError
00C19D  2  88             dey
00C19E  2  C9 01          cmp #$01                  ;if disk not set error was found, branch
00C1A0  2  F0 01          beq LoadError
00C1A2  2  88             dey                       ;otherwise print blank for any other error or no error
00C1A3  2               LoadError:
00C1A3  2  BE 5E C1       ldx DiskErrorMsgOffsets,y ;get offset to error message
00C1A6  2  A0 07          ldy #$07                  ;use to load error message to vram string
00C1A8  2               LELoop:
00C1A8  2  BD 62 C1       lda DiskErrorMsgs,x
00C1AB  2  99 4C C1       sta DiskErrorMainMsg+3,y
00C1AE  2  CA             dex
00C1AF  2  88             dey
00C1B0  2  10 F6          bpl LELoop
00C1B2  2  A9 19          lda #$19
00C1B4  2  8D 73 07       sta VRAM_Buffer_AddrCtrl     ;print error message on next NMI
00C1B7  2  20 87 62       jsr MoveAllSpritesOffscreen  ;init the screen
00C1BA  2  4C 92 6C       jmp InitializeNameTables
00C1BD  2               
00C1BD  2               GameOverCursorData:
00C1BD  2  5B 02 48       .byte $5b, $02, $48
00C1C0  2               
00C1C0  2               GameOverCursorY:
00C1C0  2  77 8F          .byte $77, $8f
00C1C2  2               
00C1C2  2               GameOverMenu:
00C1C2  2  AD FC 06                 lda SavedJoypadBits          ;if player pressed the start button
00C1C5  2  29 10                    and #Start_Button            ;then either continue or start over
00C1C7  2  D0 2D                    bne ContinueOrRetry
00C1C9  2  AD FC 06                 lda SavedJoypadBits
00C1CC  2  29 20                    and #Select_Button           ;if player pressed the select button
00C1CE  2  F0 11                    beq ChgSel                   ;then branch to select "continue" or "retry"
00C1D0  2  AE 80 07                 ldx SelectTimer              ;if select timer not expired while
00C1D3  2  D0 0C                    bne ChgSel                   ;pressing select, skip this
00C1D5  2  4A                       lsr
00C1D6  2  8D 80 07                 sta SelectTimer              ;otherwise set the select timer
00C1D9  2  AD F8 07                 lda ContinueMenuSelect
00C1DC  2  49 01                    eor #$01                     ;and toggle between the two choices
00C1DE  2  8D F8 07                 sta ContinueMenuSelect
00C1E1  2  A0 02        ChgSel:     ldy #$02
00C1E3  2  B9 BD C1     ChgSelLoop: lda GameOverCursorData,y     ;set up cursor sprite tile, attribute
00C1E6  2  99 01 02                 sta Sprite_Data+1,y          ;and X position in sprite OAM data
00C1E9  2  88                       dey
00C1EA  2  10 F7                    bpl ChgSelLoop
00C1EC  2  AC F8 07                 ldy ContinueMenuSelect
00C1EF  2  B9 C0 C1                 lda GameOverCursorY,y        ;set Y position based on the selection
00C1F2  2  8D 00 02                 sta Sprite_Data
00C1F5  2  60                       rts
00C1F6  2               
00C1F6  2               ContinueOrRetry:
00C1F6  2  AD F8 07       lda ContinueMenuSelect       ;if player selected "continue"
00C1F9  2  F0 08          beq Continue                 ;then branch to continue
00C1FB  2  A9 00          lda #$00
00C1FD  2  8D FA 07       sta CompletedWorlds          ;otherwise init completed worlds flags
00C200  2  4C 8D 70       jmp TerminateGame            ;and end the game
00C203  2               
00C203  2               Continue:
00C203  2  A0 02                ldy #$02
00C205  2  8C 5A 07             sty NumberofLives           ;give three lives
00C208  2  8D 5C 07             sta LevelNumber
00C20B  2  8D 60 07             sta AreaNumber              ;put at x-1 of the current world
00C20E  2  8D 5E 07             sta CoinTally
00C211  2  A0 0B                ldy #$0b
00C213  2  99 DD 07     ISCont: sta ScoreAndCoinDisplay,y   ;reset score
00C216  2  88                   dey
00C217  2  10 FA                bpl ISCont
00C219  2  EE 5D 07             inc Hidden1UpFlag           ;allow 1-up to be found again
00C21C  2  4C 9D 70             jmp ContinueGame
00C21F  2               
00C21F  2               ;-------------------------------------------------------------------------------------
00C21F  2               
00C21F  2               ;jump, fall and friction physics data used with mario and luigi
00C21F  2               ;note luigi's higher jump, but with lesser friction
00C21F  2               JumpFrictionData:
00C21F  2  20 20 1E 28    .byte $20, $20, $1e, $28, $28, $0d, $04
00C223  2  28 0D 04     
00C226  2  70 70 60 90    .byte $70, $70, $60, $90, $90, $0a, $09
00C22A  2  90 0A 09     
00C22D  2               
00C22D  2  E4 98 D0       .byte $e4, $98, $d0
00C230  2               
00C230  2  18 18 18 22    .byte $18, $18, $18, $22, $22, $0d, $04
00C234  2  22 0D 04     
00C237  2  42 42 3E 5D    .byte $42, $42, $3e, $5d, $5d, $0a, $09
00C23B  2  5D 0A 09     
00C23E  2               
00C23E  2  B4 68 A0       .byte $b4, $68, $a0
00C241  2               
00C241  2               LoadPhysicsData:
00C241  2  A2 60          ldx #$60               ;use luigi's offsets and RTS opcode
00C243  2  A0 21          ldy #$21
00C245  2  AD 53 07       lda SelectedPlayer     ;if selected luigi, branch to continue
00C248  2  D0 04          bne ModifyPhysics
00C24A  2               LoadMarioPhysics:
00C24A  2  A2 0E          ldx #$0e               ;otherwise use mario's offsets and ASL opcode
00C24C  2  A0 10          ldy #$10
00C24E  2               ModifyPhysics:
00C24E  2  8E F1 80       stx PhyOpcode          ;load opcode into friction code to modify it
00C251  2  A2 10          ldx #$10
00C253  2               MPhyLoop:
00C253  2  B9 1F C2       lda JumpFrictionData,y ;load physics data for the selected player
00C256  2  9D 90 7F       sta JumpMForceData,x
00C259  2  88             dey
00C25A  2  CA             dex
00C25B  2  10 F6          bpl MPhyLoop
00C25D  2  60             rts
00C25E  2               
00C25E  2               ;unused bytes
00C25E  2  FF FF          .byte $ff, $ff
00C260  2               
00C260  2               ;-------------------------------------------------------------------------------------
00C260  2               
00C260  2               ;enemy data used by pipe intro area, warp zone area and exit area
00C260  2               E_GroundArea10:
00C260  2               E_GroundArea21:
00C260  2               E_GroundArea28:
00C260  2  FF             .byte $ff
00C261  2               
00C261  2               ;exit area used in levels 1-2, 3-2, 5-2, 6-2, A-2 and B-2
00C261  2               L_GroundArea28:
00C261  2  90 31 39 F1    .byte $90, $31, $39, $f1, $bf, $37, $33, $e7, $a3, $03, $a7, $03, $cd, $41, $0f, $a6
00C265  2  BF 37 33 E7  
00C269  2  A3 03 A7 03  
00C271  2  ED 47 FD       .byte $ed, $47, $fd
00C274  2               
00C274  2               ;pipe intro area
00C274  2               L_GroundArea10:
00C274  2  38 11 0F 26    .byte $38, $11, $0f, $26, $ad, $40, $3d, $c7, $fd
00C278  2  AD 40 3D C7  
00C27C  2  FD           
00C27D  2               
00C27D  2               ;warp zone area used in levels 1-2 and 5-2
00C27D  2               L_GroundArea21:
00C27D  2  10 00 0B 13    .byte $10, $00, $0b, $13, $5b, $14, $6a, $42, $c7, $12, $c6, $42, $1b, $94, $2a, $42
00C281  2  5B 14 6A 42  
00C285  2  C7 12 C6 42  
00C28D  2  53 13 62 41    .byte $53, $13, $62, $41, $97, $17, $a6, $45, $6e, $81, $8f, $37, $02, $e8, $12, $3a
00C291  2  97 17 A6 45  
00C295  2  6E 81 8F 37  
00C29D  2  68 7A DE 0F    .byte $68, $7a, $de, $0f, $6d, $c5, $fd
00C2A1  2  6D C5 FD     
00C2A4  2               
00C2A4  2               LoadAreaPointer:
00C2A4  2  20 B4 C2                  jsr FindAreaPointer  ;find it and store it here
00C2A7  2  8D 50 07                  sta AreaPointer
00C2AA  2  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
00C2AC  2  0A                        asl
00C2AD  2  2A                        rol
00C2AE  2  2A                        rol
00C2AF  2  2A                        rol                  ;make %0xx00000 into %000000xx
00C2B0  2  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
00C2B3  2  60                        rts
00C2B4  2               
00C2B4  2               FindAreaPointer:
00C2B4  2  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00C2B7  2  B9 57 C3           lda WorldAddrOffsets,y
00C2BA  2  18                 clc                    ;add area number used to find data
00C2BB  2  6D 60 07           adc AreaNumber
00C2BE  2  A8                 tay
00C2BF  2  B9 60 C3           lda AreaAddrOffsets,y  ;from there we have our area pointer
00C2C2  2  60                 rts
00C2C3  2               
00C2C3  2               GetAreaDataAddrs:
00C2C3  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00C2C6  2  20 AA C2                 jsr GetAreaType
00C2C9  2  A8                       tay
00C2CA  2  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00C2CD  2  29 1F                    and #%00011111
00C2CF  2  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00C2D2  2  B9 94 C3                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00C2D5  2  18                       clc                      ;then add base value to 5 LSB, result
00C2D6  2  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00C2D9  2  0A                       asl
00C2DA  2  A8                       tay
00C2DB  2  B9 99 C3                 lda EnemyDataAddrs+1,y   ;use offset to load pointer
00C2DE  2  85 EA                    sta EnemyDataHigh
00C2E0  2  B9 98 C3                 lda EnemyDataAddrs,y
00C2E3  2  85 E9                    sta EnemyDataLow
00C2E5  2  AC 4E 07                 ldy AreaType             ;use area type as offset
00C2E8  2  B9 00 C4                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00C2EB  2  18                       clc
00C2EC  2  6D 4F 07                 adc AreaAddrsLOffset
00C2EF  2  0A                       asl
00C2F0  2  A8                       tay
00C2F1  2  B9 05 C4                 lda AreaDataAddrs+1,y    ;use this offset to load another pointer
00C2F4  2  85 E8                    sta AreaDataHigh
00C2F6  2  B9 04 C4                 lda AreaDataAddrs,y
00C2F9  2  85 E7                    sta AreaDataLow
00C2FB  2  A0 00                    ldy #$00                 ;load first byte of header
00C2FD  2  B1 E7                    lda (AreaData),y
00C2FF  2  48                       pha                      ;save it to the stack for now
00C300  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00C302  2  C9 04                    cmp #$04
00C304  2  90 05                    bcc StoreFore
00C306  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00C309  2  A9 00                    lda #$00
00C30B  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00C30E  2  68                       pla                      ;pull byte from stack and push it back
00C30F  2  48                       pha
00C310  2  29 38                    and #%00111000           ;save player entrance control bits
00C312  2  4A                       lsr                      ;shift bits over to LSBs
00C313  2  4A                       lsr
00C314  2  4A                       lsr
00C315  2  8D 10 07                 sta PlayerEntranceCtrl       ;save value here as player entrance control
00C318  2  68                       pla                      ;pull byte again but do not push it back
00C319  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00C31B  2  18                       clc
00C31C  2  2A                       rol                      ;rotate bits over to LSBs
00C31D  2  2A                       rol
00C31E  2  2A                       rol
00C31F  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00C322  2  C8                       iny
00C323  2  B1 E7                    lda (AreaData),y         ;load second byte of header
00C325  2  48                       pha                      ;save to stack
00C326  2  29 0F                    and #%00001111           ;mask out all but lower nybble
00C328  2  8D 27 07                 sta TerrainControl
00C32B  2  68                       pla                      ;pull and push byte to copy it to A
00C32C  2  48                       pha
00C32D  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00C32F  2  4A                       lsr
00C330  2  4A                       lsr                      ;shift bits to LSBs
00C331  2  4A                       lsr
00C332  2  4A                       lsr
00C333  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00C336  2  68                       pla
00C337  2  29 C0                    and #%11000000
00C339  2  18                       clc
00C33A  2  2A                       rol                      ;rotate bits over to LSBs
00C33B  2  2A                       rol
00C33C  2  2A                       rol
00C33D  2  C9 03                    cmp #%00000011           ;if set to 3, store here
00C33F  2  D0 05                    bne StoreStyle           ;and nullify other value
00C341  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00C344  2  A9 00                    lda #$00
00C346  2  8D 33 07     StoreStyle: sta AreaStyle
00C349  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00C34B  2  18                       clc
00C34C  2  69 02                    adc #$02
00C34E  2  85 E7                    sta AreaDataLow
00C350  2  A5 E8                    lda AreaDataHigh
00C352  2  69 00                    adc #$00
00C354  2  85 E8                    sta AreaDataHigh
00C356  2  60                       rts
00C357  2               
00C357  2               ;-------------------------------------------------------------------------------------
00C357  2               
00C357  2               WorldAddrOffsets:
00C357  2  00 05          .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
00C359  2  09 0E          .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
00C35B  2  12 17          .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
00C35D  2  1C 20          .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
00C35F  2  24             .byte World9Areas-AreaAddrOffsets
00C360  2               
00C360  2               AreaAddrOffsets:
00C360  2  20 29 40 21  World1Areas: .byte $20, $29, $40, $21, $60
00C364  2  60           
00C365  2  22 23 24 61  World2Areas: .byte $22, $23, $24, $61
00C369  2  25 29 00 26  World3Areas: .byte $25, $29, $00, $26, $62
00C36D  2  62           
00C36E  2  27 28 2A 63  World4Areas: .byte $27, $28, $2a, $63
00C372  2  2B 29 43 2C  World5Areas: .byte $2b, $29, $43, $2c, $64
00C376  2  64           
00C377  2  2D 29 01 2E  World6Areas: .byte $2d, $29, $01, $2e, $65
00C37B  2  65           
00C37C  2  2F 30 31 66  World7Areas: .byte $2f, $30, $31, $66
00C380  2  32 35 36 67  World8Areas: .byte $32, $35, $36, $67
00C384  2  38 06 68 07  World9Areas: .byte $38, $06, $68, $07
00C388  2               
00C388  2               AreaDataOfsLoopback:
00C388  2  0C 0C 42 42    .byte $0c, $0c, $42, $42, $10, $10, $30, $30, $06, $0c, $54, $06
00C38C  2  10 10 30 30  
00C390  2  06 0C 54 06  
00C394  2               
00C394  2               EnemyAddrHOffsets:
00C394  2  2C 0A 27 00    .byte $2c, $0a, $27, $00
00C398  2               
00C398  2               EnemyDataAddrs:
00C398  2  90 C7 AF C7    .word E_CastleArea1, E_CastleArea2, E_CastleArea3, E_CastleArea4, E_CastleArea5, E_CastleArea6
00C39C  2  D6 C7 E9 C7  
00C3A0  2  rr rr rr rr  
00C3A4  2  rr rr rr rr    .word E_CastleArea7, E_CastleArea8, E_CastleArea9, E_CastleArea10, E_GroundArea1, E_GroundArea2
00C3A8  2  rr rr rr rr  
00C3AC  2  1E C8 44 C8  
00C3B0  2  67 C8 90 C8    .word E_GroundArea3, E_GroundArea4, E_GroundArea5, E_GroundArea6, E_GroundArea7, E_GroundArea8
00C3B4  2  C6 C8 DD C8  
00C3B8  2  07 C9 2C C9  
00C3BC  2  43 C9 60 C2    .word E_GroundArea9, E_GroundArea10, E_GroundArea11, E_GroundArea12, E_GroundArea13, E_GroundArea14
00C3C0  2  65 C9 rr rr  
00C3C4  2  rr rr rr rr  
00C3C8  2  rr rr rr rr    .word E_GroundArea15, E_GroundArea16, E_GroundArea17, E_GroundArea18, E_GroundArea19, E_GroundArea20
00C3CC  2  rr rr rr rr  
00C3D0  2  rr rr 88 C9  
00C3D4  2  60 C2 rr rr    .word E_GroundArea21, E_GroundArea22, E_GroundArea23, E_GroundArea24, E_GroundArea25, E_GroundArea26
00C3D8  2  rr rr rr rr  
00C3DC  2  rr rr rr rr  
00C3E0  2  rr rr 60 C2    .word E_GroundArea27, E_GroundArea28, E_GroundArea29, E_UndergroundArea1, E_UndergroundArea2
00C3E4  2  rr rr 94 C9  
00C3E8  2  BA C9        
00C3EA  2  C4 C9 rr rr    .word E_UndergroundArea3, E_UndergroundArea4, E_UndergroundArea5, E_WaterArea1, E_WaterArea2
00C3EE  2  rr rr DE C9  
00C3F2  2  rr rr        
00C3F4  2  04 CA rr rr    .word E_WaterArea3, E_WaterArea4, E_WaterArea5, E_WaterArea6, E_WaterArea7, E_WaterArea8
00C3F8  2  rr rr rr rr  
00C3FC  2  rr rr rr rr  
00C400  2               
00C400  2               AreaDataHOffsets:
00C400  2  2C 0A 27 00    .byte $2c, $0a, $27, $00
00C404  2               
00C404  2               AreaDataAddrs:
00C404  2  14 CA 73 CA    .word L_CastleArea1, L_CastleArea2, L_CastleArea3, L_CastleArea4, L_CastleArea5, L_CastleArea6
00C408  2  FE CA 95 CB  
00C40C  2  rr rr rr rr  
00C410  2  rr rr rr rr    .word L_CastleArea7, L_CastleArea8, L_CastleArea9, L_CastleArea10, L_GroundArea1, L_GroundArea2
00C414  2  rr rr rr rr  
00C418  2  0A CC 65 CC  
00C41C  2  B4 CC 2D CD    .word L_GroundArea3, L_GroundArea4, L_GroundArea5, L_GroundArea6, L_GroundArea7, L_GroundArea8
00C420  2  AA CD 09 CE  
00C424  2  88 CE E7 CE  
00C428  2  5E CF 74 C2    .word L_GroundArea9, L_GroundArea10, L_GroundArea11, L_GroundArea12, L_GroundArea13, L_GroundArea14
00C42C  2  BF CF rr rr  
00C430  2  rr rr rr rr  
00C434  2  rr rr rr rr    .word L_GroundArea15, L_GroundArea16, L_GroundArea17, L_GroundArea18, L_GroundArea19, L_GroundArea20
00C438  2  rr rr rr rr  
00C43C  2  rr rr 08 D0  
00C440  2  7D C2 rr rr    .word L_GroundArea21, L_GroundArea22, L_GroundArea23, L_GroundArea24, L_GroundArea25, L_GroundArea26
00C444  2  rr rr rr rr  
00C448  2  rr rr rr rr  
00C44C  2  rr rr 61 C2    .word L_GroundArea27, L_GroundArea28, L_GroundArea29, L_UndergroundArea1, L_UndergroundArea2
00C450  2  rr rr 21 D0  
00C454  2  E2 D0        
00C456  2  1D D1 rr rr    .word L_UndergroundArea3, L_UndergroundArea4, L_UndergroundArea5, L_WaterArea1, L_WaterArea2
00C45A  2  rr rr 68 D1  
00C45E  2  rr rr        
00C460  2  1B D2 rr rr    .word L_WaterArea3, L_WaterArea4, L_WaterArea5, L_WaterArea6, L_WaterArea7, L_WaterArea8
00C464  2  rr rr rr rr  
00C468  2  rr rr rr rr  
00C46C  2               
00C46C  2               ;some unused bytes
00C46C  2  FF FF          .byte $ff, $ff
00C46E  2               
00C46E  2               GameMenuRoutine:
00C46E  2  AD FC 06                   lda SavedJoypadBits         ;check to see if the player pressed start
00C471  2  29 10                      and #Start_Button
00C473  2  F0 1F                      beq ChkSelect               ;if not, branch to check other buttons
00C475  2  A9 00                      lda #$00
00C477  2  8D FA 07                   sta CompletedWorlds
00C47A  2  8D FC 07                   sta DiskIOTask
00C47D  2  8D FB 07                   sta HardWorldFlag
00C480  2  AD 9F D2                   lda GamesBeatenCount        ;check to see if player has beaten
00C483  2  C9 08                      cmp #$08                    ;the game at least 8 times
00C485  2  90 0A                      bcc StG                     ;if not, start the game as usual at world 1
00C487  2  AD FC 06                   lda SavedJoypadBits
00C48A  2  29 80                      and #A_Button               ;check if the player pressed A + start
00C48C  2  F0 03                      beq StG                     ;if not, start the game as usual at world 1
00C48E  2  EE FB 07                   inc HardWorldFlag           ;otherwise start playing the letter worlds
00C491  2  4C EC C4     StG:          jmp StartGame
00C494  2  AD FC 06     ChkSelect:    lda SavedJoypadBits
00C497  2  C9 20                      cmp #Select_Button          ;branch if pressing select
00C499  2  F0 0F                      beq SelectLogic
00C49B  2  AE A2 07                   ldx DemoTimer
00C49E  2  D0 2F                      bne NullJoypad
00C4A0  2  8D 80 07                   sta SelectTimer             ;run demo after a certain period of time
00C4A3  2  20 53 C5                   jsr DemoEngine
00C4A6  2  B0 35                      bcs ResetTitle
00C4A8  2  90 2A                      bcc RunDemo
00C4AA  2  AD A2 07     SelectLogic:  lda DemoTimer               ;if select pressed, check demo timer one last time
00C4AD  2  F0 2E                      beq ResetTitle              ;if demo timer expired, branch to reset attract mode
00C4AF  2  A9 18                      lda #$18                    ;otherwise reset demo timer
00C4B1  2  8D A2 07                   sta DemoTimer
00C4B4  2  A5 09                      lda FrameCounter            ;erase LSB of frame counter
00C4B6  2  29 FE                      and #$fe
00C4B8  2  85 09                      sta FrameCounter
00C4BA  2  AD 80 07                   lda SelectTimer             ;if select timer not expired, skip to slow select down
00C4BD  2  D0 10                      bne NullJoypad
00C4BF  2  A9 10                      lda #$10                    ;reset select button timer
00C4C1  2  8D 80 07                   sta SelectTimer
00C4C4  2  AD 53 07                   lda SelectedPlayer          ;switch between the two players to select one
00C4C7  2  49 01                      eor #$01
00C4C9  2  8D 53 07                   sta SelectedPlayer
00C4CC  2  20 1B C5                   jsr DrawMenuCursor
00C4CF  2  A9 00        NullJoypad:   lda #$00
00C4D1  2  8D FC 06                   sta SavedJoypadBits
00C4D4  2  20 47 7A     RunDemo:      jsr GameCoreRoutine         ;run game engine
00C4D7  2  A5 0E                      lda GameEngineSubroutine    ;check to see if we're running lose life routine
00C4D9  2  C9 06                      cmp #$06
00C4DB  2  D0 33                      bne ExitMenu                ;if not, do not do all the resetting below
00C4DD  2  A9 00        ResetTitle:   lda #$00                    ;reset game modes, disable
00C4DF  2  8D 70 07                   sta OperMode                ;IRQ update and screen output
00C4E2  2  8D 72 07                   sta OperMode_Task           ;screen output
00C4E5  2  8D 22 07                   sta IRQUpdateFlag
00C4E8  2  EE 74 07                   inc DisableScreenFlag
00C4EB  2  60                         rts
00C4EC  2               
00C4EC  2               StartGame:
00C4EC  2  AD A2 07                   lda DemoTimer
00C4EF  2  F0 EC                      beq ResetTitle
00C4F1  2  EE 72 07                   inc OperMode_Task
00C4F4  2  20 FF C5                   jsr PatchPlayerNamePal      ;patch data over based on selected player
00C4F7  2  A9 00                      lda #$00
00C4F9  2  8D 5F 07                   sta WorldNumber
00C4FC  2  A9 00                      lda #$00
00C4FE  2  8D 5C 07                   sta LevelNumber
00C501  2  A9 00                      lda #$00
00C503  2  8D 60 07                   sta AreaNumber
00C506  2  A2 0B                      ldx #$0b
00C508  2  A9 00                      lda #$00
00C50A  2  9D DD 07     InitScore:    sta ScoreAndCoinDisplay,x   ;clear player score and coin display
00C50D  2  CA                         dex
00C50E  2  10 FA                      bpl InitScore
00C510  2  60           ExitMenu:     rts
00C511  2               
00C511  2               MenuCursorTemplate:
00C511  2  22 4B 83       .byte $22, $4b, $83
00C514  2  CE 24 24       .byte $ce, $24, $24
00C517  2  00             .byte $00
00C518  2               
00C518  2               MenuCursorTiles:
00C518  2  CE 24 CE       .byte $ce, $24, $ce
00C51B  2               
00C51B  2               DrawMenuCursor:
00C51B  2  A9 1C          lda #$1c                 ;set up VRAM address controller to draw cursor
00C51D  2  8D 73 07       sta VRAM_Buffer_AddrCtrl
00C520  2               
00C520  2               SetupMenuCursor:
00C520  2  AC 53 07       ldy SelectedPlayer       ;write blank and mushroom icon to template
00C523  2  B9 18 C5       lda MenuCursorTiles,y    ;in the order based on selected player
00C526  2  8D 14 C5       sta MenuCursorTemplate+3
00C529  2  B9 19 C5       lda MenuCursorTiles+1,y  ;e.g. if mario, write mushroom, then blank
00C52C  2  8D 16 C5       sta MenuCursorTemplate+5 ;and if luigi, write blank, then mushroom
00C52F  2  60             rts
00C530  2               
00C530  2               DemoActionData:
00C530  2  01 81 01 81    .byte $01, $81, $01, $81, $01, $81, $02, $01
00C534  2  01 81 02 01  
00C538  2  81 00 81 00    .byte $81, $00, $81, $00, $80, $01, $81, $01
00C53C  2  80 01 81 01  
00C540  2  00             .byte $00
00C541  2               
00C541  2               DemoTimingData:
00C541  2  B0 10 10 10    .byte $b0, $10, $10, $10, $28, $10, $28, $06
00C545  2  28 10 28 06  
00C549  2  10 10 0C 80    .byte $10, $10, $0c, $80, $10, $28, $08, $90
00C54D  2  10 28 08 90  
00C551  2  FF 00          .byte $ff, $00
00C553  2               
00C553  2               DemoEngine:
00C553  2  AE 17 07               ldx DemoAction         ;load current demo action
00C556  2  AD 18 07               lda DemoActionTimer    ;load current action timer
00C559  2  D0 0D                  bne DoAction           ;if timer still counting down, skip
00C55B  2  E8                     inx
00C55C  2  EE 17 07               inc DemoAction         ;if expired, increment action, X, and
00C55F  2  38                     sec                    ;set carry by default for demo over
00C560  2  BD 40 C5               lda DemoTimingData-1,x ;get next timer
00C563  2  8D 18 07               sta DemoActionTimer    ;store as current timer
00C566  2  F0 0A                  beq DemoOver           ;if timer already at zero, skip
00C568  2  BD 2F C5     DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
00C56B  2  8D FC 06               sta SavedJoypad1Bits
00C56E  2  CE 18 07               dec DemoActionTimer    ;decrement action timer
00C571  2  18                     clc                    ;clear carry if demo still going
00C572  2  60           DemoOver: rts
00C573  2               
00C573  2               ClearBuffersDrawIcon:
00C573  2  AD 70 07                  lda OperMode               ;check game mode
00C576  2  D0 17                     bne IncModeTask_B          ;if not attract mode, leave
00C578  2  A2 00                     ldx #$00                   ;otherwise, clear buffer space
00C57A  2  9D 00 03     TScrClear:   sta VRAM_Buffer1-1,x
00C57D  2  9D 00 04                  sta VRAM_Buffer1-1+$100,x
00C580  2  CA                        dex
00C581  2  D0 F7                     bne TScrClear
00C583  2  20 1B C5                  jsr DrawMenuCursor         ;draw player select cursor
00C586  2  EE 3C 07                  inc ScreenRoutineTask      ;move onto next task
00C589  2  60                        rts
00C58A  2               
00C58A  2               WriteTopScore:
00C58A  2  A9 FA                       lda #$fa                    ;run display routine to display top score on title
00C58C  2  20 EF 87                    jsr WriteDigits
00C58F  2  4C 26 63     IncModeTask_B: jmp IncModeTask
00C592  2               
00C592  2               InitializeGame:
00C592  2  A9 00                    lda #$00
00C594  2  8D FA 07                 sta CompletedWorlds      ;clean slate player's progress (except for games beaten)
00C597  2  8D FB 07                 sta HardWorldFlag
00C59A  2  8D 53 07                 sta SelectedPlayer
00C59D  2  20 FF C5                 jsr PatchPlayerNamePal   ;set up mario's/luigi's name and palette
00C5A0  2  20 20 C5                 jsr SetupMenuCursor      ;put menu cursor next to mario's name
00C5A3  2  A0 33                    ldy #$33                 ;set up offset in the title screen tiles
00C5A5  2  A9 0C                    lda #$0c                 ;set up counter to print up to 12 stars per row
00C5A7  2  85 00                    sta $00
00C5A9  2  A2 00                    ldx #$00                 ;init star counter
00C5AB  2  A9 26        PrintStars: lda #$26                 ;print blank by default
00C5AD  2  EC 9F D2                 cpx GamesBeatenCount     ;check star counter against games beaten
00C5B0  2  B0 02                    bcs PrintToTS            ;if counted up to games beaten, print the blank
00C5B2  2  A9 F1                    lda #$f1                 ;otherwise print a star for a beaten game
00C5B4  2  99 2B C6     PrintToTS:  sta TitleScreenGfxData,y ;print to title screen
00C5B7  2  C8                       iny
00C5B8  2  C6 00                    dec $00                  ;decrement until done printing a row
00C5BA  2  D0 02                    bne NextStarR
00C5BC  2  A0 4D                    ldy #$4d                 ;set up offset in title screen tiles for next row
00C5BE  2  E8           NextStarR:  inx
00C5BF  2  E0 18                    cpx #$18                 ;printed 24 tiles yet?  if not, go back
00C5C1  2  D0 E8                    bne PrintStars
00C5C3  2  A0 6F                    ldy #$6f                 ;clear all memory as in initialization procedure,
00C5C5  2  20 08 6F                 jsr InitializeMemory     ;but this time, clear only as far as $076f
00C5C8  2  A0 1F                    ldy #$1f
00C5CA  2  99 B0 07     ClrSndLoop: sta SoundMemory,y        ;clear out memory used
00C5CD  2  88                       dey                      ;by the sound engines
00C5CE  2  10 FA                    bpl ClrSndLoop
00C5D0  2               
00C5D0  2               DemoReset:
00C5D0  2  A9 18                    lda #$18             ;set demo timer
00C5D2  2  8D A2 07                 sta DemoTimer
00C5D5  2  20 A4 C2                 jsr LoadAreaPointer
00C5D8  2  4C 39 6E                 jmp InitializeArea
00C5DB  2               
00C5DB  2               PrimaryGameSetup:
00C5DB  2  A9 01              lda #$01
00C5DD  2  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
00C5E0  2  8D 54 07           sta PlayerSize              ;set player's size to small
00C5E3  2  A9 02              lda #$02
00C5E5  2  8D 5A 07           sta NumberofLives           ;give each player three lives
00C5E8  2  4C B9 6E           jmp SecondaryGameSetup
00C5EB  2               
00C5EB  2               ;-------------------------------------------------------------------------------------
00C5EB  2               
00C5EB  2               PlayerNameData:
00C5EB  2  16 0A 1B 12    .byte $16, $0a, $1b, $12, $18 ;"MARIO"
00C5EF  2  18           
00C5F0  2  15 1E 12 10    .byte $15, $1e, $12, $10, $12 ;"LUIGI"
00C5F4  2  12           
00C5F5  2               
00C5F5  2               PlayerPaletteData:
00C5F5  2  22 16 27 18    .byte $22, $16, $27, $18
00C5F9  2  22 30 27 19    .byte $22, $30, $27, $19
00C5FD  2               
00C5FD  2               PlayerNameOffsets:
00C5FD  2  04 09          .byte $04, $09                       ;note that offsets point to last byte
00C5FF  2               
00C5FF  2               PatchPlayerNamePal:
00C5FF  2  AC 53 07                ldy SelectedPlayer        ;get offset based on selected player
00C602  2  B9 FD C5                lda PlayerNameOffsets,y
00C605  2  48                      pha
00C606  2  C8                      iny
00C607  2  84 00                   sty $00                   ;save player + 1 temporarily (mario = 1, luigi = 2)
00C609  2  A8                      tay
00C60A  2  A2 04                   ldx #$04
00C60C  2  B9 EB C5     NamePatch: lda PlayerNameData,y      ;get name of selected player
00C60F  2  9D 75 66                sta TopStatusBarLine+3,x  ;patch to top status bar and victory message
00C612  2  9D 4A 6C                sta ThankYouMessage+$d,x
00C615  2  88                      dey
00C616  2  CA                      dex
00C617  2  10 F3                   bpl NamePatch
00C619  2  68                      pla                       ;subtract player + 1 from offset loaded earlier
00C61A  2  38                      sec                       ;to get proper offset for palette loading
00C61B  2  E5 00                   sbc $00
00C61D  2  A8                      tay
00C61E  2  A2 03                   ldx #$03
00C620  2  B9 F5 C5     PalPatch:  lda PlayerPaletteData,y   ;overwrite palette with the appropriate one
00C623  2  9D 37 65                sta PlayerColors,x
00C626  2  88                      dey
00C627  2  CA                      dex
00C628  2  10 F6                   bpl PalPatch
00C62A  2  60                      rts
00C62B  2               
00C62B  2               ;-------------------------------------------------------------------------------------
00C62B  2               
00C62B  2               TitleScreenGfxData:
00C62B  2  20 84 01 44         .byte $20, $84, $01, $44
00C62F  2  20 85 57 48         .byte $20, $85, $57, $48
00C633  2  20 9C 01 49         .byte $20, $9c, $01, $49
00C637  2  20 A4 C9 46         .byte $20, $a4, $c9, $46
00C63B  2  20 A5 57 26         .byte $20, $a5, $57, $26
00C63F  2  20 BC C9 4A         .byte $20, $bc, $c9, $4a
00C643  2  20 A5 0A D0         .byte $20, $a5, $0a, $d0, $d1, $d8, $d8, $de, $d1, $d0, $da, $de, $d1
00C647  2  D1 D8 D8 DE  
00C64B  2  D1 D0 DA DE  
00C650  2  20 C5 17 D2         .byte $20, $c5, $17, $d2, $d3, $db, $db, $db, $d9, $db, $dc, $db, $df
00C654  2  D3 DB DB DB  
00C658  2  D9 DB DC DB  
00C65D  2  26 26 26 26         .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00C661  2  26 26 26 26  
00C665  2  26 26 26 26  
00C66A  2  20 E5 17 D4         .byte $20, $e5, $17, $d4, $d5, $d4, $d9, $db, $e2, $d4, $da, $db, $e0
00C66E  2  D5 D4 D9 DB  
00C672  2  E2 D4 DA DB  
00C677  2  26 26 26 26         .byte $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26, $26
00C67B  2  26 26 26 26  
00C67F  2  26 26 26 26  
00C684  2  21 05 57 26         .byte $21, $05, $57, $26
00C688  2  21 05 0A D6         .byte $21, $05, $0a, $d6, $d7, $d6, $d7, $e1, $26, $d6, $dd, $e1, $e1
00C68C  2  D7 D6 D7 E1  
00C690  2  26 D6 DD E1  
00C695  2  21 25 17 D0         .byte $21, $25, $17, $d0, $e8, $d1, $d0, $d1, $de, $d1, $d8, $d0, $d1
00C699  2  E8 D1 D0 D1  
00C69D  2  DE D1 D8 D0  
00C6A2  2  26 DE D1 DE         .byte $26, $de, $d1, $de, $d1, $d0, $d1, $d0, $d1, $26, $26, $d0, $d1
00C6A6  2  D1 D0 D1 D0  
00C6AA  2  D1 26 26 D0  
00C6AF  2  21 45 17 DB         .byte $21, $45, $17, $db, $42, $42, $db, $42, $db, $42, $db, $db, $42
00C6B3  2  42 42 DB 42  
00C6B7  2  DB 42 DB DB  
00C6BC  2  26 DB 42 DB         .byte $26, $db, $42, $db, $42, $db, $42, $db, $42, $26, $26, $db, $42
00C6C0  2  42 DB 42 DB  
00C6C4  2  42 26 26 DB  
00C6C9  2  21 65 46 DB         .byte $21, $65, $46, $db
00C6CD  2  21 6B 11 DF         .byte $21, $6b, $11, $df, $db, $db, $db, $26, $db, $df, $db, $df, $db
00C6D1  2  DB DB DB 26  
00C6D5  2  DB DF DB DF  
00C6DA  2  DB E4 E5 26         .byte $db, $e4, $e5, $26, $26, $ec, $ed
00C6DE  2  26 EC ED     
00C6E1  2  21 85 17 DB         .byte $21, $85, $17, $db, $db, $db, $de, $43, $db, $e0, $db, $db, $db
00C6E5  2  DB DB DE 43  
00C6E9  2  DB E0 DB DB  
00C6EE  2  26 DB E3 DB         .byte $26, $db, $e3, $db, $e0, $db, $db, $e6, $e3, $26, $26, $ee, $ef
00C6F2  2  E0 DB DB E6  
00C6F6  2  E3 26 26 EE  
00C6FB  2  21 A5 17 DB         .byte $21, $a5, $17, $db, $db, $db, $db, $42, $db, $db, $db, $d4, $d9
00C6FF  2  DB DB DB 42  
00C703  2  DB DB DB D4  
00C708  2  26 DB D9 DB         .byte $26, $db, $d9, $db, $db, $d4, $d9, $d4, $d9, $e7, $26, $de, $da
00C70C  2  DB D4 D9 D4  
00C710  2  D9 E7 26 DE  
00C715  2  21 C4 19 5F         .byte $21, $c4, $19, $5f, $95, $95, $95, $95, $95, $95, $95, $95, $97
00C719  2  95 95 95 95  
00C71D  2  95 95 95 95  
00C722  2  98 78 95 96         .byte $98, $78, $95, $96, $95, $95, $97, $98, $97, $98, $95, $78, $95
00C726  2  95 95 97 98  
00C72A  2  97 98 95 78  
00C72F  2  F0 7A               .byte $f0, $7a
00C731  2  21 EF 0E CF         .byte $21, $ef, $0e, $cf, $01, $09, $08, $06, $24, $17, $12, $17, $1d
00C735  2  01 09 08 06  
00C739  2  24 17 12 17  
00C73E  2  0E 17 0D 18         .byte $0e, $17, $0d, $18
00C742  2  22 4D 0A 16         .byte $22, $4d, $0a, $16, $0a, $1b, $12, $18, $24, $10, $0a, $16, $0e
00C746  2  0A 1B 12 18  
00C74A  2  24 10 0A 16  
00C74F  2  22 8D 0A 15         .byte $22, $8d, $0a, $15, $1e, $12, $10, $12, $24, $10, $0a, $16, $0e
00C753  2  1E 12 10 12  
00C757  2  24 10 0A 16  
00C75C  2  22 EB 04 1D         .byte $22, $eb, $04, $1d, $18, $19, $28
00C760  2  18 19 28     
00C763  2  22 F5 01 00         .byte $22, $f5, $01, $00
00C767  2  23 C9 47 55         .byte $23, $c9, $47, $55
00C76B  2  23 D1 47 55         .byte $23, $d1, $47, $55
00C76F  2  23 D9 47 55         .byte $23, $d9, $47, $55
00C773  2  23 CC 43 F5         .byte $23, $cc, $43, $f5
00C777  2  23 D6 01 DD         .byte $23, $d6, $01, $dd
00C77B  2  23 DE 01 5D         .byte $23, $de, $01, $5d
00C77F  2  23 E2 04 55         .byte $23, $e2, $04, $55, $aa, $aa, $aa
00C783  2  AA AA AA     
00C786  2  23 EA 04 95         .byte $23, $ea, $04, $95, $aa, $aa, $2a
00C78A  2  AA AA 2A     
00C78D  2  00 FF FF            .byte $00, $ff, $ff
00C790  2               
00C790  2               ;-------------------------------------------------------------------------------------
00C790  2               
00C790  2               ;GAME LEVELS DATA
00C790  2               
00C790  2               ;level 1-4
00C790  2               E_CastleArea1:
00C790  2  35 9D 55 9B    .byte $35, $9d, $55, $9b, $c9, $1b, $59, $9d, $45, $9b, $c5, $1b, $26, $80, $45, $1b
00C794  2  C9 1B 59 9D  
00C798  2  45 9B C5 1B  
00C7A0  2  B9 1D F0 15    .byte $b9, $1d, $f0, $15, $59, $9d, $0f, $08, $78, $2d, $96, $28, $90, $b5, $ff
00C7A4  2  59 9D 0F 08  
00C7A8  2  78 2D 96 28  
00C7AF  2               
00C7AF  2               ;level 2-4
00C7AF  2               E_CastleArea2:
00C7AF  2  74 80 F0 38    .byte $74, $80, $f0, $38, $a0, $bb, $40, $bc, $8c, $1d, $c9, $9d, $05, $9b, $1c, $0c
00C7B3  2  A0 BB 40 BC  
00C7B7  2  8C 1D C9 9D  
00C7BF  2  59 1B B5 1D    .byte $59, $1b, $b5, $1d, $2c, $8c, $40, $15, $7c, $1b, $dc, $1d, $6c, $8c, $bc, $0c
00C7C3  2  2C 8C 40 15  
00C7C7  2  7C 1B DC 1D  
00C7CF  2  78 AD A5 28    .byte $78, $ad, $a5, $28, $90, $b5, $ff
00C7D3  2  90 B5 FF     
00C7D6  2               
00C7D6  2               ;level 3-4
00C7D6  2               E_CastleArea3:
00C7D6  2  0F 04 9C 0C    .byte $0f, $04, $9c, $0c, $0f, $07, $c5, $1b, $65, $9d, $49, $9d, $5c, $8c, $78, $2d
00C7DA  2  0F 07 C5 1B  
00C7DE  2  65 9D 49 9D  
00C7E6  2  90 B5 FF       .byte $90, $b5, $ff
00C7E9  2               
00C7E9  2               ;level 4-4
00C7E9  2               E_CastleArea4:
00C7E9  2  49 9F 67 03    .byte $49, $9f, $67, $03, $79, $9d, $a0, $3a, $57, $9f, $bb, $1d, $d5, $25, $0f, $05
00C7ED  2  79 9D A0 3A  
00C7F1  2  57 9F BB 1D  
00C7F9  2  18 1D 74 00    .byte $18, $1d, $74, $00, $84, $00, $94, $00, $c6, $29, $49, $9d, $db, $05, $0f, $08
00C7FD  2  84 00 94 00  
00C801  2  C6 29 49 9D  
00C809  2  05 9B 09 1D    .byte $05, $9b, $09, $1d, $b0, $38, $80, $95, $c0, $3c, $ec, $a8, $cc, $8c, $4a, $9b
00C80D  2  B0 38 80 95  
00C811  2  C0 3C EC A8  
00C819  2  78 2D 90 B5    .byte $78, $2d, $90, $b5, $ff
00C81D  2  FF           
00C81E  2               
00C81E  2               ;level 1-1
00C81E  2               E_GroundArea1:
00C81E  2  07 8E 47 03    .byte $07, $8e, $47, $03, $0f, $03, $10, $38, $1b, $80, $53, $06, $77, $0e, $83, $83
00C822  2  0F 03 10 38  
00C826  2  1B 80 53 06  
00C82E  2  A0 3D 90 3B    .byte $a0, $3d, $90, $3b, $90, $b7, $60, $bc, $b7, $0e, $ee, $42, $00, $f7, $80, $6b
00C832  2  90 B7 60 BC  
00C836  2  B7 0E EE 42  
00C83E  2  83 1B 83 AB    .byte $83, $1b, $83, $ab, $06, $ff
00C842  2  06 FF        
00C844  2               
00C844  2               ;level 1-3
00C844  2               E_GroundArea2:
00C844  2  96 A4 F9 24    .byte $96, $a4, $f9, $24, $d3, $83, $3a, $83, $5a, $03, $95, $07, $f4, $0f, $69, $a8
00C848  2  D3 83 3A 83  
00C84C  2  5A 03 95 07  
00C854  2  33 87 86 24    .byte $33, $87, $86, $24, $c9, $24, $4b, $83, $67, $83, $17, $83, $56, $28, $95, $24
00C858  2  C9 24 4B 83  
00C85C  2  67 83 17 83  
00C864  2  0A A4 FF       .byte $0a, $a4, $ff
00C867  2               
00C867  2               ;level 2-1
00C867  2               E_GroundArea3:
00C867  2  0F 02 47 0E    .byte $0f, $02, $47, $0e, $87, $0e, $c7, $0e, $f7, $0e, $27, $8e, $ee, $42, $25, $0f
00C86B  2  87 0E C7 0E  
00C86F  2  F7 0E 27 8E  
00C877  2  06 AC 28 8C    .byte $06, $ac, $28, $8c, $a8, $4e, $b3, $20, $8b, $8e, $f7, $90, $36, $90, $e5, $8e
00C87B  2  A8 4E B3 20  
00C87F  2  8B 8E F7 90  
00C887  2  32 8E C2 06    .byte $32, $8e, $c2, $06, $d2, $06, $e2, $06, $ff
00C88B  2  D2 06 E2 06  
00C88F  2  FF           
00C890  2               
00C890  2               ;level 2-2
00C890  2               E_GroundArea4:
00C890  2  15 8E 9B 06    .byte $15, $8e, $9b, $06, $e0, $37, $80, $bc, $0f, $04, $2b, $3b, $ab, $0e, $eb, $0e
00C894  2  E0 37 80 BC  
00C898  2  0F 04 2B 3B  
00C8A0  2  0F 06 F0 37    .byte $0f, $06, $f0, $37, $4b, $8e, $6b, $80, $bb, $3c, $4b, $bb, $ee, $42, $20, $1b
00C8A4  2  4B 8E 6B 80  
00C8A8  2  BB 3C 4B BB  
00C8B0  2  BC CB 00 AB    .byte $bc, $cb, $00, $ab, $83, $eb, $bb, $0f, $0e, $1b, $03, $9b, $37, $d4, $0e, $a3
00C8B4  2  83 EB BB 0F  
00C8B8  2  0E 1B 03 9B  
00C8C0  2  86 B3 06 C3    .byte $86, $b3, $06, $c3, $06, $ff
00C8C4  2  06 FF        
00C8C6  2               
00C8C6  2               ;level 2-3
00C8C6  2               E_GroundArea5:
00C8C6  2  C0 BE 0F 03    .byte $c0, $be, $0f, $03, $38, $0e, $15, $8f, $aa, $83, $f8, $07, $0f, $07, $96, $10
00C8CA  2  38 0E 15 8F  
00C8CE  2  AA 83 F8 07  
00C8D6  2  0F 09 48 10    .byte $0f, $09, $48, $10, $ba, $03, $ff
00C8DA  2  BA 03 FF     
00C8DD  2               
00C8DD  2               ;level 3-1
00C8DD  2               E_GroundArea6:
00C8DD  2  87 85 A3 05    .byte $87, $85, $a3, $05, $db, $83, $fb, $03, $93, $8f, $bb, $03, $ce, $42, $42, $9b
00C8E1  2  DB 83 FB 03  
00C8E5  2  93 8F BB 03  
00C8ED  2  83 AE B3 40    .byte $83, $ae, $b3, $40, $db, $00, $f4, $0f, $33, $8f, $74, $0f, $10, $bc, $f5, $0f
00C8F1  2  DB 00 F4 0F  
00C8F5  2  33 8F 74 0F  
00C8FD  2  2E C2 45 B7    .byte $2e, $c2, $45, $b7, $03, $f7, $03, $c8, $90, $ff
00C901  2  03 F7 03 C8  
00C905  2  90 FF        
00C907  2               
00C907  2               ;level 3-3
00C907  2               E_GroundArea7:
00C907  2  80 BE 83 03    .byte $80, $be, $83, $03, $92, $10, $4b, $80, $b0, $3c, $07, $80, $b7, $24, $0c, $a4
00C90B  2  92 10 4B 80  
00C90F  2  B0 3C 07 80  
00C917  2  96 A9 1B 83    .byte $96, $a9, $1b, $83, $7b, $24, $b7, $24, $97, $83, $e2, $0f, $a9, $a9, $38, $a9
00C91B  2  7B 24 B7 24  
00C91F  2  97 83 E2 0F  
00C927  2  0F 0B 74 8F    .byte $0f, $0b, $74, $8f, $ff
00C92B  2  FF           
00C92C  2               
00C92C  2               ;level 4-1
00C92C  2               E_GroundArea8:
00C92C  2  E2 91 0F 03    .byte $e2, $91, $0f, $03, $42, $11, $0f, $06, $72, $11, $0f, $08, $ee, $02, $60, $02
00C930  2  42 11 0F 06  
00C934  2  72 11 0F 08  
00C93C  2  91 EE B3 60    .byte $91, $ee, $b3, $60, $d3, $86, $ff
00C940  2  D3 86 FF     
00C943  2               
00C943  2               ;level 4-2
00C943  2               E_GroundArea9:
00C943  2  0F 02 9B 02    .byte $0f, $02, $9b, $02, $ab, $02, $0f, $04, $13, $03, $92, $11, $60, $b7, $00, $bc
00C947  2  AB 02 0F 04  
00C94B  2  13 03 92 11  
00C953  2  00 BB 0B 83    .byte $00, $bb, $0b, $83, $cb, $03, $7b, $85, $9e, $c2, $60, $e6, $05, $0f, $0c, $62
00C957  2  CB 03 7B 85  
00C95B  2  9E C2 60 E6  
00C963  2  10 FF          .byte $10, $ff
00C965  2               
00C965  2               ;level 4-3
00C965  2               E_GroundArea11:
00C965  2  E6 A9 57 A8    .byte $e6, $a9, $57, $a8, $b5, $24, $19, $a4, $76, $28, $a2, $0f, $95, $8f, $9d, $a8
00C969  2  B5 24 19 A4  
00C96D  2  76 28 A2 0F  
00C975  2  0F 07 09 29    .byte $0f, $07, $09, $29, $55, $24, $8b, $17, $a9, $24, $db, $83, $04, $a9, $24, $8f
00C979  2  55 24 8B 17  
00C97D  2  A9 24 DB 83  
00C985  2  65 0F FF       .byte $65, $0f, $ff
00C988  2               
00C988  2               ;cloud level used in levels 2-1, 3-1 and 4-1
00C988  2               E_GroundArea20:
00C988  2  0A AA 1E 22    .byte $0a, $aa, $1e, $22, $29, $1e, $25, $49, $2e, $27, $66, $ff
00C98C  2  29 1E 25 49  
00C990  2  2E 27 66 FF  
00C994  2               
00C994  2               ;level 1-2
00C994  2               E_UndergroundArea1:
00C994  2  0A 8E DE B4    .byte $0a, $8e, $de, $b4, $00, $e0, $37, $5b, $82, $2b, $a9, $aa, $29, $29, $a9, $a8
00C998  2  00 E0 37 5B  
00C99C  2  82 2B A9 AA  
00C9A4  2  29 0F 08 F0    .byte $29, $0f, $08, $f0, $3c, $79, $a9, $c5, $26, $cd, $26, $ee, $3b, $01, $67, $b4
00C9A8  2  3C 79 A9 C5  
00C9AC  2  26 CD 26 EE  
00C9B4  2  0F 0C 2E C1    .byte $0f, $0c, $2e, $c1, $00, $ff
00C9B8  2  00 FF        
00C9BA  2               
00C9BA  2               ;warp zone area used by level 1-2
00C9BA  2               E_UndergroundArea2:
00C9BA  2  09 A9 19 A9    .byte $09, $a9, $19, $a9, $de, $42, $02, $7b, $83, $ff
00C9BE  2  DE 42 02 7B  
00C9C2  2  83 FF        
00C9C4  2               
00C9C4  2               ;underground bonus rooms used in many levels
00C9C4  2               E_UndergroundArea3:
00C9C4  2  1E A0 0A 1E    .byte $1e, $a0, $0a, $1e, $23, $2b, $1e, $28, $6b, $0f, $03, $1e, $40, $08, $1e, $25
00C9C8  2  23 2B 1E 28  
00C9CC  2  6B 0F 03 1E  
00C9D4  2  4E 0F 06 1E    .byte $4e, $0f, $06, $1e, $22, $25, $1e, $25, $45, $ff
00C9D8  2  22 25 1E 25  
00C9DC  2  45 FF        
00C9DE  2               
00C9DE  2               ;level 3-2
00C9DE  2               E_WaterArea1:
00C9DE  2  0F 01 2A 07    .byte $0f, $01, $2a, $07, $2e, $3b, $41, $e9, $07, $0f, $03, $6b, $07, $f9, $07, $b8
00C9E2  2  2E 3B 41 E9  
00C9E6  2  07 0F 03 6B  
00C9EE  2  80 2A 87 4A    .byte $80, $2a, $87, $4a, $87, $b3, $0f, $84, $87, $47, $83, $87, $07, $0a, $87, $42
00C9F2  2  87 B3 0F 84  
00C9F6  2  87 47 83 87  
00C9FE  2  87 1B 87 6B    .byte $87, $1b, $87, $6b, $03, $ff
00CA02  2  03 FF        
00CA04  2               
00CA04  2               ;water area used by level 4-1
00CA04  2               E_WaterArea3:
00CA04  2  1E A7 6A 5B    .byte $1e, $a7, $6a, $5b, $82, $74, $07, $d8, $07, $e8, $02, $0f, $04, $26, $07, $ff
00CA08  2  82 74 07 D8  
00CA0C  2  07 E8 02 0F  
00CA14  2               
00CA14  2               ;level 1-4
00CA14  2               L_CastleArea1:
00CA14  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $33, $8e, $4e, $0a, $7e, $06, $9e, $0a
00CA18  2  06 33 07 34  
00CA1C  2  33 8E 4E 0A  
00CA24  2  CE 06 E3 00    .byte $ce, $06, $e3, $00, $ee, $0a, $1e, $87, $53, $0e, $8e, $02, $9c, $00, $c7, $0e
00CA28  2  EE 0A 1E 87  
00CA2C  2  53 0E 8E 02  
00CA34  2  D7 37 57 8E    .byte $d7, $37, $57, $8e, $6c, $05, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $43, $8e
00CA38  2  6C 05 DA 60  
00CA3C  2  E9 61 F8 62  
00CA44  2  C3 0E 43 8E    .byte $c3, $0e, $43, $8e, $b7, $0e, $ee, $09, $fe, $0a, $3e, $86, $57, $0e, $6e, $0a
00CA48  2  B7 0E EE 09  
00CA4C  2  FE 0A 3E 86  
00CA54  2  7E 06 AE 0A    .byte $7e, $06, $ae, $0a, $be, $06, $fe, $07, $15, $e2, $55, $62, $95, $62, $fe, $0a
00CA58  2  BE 06 FE 07  
00CA5C  2  15 E2 55 62  
00CA64  2  0D C4 CD 43    .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
00CA68  2  CE 09 DE 0B  
00CA6C  2  DD 42 FE 02  
00CA73  2               
00CA73  2               ;level 2-4
00CA73  2               L_CastleArea2:
00CA73  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $03, $e2, $0e, $06, $1e, $0c, $7e, $0a
00CA77  2  06 33 07 34  
00CA7B  2  03 E2 0E 06  
00CA83  2  8E 05 8E 82    .byte $8e, $05, $8e, $82, $8a, $8e, $8e, $0a, $ee, $02, $0a, $e0, $19, $61, $23, $06
00CA87  2  8A 8E 8E 0A  
00CA8B  2  EE 02 0A E0  
00CA93  2  28 62 2E 0B    .byte $28, $62, $2e, $0b, $7e, $0a, $81, $62, $87, $30, $8e, $04, $a7, $31, $c7, $0e
00CA97  2  7E 0A 81 62  
00CA9B  2  87 30 8E 04  
00CAA3  2  D7 33 FE 03    .byte $d7, $33, $fe, $03, $03, $8e, $0e, $0a, $11, $62, $1e, $04, $27, $32, $4e, $0a
00CAA7  2  03 8E 0E 0A  
00CAAB  2  11 62 1E 04  
00CAB3  2  51 62 57 0E    .byte $51, $62, $57, $0e, $5e, $04, $67, $34, $9e, $0a, $a1, $62, $ae, $03, $b3, $0e
00CAB7  2  5E 04 67 34  
00CABB  2  9E 0A A1 62  
00CAC3  2  BE 0B EE 09    .byte $be, $0b, $ee, $09, $fe, $0a, $2e, $82, $7a, $0e, $7e, $0a, $97, $31, $be, $04
00CAC7  2  FE 0A 2E 82  
00CACB  2  7A 0E 7E 0A  
00CAD3  2  DA 0E EE 0A    .byte $da, $0e, $ee, $0a, $f1, $62, $fe, $02, $3e, $8a, $7e, $06, $ae, $0a, $ce, $06
00CAD7  2  F1 62 FE 02  
00CADB  2  3E 8A 7E 06  
00CAE3  2  FE 0A 0D C4    .byte $fe, $0a, $0d, $c4, $11, $53, $21, $52, $24, $0b, $51, $52, $61, $52, $cd, $43
00CAE7  2  11 53 21 52  
00CAEB  2  24 0B 51 52  
00CAF3  2  CE 09 DD 42    .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00CAF7  2  DE 0B FE 02  
00CAFB  2  5D C7 FD     
00CAFE  2               
00CAFE  2               ;level 3-4
00CAFE  2               L_CastleArea3:
00CAFE  2  5B 09 05 34    .byte $5b, $09, $05, $34, $06, $35, $6e, $06, $7e, $0a, $ae, $02, $fe, $02, $0d, $01
00CB02  2  06 35 6E 06  
00CB06  2  7E 0A AE 02  
00CB0E  2  0E 0E 2E 0A    .byte $0e, $0e, $2e, $0a, $6e, $09, $be, $0a, $ed, $4b, $e4, $60, $ee, $0d, $5e, $82
00CB12  2  6E 09 BE 0A  
00CB16  2  ED 4B E4 60  
00CB1E  2  78 72 A4 3D    .byte $78, $72, $a4, $3d, $a5, $3e, $a6, $3f, $a3, $be, $a6, $3e, $a9, $32, $e9, $3a
00CB22  2  A5 3E A6 3F  
00CB26  2  A3 BE A6 3E  
00CB2E  2  9C 80 A3 33    .byte $9c, $80, $a3, $33, $a6, $33, $a9, $33, $e5, $06, $ed, $4b, $f3, $30, $f6, $30
00CB32  2  A6 33 A9 33  
00CB36  2  E5 06 ED 4B  
00CB3E  2  F9 30 FE 02    .byte $f9, $30, $fe, $02, $0d, $05, $3c, $01, $57, $73, $7c, $02, $93, $30, $a7, $73
00CB42  2  0D 05 3C 01  
00CB46  2  57 73 7C 02  
00CB4E  2  B3 37 CC 01    .byte $b3, $37, $cc, $01, $07, $83, $17, $03, $27, $03, $37, $03, $64, $3b, $77, $3a
00CB52  2  07 83 17 03  
00CB56  2  27 03 37 03  
00CB5E  2  0C 80 2E 0E    .byte $0c, $80, $2e, $0e, $9e, $02, $a5, $62, $b6, $61, $cc, $02, $c3, $33, $ed, $4b
00CB62  2  9E 02 A5 62  
00CB66  2  B6 61 CC 02  
00CB6E  2  03 B7 07 37    .byte $03, $b7, $07, $37, $83, $37, $87, $37, $dd, $4b, $03, $b5, $07, $35, $5e, $0a
00CB72  2  83 37 87 37  
00CB76  2  DD 4B 03 B5  
00CB7E  2  8E 02 AE 0A    .byte $8e, $02, $ae, $0a, $de, $06, $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42
00CB82  2  DE 06 FE 0A  
00CB86  2  0D C4 CD 43  
00CB8E  2  DE 0B FE 02    .byte $de, $0b, $fe, $02, $5d, $c7, $fd
00CB92  2  5D C7 FD     
00CB95  2               
00CB95  2               ;level 4-4
00CB95  2               L_CastleArea4:
00CB95  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $34, $4e, $03, $5c, $02, $0c, $f1, $27, $00
00CB99  2  06 33 07 34  
00CB9D  2  4E 03 5C 02  
00CBA5  2  3C 74 47 0E    .byte $3c, $74, $47, $0e, $fc, $00, $fe, $0b, $77, $8e, $ee, $09, $fe, $0a, $45, $b2
00CBA9  2  FC 00 FE 0B  
00CBAD  2  77 8E EE 09  
00CBB5  2  55 0E 99 32    .byte $55, $0e, $99, $32, $b9, $0e, $fe, $02, $0e, $85, $fe, $02, $16, $8e, $2e, $0c
00CBB9  2  B9 0E FE 02  
00CBBD  2  0E 85 FE 02  
00CBC5  2  AE 0A EE 05    .byte $ae, $0a, $ee, $05, $1e, $82, $47, $0e, $07, $bd, $c4, $72, $de, $0a, $fe, $02
00CBC9  2  1E 82 47 0E  
00CBCD  2  07 BD C4 72  
00CBD5  2  03 8E 07 0E    .byte $03, $8e, $07, $0e, $13, $3c, $17, $3d, $e3, $03, $ee, $0a, $f3, $06, $f7, $03
00CBD9  2  13 3C 17 3D  
00CBDD  2  E3 03 EE 0A  
00CBE5  2  FE 0E FE 8A    .byte $fe, $0e, $fe, $8a, $38, $e4, $4a, $72, $68, $64, $37, $b0, $98, $64, $a8, $64
00CBE9  2  38 E4 4A 72  
00CBED  2  68 64 37 B0  
00CBF5  2  E8 64 F8 64    .byte $e8, $64, $f8, $64, $0d, $c4, $71, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b
00CBF9  2  0D C4 71 64  
00CBFD  2  CD 43 CE 09  
00CC05  2  FE 02 5D C7    .byte $fe, $02, $5d, $c7, $fd
00CC09  2  FD           
00CC0A  2               
00CC0A  2               ;level 1-1
00CC0A  2               L_GroundArea1:
00CC0A  2  50 31 0F 26    .byte $50, $31, $0f, $26, $13, $e4, $23, $24, $27, $23, $37, $07, $66, $61, $ac, $74
00CC0E  2  13 E4 23 24  
00CC12  2  27 23 37 07  
00CC1A  2  C7 01 0B F1    .byte $c7, $01, $0b, $f1, $77, $73, $b6, $04, $db, $71, $5c, $82, $83, $2d, $a2, $47
00CC1E  2  77 73 B6 04  
00CC22  2  DB 71 5C 82  
00CC2A  2  A7 0A B7 29    .byte $a7, $0a, $b7, $29, $4f, $b3, $87, $0b, $93, $23, $cc, $06, $e3, $2c, $3a, $e0
00CC2E  2  4F B3 87 0B  
00CC32  2  93 23 CC 06  
00CC3A  2  7C 71 97 01    .byte $7c, $71, $97, $01, $ac, $73, $e6, $61, $0e, $b1, $b7, $f3, $dc, $02, $d3, $25
00CC3E  2  AC 73 E6 61  
00CC42  2  0E B1 B7 F3  
00CC4A  2  07 FB 2C 01    .byte $07, $fb, $2c, $01, $e7, $73, $2c, $f2, $34, $72, $57, $00, $7c, $02, $39, $f1
00CC4E  2  E7 73 2C F2  
00CC52  2  34 72 57 00  
00CC5A  2  BF 37 33 E7    .byte $bf, $37, $33, $e7, $cd, $41, $0f, $a6, $ed, $47, $fd
00CC5E  2  CD 41 0F A6  
00CC62  2  ED 47 FD     
00CC65  2               
00CC65  2               ;level 1-3
00CC65  2               L_GroundArea2:
00CC65  2  50 11 0F 26    .byte $50, $11, $0f, $26, $fe, $10, $47, $92, $56, $40, $ac, $16, $af, $12, $0f, $95
00CC69  2  FE 10 47 92  
00CC6D  2  56 40 AC 16  
00CC75  2  73 16 82 44    .byte $73, $16, $82, $44, $ec, $48, $bc, $c2, $1c, $b1, $b3, $16, $c2, $44, $86, $c0
00CC79  2  EC 48 BC C2  
00CC7D  2  1C B1 B3 16  
00CC85  2  9C 14 9F 12    .byte $9c, $14, $9f, $12, $a6, $40, $df, $15, $0b, $96, $43, $12, $97, $31, $d3, $12
00CC89  2  A6 40 DF 15  
00CC8D  2  0B 96 43 12  
00CC95  2  03 92 27 14    .byte $03, $92, $27, $14, $63, $00, $c7, $15, $d6, $43, $ac, $97, $af, $11, $1f, $96
00CC99  2  63 00 C7 15  
00CC9D  2  D6 43 AC 97  
00CCA5  2  64 13 E3 12    .byte $64, $13, $e3, $12, $2e, $91, $9d, $41, $ae, $42, $df, $20, $cd, $c7, $fd
00CCA9  2  2E 91 9D 41  
00CCAD  2  AE 42 DF 20  
00CCB4  2               
00CCB4  2               ;level 2-1
00CCB4  2               L_GroundArea3:
00CCB4  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $64, $4f, $b2, $7c, $5f, $7c, $3f, $7c, $d8, $7c, $38
00CCB8  2  6E 64 4F B2  
00CCBC  2  7C 5F 7C 3F  
00CCC4  2  83 02 A3 00    .byte $83, $02, $a3, $00, $c3, $02, $f7, $16, $5c, $d6, $cf, $35, $d3, $20, $e3, $0a
00CCC8  2  C3 02 F7 16  
00CCCC  2  5C D6 CF 35  
00CCD4  2  F3 20 25 B5    .byte $f3, $20, $25, $b5, $2c, $53, $6a, $7a, $8c, $54, $da, $72, $fc, $50, $0c, $d2
00CCD8  2  2C 53 6A 7A  
00CCDC  2  8C 54 DA 72  
00CCE4  2  39 73 5C 54    .byte $39, $73, $5c, $54, $aa, $72, $cc, $53, $f7, $16, $33, $83, $40, $06, $5c, $5b
00CCE8  2  AA 72 CC 53  
00CCEC  2  F7 16 33 83  
00CCF4  2  09 93 27 0F    .byte $09, $93, $27, $0f, $3c, $5c, $0a, $b0, $63, $27, $78, $72, $93, $09, $97, $03
00CCF8  2  3C 5C 0A B0  
00CCFC  2  63 27 78 72  
00CD04  2  A7 03 B7 22    .byte $a7, $03, $b7, $22, $47, $81, $5c, $72, $2a, $b0, $28, $0f, $3c, $5f, $58, $31
00CD08  2  47 81 5C 72  
00CD0C  2  2A B0 28 0F  
00CD14  2  B8 31 28 B1    .byte $b8, $31, $28, $b1, $3c, $5b, $98, $31, $fa, $30, $03, $b2, $20, $04, $7f, $b7
00CD18  2  3C 5B 98 31  
00CD1C  2  FA 30 03 B2  
00CD24  2  F3 67 8D C1    .byte $f3, $67, $8d, $c1, $bf, $26, $ad, $c7, $fd
00CD28  2  BF 26 AD C7  
00CD2C  2  FD           
00CD2D  2               
00CD2D  2               ;level 2-2
00CD2D  2               L_GroundArea4:
00CD2D  2  54 11 0F 26    .byte $54, $11, $0f, $26, $38, $f2, $ab, $71, $0b, $f1, $96, $42, $ce, $10, $1e, $91
00CD31  2  38 F2 AB 71  
00CD35  2  0B F1 96 42  
00CD3D  2  29 61 3A 60    .byte $29, $61, $3a, $60, $4e, $10, $78, $74, $8e, $11, $06, $c3, $1a, $e0, $1e, $10
00CD41  2  4E 10 78 74  
00CD45  2  8E 11 06 C3  
00CD4D  2  5E 11 67 63    .byte $5e, $11, $67, $63, $77, $63, $88, $62, $99, $61, $aa, $60, $be, $10, $0a, $f2
00CD51  2  77 63 88 62  
00CD55  2  99 61 AA 60  
00CD5D  2  15 45 7E 11    .byte $15, $45, $7e, $11, $7a, $31, $9a, $e0, $ac, $02, $d9, $61, $d4, $0a, $ec, $01
00CD61  2  7A 31 9A E0  
00CD65  2  AC 02 D9 61  
00CD6D  2  D6 C2 84 C3    .byte $d6, $c2, $84, $c3, $98, $fa, $d3, $07, $d7, $0b, $e9, $61, $ee, $10, $2e, $91
00CD71  2  98 FA D3 07  
00CD75  2  D7 0B E9 61  
00CD7D  2  39 71 93 03    .byte $39, $71, $93, $03, $a6, $03, $be, $10, $e1, $71, $e3, $31, $5e, $91, $69, $61
00CD81  2  A6 03 BE 10  
00CD85  2  E1 71 E3 31  
00CD8D  2  E6 41 28 E2    .byte $e6, $41, $28, $e2, $99, $71, $ae, $10, $ce, $11, $be, $90, $d6, $32, $3e, $91
00CD91  2  99 71 AE 10  
00CD95  2  CE 11 BE 90  
00CD9D  2  5F 37 66 60    .byte $5f, $37, $66, $60, $d3, $67, $6d, $c1, $af, $26, $9d, $c7, $fd
00CDA1  2  D3 67 6D C1  
00CDA5  2  AF 26 9D C7  
00CDAA  2               
00CDAA  2               ;level 2-3
00CDAA  2               L_GroundArea5:
00CDAA  2  54 11 0F 26    .byte $54, $11, $0f, $26, $af, $32, $d8, $62, $e8, $62, $f8, $62, $fe, $10, $0c, $be
00CDAE  2  AF 32 D8 62  
00CDB2  2  E8 62 F8 62  
00CDBA  2  F8 64 0D C8    .byte $f8, $64, $0d, $c8, $2c, $43, $98, $64, $ac, $39, $48, $e4, $6a, $62, $7c, $47
00CDBE  2  2C 43 98 64  
00CDC2  2  AC 39 48 E4  
00CDCA  2  FA 62 3C B7    .byte $fa, $62, $3c, $b7, $ea, $62, $fc, $4d, $f6, $02, $03, $80, $06, $02, $13, $02
00CDCE  2  EA 62 FC 4D  
00CDD2  2  F6 02 03 80  
00CDDA  2  DA 62 0D C8    .byte $da, $62, $0d, $c8, $0b, $17, $97, $16, $2c, $b1, $33, $43, $6c, $31, $ac, $31
00CDDE  2  0B 17 97 16  
00CDE2  2  2C B1 33 43  
00CDEA  2  17 93 73 12    .byte $17, $93, $73, $12, $cc, $31, $1a, $e2, $2c, $4b, $67, $48, $ea, $62, $0d, $ca
00CDEE  2  CC 31 1A E2  
00CDF2  2  2C 4B 67 48  
00CDFA  2  17 12 53 12    .byte $17, $12, $53, $12, $be, $11, $1d, $c1, $3e, $42, $6f, $20, $4d, $c7, $fd
00CDFE  2  BE 11 1D C1  
00CE02  2  3E 42 6F 20  
00CE09  2               
00CE09  2               ;level 3-1
00CE09  2               L_GroundArea6:
00CE09  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $75, $53, $aa, $57, $25, $b7, $0a, $c7, $23, $0c, $83
00CE0D  2  6E 75 53 AA  
00CE11  2  57 25 B7 0A  
00CE19  2  5C 72 87 01    .byte $5c, $72, $87, $01, $c3, $00, $c7, $20, $dc, $65, $0c, $87, $c3, $22, $f3, $03
00CE1D  2  C3 00 C7 20  
00CE21  2  DC 65 0C 87  
00CE29  2  03 A2 27 7B    .byte $03, $a2, $27, $7b, $33, $03, $43, $23, $52, $42, $9c, $06, $a7, $20, $c3, $23
00CE2D  2  33 03 43 23  
00CE31  2  52 42 9C 06  
00CE39  2  03 A2 0C 02    .byte $03, $a2, $0c, $02, $33, $09, $39, $71, $43, $23, $77, $06, $83, $67, $a7, $73
00CE3D  2  33 09 39 71  
00CE41  2  43 23 77 06  
00CE49  2  5C 82 C9 11    .byte $5c, $82, $c9, $11, $07, $80, $1c, $71, $98, $11, $9a, $10, $f3, $04, $16, $f4
00CE4D  2  07 80 1C 71  
00CE51  2  98 11 9A 10  
00CE59  2  3C 02 68 7A    .byte $3c, $02, $68, $7a, $8c, $01, $a7, $73, $e7, $73, $ac, $83, $09, $8f, $1c, $03
00CE5D  2  8C 01 A7 73  
00CE61  2  E7 73 AC 83  
00CE69  2  9F 37 13 E7    .byte $9f, $37, $13, $e7, $7c, $02, $ad, $41, $ef, $26, $0d, $0e, $39, $71, $7f, $37
00CE6D  2  7C 02 AD 41  
00CE71  2  EF 26 0D 0E  
00CE79  2  F2 68 02 E8    .byte $f2, $68, $02, $e8, $12, $3a, $1c, $00, $68, $7a, $de, $3f, $6d, $c5, $fd
00CE7D  2  12 3A 1C 00  
00CE81  2  68 7A DE 3F  
00CE88  2               
00CE88  2               ;level 3-3
00CE88  2               L_GroundArea7:
00CE88  2  55 10 0B 1F    .byte $55, $10, $0b, $1f, $0f, $26, $d6, $12, $07, $9f, $33, $1a, $fb, $1f, $f7, $94
00CE8C  2  0F 26 D6 12  
00CE90  2  07 9F 33 1A  
00CE98  2  53 94 71 71    .byte $53, $94, $71, $71, $cc, $15, $cf, $13, $1f, $98, $63, $12, $9b, $13, $a9, $71
00CE9C  2  CC 15 CF 13  
00CEA0  2  1F 98 63 12  
00CEA8  2  FB 17 09 F1    .byte $fb, $17, $09, $f1, $13, $13, $21, $42, $59, $0f, $eb, $13, $33, $93, $40, $06
00CEAC  2  13 13 21 42  
00CEB0  2  59 0F EB 13  
00CEB8  2  8C 14 8F 17    .byte $8c, $14, $8f, $17, $93, $40, $cf, $13, $0b, $94, $57, $15, $07, $93, $19, $f3
00CEBC  2  93 40 CF 13  
00CEC0  2  0B 94 57 15  
00CEC8  2  C6 43 C7 13    .byte $c6, $43, $c7, $13, $d3, $03, $e3, $03, $33, $b0, $4a, $72, $55, $46, $73, $31
00CECC  2  D3 03 E3 03  
00CED0  2  33 B0 4A 72  
00CED8  2  A8 74 E3 12    .byte $a8, $74, $e3, $12, $8e, $91, $ad, $41, $ce, $42, $ef, $20, $dd, $c7, $fd
00CEDC  2  8E 91 AD 41  
00CEE0  2  CE 42 EF 20  
00CEE7  2               
00CEE7  2               ;level 4-1
00CEE7  2               L_GroundArea8:
00CEE7  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $63, $a9, $f1, $fb, $71, $22, $83, $37, $0b, $36, $50
00CEEB  2  6E 63 A9 F1  
00CEEF  2  FB 71 22 83  
00CEF7  2  39 51 B8 62    .byte $39, $51, $b8, $62, $57, $f3, $e8, $02, $f8, $02, $08, $82, $18, $02, $2d, $4a
00CEFB  2  57 F3 E8 02  
00CEFF  2  F8 02 08 82  
00CF07  2  28 02 38 02    .byte $28, $02, $38, $02, $48, $00, $a8, $0f, $aa, $30, $bc, $5a, $6a, $b0, $4f, $b6
00CF0B  2  48 00 A8 0F  
00CF0F  2  AA 30 BC 5A  
00CF17  2  B7 04 9A B0    .byte $b7, $04, $9a, $b0, $ac, $71, $c7, $01, $e6, $74, $0d, $09, $46, $02, $56, $00
00CF1B  2  AC 71 C7 01  
00CF1F  2  E6 74 0D 09  
00CF27  2  6C 01 84 79    .byte $6c, $01, $84, $79, $86, $02, $96, $02, $a4, $71, $a6, $02, $b6, $02, $c4, $71
00CF2B  2  86 02 96 02  
00CF2F  2  A4 71 A6 02  
00CF37  2  C6 02 D6 02    .byte $c6, $02, $d6, $02, $39, $f1, $6c, $00, $77, $02, $a3, $09, $ac, $00, $b8, $72
00CF3B  2  39 F1 6C 00  
00CF3F  2  77 02 A3 09  
00CF47  2  DC 01 07 F3    .byte $dc, $01, $07, $f3, $4c, $00, $6f, $37, $e3, $03, $e6, $03, $5d, $ca, $6c, $00
00CF4B  2  4C 00 6F 37  
00CF4F  2  E3 03 E6 03  
00CF57  2  7D 41 CF 26    .byte $7d, $41, $cf, $26, $9d, $c7, $fd
00CF5B  2  9D C7 FD     
00CF5E  2               
00CF5E  2               ;level 4-2
00CF5E  2               L_GroundArea9:
00CF5E  2  50 A1 0F 26    .byte $50, $a1, $0f, $26, $17, $91, $19, $11, $48, $00, $68, $11, $6a, $10, $96, $14
00CF62  2  17 91 19 11  
00CF66  2  48 00 68 11  
00CF6E  2  D8 0A E8 02    .byte $d8, $0a, $e8, $02, $f8, $02, $dc, $81, $6c, $81, $89, $0f, $9c, $00, $c3, $29
00CF72  2  F8 02 DC 81  
00CF76  2  6C 81 89 0F  
00CF7E  2  F8 62 47 A7    .byte $f8, $62, $47, $a7, $c6, $61, $0d, $07, $56, $74, $b7, $00, $b9, $11, $cc, $76
00CF82  2  C6 61 0D 07  
00CF86  2  56 74 B7 00  
00CF8E  2  ED 4A 1C 80    .byte $ed, $4a, $1c, $80, $37, $01, $3a, $10, $de, $20, $e9, $0b, $ee, $21, $c8, $bc
00CF92  2  37 01 3A 10  
00CF96  2  DE 20 E9 0B  
00CF9E  2  9C F6 BC 00    .byte $9c, $f6, $bc, $00, $cb, $7a, $eb, $72, $0c, $82, $39, $71, $b7, $63, $cc, $03
00CFA2  2  CB 7A EB 72  
00CFA6  2  0C 82 39 71  
00CFAE  2  E6 60 26 E0    .byte $e6, $60, $26, $e0, $4a, $30, $53, $31, $5c, $58, $ed, $41, $2f, $a6, $1d, $c7
00CFB2  2  4A 30 53 31  
00CFB6  2  5C 58 ED 41  
00CFBE  2  FD             .byte $fd
00CFBF  2               
00CFBF  2               ;level 4-3
00CFBF  2               L_GroundArea11:
00CFBF  2  50 11 0F 26    .byte $50, $11, $0f, $26, $fe, $10, $8b, $93, $a9, $0f, $14, $c1, $cc, $16, $cf, $11
00CFC3  2  FE 10 8B 93  
00CFC7  2  A9 0F 14 C1  
00CFCF  2  2F 95 B7 14    .byte $2f, $95, $b7, $14, $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00
00CFD3  2  C7 96 D6 44  
00CFD7  2  2B 92 39 0F  
00CFDF  2  1B 95 97 13    .byte $1b, $95, $97, $13, $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9f
00CFE3  2  6C 95 6F 11  
00CFE7  2  A2 40 BF 15  
00CFEF  2  53 16 62 44    .byte $53, $16, $62, $44, $72, $c2, $9b, $1d, $b7, $e0, $ed, $4a, $03, $e0, $8e, $11
00CFF3  2  72 C2 9B 1D  
00CFF7  2  B7 E0 ED 4A  
00CFFF  2  9D 41 BE 42    .byte $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
00D003  2  EF 20 CD C7  
00D007  2  FD           
00D008  2               
00D008  2               ;cloud level used in levels 2-1, 3-1 and 4-1
00D008  2               L_GroundArea20:
00D008  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $03, $cf, $00, $d7, $23, $4d, $07, $af, $2a, $4c, $03, $cf
00D00C  2  03 CF 00 D7  
00D010  2  23 4D 07 AF  
00D018  2  3E 80 F3 4A    .byte $3e, $80, $f3, $4a, $bb, $c2, $bd, $c7, $fd
00D01C  2  BB C2 BD C7  
00D020  2  FD           
00D021  2               
00D021  2               ;level 1-2
00D021  2               L_UndergroundArea1:
00D021  2  48 0F 0E 01    .byte $48, $0f, $0e, $01, $5e, $02, $0a, $b0, $1c, $54, $6a, $30, $7f, $34, $c6, $64
00D025  2  5E 02 0A B0  
00D029  2  1C 54 6A 30  
00D031  2  D6 64 E6 64    .byte $d6, $64, $e6, $64, $f6, $64, $fe, $00, $f0, $07, $00, $a1, $1e, $02, $47, $73
00D035  2  F6 64 FE 00  
00D039  2  F0 07 00 A1  
00D041  2  7E 04 84 52    .byte $7e, $04, $84, $52, $94, $50, $95, $0b, $96, $50, $a4, $52, $ae, $05, $b8, $51
00D045  2  94 50 95 0B  
00D049  2  96 50 A4 52  
00D051  2  C8 51 CE 01    .byte $c8, $51, $ce, $01, $17, $f3, $45, $03, $52, $09, $62, $21, $6f, $34, $81, $21
00D055  2  17 F3 45 03  
00D059  2  52 09 62 21  
00D061  2  9E 02 B6 64    .byte $9e, $02, $b6, $64, $c6, $64, $c0, $0c, $d6, $64, $d0, $07, $e6, $64, $e0, $0c
00D065  2  C6 64 C0 0C  
00D069  2  D6 64 D0 07  
00D071  2  F0 07 FE 0A    .byte $f0, $07, $fe, $0a, $0d, $06, $0e, $01, $4e, $04, $67, $73, $8e, $02, $b7, $0a
00D075  2  0D 06 0E 01  
00D079  2  4E 04 67 73  
00D081  2  BC 03 C4 72    .byte $bc, $03, $c4, $72, $c7, $22, $08, $f2, $2c, $02, $59, $71, $7c, $01, $96, $74
00D085  2  C7 22 08 F2  
00D089  2  2C 02 59 71  
00D091  2  BC 01 D8 72    .byte $bc, $01, $d8, $72, $fc, $01, $39, $f1, $4e, $01, $9e, $04, $a7, $52, $b7, $0b
00D095  2  FC 01 39 F1  
00D099  2  4E 01 9E 04  
00D0A1  2  B8 51 C7 51    .byte $b8, $51, $c7, $51, $d7, $50, $de, $02, $3a, $e0, $3e, $0a, $9e, $00, $08, $d4
00D0A5  2  D7 50 DE 02  
00D0A9  2  3A E0 3E 0A  
00D0B1  2  18 54 28 54    .byte $18, $54, $28, $54, $48, $54, $6e, $06, $9e, $01, $a8, $52, $af, $47, $b8, $52
00D0B5  2  48 54 6E 06  
00D0B9  2  9E 01 A8 52  
00D0C1  2  C8 52 D8 52    .byte $c8, $52, $d8, $52, $de, $0f, $4d, $c7, $ce, $01, $dc, $01, $f9, $79, $1c, $82
00D0C5  2  DE 0F 4D C7  
00D0C9  2  CE 01 DC 01  
00D0D1  2  48 72 7F 37    .byte $48, $72, $7f, $37, $f2, $68, $01, $e9, $11, $3a, $68, $7a, $de, $0f, $6d, $c5
00D0D5  2  F2 68 01 E9  
00D0D9  2  11 3A 68 7A  
00D0E1  2  FD             .byte $fd
00D0E2  2               
00D0E2  2               ;warp zone area used by level 1-2
00D0E2  2               L_UndergroundArea2:
00D0E2  2  0B 0F 0E 01    .byte $0b, $0f, $0e, $01, $9c, $71, $b7, $00, $be, $00, $3e, $81, $47, $73, $5e, $00
00D0E6  2  9C 71 B7 00  
00D0EA  2  BE 00 3E 81  
00D0F2  2  63 42 8E 01    .byte $63, $42, $8e, $01, $a7, $73, $be, $00, $7e, $81, $88, $72, $f0, $59, $fe, $00
00D0F6  2  A7 73 BE 00  
00D0FA  2  7E 81 88 72  
00D102  2  00 D9 0E 01    .byte $00, $d9, $0e, $01, $39, $79, $a7, $03, $ae, $00, $b4, $03, $de, $0f, $0d, $05
00D106  2  39 79 A7 03  
00D10A  2  AE 00 B4 03  
00D112  2  0E 02 68 7A    .byte $0e, $02, $68, $7a, $be, $01, $de, $0f, $6d, $c5, $fd
00D116  2  BE 01 DE 0F  
00D11A  2  6D C5 FD     
00D11D  2               
00D11D  2               ;underground bonus rooms used with worlds 1-4
00D11D  2               L_UndergroundArea3:
00D11D  2  08 8F 0E 01    .byte $08, $8f, $0e, $01, $17, $05, $2e, $02, $30, $07, $37, $03, $3a, $49, $44, $03
00D121  2  17 05 2E 02  
00D125  2  30 07 37 03  
00D12D  2  58 47 DF 4A    .byte $58, $47, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $87, $52, $97, $2f
00D131  2  6D C7 0E 81  
00D135  2  00 5A 2E 02  
00D13D  2  99 4F 0A 90    .byte $99, $4f, $0a, $90, $93, $56, $a3, $0b, $a7, $50, $b3, $55, $df, $4a, $6d, $c7
00D141  2  93 56 A3 0B  
00D145  2  A7 50 B3 55  
00D14D  2  0E 81 00 5A    .byte $0e, $81, $00, $5a, $2e, $00, $3e, $02, $41, $56, $57, $25, $56, $45, $68, $51
00D151  2  2E 00 3E 02  
00D155  2  41 56 57 25  
00D15D  2  7A 43 B7 0B    .byte $7a, $43, $b7, $0b, $b8, $51, $df, $4a, $6d, $c7, $fd
00D161  2  B8 51 DF 4A  
00D165  2  6D C7 FD     
00D168  2               
00D168  2               ;level 3-2
00D168  2               L_WaterArea1:
00D168  2  41 01 03 B4    .byte $41, $01, $03, $b4, $04, $34, $05, $34, $5c, $02, $83, $37, $84, $37, $85, $37
00D16C  2  04 34 05 34  
00D170  2  5C 02 83 37  
00D178  2  09 C2 0C 02    .byte $09, $c2, $0c, $02, $1d, $49, $fa, $60, $09, $e1, $18, $62, $20, $63, $27, $63
00D17C  2  1D 49 FA 60  
00D180  2  09 E1 18 62  
00D188  2  33 37 37 63    .byte $33, $37, $37, $63, $47, $63, $5c, $05, $79, $43, $fe, $06, $35, $d2, $46, $48
00D18C  2  47 63 5C 05  
00D190  2  79 43 FE 06  
00D198  2  91 53 D6 51    .byte $91, $53, $d6, $51, $fe, $01, $0c, $83, $6c, $04, $b4, $62, $c4, $62, $d4, $62
00D19C  2  FE 01 0C 83  
00D1A0  2  6C 04 B4 62  
00D1A8  2  E4 62 F4 62    .byte $e4, $62, $f4, $62, $18, $d2, $79, $51, $f4, $66, $fe, $02, $0c, $8a, $1d, $49
00D1AC  2  18 D2 79 51  
00D1B0  2  F4 66 FE 02  
00D1B8  2  31 55 56 41    .byte $31, $55, $56, $41, $77, $41, $98, $41, $c5, $55, $fe, $01, $07, $e3, $17, $63
00D1BC  2  77 41 98 41  
00D1C0  2  C5 55 FE 01  
00D1C8  2  27 63 37 63    .byte $27, $63, $37, $63, $47, $63, $57, $63, $67, $63, $78, $62, $89, $61, $9a, $60
00D1CC  2  47 63 57 63  
00D1D0  2  67 63 78 62  
00D1D8  2  BC 07 CA 42    .byte $bc, $07, $ca, $42, $3a, $b3, $46, $53, $63, $34, $66, $44, $7c, $01, $9a, $33
00D1DC  2  3A B3 46 53  
00D1E0  2  63 34 66 44  
00D1E8  2  B7 52 DC 01    .byte $b7, $52, $dc, $01, $fa, $32, $05, $d4, $2c, $0d, $43, $37, $47, $35, $b7, $30
00D1EC  2  FA 32 05 D4  
00D1F0  2  2C 0D 43 37  
00D1F8  2  C3 64 23 E4    .byte $c3, $64, $23, $e4, $29, $45, $33, $64, $43, $64, $53, $64, $63, $64, $73, $64
00D1FC  2  29 45 33 64  
00D200  2  43 64 53 64  
00D208  2  9A 60 A9 61    .byte $9a, $60, $a9, $61, $b8, $62, $be, $0b, $d4, $31, $d5, $0d, $de, $0f, $0d, $ca
00D20C  2  B8 62 BE 0B  
00D210  2  D4 31 D5 0D  
00D218  2  7D 47 FD       .byte $7d, $47, $fd
00D21B  2               
00D21B  2               ;water area used by level 4-1
00D21B  2               L_WaterArea3:
00D21B  2  01 01 78 52    .byte $01, $01, $78, $52, $b5, $55, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81
00D21F  2  B5 55 DA 60  
00D223  2  E9 61 F8 62  
00D22B  2  0A CF 36 49    .byte $0a, $cf, $36, $49, $62, $43, $fe, $07, $36, $c9, $fe, $01, $0c, $84, $65, $55
00D22F  2  62 43 FE 07  
00D233  2  36 C9 FE 01  
00D23B  2  97 52 9A 32    .byte $97, $52, $9a, $32, $a9, $31, $b8, $30, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00D23F  2  A9 31 B8 30  
00D243  2  C7 63 CE 0F  
00D24B  2  FD             .byte $fd
00D24C  2               
00D24C  2               ;a bunch of unused space
00D24C  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D250  2  FF FF FF FF  
00D254  2  FF FF FF FF  
00D25C  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D260  2  FF FF FF FF  
00D264  2  FF FF FF FF  
00D26C  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D270  2  FF FF FF FF  
00D274  2  FF FF FF FF  
00D27C  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D280  2  FF FF FF FF  
00D284  2  FF FF FF FF  
00D28C  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D290  2  FF FF FF FF  
00D294  2  FF FF FF FF  
00D29C  2  FF FF FF       .byte $ff, $ff, $ff
00D29F  2               
00D29F  2               ;-------------------------------------------------------------------------------------
00D29F  2               
00D29F  2               ;this is overwritten by the contents of SM2SAVE
00D29F  2               GamesBeatenCount:
00D29F  2  00                  .byte $00
00D2A0  2               
00D2A0  2               ;-------------------------------------------------------------------------------------
00D2A0  2               
00D2A0  2               SoundEngine:
00D2A0  2  AD 70 07              lda OperMode              ;are we in attract mode?
00D2A3  2  D0 04                 bne SndOn
00D2A5  2  8D 15 40              sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
00D2A8  2  60                    rts
00D2A9  2  A9 FF        SndOn:   lda #$ff
00D2AB  2  8D 17 40              sta JOYPAD_PORT2          ;disable irqs from apu and set frame counter mode
00D2AE  2  A9 0F                 lda #$0f
00D2B0  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable first four channels
00D2B3  2  AD C6 07              lda PauseModeFlag         ;is sound already in pause mode?
00D2B6  2  D0 06                 bne InPause
00D2B8  2  A5 FA                 lda PauseSoundQueue       ;if not, check pause sfx queue
00D2BA  2  C9 01                 cmp #$01
00D2BC  2  D0 5D                 bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
00D2BE  2  AD B2 07     InPause: lda PauseSoundBuffer      ;check pause sfx buffer
00D2C1  2  D0 23                 bne ContPau
00D2C3  2  A5 FA                 lda PauseSoundQueue       ;check pause queue
00D2C5  2  F0 66                 beq SkipSoundSubroutines
00D2C7  2  8D B2 07              sta PauseSoundBuffer      ;if queue full, store in buffer and activate
00D2CA  2  8D C6 07              sta PauseModeFlag         ;pause mode to interrupt game sounds
00D2CD  2  A9 00                 lda #$00                  ;disable sound and clear sfx buffers
00D2CF  2  8D 15 40              sta SND_MASTERCTRL_REG
00D2D2  2  85 F1                 sta Square1SoundBuffer
00D2D4  2  85 F2                 sta Square2SoundBuffer
00D2D6  2  85 F3                 sta NoiseSoundBuffer
00D2D8  2  A9 0F                 lda #$0f
00D2DA  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable sound again
00D2DD  2  A9 2A                 lda #$2a                  ;store length of sound in pause counter
00D2DF  2  8D BB 07              sta Squ1_SfxLenCounter
00D2E2  2  A9 44        PTone1F: lda #$44                  ;play first tone
00D2E4  2  D0 11                 bne PTRegC                ;unconditional branch
00D2E6  2  AD BB 07     ContPau: lda Squ1_SfxLenCounter    ;check pause length left
00D2E9  2  C9 24                 cmp #$24                  ;time to play second?
00D2EB  2  F0 08                 beq PTone2F
00D2ED  2  C9 1E                 cmp #$1e                  ;time to play first again?
00D2EF  2  F0 F1                 beq PTone1F
00D2F1  2  C9 18                 cmp #$18                  ;time to play second again?
00D2F3  2  D0 09                 bne DecPauC               ;only load regs during times, otherwise skip
00D2F5  2  A9 64        PTone2F: lda #$64                  ;store reg contents and play the pause sfx
00D2F7  2  A2 84        PTRegC:  ldx #$84
00D2F9  2  A0 7F                 ldy #$7f
00D2FB  2  20 58 D3              jsr PlaySqu1Sfx
00D2FE  2  CE BB 07     DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
00D301  2  D0 2A                 bne SkipSoundSubroutines
00D303  2  A9 00                 lda #$00                  ;disable sound if in pause mode and
00D305  2  8D 15 40              sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
00D308  2  AD B2 07              lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
00D30B  2  C9 02                 cmp #$02                  ;if we need to be playing sound again
00D30D  2  D0 05                 bne SkipPIn
00D30F  2  A9 00                 lda #$00                  ;clear pause mode to allow game sounds again
00D311  2  8D C6 07              sta PauseModeFlag
00D314  2  A9 00        SkipPIn: lda #$00                  ;clear pause sfx buffer
00D316  2  8D B2 07              sta PauseSoundBuffer
00D319  2  F0 12                 beq SkipSoundSubroutines
00D31B  2               
00D31B  2               RunSoundSubroutines:
00D31B  2  20 EB D3              jsr Square1SfxHandler  ;play sfx on square channel 1
00D31E  2  20 4C D5              jsr Square2SfxHandler  ; ''  ''  '' square channel 2
00D321  2  20 77 D6              jsr NoiseSfxHandler    ; ''  ''  '' noise channel
00D324  2  20 D0 D6              jsr MusicHandler       ;play music on all channels
00D327  2  A9 00                 lda #$00               ;clear the music queues
00D329  2  85 FB                 sta AreaMusicQueue
00D32B  2  85 FC                 sta EventMusicQueue
00D32D  2               
00D32D  2               SkipSoundSubroutines:
00D32D  2  A9 00                  lda #$00               ;clear the sound effects queues
00D32F  2  85 FF                  sta Square1SoundQueue
00D331  2  85 FE                  sta Square2SoundQueue
00D333  2  85 FD                  sta NoiseSoundQueue
00D335  2  85 FA                  sta PauseSoundQueue
00D337  2  AC C0 07               ldy DAC_Counter        ;load some sort of counter
00D33A  2  A5 F4                  lda AreaMusicBuffer
00D33C  2  29 03                  and #%00000011         ;check for specific music
00D33E  2  F0 07                  beq NoIncDAC
00D340  2  EE C0 07               inc DAC_Counter        ;increment and check counter
00D343  2  C0 30                  cpy #$30
00D345  2  90 06                  bcc StrWave            ;if not there yet, just store it
00D347  2  98           NoIncDAC: tya
00D348  2  F0 03                  beq StrWave            ;if we are at zero, do not decrement
00D34A  2  CE C0 07               dec DAC_Counter        ;decrement counter
00D34D  2  8C 11 40     StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
00D350  2  60                     rts                    ;we are done here
00D351  2               
00D351  2               
00D351  2               ;--------------------------------
00D351  2               
00D351  2               Dump_Squ1_Regs:
00D351  2  8C 01 40           sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
00D354  2  8E 00 40           stx SND_SQUARE1_REG
00D357  2  60                 rts
00D358  2               
00D358  2               PlaySqu1Sfx:
00D358  2  20 51 D3           jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
00D35B  2               
00D35B  2               SetFreq_Squ1:
00D35B  2  A2 00              ldx #$00               ;set frequency reg offset for square 1 sound channel
00D35D  2               
00D35D  2               Dump_Freq_Regs:
00D35D  2  A8                   tay
00D35E  2  B9 01 DF             lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
00D361  2  F0 0B                beq NoTone                ;if zero, then do not load
00D363  2  9D 02 40             sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
00D366  2  B9 00 DF             lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
00D369  2  09 08                ora #%00001000            ;length counter
00D36B  2  9D 03 40             sta SND_REGISTER+3,x
00D36E  2  60           NoTone: rts
00D36F  2               
00D36F  2               Dump_Sq2_Regs:
00D36F  2  8E 04 40           stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
00D372  2  8C 05 40           sty SND_SQUARE2_REG+1
00D375  2  60                 rts
00D376  2               
00D376  2               PlaySqu2Sfx:
00D376  2  20 6F D3           jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
00D379  2               
00D379  2               SetFreq_Squ2:
00D379  2  A2 04              ldx #$04               ;set frequency reg offset for square 2 sound channel
00D37B  2  D0 E0              bne Dump_Freq_Regs     ;unconditional branch
00D37D  2               
00D37D  2               SetFreq_Tri:
00D37D  2  A2 08              ldx #$08               ;set frequency reg offset for triangle sound channel
00D37F  2  D0 DC              bne Dump_Freq_Regs     ;unconditional branch
00D381  2               
00D381  2               ;--------------------------------
00D381  2               
00D381  2               SwimStompEnvelopeData:
00D381  2  9F 9B 98 96        .byte $9f, $9b, $98, $96, $95, $94, $92, $90
00D385  2  95 94 92 90  
00D389  2  90 9A 97 95        .byte $90, $9a, $97, $95, $93, $92
00D38D  2  93 92        
00D38F  2               
00D38F  2               PlayFlagpoleSlide:
00D38F  2  A9 40               lda #$40               ;store length of flagpole sound
00D391  2  8D BB 07            sta Squ1_SfxLenCounter
00D394  2  A9 62               lda #$62               ;load part of reg contents for flagpole sound
00D396  2  20 5B D3            jsr SetFreq_Squ1
00D399  2  A2 99               ldx #$99               ;now load the rest
00D39B  2  D0 25               bne FPS2nd
00D39D  2               
00D39D  2               PlaySmallJump:
00D39D  2  A9 26               lda #$26               ;branch here for small mario jumping sound
00D39F  2  D0 02               bne JumpRegContents
00D3A1  2               
00D3A1  2               PlayBigJump:
00D3A1  2  A9 18               lda #$18               ;branch here for big mario jumping sound
00D3A3  2               
00D3A3  2               JumpRegContents:
00D3A3  2  A2 82               ldx #$82               ;note that small and big jump borrow each others' reg contents
00D3A5  2  A0 A7               ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
00D3A7  2  20 58 D3            jsr PlaySqu1Sfx
00D3AA  2  A9 28               lda #$28               ;store length of sfx for both jumping sounds
00D3AC  2  8D BB 07            sta Squ1_SfxLenCounter ;then continue on here
00D3AF  2               
00D3AF  2               ContinueSndJump:
00D3AF  2  AD BB 07               lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
00D3B2  2  C9 25                  cmp #$25               ;check for time to play second part yet
00D3B4  2  D0 06                  bne N2Prt
00D3B6  2  A2 5F                  ldx #$5f               ;load second part
00D3B8  2  A0 F6                  ldy #$f6
00D3BA  2  D0 08                  bne DmpJpFPS           ;unconditional branch
00D3BC  2  C9 20        N2Prt:    cmp #$20               ;check for third part
00D3BE  2  D0 29                  bne DecJpFPS
00D3C0  2  A2 48                  ldx #$48               ;load third part
00D3C2  2  A0 BC        FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
00D3C4  2  20 51 D3     DmpJpFPS: jsr Dump_Squ1_Regs
00D3C7  2  D0 20                  bne DecJpFPS           ;unconditional branch outta here
00D3C9  2               
00D3C9  2               PlayFireballThrow:
00D3C9  2  A9 05                lda #$05
00D3CB  2  A0 99                ldy #$99                 ;load reg contents for fireball throw sound
00D3CD  2  D0 04                bne Fthrow               ;unconditional branch
00D3CF  2               
00D3CF  2               PlayBump:
00D3CF  2  A9 0A                  lda #$0a                ;load length of sfx and reg contents for bump sound
00D3D1  2  A0 93                  ldy #$93
00D3D3  2  A2 9E        Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
00D3D5  2  8D BB 07               sta Squ1_SfxLenCounter
00D3D8  2  A9 0C                  lda #$0c                ;load offset for bump sound
00D3DA  2  20 58 D3               jsr PlaySqu1Sfx
00D3DD  2               
00D3DD  2               ContinueBumpThrow:
00D3DD  2  AD BB 07               lda Squ1_SfxLenCounter  ;check for second part of bump sound
00D3E0  2  C9 06                  cmp #$06
00D3E2  2  D0 05                  bne DecJpFPS
00D3E4  2  A9 BB                  lda #$bb                ;load second part directly
00D3E6  2  8D 01 40               sta SND_SQUARE1_REG+1
00D3E9  2  D0 60        DecJpFPS: bne BranchToDecLength1  ;unconditional branch
00D3EB  2               
00D3EB  2               
00D3EB  2               Square1SfxHandler:
00D3EB  2  A4 FF               ldy Square1SoundQueue   ;check for sfx in queue
00D3ED  2  F0 20               beq CheckSfx1Buffer
00D3EF  2  84 F1               sty Square1SoundBuffer  ;if found, put in buffer
00D3F1  2  30 AA               bmi PlaySmallJump       ;small jump
00D3F3  2  46 FF               lsr Square1SoundQueue
00D3F5  2  B0 AA               bcs PlayBigJump         ;big jump
00D3F7  2  46 FF               lsr Square1SoundQueue
00D3F9  2  B0 D4               bcs PlayBump            ;bump
00D3FB  2  46 FF               lsr Square1SoundQueue
00D3FD  2  B0 2C               bcs PlaySwimStomp       ;swim/stomp
00D3FF  2  46 FF               lsr Square1SoundQueue
00D401  2  B0 4A               bcs PlaySmackEnemy      ;smack enemy
00D403  2  46 FF               lsr Square1SoundQueue
00D405  2  B0 7F               bcs PlayPipeDownInj     ;pipedown/injury
00D407  2  46 FF               lsr Square1SoundQueue
00D409  2  B0 BE               bcs PlayFireballThrow   ;fireball throw
00D40B  2  46 FF               lsr Square1SoundQueue
00D40D  2  B0 80               bcs PlayFlagpoleSlide   ;slide flagpole
00D40F  2               
00D40F  2               CheckSfx1Buffer:
00D40F  2  A5 F1               lda Square1SoundBuffer   ;check for sfx in buffer
00D411  2  F0 17               beq ExS1H                ;if not found, exit sub
00D413  2  30 9A               bmi ContinueSndJump      ;small mario jump
00D415  2  4A                  lsr
00D416  2  B0 97               bcs ContinueSndJump      ;big mario jump
00D418  2  4A                  lsr
00D419  2  B0 C2               bcs ContinueBumpThrow    ;bump
00D41B  2  4A                  lsr
00D41C  2  B0 1B               bcs ContinueSwimStomp    ;swim/stomp
00D41E  2  4A                  lsr
00D41F  2  B0 3C               bcs ContinueSmackEnemy   ;smack enemy
00D421  2  4A                  lsr
00D422  2  B0 67               bcs ContinuePipeDownInj  ;pipedown/injury
00D424  2  4A                  lsr
00D425  2  B0 B6               bcs ContinueBumpThrow    ;fireball throw
00D427  2  4A                  lsr
00D428  2  B0 48               bcs DecrementSfx1Length  ;slide flagpole
00D42A  2  60           ExS1H: rts
00D42B  2               
00D42B  2               
00D42B  2               PlaySwimStomp:
00D42B  2  A9 0E              lda #$0e               ;store length of swim/stomp sound
00D42D  2  8D BB 07           sta Squ1_SfxLenCounter
00D430  2  A0 9C              ldy #$9c               ;store reg contents for swim/stomp sound
00D432  2  A2 9E              ldx #$9e
00D434  2  A9 26              lda #$26
00D436  2  20 58 D3           jsr PlaySqu1Sfx
00D439  2               
00D439  2               ContinueSwimStomp:
00D439  2  AC BB 07           ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
00D43C  2  B9 80 D3           lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
00D43F  2  8D 00 40           sta SND_SQUARE1_REG           ;envelope
00D442  2  C0 06              cpy #$06
00D444  2  D0 05              bne BranchToDecLength1
00D446  2  A9 9E              lda #$9e                      ;when the length counts down to a certain point, put this
00D448  2  8D 02 40           sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
00D44B  2               
00D44B  2               BranchToDecLength1:
00D44B  2  D0 25              bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
00D44D  2               
00D44D  2               PlaySmackEnemy:
00D44D  2  A9 0E              lda #$0e                 ;store length of smack enemy sound
00D44F  2  A0 CB              ldy #$cb
00D451  2  A2 9F              ldx #$9f
00D453  2  8D BB 07           sta Squ1_SfxLenCounter
00D456  2  A9 28              lda #$28                 ;store reg contents for smack enemy sound
00D458  2  20 58 D3           jsr PlaySqu1Sfx
00D45B  2  D0 15              bne DecrementSfx1Length  ;unconditional branch
00D45D  2               
00D45D  2               ContinueSmackEnemy:
00D45D  2  AC BB 07             ldy Squ1_SfxLenCounter  ;check about halfway through
00D460  2  C0 08                cpy #$08
00D462  2  D0 09                bne SmSpc
00D464  2  A9 A0                lda #$a0                ;if we're at the about-halfway point, make the second tone
00D466  2  8D 02 40             sta SND_SQUARE1_REG+2   ;in the smack enemy sound
00D469  2  A9 9F                lda #$9f
00D46B  2  D0 02                bne SmTick
00D46D  2  A9 90        SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
00D46F  2  8D 00 40     SmTick: sta SND_SQUARE1_REG
00D472  2               
00D472  2               DecrementSfx1Length:
00D472  2  CE BB 07           dec Squ1_SfxLenCounter    ;decrement length of sfx
00D475  2  D0 0E              bne ExSfx1
00D477  2               
00D477  2               StopSquare1Sfx:
00D477  2  A2 00                ldx #$00                ;if end of sfx reached, clear buffer
00D479  2  86 F1                stx $f1                 ;and stop making the sfx
00D47B  2  A2 0E                ldx #$0e
00D47D  2  8E 15 40             stx SND_MASTERCTRL_REG
00D480  2  A2 0F                ldx #$0f
00D482  2  8E 15 40             stx SND_MASTERCTRL_REG
00D485  2  60           ExSfx1: rts
00D486  2               
00D486  2               PlayPipeDownInj:
00D486  2  A9 2F              lda #$2f                ;load length of pipedown sound
00D488  2  8D BB 07           sta Squ1_SfxLenCounter
00D48B  2               
00D48B  2               ContinuePipeDownInj:
00D48B  2  AD BB 07              lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
00D48E  2  4A                    lsr                     ;to be written to only during six specific times
00D48F  2  B0 10                 bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
00D491  2  4A                    lsr
00D492  2  B0 0D                 bcs NoPDwnL
00D494  2  29 02                 and #%00000010
00D496  2  F0 09                 beq NoPDwnL
00D498  2  A0 91                 ldy #$91                ;and this is where it actually gets written in
00D49A  2  A2 9A                 ldx #$9a
00D49C  2  A9 44                 lda #$44
00D49E  2  20 58 D3              jsr PlaySqu1Sfx
00D4A1  2  4C 72 D4     NoPDwnL: jmp DecrementSfx1Length
00D4A4  2               
00D4A4  2               ;--------------------------------
00D4A4  2               
00D4A4  2               ExtraLifeFreqData:
00D4A4  2  58 02 54 56        .byte $58, $02, $54, $56, $4e, $44
00D4A8  2  4E 44        
00D4AA  2               
00D4AA  2               PowerUpGrabFreqData:
00D4AA  2  4C 52 4C 48        .byte $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
00D4AE  2  3E 36 3E 36  
00D4B2  2  30           
00D4B3  2  28 4A 50 4A        .byte $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
00D4B7  2  64 3C 32 3C  
00D4BB  2  32           
00D4BC  2  2C 24 3A 64        .byte $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
00D4C0  2  3A 34 2C 22  
00D4C4  2  2C           
00D4C5  2               
00D4C5  2               ;residual frequency data
00D4C5  2  22 1C 14           .byte $22, $1c, $14
00D4C8  2               
00D4C8  2               PUp_VGrow_FreqData:
00D4C8  2  14 04 22 24        .byte $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
00D4CC  2  16 04 24 26  
00D4D0  2  18 04 26 28        .byte $18, $04, $26, $28, $1a, $04, $28, $2a
00D4D4  2  1A 04 28 2A  
00D4D8  2  1C 04 2A 2C        .byte $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
00D4DC  2  1E 04 2C 2E  
00D4E0  2  20 04 2E 30        .byte $20, $04, $2e, $30, $22, $04, $30, $32
00D4E4  2  22 04 30 32  
00D4E8  2               
00D4E8  2               PlayCoinGrab:
00D4E8  2  A9 35                lda #$35             ;load length of coin grab sound
00D4EA  2  A2 8D                ldx #$8d             ;and part of reg contents
00D4EC  2  D0 04                bne CGrab_TTickRegL
00D4EE  2               
00D4EE  2               PlayTimerTick:
00D4EE  2  A9 06                lda #$06             ;load length of timer tick sound
00D4F0  2  A2 98                ldx #$98             ;and part of reg contents
00D4F2  2               
00D4F2  2               CGrab_TTickRegL:
00D4F2  2  8D BD 07             sta Squ2_SfxLenCounter
00D4F5  2  A0 7F                ldy #$7f                ;load the rest of reg contents
00D4F7  2  A9 42                lda #$42                ;of coin grab and timer tick sound
00D4F9  2  20 76 D3             jsr PlaySqu2Sfx
00D4FC  2               
00D4FC  2               ContinueCGrabTTick:
00D4FC  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second tone yet
00D4FF  2  C9 30                cmp #$30                ;timer tick sound also executes this, not sure why
00D501  2  D0 05                bne N2Tone
00D503  2  A9 54                lda #$54                ;if so, load the tone directly into the reg
00D505  2  8D 06 40             sta SND_SQUARE2_REG+2
00D508  2  D0 2E        N2Tone: bne DecrementSfx2Length
00D50A  2               
00D50A  2               PlayBlast:
00D50A  2  A9 20                lda #$20                ;load length of fireworks/gunfire sound
00D50C  2  8D BD 07             sta Squ2_SfxLenCounter
00D50F  2  A0 94                ldy #$94                ;load reg contents of fireworks/gunfire sound
00D511  2  A9 5E                lda #$5e
00D513  2  D0 0B                bne SBlasJ
00D515  2               
00D515  2               ContinueBlast:
00D515  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second part
00D518  2  C9 18                cmp #$18
00D51A  2  D0 1C                bne DecrementSfx2Length
00D51C  2  A0 93                ldy #$93                ;load second part reg contents then
00D51E  2  A9 18                lda #$18
00D520  2  D0 7F        SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
00D522  2               
00D522  2               PlayPowerUpGrab:
00D522  2  A9 36                lda #$36                    ;load length of power-up grab sound
00D524  2  8D BD 07             sta Squ2_SfxLenCounter
00D527  2               
00D527  2               ContinuePowerUpGrab:
00D527  2  AD BD 07             lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
00D52A  2  4A                   lsr                         ;divide by 2
00D52B  2  B0 0B                bcs DecrementSfx2Length     ;alter frequency every other frame
00D52D  2  A8                   tay
00D52E  2  B9 A9 D4             lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
00D531  2  A2 5D                ldx #$5d                    ;store reg contents of power-up grab sound
00D533  2  A0 7F                ldy #$7f
00D535  2               
00D535  2               LoadSqu2Regs:
00D535  2  20 76 D3             jsr PlaySqu2Sfx
00D538  2               
00D538  2               DecrementSfx2Length:
00D538  2  CE BD 07             dec Squ2_SfxLenCounter   ;decrement length of sfx
00D53B  2  D0 0E                bne ExSfx2
00D53D  2               
00D53D  2               EmptySfx2Buffer:
00D53D  2  A2 00                ldx #$00                ;initialize square 2's sound effects buffer
00D53F  2  86 F2                stx Square2SoundBuffer
00D541  2               
00D541  2               StopSquare2Sfx:
00D541  2  A2 0D                ldx #$0d                ;stop playing the sfx
00D543  2  8E 15 40             stx SND_MASTERCTRL_REG
00D546  2  A2 0F                ldx #$0f
00D548  2  8E 15 40             stx SND_MASTERCTRL_REG
00D54B  2  60           ExSfx2: rts
00D54C  2               
00D54C  2               Square2SfxHandler:
00D54C  2  A5 F2                lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
00D54E  2  29 40                and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
00D550  2  D0 65                bne ContinueExtraLife
00D552  2  A4 FE                ldy Square2SoundQueue  ;check for sfx in queue
00D554  2  F0 20                beq CheckSfx2Buffer
00D556  2  84 F2                sty Square2SoundBuffer ;if found, put in buffer and check for the following
00D558  2  30 3E                bmi PlayBowserFall     ;bowser fall
00D55A  2  46 FE                lsr Square2SoundQueue
00D55C  2  B0 8A                bcs PlayCoinGrab       ;coin grab
00D55E  2  46 FE                lsr Square2SoundQueue
00D560  2  B0 6A                bcs PlayGrowPowerUp    ;power-up reveal
00D562  2  46 FE                lsr Square2SoundQueue
00D564  2  B0 6A                bcs PlayGrowVine       ;vine grow
00D566  2  46 FE                lsr Square2SoundQueue
00D568  2  B0 A0                bcs PlayBlast          ;fireworks/gunfire
00D56A  2  46 FE                lsr Square2SoundQueue
00D56C  2  B0 80                bcs PlayTimerTick      ;timer tick
00D56E  2  46 FE                lsr Square2SoundQueue
00D570  2  B0 B0                bcs PlayPowerUpGrab    ;power-up grab
00D572  2  46 FE                lsr Square2SoundQueue
00D574  2  B0 3C                bcs PlayExtraLife      ;1-up
00D576  2               
00D576  2               CheckSfx2Buffer:
00D576  2  A5 F2                lda Square2SoundBuffer   ;check for sfx in buffer
00D578  2  F0 17                beq ExS2H                ;if not found, exit sub
00D57A  2  30 27                bmi ContinueBowserFall   ;bowser fall
00D57C  2  4A                   lsr
00D57D  2  B0 13                bcs Cont_CGrab_TTick     ;coin grab
00D57F  2  4A                   lsr
00D580  2  B0 5D                bcs ContinueGrowItems    ;power-up reveal
00D582  2  4A                   lsr
00D583  2  B0 5A                bcs ContinueGrowItems    ;vine grow
00D585  2  4A                   lsr
00D586  2  B0 8D                bcs ContinueBlast        ;fireworks/gunfire
00D588  2  4A                   lsr
00D589  2  B0 07                bcs Cont_CGrab_TTick     ;timer tick
00D58B  2  4A                   lsr
00D58C  2  B0 99                bcs ContinuePowerUpGrab  ;power-up grab
00D58E  2  4A                   lsr
00D58F  2  B0 26                bcs ContinueExtraLife    ;1-up
00D591  2  60           ExS2H:  rts
00D592  2               
00D592  2               Cont_CGrab_TTick:
00D592  2  4C FC D4             jmp ContinueCGrabTTick
00D595  2               
00D595  2               JumpToDecLength2:
00D595  2  4C 38 D5             jmp DecrementSfx2Length
00D598  2               
00D598  2               PlayBowserFall:
00D598  2  A9 38                 lda #$38                ;load length of bowser defeat sound
00D59A  2  8D BD 07              sta Squ2_SfxLenCounter
00D59D  2  A0 C4                 ldy #$c4                ;load contents of reg for bowser defeat sound
00D59F  2  A9 18                 lda #$18
00D5A1  2  D0 0B        BlstSJp: bne PBFRegs
00D5A3  2               
00D5A3  2               ContinueBowserFall:
00D5A3  2  AD BD 07               lda Squ2_SfxLenCounter   ;check for almost near the end
00D5A6  2  C9 08                  cmp #$08
00D5A8  2  D0 8E                  bne DecrementSfx2Length
00D5AA  2  A0 A4                  ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
00D5AC  2  A9 5A                  lda #$5a
00D5AE  2  A2 9F        PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
00D5B0  2  D0 83        EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
00D5B2  2               
00D5B2  2               PlayExtraLife:
00D5B2  2  A9 30                lda #$30                  ;load length of 1-up sound
00D5B4  2  8D BD 07             sta Squ2_SfxLenCounter
00D5B7  2               
00D5B7  2               ContinueExtraLife:
00D5B7  2  AD BD 07               lda Squ2_SfxLenCounter
00D5BA  2  A2 03                  ldx #$03                  ;load new tones only every eight frames
00D5BC  2  4A           DivLLoop: lsr
00D5BD  2  B0 D6                  bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
00D5BF  2  CA                     dex
00D5C0  2  D0 FA                  bne DivLLoop              ;do this until all bits checked, if none set, continue
00D5C2  2  A8                     tay
00D5C3  2  B9 A3 D4               lda ExtraLifeFreqData-1,y ;load our reg contents
00D5C6  2  A2 82                  ldx #$82
00D5C8  2  A0 7F                  ldy #$7f
00D5CA  2  D0 E4                  bne EL_LRegs              ;unconditional branch
00D5CC  2               
00D5CC  2               PlayGrowPowerUp:
00D5CC  2  A9 10                lda #$10                ;load length of power-up reveal sound
00D5CE  2  D0 02                bne GrowItemRegs
00D5D0  2               
00D5D0  2               PlayGrowVine:
00D5D0  2  A9 20                lda #$20                ;load length of vine grow sound
00D5D2  2               
00D5D2  2               GrowItemRegs:
00D5D2  2  8D BD 07             sta Squ2_SfxLenCounter
00D5D5  2  A9 7F                lda #$7f                  ;load contents of reg for both sounds directly
00D5D7  2  8D 05 40             sta SND_SQUARE2_REG+1
00D5DA  2  A9 00                lda #$00                  ;start secondary counter for both sounds
00D5DC  2  8D BE 07             sta Sfx_SecondaryCounter
00D5DF  2               
00D5DF  2               ContinueGrowItems:
00D5DF  2  EE BE 07             inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
00D5E2  2  AD BE 07             lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
00D5E5  2  4A                   lsr                       ;divide by 2 to get the offset
00D5E6  2  A8                   tay
00D5E7  2  CC BD 07             cpy Squ2_SfxLenCounter    ;have we reached the end yet?
00D5EA  2  F0 0C                beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
00D5EC  2  A9 9D                lda #$9d                  ;load contents of other reg directly
00D5EE  2  8D 04 40             sta SND_SQUARE2_REG
00D5F1  2  B9 C8 D4             lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
00D5F4  2  20 79 D3             jsr SetFreq_Squ2
00D5F7  2  60                   rts
00D5F8  2               
00D5F8  2               StopGrowItems:
00D5F8  2  4C 3D D5             jmp EmptySfx2Buffer       ;branch to stop playing sounds
00D5FB  2               
00D5FB  2               WindFreqEnvData:
00D5FB  2  37 46 55 64          .byte $37, $46, $55, $64, $74, $83, $93, $a2
00D5FF  2  74 83 93 A2  
00D603  2  B1 C0 D0 E0          .byte $b1, $c0, $d0, $e0, $f1, $f1, $f2, $e2
00D607  2  F1 F1 F2 E2  
00D60B  2  E2 C3 A3 84          .byte $e2, $c3, $a3, $84, $64, $44, $35, $25
00D60F  2  64 44 35 25  
00D613  2               
00D613  2               BrickShatterFreqData:
00D613  2  01 0E 0E 0D          .byte $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
00D617  2  0B 06 0C 0F  
00D61B  2  0A 09 03 0D          .byte $0a, $09, $03, $0d, $08, $0d, $06, $0c
00D61F  2  08 0D 06 0C  
00D623  2               
00D623  2               SkidSfxFreqData:
00D623  2  47 49 42 4A          .byte $47, $49, $42, $4a, $43, $4b
00D627  2  43 4B        
00D629  2               
00D629  2               PlaySkidSfx:
00D629  2  84 F3                sty NoiseSoundBuffer
00D62B  2  A9 06                lda #$06
00D62D  2  8D BF 07             sta Noise_SfxLenCounter
00D630  2               
00D630  2               ContinueSkidSfx:
00D630  2  AD BF 07             lda Noise_SfxLenCounter
00D633  2  A8                   tay
00D634  2  B9 22 D6             lda SkidSfxFreqData-1,y
00D637  2  8D 0A 40             sta SND_TRIANGLE_REG+2
00D63A  2  A9 18                lda #$18
00D63C  2  8D 08 40             sta SND_TRIANGLE_REG
00D63F  2  8D 0B 40             sta SND_TRIANGLE_REG+3
00D642  2  D0 1F                bne DecrementSfx3Length
00D644  2               
00D644  2               PlayBrickShatter:
00D644  2  84 F3                sty NoiseSoundBuffer
00D646  2  A9 20                lda #$20                 ;load length of brick shatter sound
00D648  2  8D BF 07             sta Noise_SfxLenCounter
00D64B  2               
00D64B  2               ContinueBrickShatter:
00D64B  2  AD BF 07             lda Noise_SfxLenCounter
00D64E  2  4A                   lsr                         ;divide by 2 and check for bit set to use offset
00D64F  2  90 12                bcc DecrementSfx3Length
00D651  2  A8                   tay
00D652  2  BE 13 D6             ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
00D655  2  B9 EA DF             lda BrickShatterEnvData,y
00D658  2               
00D658  2               PlayNoiseSfx:
00D658  2  8D 0C 40             sta SND_NOISE_REG        ;play the sfx
00D65B  2  8E 0E 40             stx SND_NOISE_REG+2
00D65E  2  A9 18                lda #$18
00D660  2  8D 0F 40             sta SND_NOISE_REG+3
00D663  2               
00D663  2               DecrementSfx3Length:
00D663  2  CE BF 07             dec Noise_SfxLenCounter  ;decrement length of sfx
00D666  2  D0 0E                bne ExSfx3
00D668  2  A9 F0                lda #$f0                 ;if done, stop playing the sfx
00D66A  2  8D 0C 40             sta SND_NOISE_REG
00D66D  2  A9 00                lda #$00
00D66F  2  8D 08 40             sta SND_TRIANGLE_REG
00D672  2  A9 00                lda #$00
00D674  2  85 F3                sta NoiseSoundBuffer
00D676  2  60           ExSfx3: rts
00D677  2               
00D677  2               NoiseSfxHandler:
00D677  2  A5 F3                lda NoiseSoundBuffer
00D679  2  30 B5                bmi ContinueSkidSfx
00D67B  2  A4 FD                ldy NoiseSoundQueue
00D67D  2  30 AA                bmi PlaySkidSfx
00D67F  2  46 FD                lsr NoiseSoundQueue
00D681  2  B0 C1                bcs PlayBrickShatter
00D683  2  4A                   lsr
00D684  2  B0 C5                bcs ContinueBrickShatter
00D686  2  46 FD                lsr NoiseSoundQueue
00D688  2  B0 0B                bcs PlayBowserFlame
00D68A  2  4A                   lsr
00D68B  2  B0 0F                bcs ContinueBowserFlame
00D68D  2  4A                   lsr
00D68E  2  B0 1F                bcs ContinueWindSfx
00D690  2  46 FD                lsr NoiseSoundQueue
00D692  2  B0 14                bcs PlayWindSfx
00D694  2  60                   rts
00D695  2               
00D695  2               PlayBowserFlame:
00D695  2  84 F3                sty NoiseSoundBuffer
00D697  2  A9 40                lda #$40                    ;load length of bowser flame sound
00D699  2  8D BF 07             sta Noise_SfxLenCounter
00D69C  2               
00D69C  2               ContinueBowserFlame:
00D69C  2  AD BF 07             lda Noise_SfxLenCounter
00D69F  2  4A                   lsr
00D6A0  2  A8                   tay
00D6A1  2  A2 0F                ldx #$0f                    ;load reg contents of bowser flame sound
00D6A3  2  B9 C9 DF             lda BowserFlameEnvData-1,y
00D6A6  2               WindBranch:
00D6A6  2  D0 B0                bne PlayNoiseSfx            ;unconditional branch here
00D6A8  2               
00D6A8  2               PlayWindSfx:
00D6A8  2  84 F3                sty NoiseSoundBuffer
00D6AA  2  A9 C0                lda #$c0
00D6AC  2  8D BF 07             sta Noise_SfxLenCounter
00D6AF  2               ContinueWindSfx:
00D6AF  2  46 FD                lsr NoiseSoundQueue         ;get bit for the wind sfx, note that it must
00D6B1  2  90 C3                bcc ExSfx3                  ;be continuously set in order for it to play
00D6B3  2  AD BF 07             lda Noise_SfxLenCounter
00D6B6  2  4A                   lsr
00D6B7  2  4A                   lsr                         ;divide length counter by 8
00D6B8  2  4A                   lsr
00D6B9  2  A8                   tay
00D6BA  2  B9 FB D5             lda WindFreqEnvData,y
00D6BD  2  29 0F                and #$0f                    ;use lower nybble as frequency data
00D6BF  2  09 10                ora #$10
00D6C1  2  AA                   tax
00D6C2  2  B9 FB D5             lda WindFreqEnvData,y       ;use upper nybble as envelope data
00D6C5  2  4A                   lsr
00D6C6  2  4A                   lsr
00D6C7  2  4A                   lsr
00D6C8  2  4A                   lsr
00D6C9  2  09 10                ora #$10
00D6CB  2  D0 D9                bne WindBranch              ;unconditional branch
00D6CD  2               
00D6CD  2               ;--------------------------------
00D6CD  2               
00D6CD  2               ContinueMusic:
00D6CD  2  4C 76 D7             jmp HandleSquare2Music  ;if we have music, start with square 2 channel
00D6D0  2               
00D6D0  2               MusicHandler:
00D6D0  2  A5 FC                lda EventMusicQueue     ;check event music queue
00D6D2  2  D0 0C                bne LoadEventMusic
00D6D4  2  A5 FB                lda AreaMusicQueue      ;check area music queue
00D6D6  2  D0 2C                bne LoadAreaMusic
00D6D8  2  AD B1 07             lda EventMusicBuffer    ;check both buffers
00D6DB  2  05 F4                ora AreaMusicBuffer
00D6DD  2  D0 EE                bne ContinueMusic
00D6DF  2  60                   rts                     ;no music, then leave
00D6E0  2               
00D6E0  2               LoadEventMusic:
00D6E0  2  8D B1 07                sta EventMusicBuffer      ;copy event music queue contents to buffer
00D6E3  2  C9 01                   cmp #DeathMusic           ;is it death music?
00D6E5  2  D0 06                   bne NoStopSfx             ;if not, jump elsewhere
00D6E7  2  20 77 D4                jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
00D6EA  2  20 41 D5                jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
00D6ED  2  A6 F4        NoStopSfx: ldx AreaMusicBuffer
00D6EF  2  8E C5 07                stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
00D6F2  2  A0 00                   ldy #$00
00D6F4  2  8C C4 07                sty NoteLengthTblAdder    ;default value for additional length byte offset
00D6F7  2  84 F4                   sty AreaMusicBuffer       ;clear area music buffer
00D6F9  2  C9 40                   cmp #TimeRunningOutMusic  ;is it time running out music?
00D6FB  2  D0 30                   bne FindEventMusicHeader
00D6FD  2  A2 08                   ldx #$08                  ;load offset to be added to length byte of header
00D6FF  2  8E C4 07                stx NoteLengthTblAdder
00D702  2  D0 29                   bne FindEventMusicHeader  ;unconditional branch
00D704  2               
00D704  2               LoadAreaMusic:
00D704  2  C9 04                 cmp #$04                  ;is it underground music?
00D706  2  D0 03                 bne NoStop1               ;no, do not stop square 1 sfx
00D708  2  20 77 D4              jsr StopSquare1Sfx
00D70B  2  A0 10        NoStop1: ldy #$10                  ;start counter used only by ground level music
00D70D  2  8C C7 07     GMLoopB: sty GroundMusicHeaderOfs
00D710  2               
00D710  2               HandleAreaMusicLoopB:
00D710  2  A0 00                 ldy #$00                  ;clear event music buffer
00D712  2  8C B1 07              sty EventMusicBuffer
00D715  2  85 F4                 sta AreaMusicBuffer       ;copy area music queue contents to buffer
00D717  2  C9 01                 cmp #$01                  ;is it ground level music?
00D719  2  D0 0E                 bne FindAreaMusicHeader
00D71B  2  EE C7 07              inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
00D71E  2  AC C7 07              ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
00D721  2  C0 32                 cpy #$32
00D723  2  D0 0C                 bne LoadHeader            ;branch ahead with alternate offset
00D725  2  A0 11                 ldy #$11
00D727  2  D0 E4                 bne GMLoopB               ;unconditional branch
00D729  2               
00D729  2               FindAreaMusicHeader:
00D729  2  A0 08                ldy #$08                   ;load Y for offset of area music
00D72B  2  84 F7                sty MusicOffset_Square2    ;residual instruction here
00D72D  2               
00D72D  2               FindEventMusicHeader:
00D72D  2  C8                   iny                       ;increment Y pointer based on previously loaded queue contents
00D72E  2  4A                   lsr                       ;bit shift and increment until we find a set bit for music
00D72F  2  90 FC                bcc FindEventMusicHeader
00D731  2               
00D731  2               LoadHeader:
00D731  2  B9 48 D9             lda MusicHeaderOffsetData,y  ;load offset for header
00D734  2  A8                   tay
00D735  2  B9 49 D9             lda MusicHeaderData,y        ;now load the header
00D738  2  85 F0                sta NoteLenLookupTblOfs
00D73A  2  B9 4A D9             lda MusicHeaderData+1,y
00D73D  2  85 F5                sta MusicDataLow
00D73F  2  B9 4B D9             lda MusicHeaderData+2,y
00D742  2  85 F6                sta MusicDataHigh
00D744  2  B9 4C D9             lda MusicHeaderData+3,y
00D747  2  85 F9                sta MusicOffset_Triangle
00D749  2  B9 4D D9             lda MusicHeaderData+4,y
00D74C  2  85 F8                sta MusicOffset_Square1
00D74E  2  B9 4E D9             lda MusicHeaderData+5,y
00D751  2  8D B0 07             sta MusicOffset_Noise
00D754  2  8D C1 07             sta NoiseDataLoopbackOfs
00D757  2  A9 01                lda #$01                     ;initialize music note counters
00D759  2  8D B4 07             sta Squ2_NoteLenCounter
00D75C  2  8D B6 07             sta Squ1_NoteLenCounter
00D75F  2  8D B9 07             sta Tri_NoteLenCounter
00D762  2  8D BA 07             sta Noise_BeatLenCounter
00D765  2  A9 00                lda #$00                     ;initialize music data offset for square 2
00D767  2  85 F7                sta MusicOffset_Square2
00D769  2  8D CA 07             sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
00D76C  2  A9 0B                lda #$0b                     ;disable triangle channel and reenable it
00D76E  2  8D 15 40             sta SND_MASTERCTRL_REG
00D771  2  A9 0F                lda #$0f
00D773  2  8D 15 40             sta SND_MASTERCTRL_REG
00D776  2               
00D776  2               HandleSquare2Music:
00D776  2  CE B4 07             dec Squ2_NoteLenCounter  ;decrement square 2 note length
00D779  2  D0 5F                bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
00D77B  2  A4 F7                ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
00D77D  2  E6 F7                inc MusicOffset_Square2
00D77F  2  B1 F5                lda (MusicData),y
00D781  2  F0 04                beq EndOfMusicData       ;if zero, the data is a null terminator
00D783  2  10 3D                bpl Squ2NoteHandler      ;if non-negative, data is a note
00D785  2  D0 2F                bne Squ2LengthHandler    ;otherwise it is length data
00D787  2               
00D787  2               EndOfMusicData:
00D787  2  AD B1 07             lda EventMusicBuffer     ;check secondary buffer for time running out music
00D78A  2  C9 40                cmp #TimeRunningOutMusic
00D78C  2  D0 05                bne NotTRO
00D78E  2  AD C5 07             lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
00D791  2  D0 1D                bne MusicLoopBack        ;and start playing the song again if there is one
00D793  2  29 04        NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
00D795  2  D0 1C                bne VictoryMLoopBack
00D797  2  A5 F4                lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
00D799  2  29 5F                and #%01011111
00D79B  2  D0 13                bne MusicLoopBack        ;if any area music except pipe intro, music loops
00D79D  2  A9 00                lda #$00                 ;clear primary and secondary buffers and initialize
00D79F  2  85 F4                sta AreaMusicBuffer      ;control regs of square and triangle channels
00D7A1  2  8D B1 07             sta EventMusicBuffer
00D7A4  2  8D 08 40             sta SND_TRIANGLE_REG
00D7A7  2  A9 90                lda #$90
00D7A9  2  8D 00 40             sta SND_SQUARE1_REG
00D7AC  2  8D 04 40             sta SND_SQUARE2_REG
00D7AF  2  60                   rts
00D7B0  2               
00D7B0  2               MusicLoopBack:
00D7B0  2  4C 10 D7             jmp HandleAreaMusicLoopB
00D7B3  2               
00D7B3  2               VictoryMLoopBack:
00D7B3  2  4C E0 D6             jmp LoadEventMusic
00D7B6  2               
00D7B6  2               Squ2LengthHandler:
00D7B6  2  20 07 D9             jsr ProcessLengthData    ;store length of note
00D7B9  2  8D B3 07             sta Squ2_NoteLenBuffer
00D7BC  2  A4 F7                ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00D7BE  2  E6 F7                inc MusicOffset_Square2
00D7C0  2  B1 F5                lda (MusicData),y
00D7C2  2               
00D7C2  2               Squ2NoteHandler:
00D7C2  2  A6 F2                  ldx Square2SoundBuffer     ;is there a sound playing on this channel?
00D7C4  2  D0 0E                  bne SkipFqL1
00D7C6  2  20 79 D3               jsr SetFreq_Squ2           ;no, then play the note
00D7C9  2  F0 03                  beq Rest                   ;check to see if note is rest
00D7CB  2  20 14 D9               jsr LoadControlRegs        ;if not, load control regs for square 2
00D7CE  2  8D B5 07     Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
00D7D1  2  20 6F D3               jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
00D7D4  2  AD B3 07     SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
00D7D7  2  8D B4 07               sta Squ2_NoteLenCounter
00D7DA  2               
00D7DA  2               MiscSqu2MusicTasks:
00D7DA  2  A5 F2                   lda Square2SoundBuffer     ;is there a sound playing on square 2?
00D7DC  2  D0 1A                   bne HandleSquare1Music
00D7DE  2  AD B1 07                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00D7E1  2  29 91                   and #%10010001             ;note that regs for death music or d4 are loaded by default
00D7E3  2  D0 13                   bne HandleSquare1Music
00D7E5  2  AC B5 07                ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
00D7E8  2  F0 03                   beq NoDecEnv1
00D7EA  2  CE B5 07                dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
00D7ED  2  20 30 D9     NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
00D7F0  2  8D 04 40                sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
00D7F3  2  A2 7F                   ldx #$7f                   ;death music or d4 set on secondary buffer
00D7F5  2  8E 05 40                stx SND_SQUARE2_REG+1
00D7F8  2               
00D7F8  2               HandleSquare1Music:
00D7F8  2  A4 F8                ldy MusicOffset_Square1    ;is there a nonzero offset here?
00D7FA  2  F0 5A                beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
00D7FC  2  CE B6 07             dec Squ1_NoteLenCounter    ;decrement square 1 note length
00D7FF  2  D0 32                bne MiscSqu1MusicTasks     ;is it time for more data?
00D801  2               
00D801  2               FetchSqu1MusicData:
00D801  2  A4 F8                ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
00D803  2  E6 F8                inc MusicOffset_Square1
00D805  2  B1 F5                lda (MusicData),y
00D807  2  D0 0F                bne Squ1NoteHandler        ;if nonzero, then skip this part
00D809  2  A9 83                lda #$83
00D80B  2  8D 00 40             sta SND_SQUARE1_REG        ;store some data into control regs for square 1
00D80E  2  A9 94                lda #$94                   ;and fetch another byte of data, used to give
00D810  2  8D 01 40             sta SND_SQUARE1_REG+1      ;death music its unique sound
00D813  2  8D CA 07             sta AltRegContentFlag
00D816  2  D0 E9                bne FetchSqu1MusicData     ;unconditional branch
00D818  2               
00D818  2               Squ1NoteHandler:
00D818  2  20 01 D9                jsr AlternateLengthHandler
00D81B  2  8D B6 07                sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
00D81E  2  A4 F1                   ldy Square1SoundBuffer     ;is there a sound playing on square 1?
00D820  2  D0 34                   bne HandleTriangleMusic
00D822  2  8A                      txa
00D823  2  29 3E                   and #%00111110             ;change saved data to appropriate note format
00D825  2  20 5B D3                jsr SetFreq_Squ1           ;play the note
00D828  2  F0 03                   beq SkipCtrlL
00D82A  2  20 14 D9                jsr LoadControlRegs
00D82D  2  8D B7 07     SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
00D830  2  20 51 D3                jsr Dump_Squ1_Regs
00D833  2               
00D833  2               MiscSqu1MusicTasks:
00D833  2  A5 F1                      lda Square1SoundBuffer     ;is there a sound playing on square 1?
00D835  2  D0 1F                      bne HandleTriangleMusic
00D837  2  AD B1 07                   lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00D83A  2  29 91                      and #%10010001
00D83C  2  D0 0E                      bne DeathMAltReg
00D83E  2  AC B7 07                   ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
00D841  2  F0 03                      beq NoDecEnv2
00D843  2  CE B7 07                   dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
00D846  2  20 30 D9     NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
00D849  2  8D 00 40                   sta SND_SQUARE1_REG        ;based on offset set by first load
00D84C  2  AD CA 07     DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
00D84F  2  D0 02                      bne DoAltLoad
00D851  2  A9 7F                      lda #$7f                   ;load this value if zero, the alternate value
00D853  2  8D 01 40     DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
00D856  2               
00D856  2               HandleTriangleMusic:
00D856  2  A5 F9                lda MusicOffset_Triangle
00D858  2  CE B9 07             dec Tri_NoteLenCounter    ;decrement triangle note length
00D85B  2  D0 4C                bne HandleNoiseMusic      ;is it time for more data?
00D85D  2  A4 F9                ldy MusicOffset_Triangle  ;increment triangle music offset and fetch data
00D85F  2  E6 F9                inc MusicOffset_Triangle
00D861  2  B1 F5                lda (MusicData),y
00D863  2  F0 41                beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
00D865  2  10 13                bpl TriNoteHandler        ;if non-negative, data is note
00D867  2  20 07 D9             jsr ProcessLengthData     ;otherwise, it is length data
00D86A  2  8D B8 07             sta Tri_NoteLenBuffer     ;save contents of A
00D86D  2  A9 1F                lda #$1f
00D86F  2  8D 08 40             sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
00D872  2  A4 F9                ldy MusicOffset_Triangle  ;fetch another byte
00D874  2  E6 F9                inc MusicOffset_Triangle
00D876  2  B1 F5                lda (MusicData),y
00D878  2  F0 2C                beq LoadTriCtrlReg        ;check once more for nonzero data
00D87A  2               
00D87A  2               TriNoteHandler:
00D87A  2  20 7D D3               jsr SetFreq_Tri
00D87D  2  AE B8 07               ldx Tri_NoteLenBuffer   ;save length in triangle note counter
00D880  2  8E B9 07               stx Tri_NoteLenCounter
00D883  2  AD B1 07               lda EventMusicBuffer
00D886  2  29 6E                  and #%01101110          ;check for death music or d4 set on secondary buffer
00D888  2  D0 06                  bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
00D88A  2  A5 F4                  lda AreaMusicBuffer     ;check primary buffer for water or castle level music
00D88C  2  29 0A                  and #%00001010
00D88E  2  F0 19                  beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
00D890  2  8A           NotDOrD4: txa                     ;if playing water or castle music or any secondary
00D891  2  C9 12                  cmp #$12                ;besides death music or d4 set, check length of note
00D893  2  B0 0F                  bcs LongN
00D895  2  AD B1 07               lda EventMusicBuffer    ;check for win castle music again if not playing a long note
00D898  2  29 08                  and #EndOfCastleMusic
00D89A  2  F0 04                  beq MediN
00D89C  2  A9 0F                  lda #$0f                ;load value $0f if playing the win castle music and playing a short
00D89E  2  D0 06                  bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
00D8A0  2  A9 1F        MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
00D8A2  2  D0 02                  bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
00D8A4  2  A9 FF        LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
00D8A6  2               
00D8A6  2               LoadTriCtrlReg:
00D8A6  2  8D 08 40             sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
00D8A9  2               
00D8A9  2               HandleNoiseMusic:
00D8A9  2  A5 F4                lda AreaMusicBuffer       ;check if playing underground or castle music
00D8AB  2  29 F3                and #%11110011
00D8AD  2  F0 51                beq ExitMusicHandler      ;if so, skip the noise routine
00D8AF  2  CE BA 07             dec Noise_BeatLenCounter  ;decrement noise beat length
00D8B2  2  D0 4C                bne ExitMusicHandler      ;is it time for more data?
00D8B4  2               
00D8B4  2               FetchNoiseBeatData:
00D8B4  2  AC B0 07             ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
00D8B7  2  EE B0 07             inc MusicOffset_Noise
00D8BA  2  B1 F5                lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
00D8BC  2  D0 08                bne NoiseBeatHandler
00D8BE  2  AD C1 07             lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
00D8C1  2  8D B0 07             sta MusicOffset_Noise       ;and loopback next time around
00D8C4  2  D0 EE                bne FetchNoiseBeatData      ;unconditional branch
00D8C6  2               
00D8C6  2               NoiseBeatHandler:
00D8C6  2  20 01 D9             jsr AlternateLengthHandler
00D8C9  2  8D BA 07             sta Noise_BeatLenCounter    ;store length in noise beat counter
00D8CC  2  8A                   txa
00D8CD  2  29 3E                and #%00111110              ;reload data and erase length bits
00D8CF  2  F0 24                beq SilentBeat              ;if no beat data, silence
00D8D1  2  C9 30                cmp #$30                    ;check the beat data and play the appropriate
00D8D3  2  F0 18                beq LongBeat                ;noise accordingly
00D8D5  2  C9 20                cmp #$20
00D8D7  2  F0 0C                beq StrongBeat
00D8D9  2  29 10                and #%00010000
00D8DB  2  F0 18                beq SilentBeat
00D8DD  2  A9 1C                lda #$1c        ;short beat data
00D8DF  2  A2 03                ldx #$03
00D8E1  2  A0 18                ldy #$18
00D8E3  2  D0 12                bne PlayBeat
00D8E5  2               
00D8E5  2               StrongBeat:
00D8E5  2  A9 1C                lda #$1c        ;strong beat data
00D8E7  2  A2 0C                ldx #$0c
00D8E9  2  A0 18                ldy #$18
00D8EB  2  D0 0A                bne PlayBeat
00D8ED  2               
00D8ED  2               LongBeat:
00D8ED  2  A9 1C                lda #$1c        ;long beat data
00D8EF  2  A2 03                ldx #$03
00D8F1  2  A0 58                ldy #$58
00D8F3  2  D0 02                bne PlayBeat
00D8F5  2               
00D8F5  2               SilentBeat:
00D8F5  2  A9 10                lda #$10        ;silence
00D8F7  2               
00D8F7  2               PlayBeat:
00D8F7  2  8D 0C 40             sta SND_NOISE_REG    ;load beat data into noise regs
00D8FA  2  8E 0E 40             stx SND_NOISE_REG+2
00D8FD  2  8C 0F 40             sty SND_NOISE_REG+3
00D900  2               
00D900  2               ExitMusicHandler:
00D900  2  60                   rts
00D901  2               
00D901  2               AlternateLengthHandler:
00D901  2  AA                   tax            ;save a copy of original byte into X
00D902  2  6A                   ror            ;save LSB from original byte into carry
00D903  2  8A                   txa            ;reload original byte and rotate three times
00D904  2  2A                   rol            ;turning xx00000x into 00000xxx, with the
00D905  2  2A                   rol            ;bit in carry as the MSB here
00D906  2  2A                   rol
00D907  2               
00D907  2               ProcessLengthData:
00D907  2  29 07                and #%00000111              ;clear all but the three LSBs
00D909  2  18                   clc
00D90A  2  65 F0                adc NoteLenLookupTblOfs     ;add offset loaded from first header byte
00D90C  2  6D C4 07             adc NoteLengthTblAdder      ;add extra if time running out music
00D90F  2  A8                   tay
00D910  2  B9 66 DF             lda MusicLengthLookupTbl,y  ;load length
00D913  2  60                   rts
00D914  2               
00D914  2               LoadControlRegs:
00D914  2  AD B1 07                lda EventMusicBuffer  ;check secondary buffer for win castle music
00D917  2  29 08                   and #EndOfCastleMusic
00D919  2  F0 04                   beq NotECstlM
00D91B  2  A9 04                   lda #$04              ;this value is only used for win castle music
00D91D  2  D0 0C                   bne AllMus            ;unconditional branch
00D91F  2  A5 F4        NotECstlM: lda AreaMusicBuffer
00D921  2  29 7D                   and #%01111101        ;check primary buffer for water music
00D923  2  F0 04                   beq WaterMus
00D925  2  A9 08                   lda #$08              ;this is the default value for all other music
00D927  2  D0 02                   bne AllMus
00D929  2  A9 28        WaterMus:  lda #$28              ;this value is used for water music and all other event music
00D92B  2  A2 82        AllMus:    ldx #$82              ;load contents of other sound regs for square 2
00D92D  2  A0 7F                   ldy #$7f
00D92F  2  60                      rts
00D930  2               
00D930  2               LoadEnvelopeData:
00D930  2  AD B1 07             lda EventMusicBuffer           ;check secondary buffer for win castle music
00D933  2  29 08                and #EndOfCastleMusic
00D935  2  F0 04                beq LoadUsualEnvData
00D937  2  B9 96 DF             lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
00D93A  2  60                   rts
00D93B  2               
00D93B  2               LoadUsualEnvData:
00D93B  2  A5 F4                lda AreaMusicBuffer            ;check primary buffer for water music
00D93D  2  29 7D                and #%01111101
00D93F  2  F0 04                beq LoadWaterEventMusEnvData
00D941  2  B9 9A DF             lda AreaMusicEnvData,y         ;load default data from offset for all other music
00D944  2  60                   rts
00D945  2               
00D945  2               LoadWaterEventMusEnvData:
00D945  2  B9 A2 DF             lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
00D948  2  60                   rts
00D949  2               
00D949  2               MusicHeaderData:
00D949  2  A0             .byte DeathMusHdr-MHD
00D94A  2  54             .byte GameOverMusHdr-MHD
00D94B  2  54             .byte GameOverMusHdr-MHD
00D94C  2  5F             .byte WinCastleMusHdr-MHD
00D94D  2  54             .byte GameOverMusHdr-MHD
00D94E  2  3C             .byte EndOfLevelMusHdr-MHD
00D94F  2  31             .byte TimeRunningOutHdr-MHD
00D950  2  4B             .byte SilenceHdr-MHD
00D951  2               
00D951  2  64             .byte GroundLevelPart1Hdr-MHD   ;area music
00D952  2  59             .byte WaterMusHdr-MHD
00D953  2  46             .byte UndergroundMusHdr-MHD
00D954  2  4F             .byte CastleMusHdr-MHD
00D955  2  36             .byte Star_CloudHdr-MHD
00D956  2  88             .byte GroundLevelLeadInHdr-MHD
00D957  2  36             .byte Star_CloudHdr-MHD
00D958  2  4B             .byte SilenceHdr-MHD
00D959  2               
00D959  2  88             .byte GroundLevelLeadInHdr-MHD  ;ground level music layout
00D95A  2  64 64          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00D95C  2  6A 70 6A 76    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00D960  2  6A 70 6A 76    .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00D964  2  7C 82 7C 88    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00D968  2  64 64          .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00D96A  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D96E  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D972  2  7C 82 7C 88    .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00D976  2  8E 94 8E 9A    .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00D97A  2               
00D97A  2               ;music headers
00D97A  2               ;header format is as follows:
00D97A  2               ;1 byte - length byte offset
00D97A  2               ;2 bytes -  music data address
00D97A  2               ;1 byte - triangle data offset
00D97A  2               ;1 byte - square 1 data offset
00D97A  2               ;1 byte - noise data offset (not used by secondary music)
00D97A  2               
00D97A  2  08 A9 DC 27  TimeRunningOutHdr:     .byte $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
00D97E  2  18           
00D97F  2  20 EF D9 2E  Star_CloudHdr:         .byte $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
00D983  2  1A 40        
00D985  2  20 E7 DC 3D  EndOfLevelMusHdr:      .byte $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
00D989  2  21           
00D98A  2  20 FB DC 3F  ResidualHeaderData:    .byte $20, $fb, $dc, $3f, $1d
00D98E  2  1D           
00D98F  2  18 48 DD 00  UndergroundMusHdr:     .byte $18, <UndergroundMusData, >UndergroundMusData, $00, $00
00D993  2  00           
00D994  2  08 53 DA 00  SilenceHdr:            .byte $08, <SilenceData, >SilenceData, $00
00D998  2  00 DB DB 93  CastleMusHdr:          .byte $00, <CastleMusData, >CastleMusData, $93, $62
00D99C  2  62           
00D99D  2  18 7C DC 1E  GameOverMusHdr:        .byte $18, <GameOverMusData, >GameOverMusData, $1e, $14
00D9A1  2  14           
00D9A2  2  08 89 DD A0  WaterMusHdr:           .byte $08, <WaterMusData, >WaterMusData, $a0, $70, $68
00D9A6  2  70 68        
00D9A8  2  08 88 DE 4C  WinCastleMusHdr:       .byte $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
00D9AC  2  24           
00D9AD  2  18 38 DA 2D  GroundLevelPart1Hdr:   .byte $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
00D9B1  2  1C B8        
00D9B3  2  18 80 DA 20  GroundLevelPart2AHdr:  .byte $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
00D9B7  2  12 70        
00D9B9  2  18 AC DA 1B  GroundLevelPart2BHdr:  .byte $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
00D9BD  2  10 44        
00D9BF  2  18 D4 DA 11  GroundLevelPart2CHdr:  .byte $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
00D9C3  2  0A 1C        
00D9C5  2  18 F9 DA 2D  GroundLevelPart3AHdr:  .byte $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
00D9C9  2  10 58        
00D9CB  2  18 12 DB 14  GroundLevelPart3BHdr:  .byte $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
00D9CF  2  0D 3F        
00D9D1  2  18 30 DB 15  GroundLevelLeadInHdr:  .byte $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
00D9D5  2  0D 21        
00D9D7  2  18 5C DB 18  GroundLevelPart4AHdr:  .byte $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
00D9DB  2  10 7A        
00D9DD  2  18 82 DB 19  GroundLevelPart4BHdr:  .byte $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
00D9E1  2  0F 54        
00D9E3  2  18 AB DB 1E  GroundLevelPart4CHdr:  .byte $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
00D9E7  2  12 2B        
00D9E9  2  18 A9 DB 1E  DeathMusHdr:           .byte $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
00D9ED  2  0F 2D        
00D9EF  2               
00D9EF  2               ;--------------------------------
00D9EF  2               
00D9EF  2               ;MUSIC DATA
00D9EF  2               ;square 2/triangle format
00D9EF  2               ;d7 - length byte flag (0-note, 1-length)
00D9EF  2               ;if d7 is set to 0 and d6-d0 is nonzero:
00D9EF  2               ;d6-d0 - note offset in frequency look-up table (must be even)
00D9EF  2               ;if d7 is set to 1:
00D9EF  2               ;d6-d3 - unused
00D9EF  2               ;d2-d0 - length offset in length look-up table
00D9EF  2               ;value of $00 in square 2 data is used as null terminator, affects all sound channels
00D9EF  2               ;value of $00 in triangle data causes routine to skip note
00D9EF  2               
00D9EF  2               ;square 1 format
00D9EF  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00D9EF  2               ;d5-d1 - note offset in frequency look-up table
00D9EF  2               ;value of $00 in square 1 data is flag alternate control reg data to be loaded
00D9EF  2               
00D9EF  2               ;noise format
00D9EF  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00D9EF  2               ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
00D9EF  2               ;d3-d1 - unused
00D9EF  2               ;value of $00 in noise data is used as null terminator, affects only noise
00D9EF  2               
00D9EF  2               ;all music data is organized into sections (unless otherwise stated):
00D9EF  2               ;square 2, square 1, triangle, noise
00D9EF  2               
00D9EF  2               Star_CloudMData:
00D9EF  2  84 2C 2C 2C        .byte $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
00D9F3  2  82 04 2C 04  
00D9F7  2  85 2C 84 2C  
00D9FC  2  2A 2A 2A 82        .byte $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
00DA00  2  04 2A 04 85  
00DA04  2  2A 84 2A 2A  
00DA09  2               
00DA09  2  1F 1F 1F 98        .byte $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
00DA0D  2  1F 1F 98 9E  
00DA11  2  98 1F        
00DA13  2  1D 1D 1D 94        .byte $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
00DA17  2  1D 1D 94 9C  
00DA1B  2  94 1D        
00DA1D  2               
00DA1D  2  86 18 85 26        .byte $86, $18, $85, $26, $30, $84, $04, $26, $30
00DA21  2  30 84 04 26  
00DA25  2  30           
00DA26  2  86 14 85 22        .byte $86, $14, $85, $22, $2c, $84, $04, $22, $2c
00DA2A  2  2C 84 04 22  
00DA2E  2  2C           
00DA2F  2               
00DA2F  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00DA33  2  31 D0 C4 D0  
00DA37  2  00           
00DA38  2               
00DA38  2               GroundM_P1Data:
00DA38  2  85 2C 22 1C        .byte $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
00DA3C  2  84 26 2A 82  
00DA40  2  28 26 04     
00DA43  2  87 22 34 3A        .byte $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
00DA47  2  82 40 04 36  
00DA4B  2  84 3A 34     
00DA4E  2  82 2C 30 85        .byte $82, $2c, $30, $85, $2a
00DA52  2  2A           
00DA53  2               
00DA53  2               SilenceData:
00DA53  2  00                 .byte $00
00DA54  2               
00DA54  2  5D 55 4D 15        .byte $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
00DA58  2  19 96 15 D5  
00DA5C  2  E3 EB        
00DA5E  2  2D A6 2B 27        .byte $2d, $a6, $2b, $27, $9c, $9e, $59
00DA62  2  9C 9E 59     
00DA65  2               
00DA65  2  85 22 1C 14        .byte $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
00DA69  2  84 1E 22 82  
00DA6D  2  20 1E 04 87  
00DA71  2  1C 2C 34 82        .byte $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
00DA75  2  36 04 30 34  
00DA79  2  04 2C 04 26  
00DA7D  2  2A 85 22           .byte $2a, $85, $22
00DA80  2               
00DA80  2               GroundM_P2AData:
00DA80  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00DA84  2  38 36 32 04  
00DA88  2  34           
00DA89  2  04 24 26 2C        .byte $04, $24, $26, $2c, $04, $26, $2c, $30, $00
00DA8D  2  04 26 2C 30  
00DA91  2  00           
00DA92  2               
00DA92  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00DA96  2  2B AC 84     
00DA99  2  9C 9E A2 84        .byte $9c, $9e, $a2, $84, $94, $9c, $9e
00DA9D  2  94 9C 9E     
00DAA0  2               
00DAA0  2  85 14 22 84        .byte $85, $14, $22, $84, $2c, $85, $1e
00DAA4  2  2C 85 1E     
00DAA7  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $1e
00DAAB  2  1E           
00DAAC  2               
00DAAC  2               GroundM_P2BData:
00DAAC  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00DAB0  2  38 36 32 04  
00DAB4  2  34           
00DAB5  2  04 64 04 64        .byte $04, $64, $04, $64, $86, $64, $00
00DAB9  2  86 64 00     
00DABC  2               
00DABC  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00DAC0  2  2B AC 84     
00DAC3  2  37 B6 B6 45        .byte $37, $b6, $b6, $45
00DAC7  2               
00DAC7  2  85 14 1C 82        .byte $85, $14, $1c, $82, $22, $84, $2c
00DACB  2  22 84 2C     
00DACE  2  4E 82 4E 84        .byte $4e, $82, $4e, $84, $4e, $22
00DAD2  2  4E 22        
00DAD4  2               
00DAD4  2               GroundM_P2CData:
00DAD4  2  84 04 85 32        .byte $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
00DAD8  2  85 30 86 2C  
00DADC  2  04 00        
00DADE  2               
00DADE  2  05 A4 05 9E        .byte $05, $a4, $05, $9e, $05, $9d, $85
00DAE2  2  05 9D 85     
00DAE5  2               
00DAE5  2  84 14 85 24        .byte $84, $14, $85, $24, $28, $2c, $82
00DAE9  2  28 2C 82     
00DAEC  2  22 84 22 14        .byte $22, $84, $22, $14
00DAF0  2               
00DAF0  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00DAF4  2  31 D0 C4 D0  
00DAF8  2  00           
00DAF9  2               
00DAF9  2               GroundM_P3AData:
00DAF9  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $2c, $82, $2c, $30
00DAFD  2  2C 82 2C 30  
00DB01  2  04 34 2C 04        .byte $04, $34, $2c, $04, $26, $86, $22, $00
00DB05  2  26 86 22 00  
00DB09  2               
00DB09  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
00DB0D  2  29 A2 1D 9C  
00DB11  2  95           
00DB12  2               
00DB12  2               GroundM_P3BData:
00DB12  2  82 2C 2C 04        .byte $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
00DB16  2  2C 04 2C 30  
00DB1A  2  85 34 04 04  
00DB1F  2               
00DB1F  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $a8, $63, $04
00DB23  2  A8 63 04     
00DB26  2               
00DB26  2               ;triangle data used by both sections of third part
00DB26  2  85 0E 1A 84        .byte $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
00DB2A  2  24 85 22 14  
00DB2E  2  84 0C        
00DB30  2               
00DB30  2               GroundMLdInData:
00DB30  2  82 34 84 34        .byte $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
00DB34  2  34 82 2C 84  
00DB38  2  34 86 3A 04  
00DB3D  2               
00DB3D  2  A0 21 21 A0        .byte $a0, $21, $21, $a0, $21, $2b, $05, $a3
00DB41  2  21 2B 05 A3  
00DB45  2               
00DB45  2  82 18 84 18        .byte $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
00DB49  2  18 82 18 18  
00DB4D  2  04 86 3A 22  
00DB51  2               
00DB51  2               ;noise data used by lead-in and third part sections
00DB51  2  31 90 31 90        .byte $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
00DB55  2  31 71 31 90  
00DB59  2  90 90 00     
00DB5C  2               
00DB5C  2               GroundM_P4AData:
00DB5C  2  82 34 84 2C        .byte $82, $34, $84, $2c, $85, $22, $84, $24
00DB60  2  85 22 84 24  
00DB64  2  82 26 36 04        .byte $82, $26, $36, $04, $36, $86, $26, $00
00DB68  2  36 86 26 00  
00DB6C  2               
00DB6C  2  AC 27 5D 1D        .byte $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
00DB70  2  9E 2D AC 9F  
00DB74  2               
00DB74  2  85 14 82 20        .byte $85, $14, $82, $20, $84, $22, $2c
00DB78  2  84 22 2C     
00DB7B  2  1E 1E 82 2C        .byte $1e, $1e, $82, $2c, $2c, $1e, $04
00DB7F  2  2C 1E 04     
00DB82  2               
00DB82  2               GroundM_P4BData:
00DB82  2  87 2A 40 40        .byte $87, $2a, $40, $40, $40, $3a, $36
00DB86  2  40 3A 36     
00DB89  2  82 34 2C 04        .byte $82, $34, $2c, $04, $26, $86, $22, $00
00DB8D  2  26 86 22 00  
00DB91  2               
00DB91  2  E3 F7 F7 F7        .byte $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
00DB95  2  F5 F1 AC 27  
00DB99  2  9E 9D        
00DB9B  2               
00DB9B  2  85 18 82 1E        .byte $85, $18, $82, $1e, $84, $22, $2a
00DB9F  2  84 22 2A     
00DBA2  2  22 22 82 2C        .byte $22, $22, $82, $2c, $2c, $22, $04
00DBA6  2  2C 22 04     
00DBA9  2               
00DBA9  2               DeathMusData:
00DBA9  2  86 04              .byte $86, $04 ;death music share data with fourth part c of ground level music
00DBAB  2               
00DBAB  2               GroundM_P4CData:
00DBAB  2  82 2A 36 04        .byte $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
00DBAF  2  36 87 36 34  
00DBB3  2  30 86 2C 04  
00DBB8  2               
00DBB8  2  00 68 6A 6C        .byte $00, $68, $6a, $6c, $45 ;death music only
00DBBC  2  45           
00DBBD  2               
00DBBD  2  A2 31 B0 F1        .byte $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
00DBC1  2  ED EB A2 1D  
00DBC5  2  9C 95        
00DBC7  2               
00DBC7  2  86 04              .byte $86, $04 ;death music only
00DBC9  2               
00DBC9  2  85 22 82 22        .byte $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
00DBCD  2  87 22 26 2A  
00DBD1  2  84 2C 22 86  
00DBD6  2               
00DBD6  2               ;noise data used by fourth part sections
00DBD6  2  51 90 31 11        .byte $51, $90, $31, $11, $00
00DBDA  2  00           
00DBDB  2               
00DBDB  2               CastleMusData:
00DBDB  2  80 22 28 22        .byte $80, $22, $28, $22, $26, $22, $24, $22, $26
00DBDF  2  26 22 24 22  
00DBE3  2  26           
00DBE4  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00DBE8  2  22 28 22 26  
00DBEC  2  22 28 22 26        .byte $22, $28, $22, $26, $22, $24, $22, $26
00DBF0  2  22 24 22 26  
00DBF4  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00DBF8  2  22 28 22 26  
00DBFC  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00DC00  2  20 26 20 28  
00DC04  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00DC08  2  20 26 20 24  
00DC0C  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00DC10  2  20 26 20 28  
00DC14  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00DC18  2  20 26 20 24  
00DC1C  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00DC20  2  28 30 28 2E  
00DC24  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e
00DC28  2  28 2C 28 2E  
00DC2C  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00DC30  2  28 30 28 2E  
00DC34  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
00DC38  2  28 2C 28 2E  
00DC3C  2  00           
00DC3D  2               
00DC3D  2  04 70 6E 6C        .byte $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
00DC41  2  6E 70 72 70  
00DC45  2  6E           
00DC46  2  70 6E 6C 6E        .byte $70, $6e, $6c, $6e, $70, $72, $70, $6e
00DC4A  2  70 72 70 6E  
00DC4E  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00DC52  2  6E 70 6E 6C  
00DC56  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00DC5A  2  6E 70 6E 6C  
00DC5E  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00DC62  2  76 74 72 74  
00DC66  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00DC6A  2  76 74 72 74  
00DC6E  2               
00DC6E  2  84 1A 83 18        .byte $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
00DC72  2  20 84 1E 83  
00DC76  2  1C 28        
00DC78  2  26 1C 1A 1C        .byte $26, $1c, $1a, $1c
00DC7C  2               
00DC7C  2               GameOverMusData:
00DC7C  2  82 2C 04 04        .byte $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
00DC80  2  22 04 04 84  
00DC84  2  1C 87        
00DC86  2  26 2A 26 84        .byte $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
00DC8A  2  24 28 24 80  
00DC8E  2  22 00        
00DC90  2               
00DC90  2  9C 05 94 05        .byte $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
00DC94  2  0D 9F 1E 9C  
00DC98  2  98 9D        
00DC9A  2               
00DC9A  2  82 22 04 04        .byte $82, $22, $04, $04, $1c, $04, $04, $84, $14
00DC9E  2  1C 04 04 84  
00DCA2  2  14           
00DCA3  2  86 1E 80 16        .byte $86, $1e, $80, $16, $80, $14
00DCA7  2  80 14        
00DCA9  2               
00DCA9  2               TimeRunOutMusData:
00DCA9  2  81 1C 30 04        .byte $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
00DCAD  2  30 30 04 1E  
00DCB1  2  32 04 32 32  
00DCB5  2  04 20 34 04        .byte $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
00DCB9  2  34 34 04 36  
00DCBD  2  04 84 36 00  
00DCC1  2               
00DCC1  2  46 A4 64 A4        .byte $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
00DCC5  2  48 A6 66 A6  
00DCC9  2  4A A8 68 A8  
00DCCD  2  6A 44 2B           .byte $6a, $44, $2b
00DCD0  2               
00DCD0  2  81 2A 42 04        .byte $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
00DCD4  2  42 42 04 2C  
00DCD8  2  64 04 64 64  
00DCDC  2  04 2E 46 04        .byte $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
00DCE0  2  46 46 04 22  
00DCE4  2  04 84 22     
00DCE7  2               
00DCE7  2               WinLevelMusData:
00DCE7  2  87 04 06 0C        .byte $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
00DCEB  2  14 1C 22 86  
00DCEF  2  2C 22        
00DCF1  2  87 04 60 0E        .byte $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
00DCF5  2  14 1A 24 86  
00DCF9  2  2C 24        
00DCFB  2  87 04 08 10        .byte $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
00DCFF  2  18 1E 28 86  
00DD03  2  30 30        
00DD05  2  80 64 00           .byte $80, $64, $00
00DD08  2               
00DD08  2  CD D5 DD E3        .byte $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
00DD0C  2  ED F5 BB B5  
00DD10  2  CF D5        
00DD12  2  DB E5 ED F3        .byte $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
00DD16  2  BD B3 D1 D9  
00DD1A  2  DF E9        
00DD1C  2  F1 F7 BF FF        .byte $f1, $f7, $bf, $ff, $ff, $ff, $34
00DD20  2  FF FF 34     
00DD23  2  00                 .byte $00 ;unused byte
00DD24  2               
00DD24  2  86 04 87 14        .byte $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
00DD28  2  1C 22 86 34  
00DD2C  2  84 2C        
00DD2E  2  04 04 04 87        .byte $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
00DD32  2  14 1A 24 86  
00DD36  2  32 84        
00DD38  2  2C 04 86 04        .byte $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
00DD3C  2  87 18 1E 28  
00DD40  2  86 36        
00DD42  2  87 30 30 30        .byte $87, $30, $30, $30, $80, $2c
00DD46  2  80 2C        
00DD48  2               
00DD48  2               ;square 2 and triangle use the same data, square 1 is unused
00DD48  2               UndergroundMusData:
00DD48  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00DD4C  2  26 10 28 80  
00DD50  2  04           
00DD51  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00DD55  2  26 10 28 80  
00DD59  2  04           
00DD5A  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
00DD5E  2  18 60 1A 80  
00DD62  2  04           
00DD63  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
00DD67  2  18 60 1A 86  
00DD6B  2  04           
00DD6C  2  83 1A 18 16        .byte $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
00DD70  2  84 14 1A 18  
00DD74  2  0E 0C        
00DD76  2  16 83 14 20        .byte $16, $83, $14, $20, $1e, $1c, $28, $26, $87
00DD7A  2  1E 1C 28 26  
00DD7E  2  87           
00DD7F  2  24 1A 12 10        .byte $24, $1a, $12, $10, $62, $0e, $80, $04, $04
00DD83  2  62 0E 80 04  
00DD87  2  04           
00DD88  2  00                 .byte $00
00DD89  2               
00DD89  2               ;noise data directly follows square 2 here unlike in other songs
00DD89  2               WaterMusData:
00DD89  2  82 18 1C 20        .byte $82, $18, $1c, $20, $22, $26, $28
00DD8D  2  22 26 28     
00DD90  2  81 2A 2A 2A        .byte $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
00DD94  2  04 2A 04 83  
00DD98  2  2A 82 22     
00DD9B  2  86 34 32 34        .byte $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
00DD9F  2  81 04 22 26  
00DDA3  2  2A 2C 30     
00DDA6  2  86 34 83 32        .byte $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
00DDAA  2  82 36 84 34  
00DDAE  2  85 04 81 22  
00DDB2  2  86 30 2E 30        .byte $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
00DDB6  2  81 04 22 26  
00DDBA  2  2A 2C 2E     
00DDBD  2  86 30 83 22        .byte $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
00DDC1  2  82 36 84 34  
00DDC5  2  85 04 81 22  
00DDC9  2  86 3A 3A 3A        .byte $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
00DDCD  2  82 3A 81 40  
00DDD1  2  82 04 81 3A  
00DDD5  2  86 36 36 36        .byte $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
00DDD9  2  82 36 81 3A  
00DDDD  2  82 04 81 36  
00DDE1  2  86 34 82 26        .byte $86, $34, $82, $26, $2a, $36
00DDE5  2  2A 36        
00DDE7  2  81 34 34 85        .byte $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
00DDEB  2  34 81 2A 86  
00DDEF  2  2C 00        
00DDF1  2               
00DDF1  2  84 90 B0 84        .byte $84, $90, $b0, $84, $50, $50, $b0, $00
00DDF5  2  50 50 B0 00  
00DDF9  2               
00DDF9  2  98 96 94 92        .byte $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
00DDFD  2  94 96 58 58  
00DE01  2  58 44        
00DE03  2  5C 44 9F A3        .byte $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
00DE07  2  A1 A3 85 A3  
00DE0B  2  E0 A6        
00DE0D  2  23 C4 9F 9D        .byte $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
00DE11  2  9F 85 9F D2  
00DE15  2  A6 23        
00DE17  2  C4 B5 B1 AF        .byte $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
00DE1B  2  85 B1 AF AD  
00DE1F  2  85 95        
00DE21  2  9E A2 AA 6A        .byte $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
00DE25  2  6A 6B 5E 9D  
00DE29  2               
00DE29  2  84 04 04 82        .byte $84, $04, $04, $82, $22, $86, $22
00DE2D  2  22 86 22     
00DE30  2  82 14 22 2C        .byte $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
00DE34  2  12 22 2A 14  
00DE38  2  22 2C        
00DE3A  2  1C 22 2C 14        .byte $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
00DE3E  2  22 2C 12 22  
00DE42  2  2A 14        
00DE44  2  22 2C 1C 22        .byte $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
00DE48  2  2C 18 22 2A  
00DE4C  2  16 20        
00DE4E  2  28 18 22 2A        .byte $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
00DE52  2  12 22 2A 18  
00DE56  2  22 2A        
00DE58  2  12 22 2A 14        .byte $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
00DE5C  2  22 2C 0C 22  
00DE60  2  2C 14 22 34  
00DE65  2  22 30 10 22        .byte $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
00DE69  2  2E 16 22 34  
00DE6D  2  18 26        
00DE6F  2  36 16 26 36        .byte $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
00DE73  2  14 26 36 12  
00DE77  2  22 36        
00DE79  2  5C 22 34 0C        .byte $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
00DE7D  2  22 22 81 1E  
00DE81  2  1E 85 1E     
00DE84  2  81 12 86 14        .byte $81, $12, $86, $14
00DE88  2               
00DE88  2               EndOfCastleMusData:
00DE88  2  81 2C 22 1C        .byte $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
00DE8C  2  2C 22 1C 85  
00DE90  2  2C 04        
00DE92  2  81 2E 24 1E        .byte $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
00DE96  2  2E 24 1E 85  
00DE9A  2  2E 04        
00DE9C  2  81 32 28 22        .byte $81, $32, $28, $22, $32, $28, $22, $85, $32
00DEA0  2  32 28 22 85  
00DEA4  2  32           
00DEA5  2  87 36 36 36        .byte $87, $36, $36, $36, $84, $3a, $00
00DEA9  2  84 3A 00     
00DEAC  2               
00DEAC  2  5C 54 4C 5C        .byte $5c, $54, $4c, $5c, $54, $4c
00DEB0  2  54 4C        
00DEB2  2  5C 1C 1C 5C        .byte $5c, $1c, $1c, $5c, $5c, $5c, $5c
00DEB6  2  5C 5C 5C     
00DEB9  2  5E 56 4E 5E        .byte $5e, $56, $4e, $5e, $56, $4e
00DEBD  2  56 4E        
00DEBF  2  5E 1E 1E 5E        .byte $5e, $1e, $1e, $5e, $5e, $5e, $5e
00DEC3  2  5E 5E 5E     
00DEC6  2  62 5A 50 62        .byte $62, $5a, $50, $62, $5a, $50
00DECA  2  5A 50        
00DECC  2  62 22 22 62        .byte $62, $22, $22, $62, $e7, $e7, $e7, $2b
00DED0  2  E7 E7 E7 2B  
00DED4  2               
00DED4  2  86 14 81 14        .byte $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
00DED8  2  80 14 14 81  
00DEDC  2  14 14 14 14  
00DEE0  2  86 16 81 16        .byte $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
00DEE4  2  80 16 16 81  
00DEE8  2  16 16 16 16  
00DEEC  2  81 28 22 1A        .byte $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
00DEF0  2  28 22 1A 28  
00DEF4  2  80 28 28     
00DEF7  2  81 28 87 2C        .byte $81, $28, $87, $2c, $2c, $2c, $84, $30
00DEFB  2  2C 2C 84 30  
00DEFF  2               
00DEFF  2               ;unused byte
00DEFF  2  FF                 .byte $ff
00DF00  2               
00DF00  2               FreqRegLookupTbl:
00DF00  2  00 88 00 2F        .byte $00, $88, $00, $2f, $00, $00
00DF04  2  00 00        
00DF06  2  02 A6 02 80        .byte $02, $a6, $02, $80, $02, $5c, $02, $3a
00DF0A  2  02 5C 02 3A  
00DF0E  2  02 1A 01 DF        .byte $02, $1a, $01, $df, $01, $c4, $01, $ab
00DF12  2  01 C4 01 AB  
00DF16  2  01 93 01 7C        .byte $01, $93, $01, $7c, $01, $67, $01, $53
00DF1A  2  01 67 01 53  
00DF1E  2  01 40 01 2E        .byte $01, $40, $01, $2e, $01, $1d, $01, $0d
00DF22  2  01 1D 01 0D  
00DF26  2  00 FE 00 EF        .byte $00, $fe, $00, $ef, $00, $e2, $00, $d5
00DF2A  2  00 E2 00 D5  
00DF2E  2  00 C9 00 BE        .byte $00, $c9, $00, $be, $00, $b3, $00, $a9
00DF32  2  00 B3 00 A9  
00DF36  2  00 A0 00 97        .byte $00, $a0, $00, $97, $00, $8e, $00, $86
00DF3A  2  00 8E 00 86  
00DF3E  2  00 77 00 7E        .byte $00, $77, $00, $7e, $00, $71, $00, $54
00DF42  2  00 71 00 54  
00DF46  2  00 64 00 5F        .byte $00, $64, $00, $5f, $00, $59, $00, $50
00DF4A  2  00 59 00 50  
00DF4E  2  00 47 00 43        .byte $00, $47, $00, $43, $00, $3b, $00, $35
00DF52  2  00 3B 00 35  
00DF56  2  00 2A 00 23        .byte $00, $2a, $00, $23, $04, $75, $03, $57
00DF5A  2  04 75 03 57  
00DF5E  2  02 F9 02 CF        .byte $02, $f9, $02, $cf, $01, $fc, $00, $6a
00DF62  2  01 FC 00 6A  
00DF66  2               
00DF66  2               MusicLengthLookupTbl:
00DF66  2  05 0A 14 28        .byte $05, $0a, $14, $28, $50, $1e, $3c, $02
00DF6A  2  50 1E 3C 02  
00DF6E  2  04 08 10 20        .byte $04, $08, $10, $20, $40, $18, $30, $0c
00DF72  2  40 18 30 0C  
00DF76  2  03 06 0C 18        .byte $03, $06, $0c, $18, $30, $12, $24, $08
00DF7A  2  30 12 24 08  
00DF7E  2  36 03 09 06        .byte $36, $03, $09, $06, $12, $1b, $24, $0c
00DF82  2  12 1B 24 0C  
00DF86  2  24 02 06 04        .byte $24, $02, $06, $04, $0c, $12, $18, $08
00DF8A  2  0C 12 18 08  
00DF8E  2  12 01 03 02        .byte $12, $01, $03, $02, $06, $09, $0c, $04
00DF92  2  06 09 0C 04  
00DF96  2               
00DF96  2               EndOfCastleMusicEnvData:
00DF96  2  98 99 9A 9B        .byte $98, $99, $9a, $9b
00DF9A  2               
00DF9A  2               AreaMusicEnvData:
00DF9A  2  90 94 94 95        .byte $90, $94, $94, $95, $95, $96, $97, $98
00DF9E  2  95 96 97 98  
00DFA2  2               
00DFA2  2               WaterEventMusEnvData:
00DFA2  2  90 91 92 92        .byte $90, $91, $92, $92, $93, $93, $93, $94
00DFA6  2  93 93 93 94  
00DFAA  2  94 94 94 94        .byte $94, $94, $94, $94, $94, $95, $95, $95
00DFAE  2  94 95 95 95  
00DFB2  2  95 95 95 96        .byte $95, $95, $95, $96, $96, $96, $96, $96
00DFB6  2  96 96 96 96  
00DFBA  2  96 96 96 96        .byte $96, $96, $96, $96, $96, $96, $96, $96
00DFBE  2  96 96 96 96  
00DFC2  2  96 96 96 96        .byte $96, $96, $96, $96, $95, $95, $94, $93
00DFC6  2  95 95 94 93  
00DFCA  2               
00DFCA  2               BowserFlameEnvData:
00DFCA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00DFCE  2  17 18 19 19  
00DFD2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00DFD6  2  1D 1E 1E 1F  
00DFDA  2  1F 1F 1F 1E        .byte $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
00DFDE  2  1D 1C 1E 1F  
00DFE2  2  1F 1E 1D 1C        .byte $1f, $1e, $1d, $1c, $1a, $18, $16, $14
00DFE6  2  1A 18 16 14  
00DFEA  2               
00DFEA  2               BrickShatterEnvData:
00DFEA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00DFEE  2  17 18 19 19  
00DFF2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00DFF6  2  1D 1E 1E 1F  
00DFFA  2               
00DFFA  2  A0 60                .word NMIHandler
00DFFC  2  00 60                .word Start
00DFFE  2  A2 61                .word IRQHandler
00E000  2               
00E000  1               .reloc
00A19Er 1               .endscope
00A19Er 1               MainEnd:
00A19Er 1               
00A19Er 1  03           .byte FileHeaderBlock
00A19Fr 1  04 20        .byte $04,$20
00A1A1r 1  53 4D 32 44  .byte "SM2DATA2"
00A1A5r 1  41 54 41 32  
00A1A9r 1  70 C4        .word $c470
00A1ABr 1  2F 0E        .word Data2End-Data2Start
00A1ADr 1  00 04        .byte PRG,FileDataBlock
00A1AFr 1               Data2Start:
00A1AFr 1               .scope FILE_SM2DATA2
00A1AFr 1               .org $C470
00C470  1               .include "sm2data2.asm"
00C470  2               ;SMB2J DISASSEMBLY (SM2DATA2 portion)
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------
00C470  2               ;DEFINES
00C470  2               
00C470  2               FrameCounter          = $09
00C470  2               Enemy_State           = $1e
00C470  2               Enemy_Y_Position      = $cf
00C470  2               PiranhaPlantUpYPos    = $0417
00C470  2               PiranhaPlantDownYPos  = $0434
00C470  2               PiranhaPlant_Y_Speed  = $58
00C470  2               PiranhaPlant_MoveFlag = $a0
00C470  2               
00C470  2               Player_X_Scroll       = $06ff
00C470  2               
00C470  2               Player_PageLoc        = $6d
00C470  2               Player_X_Position     = $86
00C470  2               
00C470  2               AreaObjectLength      = $0730
00C470  2               WindFlag              = $07f9
00C470  2               AreaType              = $074e
00C470  2               
00C470  2               TimerControl          = $0747
00C470  2               EnemyFrameTimer       = $078a
00C470  2               
00C470  2               Sprite_Y_Position     = $0200
00C470  2               Sprite_Tilenumber     = $0201
00C470  2               Sprite_Attributes     = $0202
00C470  2               Sprite_X_Position     = $0203
00C470  2               
00C470  2               Alt_SprDataOffset     = $06ec
00C470  2               
00C470  2               NoiseSoundQueue       = $fd
00C470  2               
00C470  2               MetatileBuffer        = $06a1
00C470  2               
00C470  2               ; import from other files
00C470  2               .import GetPipeHeight
00C470  2               .import FindEmptyEnemySlot
00C470  2               .import SetupPiranhaPlant
00C470  2               .import VerticalPipeData
00C470  2               .import RenderUnderPart
00C470  2               ; export to other files
00C470  2               .export E_CastleArea5
00C470  2               .export E_CastleArea6
00C470  2               .export E_CastleArea7
00C470  2               .export E_CastleArea8
00C470  2               .export E_GroundArea12
00C470  2               .export E_GroundArea13
00C470  2               .export E_GroundArea14
00C470  2               .export E_GroundArea15
00C470  2               .export E_GroundArea16
00C470  2               .export E_GroundArea17
00C470  2               .export E_GroundArea18
00C470  2               .export E_GroundArea19
00C470  2               .export E_GroundArea22
00C470  2               .export E_GroundArea23
00C470  2               .export E_GroundArea24
00C470  2               .export E_GroundArea29
00C470  2               .export E_UndergroundArea4
00C470  2               .export E_UndergroundArea5
00C470  2               .export E_WaterArea2
00C470  2               .export E_WaterArea4
00C470  2               .export E_WaterArea5
00C470  2               .export L_CastleArea5
00C470  2               .export L_CastleArea6
00C470  2               .export L_CastleArea7
00C470  2               .export L_CastleArea8
00C470  2               .export L_GroundArea12
00C470  2               .export L_GroundArea13
00C470  2               .export L_GroundArea14
00C470  2               .export L_GroundArea15
00C470  2               .export L_GroundArea16
00C470  2               .export L_GroundArea17
00C470  2               .export L_GroundArea18
00C470  2               .export L_GroundArea19
00C470  2               .export L_GroundArea22
00C470  2               .export L_GroundArea23
00C470  2               .export L_GroundArea24
00C470  2               .export L_GroundArea29
00C470  2               .export L_UndergroundArea4
00C470  2               .export L_UndergroundArea5
00C470  2               .export L_WaterArea2
00C470  2               .export L_WaterArea4
00C470  2               .export L_WaterArea5
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------------------
00C470  2               ;$06 - used to store vertical length of pipe
00C470  2               ;$07 - starts with adder from area parser, used to store row offset
00C470  2               
00C470  2               UpsideDownPipe_High:
00C470  2  A9 01               lda #$01                     ;start at second row
00C472  2  48                  pha
00C473  2  D0 03               bne UDP
00C475  2               UpsideDownPipe_Low:
00C475  2  A9 04               lda #$04                     ;start at fifth row
00C477  2  48                  pha
00C478  2  20 rr rr     UDP:   jsr GetPipeHeight            ;get pipe height from object byte
00C47B  2  68                  pla
00C47C  2  85 07               sta $07                      ;save buffer offset temporarily
00C47E  2  98                  tya
00C47F  2  48                  pha                          ;save pipe height temporarily
00C480  2  BC 30 07            ldy AreaObjectLength,x       ;if on second column of pipe, skip this
00C483  2  F0 23               beq NoUDP
00C485  2  20 rr rr            jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
00C488  2  B0 1E               bcs NoUDP                    ;piranha plant, if no empty slots, skip this
00C48A  2  A9 04               lda #$04
00C48C  2  20 rr rr            jsr SetupPiranhaPlant        ;set up upside-down piranha plant
00C48F  2  A5 06               lda $06
00C491  2  0A                  asl
00C492  2  0A                  asl                          ;multiply height of pipe by 16
00C493  2  0A                  asl                          ;and add enemy Y position previously set up
00C494  2  0A                  asl                          ;then subtract 10 pixels, save as new Y position
00C495  2  18                  clc
00C496  2  75 CF               adc Enemy_Y_Position,x
00C498  2  38                  sec
00C499  2  E9 0A               sbc #$0a
00C49B  2  95 CF               sta Enemy_Y_Position,x
00C49D  2  9D 34 04            sta PiranhaPlantDownYPos,x   ;set as "down" position
00C4A0  2  18                  clc                          ;add 24 pixels, save as "up" position
00C4A1  2  69 18               adc #$18                     ;note up and down here are reversed
00C4A3  2  9D 17 04            sta PiranhaPlantUpYPos,x
00C4A6  2  F6 A0               inc PiranhaPlant_MoveFlag,x  ;set movement flag
00C4A8  2  68           NoUDP: pla
00C4A9  2  A8                  tay                          ;return tile offset
00C4AA  2  48                  pha
00C4AB  2  A6 07               ldx $07
00C4AD  2  B9 rr rr            lda VerticalPipeData+2,y
00C4B0  2  A4 06               ldy $06                      ;render the pipe shaft
00C4B2  2  88                  dey
00C4B3  2  20 rr rr            jsr RenderUnderPart
00C4B6  2  68                  pla
00C4B7  2  A8                  tay
00C4B8  2  B9 rr rr            lda VerticalPipeData,y       ;and render the pipe end
00C4BB  2  9D A1 06            sta MetatileBuffer,x
00C4BE  2  60                  rts
00C4BF  2               
00C4BF  2  60                  rts                        ;unused, nothing jumps here
00C4C0  2               
00C4C0  2               MoveUpsideDownPiranhaP:
00C4C0  2  B5 1E              lda Enemy_State,x           ;check enemy state
00C4C2  2  D0 39              bne ExMoveUDPP              ;if set at all, branch to leave
00C4C4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00C4C7  2  D0 34              bne ExMoveUDPP              ;branch to end if not yet expired
00C4C9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00C4CB  2  D0 0B              bne SetupToMovePPlant       ;if moving, skip to part ahead
00C4CD  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4CF  2  49 FF              eor #$ff
00C4D1  2  18                 clc                         ;change to two's compliment
00C4D2  2  69 01              adc #$01
00C4D4  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00C4D6  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00C4D8  2               
00C4D8  2               SetupToMovePPlant:
00C4D8  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
00C4DB  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4DD  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00C4DF  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
00C4E2  2               
00C4E2  2               RiseFallPiranhaPlant:
00C4E2  2  85 00               sta $00                     ;save vertical coordinate here
00C4E4  2  AD 47 07            lda TimerControl            ;get master timer control
00C4E7  2  D0 14               bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
00C4E9  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00C4EB  2  18                  clc
00C4EC  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00C4EE  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00C4F0  2  C5 00               cmp $00                     ;compare against low or high coordinate
00C4F2  2  D0 09               bne ExMoveUDPP              ;branch to leave if not yet reached
00C4F4  2  A9 00               lda #$00
00C4F6  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00C4F8  2  A9 20               lda #$20
00C4FA  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00C4FD  2               ExMoveUDPP:
00C4FD  2  60                  rts
00C4FE  2               
00C4FE  2               ;-------------------------------------------------------------------------------------
00C4FE  2               
00C4FE  2               BlowPlayerAround:
00C4FE  2  AD F9 07             lda WindFlag            ;if wind is turned off, just exit
00C501  2  F0 28                beq ExBlow
00C503  2  AD 4E 07             lda AreaType            ;don't blow the player around unless
00C506  2  C9 01                cmp #$01                ;the area is ground type
00C508  2  D0 21                bne ExBlow
00C50A  2  A0 01                ldy #$01
00C50C  2  A5 09                lda FrameCounter        ;branch to set d0 if on an odd frame
00C50E  2  0A                   asl
00C50F  2  B0 02                bcs BThr                ;otherwise wind will only blow
00C511  2  A0 03                ldy #$03                ;one out of every four frames
00C513  2  84 00        BThr:   sty $00
00C515  2  A5 09                lda FrameCounter        ;throttle wind blowing by using the frame counter
00C517  2  25 00                and $00                 ;to mask out certain frames
00C519  2  D0 10                bne ExBlow
00C51B  2  A5 86                lda Player_X_Position   ;move player slightly to the right
00C51D  2  18                   clc                     ;to simulate the wind moving the player
00C51E  2  69 01                adc #$01
00C520  2  85 86                sta Player_X_Position
00C522  2  A5 6D                lda Player_PageLoc
00C524  2  69 00                adc #$00
00C526  2  85 6D                sta Player_PageLoc
00C528  2  EE FF 06             inc Player_X_Scroll     ;add one to movement speed for scroll
00C52B  2  60           ExBlow: rts
00C52C  2               
00C52C  2               ;note the position data values are overwritten in RAM
00C52C  2               LeavesYPos:
00C52C  2  30 70 B8 50          .byte $30, $70, $b8, $50, $98, $30
00C530  2  98 30        
00C532  2  70 B8 50 98          .byte $70, $b8, $50, $98, $30, $70
00C536  2  30 70        
00C538  2               
00C538  2               LeavesXPos:
00C538  2  30 30 30 60          .byte $30, $30, $30, $60, $60, $a0
00C53C  2  60 A0        
00C53E  2  A0 A0 D0 D0          .byte $a0, $a0, $d0, $d0, $d0, $60
00C542  2  D0 60        
00C544  2               
00C544  2               LeavesTile:
00C544  2  7B 7B 7B 7B          .byte $7b, $7b, $7b, $7b, $7a, $7a
00C548  2  7A 7A        
00C54A  2  7B 7B 7B 7A          .byte $7b, $7b, $7b, $7a, $7b, $7a
00C54E  2  7B 7A        
00C550  2               
00C550  2               SimulateWind:
00C550  2  AD F9 07               lda WindFlag             ;if no wind, branch to leave
00C553  2  F0 33                  beq ExSimW
00C555  2  A9 04                  lda #$04                 ;play wind sfx
00C557  2  85 FD                  sta NoiseSoundQueue
00C559  2  20 A1 C5               jsr ModifyLeavesPos      ;modify X and Y position data of leaves
00C55C  2  A2 00                  ldx #$00                 ;use mostly unused sprite data offset
00C55E  2  AC EB 06               ldy Alt_SprDataOffset-1  ;for first six leaves
00C561  2  BD 2C C5     DrawLeaf: lda LeavesYPos,x
00C564  2  99 00 02               sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
00C567  2  BD 44 C5               lda LeavesTile,x
00C56A  2  99 01 02               sta Sprite_Tilenumber,y
00C56D  2  A9 41                  lda #$41
00C56F  2  99 02 02               sta Sprite_Attributes,y
00C572  2  BD 38 C5               lda LeavesXPos,x
00C575  2  99 03 02               sta Sprite_X_Position,y
00C578  2  C8                     iny
00C579  2  C8                     iny
00C57A  2  C8                     iny
00C57B  2  C8                     iny
00C57C  2  E8                     inx                      ;if still on first six leaves, continue
00C57D  2  E0 06                  cpx #$06                 ;using the first sprite data offset
00C57F  2  D0 03                  bne DLLoop               ;otherwise use the next one instead
00C581  2  AC EC 06               ldy Alt_SprDataOffset    ;note the next one is also used by blocks
00C584  2  E0 0C        DLLoop:   cpx #$0c                 ;continue until done putting all leaves on the screen
00C586  2  D0 D9                  bne DrawLeaf
00C588  2  60           ExSimW:   rts
00C589  2               
00C589  2               LeavesPosAdder:
00C589  2  57 57 56 56     .byte $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
00C58D  2  58 58 56 56  
00C591  2  57 58 57 58  
00C595  2  59 59 58 58     .byte $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
00C599  2  5A 5A 58 58  
00C59D  2  59 5A 59 5A  
00C5A1  2               
00C5A1  2               ModifyLeavesPos:
00C5A1  2  A2 0B                 ldx #$0b
00C5A3  2  BD 38 C5     MLPLoop: lda LeavesXPos,x      ;add each adder to each X position twice
00C5A6  2  18                    clc                   ;and to each Y position once
00C5A7  2  7D 89 C5              adc LeavesPosAdder,x
00C5AA  2  7D 89 C5              adc LeavesPosAdder,x
00C5AD  2  9D 38 C5              sta LeavesXPos,x
00C5B0  2  BD 2C C5              lda LeavesYPos,x
00C5B3  2  18                    clc
00C5B4  2  7D 89 C5              adc LeavesPosAdder,x
00C5B7  2  9D 2C C5              sta LeavesYPos,x
00C5BA  2  CA                    dex
00C5BB  2  10 E6                 bpl MLPLoop
00C5BD  2  60                    rts
00C5BE  2               
00C5BE  2               WindOn:
00C5BE  2  A9 01             lda #$01         ;branch to turn the wind on
00C5C0  2  D0 02             bne WOn
00C5C2  2               WindOff:
00C5C2  2  A9 00             lda #$00         ;turn the wind off
00C5C4  2  8D F9 07     WOn: sta WindFlag
00C5C7  2  60                rts
00C5C8  2               
00C5C8  2               ;some unused bytes
00C5C8  2  FF FF FF FF     .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00C5CC  2  FF FF FF FF  
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               
00C5D0  2               ;level 5-4
00C5D0  2               E_CastleArea5:
00C5D0  2  2A A9 6B 0C    .byte $2a, $a9, $6b, $0c, $cb, $0c, $15, $9c, $89, $1c, $cc, $1d, $09, $9d, $f5, $1c
00C5D4  2  CB 0C 15 9C  
00C5D8  2  89 1C CC 1D  
00C5E0  2  6B A9 AB 0C    .byte $6b, $a9, $ab, $0c, $db, $29, $48, $9d, $9b, $0c, $5b, $8c, $a5, $1c, $49, $9d
00C5E4  2  DB 29 48 9D  
00C5E8  2  9B 0C 5B 8C  
00C5F0  2  79 1D 09 9D    .byte $79, $1d, $09, $9d, $6b, $0c, $c9, $1f, $3b, $8c, $88, $95, $b9, $1c, $19, $9d
00C5F4  2  6B 0C C9 1F  
00C5F8  2  3B 8C 88 95  
00C600  2  30 CC 78 2D    .byte $30, $cc, $78, $2d, $a6, $28, $90, $b5, $ff
00C604  2  A6 28 90 B5  
00C608  2  FF           
00C609  2               
00C609  2               ;level 6-4
00C609  2               E_CastleArea6:
00C609  2  0F 02 09 1F    .byte $0f, $02, $09, $1f, $8b, $85, $2b, $8c, $e9, $1b, $25, $9d, $0f, $07, $09, $1d
00C60D  2  8B 85 2B 8C  
00C611  2  E9 1B 25 9D  
00C619  2  6D 28 99 1B    .byte $6d, $28, $99, $1b, $b5, $2c, $4b, $8c, $09, $9f, $fb, $15, $9d, $a8, $0f, $0c
00C61D  2  B5 2C 4B 8C  
00C621  2  09 9F FB 15  
00C629  2  2B 0C 78 2D    .byte $2b, $0c, $78, $2d, $90, $b5, $ff
00C62D  2  90 B5 FF     
00C630  2               
00C630  2               ;level 7-4
00C630  2               E_CastleArea7:
00C630  2  05 9D 0D A8    .byte $05, $9d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c, $42, $ac
00C634  2  DD 1D 07 AC  
00C638  2  54 2C A2 2C  
00C640  2  26 9D D4 03    .byte $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02, $9b, $02
00C644  2  24 83 64 03  
00C648  2  2B 82 4B 02  
00C650  2  5B 82 7B 02    .byte $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02, $a6, $1b
00C654  2  0B 82 2B 02  
00C658  2  C6 1B 28 82  
00C660  2  7B 95 85 0C    .byte $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5, $ff
00C664  2  9D 9B 0F 0E  
00C668  2  78 2D 7A 1D  
00C66F  2               
00C66F  2               ;level 8-4
00C66F  2               E_CastleArea8:
00C66F  2  19 9B 99 1B    .byte $19, $9b, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0e, $83, $e0, $0f, $06, $2e
00C673  2  2C 8C 59 1B  
00C677  2  C5 0F 0E 83  
00C67F  2  67 E7 0F 08    .byte $67, $e7, $0f, $08, $9b, $07, $0e, $83, $e0, $39, $0e, $87, $10, $bd, $28, $59
00C683  2  9B 07 0E 83  
00C687  2  E0 39 0E 87  
00C68F  2  9F 0F 0F 34    .byte $9f, $0f, $0f, $34, $0f, $77, $10, $9e, $67, $f1, $0f, $12, $0e, $67, $e3, $78
00C693  2  0F 77 10 9E  
00C697  2  67 F1 0F 12  
00C69F  2  2D 0F 15 3B    .byte $2d, $0f, $15, $3b, $29, $57, $82, $0f, $18, $55, $1d, $78, $2d, $90, $b5, $ff
00C6A3  2  29 57 82 0F  
00C6A7  2  18 55 1D 78  
00C6AF  2               
00C6AF  2               ;level 5-1
00C6AF  2               E_GroundArea12:
00C6AF  2  1B 82 4B 02    .byte $1b, $82, $4b, $02, $7b, $02, $ab, $02, $0f, $03, $f9, $0e, $d0, $be, $8e, $c4
00C6B3  2  7B 02 AB 02  
00C6B7  2  0F 03 F9 0E  
00C6BF  2  86 F8 0E C0    .byte $86, $f8, $0e, $c0, $ba, $0f, $0d, $3a, $0e, $bb, $02, $30, $b7, $80, $bc, $c0
00C6C3  2  BA 0F 0D 3A  
00C6C7  2  0E BB 02 30  
00C6CF  2  BC 0F 12 24    .byte $bc, $0f, $12, $24, $0f, $54, $0f, $ce, $3c, $80, $d3, $0f, $cb, $8e, $f9, $0e
00C6D3  2  0F 54 0F CE  
00C6D7  2  3C 80 D3 0F  
00C6DF  2  FF             .byte $ff
00C6E0  2               
00C6E0  2               ;level 5-3
00C6E0  2               E_GroundArea13:
00C6E0  2  0A AA 15 8F    .byte $0a, $aa, $15, $8f, $44, $0f, $4e, $44, $80, $d8, $07, $57, $90, $0f, $06, $67
00C6E4  2  44 0F 4E 44  
00C6E8  2  80 D8 07 57  
00C6F0  2  24 8B 17 B9    .byte $24, $8b, $17, $b9, $24, $ab, $97, $16, $87, $2a, $28, $84, $0f, $57, $a9, $a5
00C6F4  2  24 AB 97 16  
00C6F8  2  87 2A 28 84  
00C700  2  29 F5 29 A7    .byte $29, $f5, $29, $a7, $a4, $0a, $a4, $ff
00C704  2  A4 0A A4 FF  
00C708  2               
00C708  2               ;level 6-1
00C708  2               E_GroundArea14:
00C708  2  07 82 67 0E    .byte $07, $82, $67, $0e, $40, $bd, $e0, $38, $d0, $bc, $6e, $84, $a0, $9b, $05, $0f
00C70C  2  40 BD E0 38  
00C710  2  D0 BC 6E 84  
00C718  2  06 BB 05 0F    .byte $06, $bb, $05, $0f, $08, $0b, $0e, $4b, $0e, $0f, $0a, $05, $29, $85, $29, $0f
00C71C  2  08 0B 0E 4B  
00C720  2  0E 0F 0A 05  
00C728  2  0C DD 28 FF    .byte $0c, $dd, $28, $ff
00C72C  2               
00C72C  2               ;level 6-3
00C72C  2               E_GroundArea15:
00C72C  2  0F 02 28 10    .byte $0f, $02, $28, $10, $e6, $03, $d8, $90, $0f, $05, $85, $0f, $78, $83, $c8, $10
00C730  2  E6 03 D8 90  
00C734  2  0F 05 85 0F  
00C73C  2  18 83 58 83    .byte $18, $83, $58, $83, $f7, $90, $0f, $0c, $43, $0f, $73, $8f, $ff
00C740  2  F7 90 0F 0C  
00C744  2  43 0F 73 8F  
00C749  2               
00C749  2               ;level 7-1
00C749  2               E_GroundArea16:
00C749  2  A7 83 D7 03    .byte $a7, $83, $d7, $03, $0f, $03, $6b, $00, $0f, $06, $e3, $0f, $14, $8f, $3e, $44
00C74D  2  0F 03 6B 00  
00C751  2  0F 06 E3 0F  
00C759  2  C3 0B 80 87    .byte $c3, $0b, $80, $87, $05, $ab, $05, $db, $83, $0f, $0b, $07, $05, $13, $0e, $2b
00C75D  2  05 AB 05 DB  
00C761  2  83 0F 0B 07  
00C769  2  02 4B 02 0F    .byte $02, $4b, $02, $0f, $10, $0b, $0e, $b0, $37, $90, $bc, $80, $bc, $ae, $44, $c0
00C76D  2  10 0B 0E B0  
00C771  2  37 90 BC 80  
00C779  2  FF             .byte $ff
00C77A  2               
00C77A  2               ;level 7-2
00C77A  2               E_GroundArea17:
00C77A  2  0A AA D5 8F    .byte $0a, $aa, $d5, $8f, $03, $8f, $3e, $44, $c6, $d8, $83, $0f, $06, $a6, $11, $b9
00C77E  2  03 8F 3E 44  
00C782  2  C6 D8 83 0F  
00C78A  2  0E 39 9D 79    .byte $0e, $39, $9d, $79, $1b, $a6, $11, $e8, $03, $87, $83, $16, $90, $a6, $11, $b9
00C78E  2  1B A6 11 E8  
00C792  2  03 87 83 16  
00C79A  2  1D 05 8F 38    .byte $1d, $05, $8f, $38, $29, $89, $29, $26, $8f, $46, $29, $ff
00C79E  2  29 89 29 26  
00C7A2  2  8F 46 29 FF  
00C7A6  2               
00C7A6  2               ;level 7-3
00C7A6  2               E_GroundArea18:
00C7A6  2  0F 04 A3 10    .byte $0f, $04, $a3, $10, $0f, $09, $e3, $29, $0f, $0d, $55, $24, $a9, $24, $0f, $11
00C7AA  2  0F 09 E3 29  
00C7AE  2  0F 0D 55 24  
00C7B6  2  59 1D A9 1B    .byte $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
00C7BA  2  23 8F 15 9B  
00C7BE  2  FF           
00C7BF  2               
00C7BF  2               ;level 8-1
00C7BF  2               E_GroundArea19:
00C7BF  2  0F 01 DB 02    .byte $0f, $01, $db, $02, $30, $b7, $80, $3b, $1b, $8e, $4a, $0e, $eb, $03, $3b, $82
00C7C3  2  30 B7 80 3B  
00C7C7  2  1B 8E 4A 0E  
00C7CF  2  5B 02 E5 0F    .byte $5b, $02, $e5, $0f, $14, $8f, $44, $0f, $5b, $82, $0c, $85, $35, $8f, $06, $85
00C7D3  2  14 8F 44 0F  
00C7D7  2  5B 82 0C 85  
00C7DF  2  E3 05 DB 83    .byte $e3, $05, $db, $83, $3e, $84, $e0, $ff
00C7E3  2  3E 84 E0 FF  
00C7E7  2               
00C7E7  2               ;level 8-2
00C7E7  2               E_GroundArea22:
00C7E7  2  0F 02 0A 29    .byte $0f, $02, $0a, $29, $f7, $02, $80, $bc, $6b, $82, $7b, $02, $9b, $02, $ab, $02
00C7EB  2  F7 02 80 BC  
00C7EF  2  6B 82 7B 02  
00C7F7  2  39 8E 0F 07    .byte $39, $8e, $0f, $07, $ce, $35, $ec, $f5, $0f, $fb, $85, $fb, $85, $3e, $c4, $e3
00C7FB  2  CE 35 EC F5  
00C7FF  2  0F FB 85 FB  
00C807  2  A7 02 FF       .byte $a7, $02, $ff
00C80A  2               
00C80A  2               ;level 8-3
00C80A  2               E_GroundArea23:
00C80A  2  09 A9 86 11    .byte $09, $a9, $86, $11, $d5, $10, $a3, $8f, $d5, $29, $86, $91, $2b, $83, $58, $03
00C80E  2  D5 10 A3 8F  
00C812  2  D5 29 86 91  
00C81A  2  5B 85 EB 05    .byte $5b, $85, $eb, $05, $3e, $bc, $e0, $0f, $09, $43, $0f, $74, $0f, $6b, $85, $db
00C81E  2  3E BC E0 0F  
00C822  2  09 43 0F 74  
00C82A  2  05 C6 A4 19    .byte $05, $c6, $a4, $19, $a4, $12, $8f
00C82E  2  A4 12 8F     
00C831  2               ;another unused area
00C831  2               E_GroundArea24:
00C831  2  FF             .byte $ff
00C832  2               
00C832  2               ;cloud level used with level 5-1
00C832  2               E_GroundArea29:
00C832  2  0A AA 2E 2B    .byte $0a, $aa, $2e, $2b, $98, $2e, $36, $e7, $ff
00C836  2  98 2E 36 E7  
00C83A  2  FF           
00C83B  2               
00C83B  2               ;level 5-2
00C83B  2               E_UndergroundArea4:
00C83B  2  0B 83 B7 03    .byte $0b, $83, $b7, $03, $d7, $03, $0f, $05, $67, $03, $7b, $02, $9b, $02, $80, $b9
00C83F  2  D7 03 0F 05  
00C843  2  67 03 7B 02  
00C84B  2  3B 83 4E B4    .byte $3b, $83, $4e, $b4, $80, $86, $2b, $c9, $2c, $16, $ac, $67, $b4, $de, $3b, $81
00C84F  2  80 86 2B C9  
00C853  2  2C 16 AC 67  
00C85B  2  FF             .byte $ff
00C85C  2               
00C85C  2               ;underground bonus rooms used with worlds 5-8
00C85C  2               E_UndergroundArea5:
00C85C  2  1E AF CA 1E    .byte $1e, $af, $ca, $1e, $2c, $85, $0f, $04, $1e, $2d, $a7, $1e, $2f, $ce, $1e, $35
00C860  2  2C 85 0F 04  
00C864  2  1E 2D A7 1E  
00C86C  2  E5 0F 07 1E    .byte $e5, $0f, $07, $1e, $2b, $87, $1e, $30, $c5, $ff
00C870  2  2B 87 1E 30  
00C874  2  C5 FF        
00C876  2               
00C876  2               ;level 6-2
00C876  2               E_WaterArea2:
00C876  2  0F 01 2E 3B    .byte $0f, $01, $2e, $3b, $a1, $5b, $07, $ab, $07, $69, $87, $ba, $07, $fb, $87, $65
00C87A  2  A1 5B 07 AB  
00C87E  2  07 69 87 BA  
00C886  2  A7 6A 27 A6    .byte $a7, $6a, $27, $a6, $a7, $ac, $27, $1b, $87, $88, $07, $2b, $83, $7b, $07, $a7
00C88A  2  A7 AC 27 1B  
00C88E  2  87 88 07 2B  
00C896  2  90 E5 83 14    .byte $90, $e5, $83, $14, $a7, $19, $27, $77, $07, $f8, $07, $47, $8f, $b9, $07, $ff
00C89A  2  A7 19 27 77  
00C89E  2  07 F8 07 47  
00C8A6  2               
00C8A6  2               ;water area used in level 8-4
00C8A6  2               E_WaterArea4:
00C8A6  2  07 9B 0A 07    .byte $07, $9b, $0a, $07, $b9, $1b, $66, $9b, $78, $07, $ae, $67, $e5, $ff
00C8AA  2  B9 1B 66 9B  
00C8AE  2  78 07 AE 67  
00C8B4  2               
00C8B4  2               ;water area used in level 6-1
00C8B4  2               E_WaterArea5:
00C8B4  2  97 87 CB 00    .byte $97, $87, $cb, $00, $ee, $2b, $f8, $fe, $2d, $ad, $75, $87, $d3, $27, $d9, $27
00C8B8  2  EE 2B F8 FE  
00C8BC  2  2D AD 75 87  
00C8C4  2  0F 04 56 0F    .byte $0f, $04, $56, $0f, $ff
00C8C8  2  FF           
00C8C9  2               
00C8C9  2               ;level 5-4
00C8C9  2               L_CastleArea5:
00C8C9  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $03, $4c, $50, $4e, $07, $57, $31
00C8CD  2  06 33 07 33  
00C8D1  2  3E 03 4C 50  
00C8D9  2  6E 03 7C 52    .byte $6e, $03, $7c, $52, $9e, $07, $fe, $0a, $7e, $89, $9e, $0a, $ee, $09, $fe, $0b
00C8DD  2  9E 07 FE 0A  
00C8E1  2  7E 89 9E 0A  
00C8E9  2  13 8E 1E 09    .byte $13, $8e, $1e, $09, $3e, $0a, $6e, $09, $87, $0e, $9e, $02, $c6, $07, $ca, $0e
00C8ED  2  3E 0A 6E 09  
00C8F1  2  87 0E 9E 02  
00C8F9  2  F7 62 07 8E    .byte $f7, $62, $07, $8e, $08, $61, $17, $62, $1e, $0a, $4e, $06, $5e, $0a, $7e, $06
00C8FD  2  08 61 17 62  
00C901  2  1E 0A 4E 06  
00C909  2  8E 0A AE 06    .byte $8e, $0a, $ae, $06, $be, $07, $f3, $0e, $1e, $86, $2e, $0a, $84, $37, $93, $36
00C90D  2  BE 07 F3 0E  
00C911  2  1E 86 2E 0A  
00C919  2  A2 45 1E 89    .byte $a2, $45, $1e, $89, $46, $0e, $6e, $0a, $a7, $31, $db, $60, $f7, $60, $1b, $e0
00C91D  2  46 0E 6E 0A  
00C921  2  A7 31 DB 60  
00C929  2  37 31 7E 09    .byte $37, $31, $7e, $09, $8e, $0b, $a3, $0e, $fe, $04, $17, $bb, $47, $0e, $77, $0e
00C92D  2  8E 0B A3 0E  
00C931  2  FE 04 17 BB  
00C939  2  BE 02 CE 0A    .byte $be, $02, $ce, $0a, $07, $8e, $17, $31, $63, $31, $a7, $34, $c7, $0e, $13, $b1
00C93D  2  07 8E 17 31  
00C941  2  63 31 A7 34  
00C949  2  4E 09 1E 8A    .byte $4e, $09, $1e, $8a, $7e, $02, $97, $34, $b7, $0e, $ce, $0a, $de, $02, $d8, $61
00C94D  2  7E 02 97 34  
00C951  2  B7 0E CE 0A  
00C959  2  F7 62 FE 03    .byte $f7, $62, $fe, $03, $07, $b4, $17, $0e, $47, $62, $4e, $0a, $5e, $03, $51, $61
00C95D  2  07 B4 17 0E  
00C961  2  47 62 4E 0A  
00C969  2  67 62 77 34    .byte $67, $62, $77, $34, $b7, $62, $c1, $61, $da, $60, $e9, $61, $f8, $62, $fe, $0a
00C96D  2  B7 62 C1 61  
00C971  2  DA 60 E9 61  
00C979  2  0D C4 01 52    .byte $0d, $c4, $01, $52, $11, $52, $21, $52, $31, $52, $41, $52, $51, $52, $61, $52
00C97D  2  11 52 21 52  
00C981  2  31 52 41 52  
00C989  2  CD 43 CE 09    .byte $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7, $fd
00C98D  2  DE 0B DD 42  
00C991  2  FE 02 5D C7  
00C996  2               
00C996  2               ;level 6-4
00C996  2               L_CastleArea6:
00C996  2  5B 09 05 32    .byte $5b, $09, $05, $32, $06, $33, $4e, $0a, $87, $31, $fe, $02, $88, $f2, $c7, $33
00C99A  2  06 33 4E 0A  
00C99E  2  87 31 FE 02  
00C9A6  2  0D 02 07 0E    .byte $0d, $02, $07, $0e, $17, $34, $6e, $0a, $8e, $02, $bf, $67, $ed, $4b, $b7, $b6
00C9AA  2  17 34 6E 0A  
00C9AE  2  8E 02 BF 67  
00C9B6  2  C3 35 1E 8A    .byte $c3, $35, $1e, $8a, $2e, $02, $33, $3f, $37, $3f, $88, $f2, $c7, $33, $ed, $4b
00C9BA  2  2E 02 33 3F  
00C9BE  2  37 3F 88 F2  
00C9C6  2  0D 06 03 33    .byte $0d, $06, $03, $33, $0f, $74, $47, $73, $67, $73, $7e, $09, $9e, $0a, $ed, $4b
00C9CA  2  0F 74 47 73  
00C9CE  2  67 73 7E 09  
00C9D6  2  F7 32 07 8E    .byte $f7, $32, $07, $8e, $97, $0e, $ae, $00, $de, $02, $e3, $35, $e7, $35, $3e, $8a
00C9DA  2  97 0E AE 00  
00C9DE  2  DE 02 E3 35  
00C9E6  2  4E 02 53 3E    .byte $4e, $02, $53, $3e, $57, $3e, $07, $8e, $a7, $34, $bf, $63, $ed, $4b, $2e, $8a
00C9EA  2  57 3E 07 8E  
00C9EE  2  A7 34 BF 63  
00C9F6  2  FE 06 2E 88    .byte $fe, $06, $2e, $88, $34, $33, $35, $33, $6e, $06, $8e, $0c, $be, $06, $fe, $0a
00C9FA  2  34 33 35 33  
00C9FE  2  6E 06 8E 0C  
00CA06  2  01 D2 0D 44    .byte $01, $d2, $0d, $44, $11, $52, $21, $52, $31, $52, $41, $52, $42, $0b, $51, $52
00CA0A  2  11 52 21 52  
00CA0E  2  31 52 41 52  
00CA16  2  61 52 CD 43    .byte $61, $52, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00CA1A  2  CE 09 DD 42  
00CA1E  2  DE 0B FE 02  
00CA25  2               
00CA25  2               ;level 7-4
00CA25  2               L_CastleArea7:
00CA25  2  58 07 05 35    .byte $58, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
00CA29  2  06 3D 07 3D  
00CA2D  2  BE 06 DE 0C  
00CA35  2  6E 43 CE 0A    .byte $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05, $28, $39
00CA39  2  E1 67 F1 67  
00CA3D  2  01 E7 11 67  
00CA45  2  6E 40 BE 01    .byte $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00, $bf, $00
00CA49  2  C7 06 DB 0E  
00CA4D  2  DE 00 1F 80  
00CA55  2  0F 80 5F 00    .byte $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30, $3e, $0c
00CA59  2  7E 05 A8 37  
00CA5D  2  FE 02 24 8E  
00CA65  2  4E 43 AE 0A    .byte $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c, $7e, $02
00CA69  2  BE 0C EE 0A  
00CA6D  2  FE 0C 2E 8A  
00CA75  2  8E 0E 98 36    .byte $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86, $4e, $0c
00CA79  2  B9 34 08 BF  
00CA7D  2  09 3F 0E 82  
00CA85  2  9E 09 C1 62    .byte $9e, $09, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c, $7e, $09, $a1, $62
00CA89  2  C4 0E EE 0C  
00CA8D  2  0E 86 5E 0C  
00CA95  2  A4 0E CE 0C    .byte $a4, $0e, $ce, $0c, $fe, $0a, $28, $b4, $a6, $31, $e8, $34, $8b, $b2, $9b, $0e
00CA99  2  FE 0A 28 B4  
00CA9D  2  A6 31 E8 34  
00CAA5  2  FE 07 FE 8A    .byte $fe, $07, $fe, $8a, $0d, $c4, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
00CAA9  2  0D C4 CD 43  
00CAAD  2  CE 09 DD 42  
00CAB5  2  5D C7 FD       .byte $5d, $c7, $fd
00CAB8  2               
00CAB8  2               ;level 8-4
00CAB8  2               L_CastleArea8:
00CAB8  2  5B 03 05 34    .byte $5b, $03, $05, $34, $06, $35, $07, $36, $6e, $0a, $ee, $02, $fe, $05, $0d, $01
00CABC  2  06 35 07 36  
00CAC0  2  6E 0A EE 02  
00CAC8  2  17 0E 97 0E    .byte $17, $0e, $97, $0e, $9e, $02, $c6, $05, $fa, $30, $fe, $0a, $4e, $82, $57, $0e
00CACC  2  9E 02 C6 05  
00CAD0  2  FA 30 FE 0A  
00CAD8  2  58 62 68 62    .byte $58, $62, $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $7b, $39, $f3
00CADC  2  79 61 8A 60  
00CAE0  2  8E 0A F5 31  
00CAE8  2  97 33 B5 71    .byte $97, $33, $b5, $71, $39, $f3, $4d, $48, $9e, $02, $ae, $05, $cd, $4a, $ed, $4b
00CAEC  2  39 F3 4D 48  
00CAF0  2  9E 02 AE 05  
00CAF8  2  0E 81 17 06    .byte $0e, $81, $17, $06, $39, $73, $5c, $02, $85, $65, $95, $32, $a9, $7b, $cc, $03
00CAFC  2  39 73 5C 02  
00CB00  2  85 65 95 32  
00CB08  2  5E 8F 6D 47    .byte $5e, $8f, $6d, $47, $fe, $02, $0d, $07, $39, $73, $4e, $0a, $ae, $02, $ec, $71
00CB0C  2  FE 02 0D 07  
00CB10  2  39 73 4E 0A  
00CB18  2  07 81 17 02    .byte $07, $81, $17, $02, $39, $73, $e6, $05, $39, $fb, $4e, $0a, $c4, $31, $eb, $61
00CB1C  2  39 73 E6 05  
00CB20  2  39 FB 4E 0A  
00CB28  2  FE 02 07 B0    .byte $fe, $02, $07, $b0, $1e, $0a, $4e, $06, $57, $0e, $be, $02, $c9, $61, $da, $60
00CB2C  2  1E 0A 4E 06  
00CB30  2  57 0E BE 02  
00CB38  2  ED 4B 0E 85    .byte $ed, $4b, $0e, $85, $0d, $0e, $fe, $0a, $78, $e4, $8e, $06, $b3, $06, $bf, $47
00CB3C  2  0D 0E FE 0A  
00CB40  2  78 E4 8E 06  
00CB48  2  EE 0F 6D C7    .byte $ee, $0f, $6d, $c7, $0e, $82, $39, $73, $9a, $60, $a9, $61, $ae, $06, $de, $0a
00CB4C  2  0E 82 39 73  
00CB50  2  9A 60 A9 61  
00CB58  2  E7 03 EB 79    .byte $e7, $03, $eb, $79, $f7, $03, $fe, $06, $0d, $14, $fe, $0a, $5e, $82, $7f, $66
00CB5C  2  F7 03 FE 06  
00CB60  2  0D 14 FE 0A  
00CB68  2  9E 0A F8 64    .byte $9e, $0a, $f8, $64, $fe, $0b, $9e, $84, $be, $05, $be, $82, $da, $60, $e9, $61
00CB6C  2  FE 0B 9E 84  
00CB70  2  BE 05 BE 82  
00CB78  2  F8 62 FE 0A    .byte $f8, $62, $fe, $0a, $0d, $c4, $11, $64, $51, $62, $cd, $43, $ce, $09, $dd, $42
00CB7C  2  0D C4 11 64  
00CB80  2  51 62 CD 43  
00CB88  2  DE 0B FE 02    .byte $de, $0b, $fe, $02, $5d, $c7, $fd
00CB8C  2  5D C7 FD     
00CB8F  2               
00CB8F  2               ;level 5-1
00CB8F  2               L_GroundArea12:
00CB8F  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $75, $cc, $73, $a3, $b3, $bf, $74, $0c, $84, $83, $3f
00CB93  2  6E 75 CC 73  
00CB97  2  A3 B3 BF 74  
00CB9F  2  9F 74 EF 71    .byte $9f, $74, $ef, $71, $ec, $01, $2f, $f1, $2c, $01, $6f, $71, $6c, $01, $a8, $91
00CBA3  2  EC 01 2F F1  
00CBA7  2  2C 01 6F 71  
00CBAF  2  AA 10 77 FB    .byte $aa, $10, $77, $fb, $56, $f4, $39, $f1, $bf, $37, $33, $e7, $43, $04, $47, $03
00CBB3  2  56 F4 39 F1  
00CBB7  2  BF 37 33 E7  
00CBBF  2  6C 05 C3 67    .byte $6c, $05, $c3, $67, $d3, $67, $e3, $67, $ed, $4c, $fc, $07, $73, $e7, $83, $67
00CBC3  2  D3 67 E3 67  
00CBC7  2  ED 4C FC 07  
00CBCF  2  93 67 A3 67    .byte $93, $67, $a3, $67, $bc, $08, $43, $e7, $53, $67, $dc, $02, $59, $91, $c3, $33
00CBD3  2  BC 08 43 E7  
00CBD7  2  53 67 DC 02  
00CBDF  2  D9 71 DF 72    .byte $d9, $71, $df, $72, $2d, $cd, $5b, $71, $9b, $71, $3b, $f1, $a7, $c2, $db, $71
00CBE3  2  2D CD 5B 71  
00CBE7  2  9B 71 3B F1  
00CBEF  2  0D 10 9B 71    .byte $0d, $10, $9b, $71, $0a, $b0, $1c, $04, $67, $63, $76, $64, $85, $65, $94, $66
00CBF3  2  0A B0 1C 04  
00CBF7  2  67 63 76 64  
00CBFF  2  A3 67 B3 67    .byte $a3, $67, $b3, $67, $cc, $09, $73, $a3, $87, $22, $b3, $09, $d6, $83, $e3, $03
00CC03  2  CC 09 73 A3  
00CC07  2  87 22 B3 09  
00CC0F  2  FE 3F 0D 15    .byte $fe, $3f, $0d, $15, $de, $31, $ec, $01, $03, $f7, $9d, $41, $df, $26, $0d, $18
00CC13  2  DE 31 EC 01  
00CC17  2  03 F7 9D 41  
00CC1F  2  39 71 7F 37    .byte $39, $71, $7f, $37, $f2, $68, $01, $e9, $11, $39, $68, $7a, $de, $3f, $6d, $c5
00CC23  2  F2 68 01 E9  
00CC27  2  11 39 68 7A  
00CC2F  2  FD             .byte $fd
00CC30  2               
00CC30  2               ;level 5-3
00CC30  2               L_GroundArea13:
00CC30  2  50 11 0F 26    .byte $50, $11, $0f, $26, $df, $32, $fe, $10, $0d, $01, $98, $74, $c8, $13, $52, $e1
00CC34  2  DF 32 FE 10  
00CC38  2  0D 01 98 74  
00CC40  2  63 31 61 79    .byte $63, $31, $61, $79, $c6, $61, $06, $e1, $8b, $71, $ab, $71, $e4, $19, $eb, $19
00CC44  2  C6 61 06 E1  
00CC48  2  8B 71 AB 71  
00CC50  2  60 86 C8 13    .byte $60, $86, $c8, $13, $cd, $4b, $39, $f3, $98, $13, $17, $f5, $7c, $15, $7f, $13
00CC54  2  CD 4B 39 F3  
00CC58  2  98 13 17 F5  
00CC60  2  CF 15 D4 40    .byte $cf, $15, $d4, $40, $0b, $9a, $23, $16, $32, $44, $a3, $95, $b2, $43, $0d, $0a
00CC64  2  0B 9A 23 16  
00CC68  2  32 44 A3 95  
00CC70  2  27 14 3D 4A    .byte $27, $14, $3d, $4a, $a4, $40, $bc, $16, $bf, $13, $c4, $40, $04, $c0, $1f, $16
00CC74  2  A4 40 BC 16  
00CC78  2  BF 13 C4 40  
00CC80  2  24 40 43 31    .byte $24, $40, $43, $31, $ce, $11, $dd, $41, $0e, $d2, $3f, $20, $3d, $c7, $fd
00CC84  2  CE 11 DD 41  
00CC88  2  0E D2 3F 20  
00CC8F  2               
00CC8F  2               ;level 6-1
00CC8F  2               L_GroundArea14:
00CC8F  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $40, $d6, $61, $e7, $07, $f7, $21, $16, $e1, $34, $63
00CC93  2  6E 40 D6 61  
00CC97  2  E7 07 F7 21  
00CC9F  2  47 21 54 04    .byte $47, $21, $54, $04, $67, $0a, $74, $63, $dc, $01, $06, $e1, $17, $26, $86, $61
00CCA3  2  67 0A 74 63  
00CCA7  2  DC 01 06 E1  
00CCAF  2  66 C2 58 C1    .byte $66, $c2, $58, $c1, $f7, $03, $04, $f6, $8a, $10, $9c, $04, $e8, $62, $f9, $61
00CCB3  2  F7 03 04 F6  
00CCB7  2  8A 10 9C 04  
00CCBF  2  0A E0 53 31    .byte $0a, $e0, $53, $31, $5f, $73, $7b, $71, $77, $25, $fc, $e2, $17, $aa, $23, $00
00CCC3  2  5F 73 7B 71  
00CCC7  2  77 25 FC E2  
00CCCF  2  3C 67 B3 01    .byte $3c, $67, $b3, $01, $cc, $63, $db, $71, $df, $73, $fc, $00, $4f, $b7, $ca, $7a
00CCD3  2  CC 63 DB 71  
00CCD7  2  DF 73 FC 00  
00CCDF  2  C5 31 EC 54    .byte $c5, $31, $ec, $54, $3c, $dc, $5d, $4c, $0f, $b3, $47, $63, $6b, $f1, $8c, $0a
00CCE3  2  3C DC 5D 4C  
00CCE7  2  0F B3 47 63  
00CCEF  2  39 F1 EC 03    .byte $39, $f1, $ec, $03, $f0, $33, $0f, $e2, $29, $73, $49, $61, $58, $62, $67, $73
00CCF3  2  F0 33 0F E2  
00CCF7  2  29 73 49 61  
00CCFF  2  85 65 94 66    .byte $85, $65, $94, $66, $a3, $77, $ad, $4d, $4d, $c1, $6f, $26, $5d, $c7, $fd
00CD03  2  A3 77 AD 4D  
00CD07  2  4D C1 6F 26  
00CD0E  2               
00CD0E  2               ;level 6-3
00CD0E  2               L_GroundArea15:
00CD0E  2  50 11 0F 26    .byte $50, $11, $0f, $26, $af, $32, $d8, $62, $de, $10, $08, $e4, $5a, $62, $6c, $4c
00CD12  2  AF 32 D8 62  
00CD16  2  DE 10 08 E4  
00CD1E  2  86 43 AD 48    .byte $86, $43, $ad, $48, $3a, $e2, $53, $42, $88, $64, $9c, $36, $08, $e4, $4a, $62
00CD22  2  3A E2 53 42  
00CD26  2  88 64 9C 36  
00CD2E  2  5C 4D 3A E2    .byte $5c, $4d, $3a, $e2, $9c, $32, $fc, $41, $3c, $b1, $83, $00, $ac, $42, $2a, $e2
00CD32  2  9C 32 FC 41  
00CD36  2  3C B1 83 00  
00CD3E  2  3C 46 AA 62    .byte $3c, $46, $aa, $62, $bc, $4e, $c6, $43, $46, $c3, $aa, $62, $bd, $48, $0b, $96
00CD42  2  BC 4E C6 43  
00CD46  2  46 C3 AA 62  
00CD4E  2  47 07 C7 12    .byte $47, $07, $c7, $12, $3c, $c2, $9c, $41, $cd, $48, $dc, $32, $4c, $c2, $bc, $32
00CD52  2  3C C2 9C 41  
00CD56  2  CD 48 DC 32  
00CD5E  2  1C B1 5A 62    .byte $1c, $b1, $5a, $62, $6c, $44, $76, $43, $ba, $62, $dc, $32, $5d, $ca, $73, $12
00CD62  2  6C 44 76 43  
00CD66  2  BA 62 DC 32  
00CD6E  2  E3 12 8E 91    .byte $e3, $12, $8e, $91, $9d, $41, $be, $42, $ef, $20, $cd, $c7, $fd
00CD72  2  9D 41 BE 42  
00CD76  2  EF 20 CD C7  
00CD7B  2               
00CD7B  2               ;level 7-1
00CD7B  2               L_GroundArea16:
00CD7B  2  52 B1 0F 20    .byte $52, $b1, $0f, $20, $6e, $76, $03, $b1, $09, $71, $0f, $71, $6f, $33, $a7, $63
00CD7F  2  6E 76 03 B1  
00CD83  2  09 71 0F 71  
00CD8B  2  B7 34 BC 0E    .byte $b7, $34, $bc, $0e, $4d, $cc, $03, $a6, $08, $72, $3f, $72, $6d, $4c, $73, $07
00CD8F  2  4D CC 03 A6  
00CD93  2  08 72 3F 72  
00CD9B  2  77 73 83 27    .byte $77, $73, $83, $27, $ac, $00, $bf, $73, $3c, $80, $9a, $30, $ac, $5b, $c6, $3c
00CD9F  2  AC 00 BF 73  
00CDA3  2  3C 80 9A 30  
00CDAB  2  6A B0 75 10    .byte $6a, $b0, $75, $10, $96, $74, $b6, $0a, $da, $30, $e3, $28, $ec, $5b, $ed, $48
00CDAF  2  96 74 B6 0A  
00CDB3  2  DA 30 E3 28  
00CDBB  2  AA B0 33 B4    .byte $aa, $b0, $33, $b4, $51, $79, $ad, $4a, $dd, $4d, $e3, $2c, $0c, $fa, $73, $07
00CDBF  2  51 79 AD 4A  
00CDC3  2  DD 4D E3 2C  
00CDCB  2  B3 04 CB 71    .byte $b3, $04, $cb, $71, $ec, $07, $0d, $0a, $39, $71, $df, $33, $ca, $b0, $d6, $10
00CDCF  2  EC 07 0D 0A  
00CDD3  2  39 71 DF 33  
00CDDB  2  D7 30 DC 0C    .byte $d7, $30, $dc, $0c, $03, $b1, $ad, $41, $ef, $26, $ed, $c7, $39, $f1, $0d, $10
00CDDF  2  03 B1 AD 41  
00CDE3  2  EF 26 ED C7  
00CDEB  2  7D 4C 0D 13    .byte $7d, $4c, $0d, $13, $a8, $11, $aa, $10, $1c, $83, $d7, $7b, $f3, $67, $5d, $cd
00CDEF  2  A8 11 AA 10  
00CDF3  2  1C 83 D7 7B  
00CDFB  2  6D 47 FD       .byte $6d, $47, $fd
00CDFE  2               
00CDFE  2               ;level 7-2
00CDFE  2               L_GroundArea17:
00CDFE  2  56 11 0F 26    .byte $56, $11, $0f, $26, $df, $32, $fe, $11, $0d, $01, $0c, $5f, $03, $80, $0c, $52
00CE02  2  DF 32 FE 11  
00CE06  2  0D 01 0C 5F  
00CE0E  2  29 15 7C 5B    .byte $29, $15, $7c, $5b, $23, $b2, $29, $1f, $31, $79, $1c, $de, $48, $3b, $ed, $4b
00CE12  2  23 B2 29 1F  
00CE16  2  31 79 1C DE  
00CE1E  2  39 F1 CF B3    .byte $39, $f1, $cf, $b3, $fe, $10, $37, $8e, $77, $0e, $9e, $11, $a8, $34, $a9, $34
00CE22  2  FE 10 37 8E  
00CE26  2  77 0E 9E 11  
00CE2E  2  AA 34 F8 62    .byte $aa, $34, $f8, $62, $fe, $10, $37, $b6, $de, $11, $e7, $63, $f8, $62, $09, $e1
00CE32  2  FE 10 37 B6  
00CE36  2  DE 11 E7 63  
00CE3E  2  0E 10 47 36    .byte $0e, $10, $47, $36, $b7, $0e, $be, $91, $ca, $32, $ee, $10, $1d, $ca, $7e, $11
00CE42  2  B7 0E BE 91  
00CE46  2  CA 32 EE 10  
00CE4E  2  83 77 9E 10    .byte $83, $77, $9e, $10, $1e, $91, $2d, $41, $4f, $26, $4d, $c7, $fd
00CE52  2  1E 91 2D 41  
00CE56  2  4F 26 4D C7  
00CE5B  2               
00CE5B  2               ;level 7-3
00CE5B  2               L_GroundArea18:
00CE5B  2  57 11 0F 26    .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
00CE5F  2  FE 10 4B 92  
00CE63  2  59 0F AD 4C  
00CE6B  2  29 0F 7B 93    .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
00CE6F  2  99 0F 0D 06  
00CE73  2  27 12 35 0F  
00CE7B  2  A3 31 AB 71    .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
00CE7F  2  F7 75 23 B1  
00CE83  2  87 13 95 0F  
00CE8B  2  38 13 55 00    .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $3b, $92, $49, $0f, $ad, $4c
00CE8F  2  9B 16 0B 96  
00CE93  2  C7 75 3B 92  
00CE9B  2  29 92 52 40    .byte $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93, $0a, $13
00CE9F  2  6C 15 6F 11  
00CEA3  2  72 40 BF 15  
00CEAB  2  12 41 8B 12    .byte $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32, $13, $b1
00CEAF  2  99 0F 0D 10  
00CEB3  2  47 16 46 45  
00CEBB  2  57 0E A7 0E    .byte $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e, $8d, $4d
00CEBF  2  D3 31 53 B1  
00CEC3  2  A6 31 03 B2  
00CECB  2  AE 11 BD 41    .byte $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
00CECF  2  EE 52 0F A0  
00CED3  2  DD 47 FD     
00CED6  2               
00CED6  2               ;level 8-1
00CED6  2               L_GroundArea19:
00CED6  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $65, $57, $f3, $60, $21, $6f, $62, $ac, $75, $07, $80
00CEDA  2  6E 65 57 F3  
00CEDE  2  60 21 6F 62  
00CEE6  2  1C 76 87 01    .byte $1c, $76, $87, $01, $9c, $70, $b0, $33, $cf, $66, $57, $e3, $6c, $04, $cd, $4c
00CEEA  2  9C 70 B0 33  
00CEEE  2  CF 66 57 E3  
00CEF6  2  9A B0 AC 0C    .byte $9a, $b0, $ac, $0c, $83, $b1, $8f, $74, $bd, $4d, $f8, $11, $fa, $10, $83, $87
00CEFA  2  83 B1 8F 74  
00CEFE  2  BD 4D F8 11  
00CF06  2  93 22 9F 74    .byte $93, $22, $9f, $74, $59, $f1, $89, $61, $a9, $61, $bc, $0c, $67, $a0, $eb, $71
00CF0A  2  59 F1 89 61  
00CF0E  2  A9 61 BC 0C  
00CF16  2  77 87 7A 10    .byte $77, $87, $7a, $10, $86, $51, $95, $52, $a4, $53, $b6, $04, $b3, $24, $26, $85
00CF1A  2  86 51 95 52  
00CF1E  2  A4 53 B6 04  
00CF26  2  4A 10 53 23    .byte $4a, $10, $53, $23, $5c, $00, $6f, $73, $93, $08, $07, $fb, $2c, $04, $33, $30
00CF2A  2  5C 00 6F 73  
00CF2E  2  93 08 07 FB  
00CF36  2  74 76 EB 71    .byte $74, $76, $eb, $71, $57, $8b, $6c, $02, $96, $74, $e3, $30, $0c, $86, $7d, $41
00CF3A  2  57 8B 6C 02  
00CF3E  2  96 74 E3 30  
00CF46  2  BF 26 BD C7    .byte $bf, $26, $bd, $c7, $fd
00CF4A  2  FD           
00CF4B  2               
00CF4B  2               ;level 8-2
00CF4B  2               L_GroundArea22:
00CF4B  2  50 61 0F 26    .byte $50, $61, $0f, $26, $bb, $f1, $dc, $06, $23, $87, $b5, $71, $b7, $31, $d7, $28
00CF4F  2  BB F1 DC 06  
00CF53  2  23 87 B5 71  
00CF5B  2  06 C5 67 08    .byte $06, $c5, $67, $08, $0d, $05, $39, $71, $7c, $00, $9e, $62, $b6, $0b, $e6, $08
00CF5F  2  0D 05 39 71  
00CF63  2  7C 00 9E 62  
00CF6B  2  4E E0 5D 4C    .byte $4e, $e0, $5d, $4c, $59, $0f, $6c, $02, $93, $67, $ac, $56, $ad, $4c, $1f, $b1
00CF6F  2  59 0F 6C 02  
00CF73  2  93 67 AC 56  
00CF7B  2  3C 01 98 0A    .byte $3c, $01, $98, $0a, $9e, $20, $a8, $21, $f3, $09, $0e, $a1, $27, $20, $3e, $62
00CF7F  2  9E 20 A8 21  
00CF83  2  F3 09 0E A1  
00CF8B  2  56 08 7D 4D    .byte $56, $08, $7d, $4d, $c6, $08, $3e, $e0, $9e, $62, $b6, $08, $1e, $e0, $4c, $00
00CF8F  2  C6 08 3E E0  
00CF93  2  9E 62 B6 08  
00CF9B  2  6C 00 A7 7B    .byte $6c, $00, $a7, $7b, $de, $2f, $6d, $c7, $fe, $10, $0b, $93, $5b, $15, $b7, $12
00CF9F  2  DE 2F 6D C7  
00CFA3  2  FE 10 0B 93  
00CFAB  2  03 91 AB 1F    .byte $03, $91, $ab, $1f, $bd, $41, $ef, $26, $ad, $c7, $fd
00CFAF  2  BD 41 EF 26  
00CFB3  2  AD C7 FD     
00CFB6  2               
00CFB6  2               ;level 8-3
00CFB6  2               L_GroundArea23:
00CFB6  2  50 50 0F 26    .byte $50, $50, $0f, $26, $0b, $1f, $57, $92, $8b, $12, $d2, $14, $4b, $92, $59, $0f
00CFBA  2  0B 1F 57 92  
00CFBE  2  8B 12 D2 14  
00CFC6  2  0B 95 BB 1F    .byte $0b, $95, $bb, $1f, $be, $52, $58, $e2, $9e, $50, $97, $08, $bb, $1f, $ae, $d2
00CFCA  2  BE 52 58 E2  
00CFCE  2  9E 50 97 08  
00CFD6  2  B6 08 BB 1F    .byte $b6, $08, $bb, $1f, $dd, $4a, $f6, $07, $26, $89, $8e, $50, $98, $62, $eb, $11
00CFDA  2  DD 4A F6 07  
00CFDE  2  26 89 8E 50  
00CFE6  2  07 F3 0B 1D    .byte $07, $f3, $0b, $1d, $2e, $52, $47, $0a, $ce, $50, $eb, $1f, $ee, $52, $5e, $d0
00CFEA  2  2E 52 47 0A  
00CFEE  2  CE 50 EB 1F  
00CFF6  2  D9 0F AB 9F    .byte $d9, $0f, $ab, $9f, $be, $52, $8e, $d0, $ab, $1d, $ae, $52, $36, $8b, $56, $08
00CFFA  2  BE 52 8E D0  
00CFFE  2  AB 1D AE 52  
00D006  2  5E 50 DC 15    .byte $5e, $50, $dc, $15, $df, $12, $2f, $95, $c3, $31, $5b, $9f, $6d, $41, $8e, $52
00D00A  2  DF 12 2F 95  
00D00E  2  C3 31 5B 9F  
00D016  2  AF 20 AD C7    .byte $af, $20, $ad, $c7
00D01A  2               ;another unused area
00D01A  2               L_GroundArea24:
00D01A  2  FD             .byte $fd
00D01B  2               
00D01B  2               ;cloud level used with level 5-1
00D01B  2               L_GroundArea29:
00D01B  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $f3, $4f, $fa, $c6, $68, $a0, $69, $20, $6a, $20, $7a, $47
00D01F  2  F3 4F FA C6  
00D023  2  68 A0 69 20  
00D02B  2  F8 20 F9 20    .byte $f8, $20, $f9, $20, $fa, $20, $0a, $cf, $b4, $49, $55, $a0, $56, $20, $73, $47
00D02F  2  FA 20 0A CF  
00D033  2  B4 49 55 A0  
00D03B  2  F5 20 F6 20    .byte $f5, $20, $f6, $20, $22, $a1, $41, $48, $52, $20, $72, $20, $92, $20, $b2, $20
00D03F  2  22 A1 41 48  
00D043  2  52 20 72 20  
00D04B  2  FE 00 9B C2    .byte $fe, $00, $9b, $c2, $ad, $c7, $fd
00D04F  2  AD C7 FD     
00D052  2               
00D052  2               ;level 5-2
00D052  2               L_UndergroundArea4:
00D052  2  48 0F 1E 01    .byte $48, $0f, $1e, $01, $27, $06, $5e, $02, $8f, $63, $8c, $01, $ef, $67, $1c, $81
00D056  2  27 06 5E 02  
00D05A  2  8F 63 8C 01  
00D062  2  2E 09 3C 63    .byte $2e, $09, $3c, $63, $73, $01, $8c, $60, $fe, $02, $1e, $8e, $3e, $02, $44, $07
00D066  2  73 01 8C 60  
00D06A  2  FE 02 1E 8E  
00D072  2  45 52 4E 0E    .byte $45, $52, $4e, $0e, $8e, $02, $99, $71, $b5, $24, $b6, $24, $b7, $24, $fe, $02
00D076  2  8E 02 99 71  
00D07A  2  B5 24 B6 24  
00D082  2  07 87 17 22    .byte $07, $87, $17, $22, $37, $52, $37, $0b, $47, $52, $4e, $0a, $57, $52, $5e, $02
00D086  2  37 52 37 0B  
00D08A  2  47 52 4E 0A  
00D092  2  67 52 77 52    .byte $67, $52, $77, $52, $7e, $0a, $87, $52, $8e, $02, $96, $46, $97, $52, $a7, $52
00D096  2  7E 0A 87 52  
00D09A  2  8E 02 96 46  
00D0A2  2  B7 52 C7 52    .byte $b7, $52, $c7, $52, $d7, $52, $e7, $52, $f7, $52, $fe, $04, $07, $a3, $47, $08
00D0A6  2  D7 52 E7 52  
00D0AA  2  F7 52 FE 04  
00D0B2  2  57 26 C7 0A    .byte $57, $26, $c7, $0a, $e9, $71, $17, $a7, $97, $08, $9e, $01, $a0, $24, $c6, $74
00D0B6  2  E9 71 17 A7  
00D0BA  2  97 08 9E 01  
00D0C2  2  F0 0C FE 04    .byte $f0, $0c, $fe, $04, $0c, $80, $6f, $32, $98, $62, $a8, $62, $bc, $00, $c7, $73
00D0C6  2  0C 80 6F 32  
00D0CA  2  98 62 A8 62  
00D0D2  2  E7 73 FE 02    .byte $e7, $73, $fe, $02, $7f, $e7, $8e, $01, $9e, $00, $de, $02, $f7, $0b, $fe, $0e
00D0D6  2  7F E7 8E 01  
00D0DA  2  9E 00 DE 02  
00D0E2  2  4E 82 54 52    .byte $4e, $82, $54, $52, $64, $51, $6e, $00, $74, $09, $9f, $00, $df, $00, $2f, $80
00D0E6  2  64 51 6E 00  
00D0EA  2  74 09 9F 00  
00D0F2  2  4E 02 59 47    .byte $4e, $02, $59, $47, $ce, $0a, $07, $f5, $68, $54, $7f, $64, $88, $54, $a8, $54
00D0F6  2  CE 0A 07 F5  
00D0FA  2  68 54 7F 64  
00D102  2  AE 01 B8 52    .byte $ae, $01, $b8, $52, $bf, $47, $c8, $52, $d8, $52, $e8, $52, $ee, $0f, $4d, $c7
00D106  2  BF 47 C8 52  
00D10A  2  D8 52 E8 52  
00D112  2  0D 0D 0E 02    .byte $0d, $0d, $0e, $02, $68, $7a, $be, $01, $ee, $0f, $6d, $c5, $fd
00D116  2  68 7A BE 01  
00D11A  2  EE 0F 6D C5  
00D11F  2               
00D11F  2               ;underground bonus rooms used with worlds 5-8
00D11F  2               L_UndergroundArea5:
00D11F  2  08 0F 0E 01    .byte $08, $0f, $0e, $01, $2e, $05, $38, $2c, $3a, $4f, $08, $ac, $c7, $0b, $ce, $01
00D123  2  2E 05 38 2C  
00D127  2  3A 4F 08 AC  
00D12F  2  DF 4A 6D C7    .byte $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $2e, $02, $b8, $4f, $cf, $65, $0f, $e5
00D133  2  0E 81 00 5A  
00D137  2  2E 02 B8 4F  
00D13F  2  4F 65 8F 65    .byte $4f, $65, $8f, $65, $df, $4a, $6d, $c7, $0e, $81, $00, $5a, $30, $07, $34, $52
00D143  2  DF 4A 6D C7  
00D147  2  0E 81 00 5A  
00D14F  2  3E 02 42 47    .byte $3e, $02, $42, $47, $44, $47, $46, $27, $c0, $0b, $c4, $52, $df, $4a, $6d, $c7
00D153  2  44 47 46 27  
00D157  2  C0 0B C4 52  
00D15F  2  FD             .byte $fd
00D160  2               
00D160  2               ;level 6-2
00D160  2               L_WaterArea2:
00D160  2  41 01 27 D3    .byte $41, $01, $27, $d3, $79, $51, $c4, $56, $00, $e2, $03, $53, $0c, $0f, $12, $3b
00D164  2  79 51 C4 56  
00D168  2  00 E2 03 53  
00D170  2  1A 42 43 54    .byte $1a, $42, $43, $54, $6d, $49, $83, $53, $99, $53, $c3, $54, $da, $52, $0c, $84
00D174  2  6D 49 83 53  
00D178  2  99 53 C3 54  
00D180  2  09 53 53 64    .byte $09, $53, $53, $64, $63, $31, $67, $34, $86, $41, $8c, $01, $a3, $30, $b3, $64
00D184  2  63 31 67 34  
00D188  2  86 41 8C 01  
00D190  2  CC 03 D9 42    .byte $cc, $03, $d9, $42, $5c, $84, $a0, $62, $a8, $62, $b0, $62, $b8, $62, $c0, $62
00D194  2  5C 84 A0 62  
00D198  2  A8 62 B0 62  
00D1A0  2  C8 62 D0 62    .byte $c8, $62, $d0, $62, $d8, $62, $e0, $62, $e8, $62, $16, $c2, $58, $52, $8c, $04
00D1A4  2  D8 62 E0 62  
00D1A8  2  E8 62 16 C2  
00D1B0  2  A7 55 D0 63    .byte $a7, $55, $d0, $63, $d7, $65, $e2, $61, $e7, $65, $f2, $61, $f7, $65, $13, $b8
00D1B4  2  D7 65 E2 61  
00D1B8  2  E7 65 F2 61  
00D1C0  2  17 38 8C 03    .byte $17, $38, $8c, $03, $1d, $c9, $50, $62, $5c, $0b, $62, $3e, $63, $52, $8a, $52
00D1C4  2  1D C9 50 62  
00D1C8  2  5C 0B 62 3E  
00D1D0  2  93 54 AA 42    .byte $93, $54, $aa, $42, $d3, $51, $ea, $41, $03, $d3, $1c, $04, $1a, $52, $33, $55
00D1D4  2  D3 51 EA 41  
00D1D8  2  03 D3 1C 04  
00D1E0  2  73 44 77 44    .byte $73, $44, $77, $44, $16, $d2, $19, $31, $1a, $32, $5c, $0f, $9a, $47, $95, $64
00D1E4  2  16 D2 19 31  
00D1E8  2  1A 32 5C 0F  
00D1F0  2  A5 64 B5 64    .byte $a5, $64, $b5, $64, $c5, $64, $d5, $64, $e5, $64, $f5, $64, $05, $e4, $40, $61
00D1F4  2  C5 64 D5 64  
00D1F8  2  E5 64 F5 64  
00D200  2  42 35 56 34    .byte $42, $35, $56, $34, $5c, $09, $a2, $61, $a6, $61, $b3, $34, $b7, $34, $fc, $08
00D204  2  5C 09 A2 61  
00D208  2  A6 61 B3 34  
00D210  2  0C 87 28 54    .byte $0c, $87, $28, $54, $59, $53, $9a, $30, $a9, $61, $b8, $62, $be, $0b, $d4, $60
00D214  2  59 53 9A 30  
00D218  2  A9 61 B8 62  
00D220  2  D5 0D DE 0F    .byte $d5, $0d, $de, $0f, $0d, $ca, $7d, $47, $fd
00D224  2  0D CA 7D 47  
00D228  2  FD           
00D229  2               
00D229  2               ;water area used in level 8-4
00D229  2               L_WaterArea4:
00D229  2  07 0F 0E 02    .byte $07, $0f, $0e, $02, $39, $73, $05, $8e, $2e, $0b, $b7, $0e, $64, $8e, $6e, $02
00D22D  2  39 73 05 8E  
00D231  2  2E 0B B7 0E  
00D239  2  CE 06 DE 0F    .byte $ce, $06, $de, $0f, $e6, $0d, $7d, $c7, $fd
00D23D  2  E6 0D 7D C7  
00D241  2  FD           
00D242  2               
00D242  2               ;water area used in level 6-1
00D242  2               L_WaterArea5:
00D242  2  01 01 77 39    .byte $01, $01, $77, $39, $a3, $43, $00, $bf, $29, $51, $39, $48, $61, $55, $d6, $54
00D246  2  A3 43 00 BF  
00D24A  2  29 51 39 48  
00D252  2  D2 44 0C 82    .byte $d2, $44, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32, $4a, $47, $97, $32
00D256  2  2E 02 31 66  
00D25A  2  44 47 47 32  
00D262  2  C1 66 CE 01    .byte $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f, $fe, $01, $27, $d3
00D266  2  DC 02 FE 0E  
00D26A  2  0C 8F 08 4F  
00D272  2  5C 02 9A 60    .byte $5c, $02, $9a, $60, $a9, $61, $b8, $62, $c7, $63, $ce, $0f, $d5, $0d, $7d, $c7
00D276  2  A9 61 B8 62  
00D27A  2  C7 63 CE 0F  
00D282  2  FD             .byte $fd
00D283  2               
00D283  2               ;unused bytes
00D283  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D287  2  FF FF FF FF  
00D28B  2  FF FF FF FF  
00D291  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D295  2  FF FF FF FF  
00D299  2  FF FF FF FF  
00D29F  2               
00D29F  1               .reloc
00AFDEr 1               .endscope
00AFDEr 1               Data2End:
00AFDEr 1               
00AFDEr 1  03           .byte FileHeaderBlock
00AFDFr 1  05 30        .byte $05,$30
00AFE1r 1  53 4D 32 44  .byte "SM2DATA3"
00AFE5r 1  41 54 41 33  
00AFE9r 1  D0 C5        .word $c5d0
00AFEBr 1  CF 0C        .word Data3End-Data3Start
00AFEDr 1  00 04        .byte PRG,FileDataBlock
00AFEFr 1               Data3Start:
00AFEFr 1               .scope FILE_SM2DATA3
00AFEFr 1               .org $C5D0
00C5D0  1               .include "sm2data3.asm"
00C5D0  2               ;SMB2J DISASSEMBLY (SM2DATA3 portion)
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               ;DEFINES
00C5D0  2               
00C5D0  2               OperMode              = $0770
00C5D0  2               OperMode_Task         = $0772
00C5D0  2               ScreenRoutineTask     = $073c
00C5D0  2               DiskIOTask            = $07fc
00C5D0  2               
00C5D0  2               VRAM_Buffer1          = $0301
00C5D0  2               VRAM_Buffer_AddrCtrl  = $0773
00C5D0  2               DisableScreenFlag     = $0774
00C5D0  2               SelectTimer           = $0780
00C5D0  2               ScreenTimer           = $07a0
00C5D0  2               WorldEndTimer         = $07a1
00C5D0  2               FantasyW9MsgFlag      = $07f5
00C5D0  2               
00C5D0  2               IRQUpdateFlag        = $0722
00C5D0  2               IRQAckFlag           = $077b
00C5D0  2               
00C5D0  2               FDSBIOS_DELAY     = $e149
00C5D0  2               FDSBIOS_LOADFILES = $e1f8
00C5D0  2               FDSBIOS_WRITEFILE = $e239
00C5D0  2               NameTableSelect   = $077a
00C5D0  2               CompletedWorlds   = $07fa
00C5D0  2               HardWorldFlag     = $07fb
00C5D0  2               FileListNumber    = $07f7
00C5D0  2               
00C5D0  2               GamePauseStatus   = $0776
00C5D0  2               
00C5D0  2               ObjectOffset        = $08
00C5D0  2               Enemy_ID            = $16
00C5D0  2               Enemy_Y_Position    = $cf
00C5D0  2               Enemy_Rel_XPos      = $03ae
00C5D0  2               Enemy_SprDataOffset = $06e5
00C5D0  2               
00C5D0  2               SelectedPlayer      = $0753
00C5D0  2               NumberofLives       = $075a
00C5D0  2               DigitModifier       = $0134
00C5D0  2               WorldNumber         = $075f
00C5D0  2               
00C5D0  2               ;sound related defines
00C5D0  2               Squ2_NoteLenBuffer      = $0610
00C5D0  2               Squ2_NoteLenCounter     = $0611
00C5D0  2               Squ2_EnvelopeDataCtrl   = $0612
00C5D0  2               Squ1_NoteLenCounter     = $0613
00C5D0  2               Squ1_EnvelopeDataCtrl   = $0614
00C5D0  2               Tri_NoteLenBuffer       = $0615
00C5D0  2               Tri_NoteLenCounter      = $0616
00C5D0  2               Noise_BeatLenCounter    = $0617
00C5D0  2               FDSSND_LenBuffer        = $05f2
00C5D0  2               FDSSND_LenCounter       = $05f1
00C5D0  2               FDSSND_MasterEnvTimer   = $05f3
00C5D0  2               FDSSND_ModTableNumber   = $05f6
00C5D0  2               FDSSND_MasterEnvSet     = $05f7
00C5D0  2               FDSSND_VolumeEnvTimer   = $05f8
00C5D0  2               FDSSND_VolumeEnvOffset  = $05f9
00C5D0  2               FDSSND_SweepModTimer    = $05fa
00C5D0  2               FDSSND_SweepModOffset   = $05fb
00C5D0  2               
00C5D0  2               PauseSoundQueue       = $fa
00C5D0  2               Square1SoundQueue     = $ff
00C5D0  2               Square2SoundQueue     = $fe
00C5D0  2               NoiseSoundQueue       = $fd
00C5D0  2               AreaMusicQueue        = $fb
00C5D0  2               EventMusicQueue       = $fc
00C5D0  2               
00C5D0  2               Square1SoundBuffer    = $f1
00C5D0  2               Square2SoundBuffer    = $f2
00C5D0  2               NoiseSoundBuffer      = $f3
00C5D0  2               AreaMusicBuffer       = $f4
00C5D0  2               EventMusicBuffer      = $07b1
00C5D0  2               PauseSoundBuffer      = $07b2
00C5D0  2               AltMusicBuffer        = $0608
00C5D0  2               
00C5D0  2               PatternNumber         = $061d
00C5D0  2               
00C5D0  2               MusicData             = $66
00C5D0  2               MusicDataLow          = $66
00C5D0  2               MusicDataHigh         = $67
00C5D0  2               WaveformData          = $68
00C5D0  2               FDSSND_VolumeEnvData  = $6a
00C5D0  2               FDSSND_SweepModData   = $6c
00C5D0  2               MusicOffset_Square2   = $060a
00C5D0  2               MusicOffset_Square1   = $060b
00C5D0  2               MusicOffset_Triangle  = $060c
00C5D0  2               MusicOffset_Noise     = $060d
00C5D0  2               MusicOffset_FDSSND    = $061f
00C5D0  2               
00C5D0  2               NoteLenLookupTblOfs   = $f0
00C5D0  2               DAC_Counter           = $07c0
00C5D0  2               NoiseDataLoopbackOfs  = $061b
00C5D0  2               NoteLengthTblAdder    = $0609
00C5D0  2               AreaMusicBuffer_Alt   = $07c5
00C5D0  2               PauseModeFlag         = $07c6
00C5D0  2               GroundMusicHeaderOfs  = $07c7
00C5D0  2               AltRegContentFlag     = $07ca
00C5D0  2               
00C5D0  2               WaveformID            = $060e
00C5D0  2               
00C5D0  2               MsgCounter            = $0719
00C5D0  2               MsgFractional         = $0749
00C5D0  2               
00C5D0  2               EndControlCntr        = $0761
00C5D0  2               BlueColorOfs          = $0762
00C5D0  2               BlueDelayFlag         = $0763
00C5D0  2               MushroomRetDelay      = $0764
00C5D0  2               MRetainerOffset       = $0762
00C5D0  2               CurrentFlashMRet      = $0763
00C5D0  2               
00C5D0  2               MHD = MusicHeaderOffsetData
00C5D0  2               
00C5D0  2               GameOverMode          = 3
00C5D0  2               
00C5D0  2               SND_REGISTER          = $4000
00C5D0  2               SND_SQUARE1_REG       = $4000
00C5D0  2               SND_SQUARE2_REG       = $4004
00C5D0  2               SND_TRIANGLE_REG      = $4008
00C5D0  2               SND_NOISE_REG         = $400c
00C5D0  2               SND_DELTA_REG         = $4010
00C5D0  2               SND_MASTERCTRL_REG    = $4015
00C5D0  2               
00C5D0  2               SPR_DMA               = $4014
00C5D0  2               JOYPAD_PORT           = $4016
00C5D0  2               JOYPAD_PORT1          = $4016
00C5D0  2               JOYPAD_PORT2          = $4017
00C5D0  2               
00C5D0  2               FDS_IRQTIMER_LOW      = $4020
00C5D0  2               FDS_IRQTIMER_HIGH     = $4021
00C5D0  2               FDS_IRQTIMER_CTRL     = $4022
00C5D0  2               FDS_CTRL_REG          = $4025
00C5D0  2               FDS_STATUS            = $4030
00C5D0  2               FDS_DRIVE_STATUS      = $4032
00C5D0  2               
00C5D0  2               FDSSND_VOLUMECTRL      = $4080
00C5D0  2               FDSSND_FREQLOW         = $4082
00C5D0  2               FDSSND_FREQHIGH        = $4083
00C5D0  2               FDSSND_SWEEPCTRL       = $4084
00C5D0  2               FDSSND_SWEEPBIAS       = $4085
00C5D0  2               FDSSND_MODFREQLOW      = $4086
00C5D0  2               FDSSND_MODFREQHIGH     = $4087
00C5D0  2               FDSSND_MODTBLAPPEND    = $4088
00C5D0  2               FDSSND_WAVEENABLEWR    = $4089
00C5D0  2               FDSSND_WAVERAM         = $4040
00C5D0  2               
00C5D0  2               Sfx_ExtraLife          = %01000000
00C5D0  2               Sfx_CoinGrab           = %00000001
00C5D0  2               VictoryMusic           = %00000100
00C5D0  2               
00C5D0  2               ; imports from other files
00C5D0  2               .import MoveSpritesOffscreen
00C5D0  2               .import FreqRegLookupTbl
00C5D0  2               .import NextWorld
00C5D0  2               .import WriteTopStatusLine
00C5D0  2               .import WriteBottomStatusLine
00C5D0  2               .import GetAreaPalette
00C5D0  2               .import GetBackgroundColor
00C5D0  2               .import EndAreaPoints
00C5D0  2               .import JumpEngine
00C5D0  2               .import Square2SfxHandler
00C5D0  2               .import PrintStatusBarNumbers
00C5D0  2               .import DiskIDString
00C5D0  2               .import EnemyGfxHandler
00C5D0  2               .import SoundEngine
00C5D0  2               .import DiskScreen
00C5D0  2               .import WaitForEject
00C5D0  2               .import WaitForReinsert
00C5D0  2               .import ResetDiskVars
00C5D0  2               .import DiskErrorHandler
00C5D0  2               .import AttractModeSubs
00C5D0  2               .import SoundEngineJSRCode
00C5D0  2               .import InitScreenPalette
00C5D0  2               
00C5D0  2               ; exports to other files
00C5D0  2               .export EraseLivesLines
00C5D0  2               .export RunMushroomRetainers
00C5D0  2               .export EndingDiskRoutines
00C5D0  2               .export AwardExtraLives
00C5D0  2               .export PrintVictoryMsgsForWorld8
00C5D0  2               .export FadeToBlue
00C5D0  2               .export ScreenSubsForFinalRoom
00C5D0  2               .export WriteNameToVictoryMsg
00C5D0  2               .export UnusedAttribData
00C5D0  2               .export FinalRoomPalette
00C5D0  2               .export ThankYouMessageFinal
00C5D0  2               .export PeaceIsPavedMsg
00C5D0  2               .export WithKingdomSavedMsg
00C5D0  2               .export HurrahMsg
00C5D0  2               .export OurOnlyHeroMsg
00C5D0  2               .export ThisEndsYourTripMsg
00C5D0  2               .export OfALongFriendshipMsg
00C5D0  2               .export PointsAddedMsg
00C5D0  2               .export ForEachPlayerLeftMsg
00C5D0  2               .export PrincessPeachsRoom
00C5D0  2               .export FantasyWorld9Msg
00C5D0  2               .export SuperPlayerMsg
00C5D0  2               .export E_CastleArea9
00C5D0  2               .export E_CastleArea10
00C5D0  2               .export E_GroundArea25
00C5D0  2               .export E_GroundArea26
00C5D0  2               .export E_GroundArea27
00C5D0  2               .export E_WaterArea6
00C5D0  2               .export E_WaterArea7
00C5D0  2               .export E_WaterArea8
00C5D0  2               .export L_CastleArea9
00C5D0  2               .export L_CastleArea10
00C5D0  2               .export L_GroundArea25
00C5D0  2               .export L_GroundArea26
00C5D0  2               .export L_GroundArea27
00C5D0  2               .export L_WaterArea6
00C5D0  2               .export L_WaterArea7
00C5D0  2               .export L_WaterArea8
00C5D0  2               
00C5D0  2               ;-------------------------------------------------------------------------------------
00C5D0  2               
00C5D0  2               PrintWorld9Msgs:
00C5D0  2  AD 70 07            lda OperMode              ;if in game over mode, branch
00C5D3  2  C9 03               cmp #GameOverMode         ;note this routine only runs after world 8 and replaces
00C5D5  2  F0 1A               beq W9GameOver            ;the routine DemoReset in memory
00C5D7  2  AD F5 07            lda FantasyW9MsgFlag      ;if world 9 flag was set earlier, skip this part
00C5DA  2  D0 0D               bne NoFW9
00C5DC  2  A9 1D               lda #$1d                  ;otherwise set VRAM pointer to print
00C5DE  2  8D 73 07            sta VRAM_Buffer_AddrCtrl  ;the hidden fantasy "9 world" message
00C5E1  2  A9 10               lda #$10
00C5E3  2  8D A0 07            sta ScreenTimer
00C5E6  2  EE F5 07            inc FantasyW9MsgFlag      ;and set flag to keep it from getting printed again
00C5E9  2  A9 00        NoFW9: lda #$00
00C5EB  2  8D 74 07            sta DisableScreenFlag     ;turn screen back on, move on to next screen sub
00C5EE  2  4C 1A C6            jmp NextScreenTask
00C5F1  2               
00C5F1  2               W9GameOver:
00C5F1  2  A9 20            lda #$20
00C5F3  2  8D A0 07         sta ScreenTimer
00C5F6  2  A9 1E            lda #$1e                  ;set VRAM pointer to print world 9 goodbye message
00C5F8  2  8D 73 07         sta VRAM_Buffer_AddrCtrl
00C5FB  2  4C 3E C6         jmp NextOperTask          ;move on to next task
00C5FE  2               
00C5FE  2               ScreenSubsForFinalRoom:
00C5FE  2  AD 3C 07         lda ScreenRoutineTask
00C601  2  20 rr rr         jsr JumpEngine
00C604  2               
00C604  2  rr rr            .word InitScreenPalette
00C606  2  rr rr            .word WriteTopStatusLine
00C608  2  rr rr            .word WriteBottomStatusLine
00C60A  2  12 C6            .word DrawFinalRoom
00C60C  2  rr rr            .word GetAreaPalette
00C60E  2  rr rr            .word GetBackgroundColor
00C610  2  1E C6            .word RevealPrincess
00C612  2               
00C612  2               DrawFinalRoom:
00C612  2  A9 1B            lda #$1b                   ;draw the princess's room
00C614  2  8D 73 07         sta VRAM_Buffer_AddrCtrl
00C617  2  8D 22 07         sta IRQUpdateFlag
00C61A  2               NextScreenTask:
00C61A  2  EE 3C 07         inc ScreenRoutineTask
00C61D  2  60               rts
00C61E  2               
00C61E  2               RevealPrincess:
00C61E  2  A9 A2            lda #$a2                   ;print game timer
00C620  2  20 rr rr         jsr PrintStatusBarNumbers
00C623  2  A9 CC            lda #>AlternateSoundEngine
00C625  2  8D rr rr         sta SoundEngineJSRCode+2      ;change sound engine address
00C628  2  A9 5F            lda #<AlternateSoundEngine ;to run the alt music engine on every NMI
00C62A  2  8D rr rr         sta SoundEngineJSRCode+1
00C62D  2  A9 01            lda #$01
00C62F  2  85 FB            sta AreaMusicQueue         ;play the only song available to it
00C631  2  A9 00            lda #$00                   ;aka the victory music
00C633  2  85 0C            sta $0c                    ;residual, this does nothing
00C635  2  8D 7A 07         sta NameTableSelect
00C638  2  8D 22 07         sta IRQUpdateFlag          ;turn screen back on but without IRQs
00C63B  2  8D 74 07         sta DisableScreenFlag
00C63E  2               NextOperTask:
00C63E  2  EE 72 07         inc OperMode_Task
00C641  2  60               rts
00C642  2               
00C642  2               PrintVictoryMsgsForWorld8:
00C642  2  AD 49 07              lda MsgFractional          ;if fractional not looped to zero
00C645  2  D0 19                 bne IncVMC                 ;then branch to increment it
00C647  2  AC 19 07              ldy MsgCounter
00C64A  2  C0 0A                 cpy #$0a                   ;if message counter gone past a certain
00C64C  2  B0 24                 bcs EndVictoryMessages     ;point, branch to set timer and stop printing messages
00C64E  2  C8                    iny
00C64F  2  C8                    iny
00C650  2  C8                    iny                        ;add 3 to message counter to print the messages
00C651  2  C0 05                 cpy #$05                   ;for world 8 (as opposed to worlds 1-7)
00C653  2  D0 04                 bne PrintVM
00C655  2  A9 04                 lda #VictoryMusic          ;residual code from original smb source, this will not
00C657  2  85 FC                 sta EventMusicQueue        ;be checked due to alternate vector for sound engine
00C659  2  98           PrintVM: tya
00C65A  2  18                    clc
00C65B  2  69 0C                 adc #$0c                   ;get appropriate range for victory messages
00C65D  2  8D 73 07              sta VRAM_Buffer_AddrCtrl
00C660  2  AD 49 07     IncVMC:  lda MsgFractional
00C663  2  18                    clc
00C664  2  69 04                 adc #$04                   ;add four to counter's fractional
00C666  2  8D 49 07              sta MsgFractional
00C669  2  AD 19 07              lda MsgCounter             ;add carry to the message counter itself
00C66C  2  69 00                 adc #$00
00C66E  2  8D 19 07              sta MsgCounter
00C671  2  60                    rts
00C672  2               
00C672  2               EndVictoryMessages:
00C672  2  A9 0C                lda #$0c                   ;set interval timer, then move onto next task
00C674  2  8D A1 07             sta WorldEndTimer
00C677  2  EE 72 07     ExAEL:  inc OperMode_Task
00C67A  2               
00C67A  2               EraseEndingCounters:
00C67A  2  A9 00                lda #$00
00C67C  2  8D 61 07             sta EndControlCntr
00C67F  2  8D 62 07             sta MRetainerOffset
00C682  2  8D 63 07             sta CurrentFlashMRet
00C685  2  60           NotYet: rts
00C686  2               
00C686  2               AwardExtraLives:
00C686  2  AD A1 07         lda WorldEndTimer          ;wait until timer expires before running this sub
00C689  2  D0 FA            bne NotYet
00C68B  2  AD 5A 07         lda NumberofLives          ;if counted all extra lives, branch
00C68E  2  30 E7            bmi ExAEL                  ;to run another task in victory mode
00C690  2  AD 80 07         lda SelectTimer
00C693  2  D0 F0            bne NotYet                 ;if short delay between each count of extra lives
00C695  2  A9 30            lda #$30                   ;not expired, wait, otherwise, reset the timer
00C697  2  8D 80 07         sta SelectTimer
00C69A  2  A9 40            lda #Sfx_ExtraLife
00C69C  2  85 FE            sta Square2SoundQueue
00C69E  2  CE 5A 07         dec NumberofLives          ;count down each extra life
00C6A1  2  A9 01            lda #$01                   ;give 100,000 points to player for each one
00C6A3  2  8D 35 01         sta DigitModifier+1
00C6A6  2  4C rr rr         jmp EndAreaPoints
00C6A9  2               
00C6A9  2               BlueTransPalette:
00C6A9  2  3F 00 10         .byte $3f, $00, $10
00C6AC  2  0F 30 0F 0F      .byte $0f, $30, $0f, $0f, $0f, $30, $10, $00, $0f, $21, $12, $21, $0f, $27, $17, $00
00C6B0  2  0F 30 10 00  
00C6B4  2  0F 21 12 21  
00C6BC  2  00               .byte $00
00C6BD  2               
00C6BD  2               BlueTints:
00C6BD  2  01 02 11 21      .byte $01, $02, $11, $21
00C6C1  2               
00C6C1  2               TwoBlankRows:
00C6C1  2  22 86 55 24      .byte $22, $86, $55, $24
00C6C5  2  22 A6 55 24      .byte $22, $a6, $55, $24
00C6C9  2  00               .byte $00
00C6CA  2               
00C6CA  2               FadeToBlue:
00C6CA  2  EE 61 07               inc EndControlCntr   ;increment a counter
00C6CD  2  AD 63 07               lda BlueDelayFlag    ;if it's time to fade to blue, branch
00C6D0  2  D0 0D                  bne BlueUpdateTiming
00C6D2  2  AD 61 07               lda EndControlCntr
00C6D5  2  29 FF                  and #$ff             ;otherwise wait until counter wraps
00C6D7  2  D0 36                  bne ExFade           ;then set the flag
00C6D9  2  EE 63 07               inc BlueDelayFlag
00C6DC  2  4C E6 C6               jmp BlueUpd          ;skip over next part if the flag was just set
00C6DF  2               
00C6DF  2               BlueUpdateTiming:
00C6DF  2  AD 61 07                lda EndControlCntr
00C6E2  2  29 0F                   and #$0f               ;execute the next part only every 16 frames
00C6E4  2  D0 29                   bne ExFade
00C6E6  2  A2 13        BlueUpd:   ldx #$13
00C6E8  2  BD A9 C6     BlueULoop: lda BlueTransPalette,x ;write palette to VRAM buffer
00C6EB  2  9D 01 03                sta VRAM_Buffer1,x
00C6EE  2  CA                      dex
00C6EF  2  10 F7                   bpl BlueULoop
00C6F1  2  A2 0C                   ldx #$0c
00C6F3  2  AC 62 07                ldy BlueColorOfs       ;get color offset
00C6F6  2  B9 BD C6     NextBlue:  lda BlueTints,y        ;set background color based on color offset
00C6F9  2  9D 04 03                sta VRAM_Buffer1+3,x
00C6FC  2  CA                      dex                    ;be sure to set the same background color
00C6FD  2  CA                      dex                    ;in all four palettes (even though only the first
00C6FE  2  CA                      dex                    ;one is acknowledged)
00C6FF  2  CA                      dex
00C700  2  10 F4                   bpl NextBlue
00C702  2  EE 62 07                inc BlueColorOfs       ;increment to next color which will show up
00C705  2  AD 62 07                lda BlueColorOfs       ;16 frames later, thus causing a slow color change
00C708  2  C9 04                   cmp #$04               ;if not changed to last color, leave
00C70A  2  D0 03                   bne ExFade
00C70C  2  EE 72 07                inc OperMode_Task      ;otherwise move on to the next task
00C70F  2  60           ExFade:    rts
00C710  2               
00C710  2               EraseLivesLines:
00C710  2  A2 08             ldx #$08                  ;erase bottom two lines
00C712  2  BD C1 C6     ELL: lda TwoBlankRows,x
00C715  2  9D 01 03          sta VRAM_Buffer1,x
00C718  2  CA                dex
00C719  2  10 F7             bpl ELL
00C71B  2  EE 72 07          inc OperMode_Task
00C71E  2  20 7A C6          jsr EraseEndingCounters   ;init ending counters
00C721  2  A9 60             lda #$60
00C723  2  8D 64 07          sta MushroomRetDelay      ;wait before flashing each mushroom retainer in next sub
00C726  2  60                rts
00C727  2               
00C727  2               RunMushroomRetainers:
00C727  2  20 BD C7            jsr MushroomRetainersForW8  ;draw and flash the seven mushroom retainers
00C72A  2  AD 08 06            lda AltMusicBuffer          ;if still playing victory music, branch to leave
00C72D  2  D0 08               bne ExRMR
00C72F  2  AD FB 07            lda HardWorldFlag           ;if on world D, branch elsewhere
00C732  2  D0 36               bne BackToNormal
00C734  2  EE 72 07            inc OperMode_Task           ;otherwise just move onto the last task
00C737  2  60           ExRMR: rts
00C738  2               
00C738  2               EndingDiskRoutines:
00C738  2  AD FC 07         lda DiskIOTask
00C73B  2  20 rr rr         jsr JumpEngine
00C73E  2               
00C73E  2  rr rr            .word DiskScreen
00C740  2  59 C7            .word UpdateGamesBeaten
00C742  2  rr rr            .word WaitForEject
00C744  2  rr rr            .word WaitForReinsert
00C746  2  rr rr            .word ResetDiskVars
00C748  2               
00C748  2               SaveFileHeader:
00C748  2  0F 53 4D 32      .byte $0f, "SM2SAVE "
00C74C  2  53 41 56 45  
00C750  2  20           
00C751  2  9F D2            .word $d29f
00C753  2  01 00 00         .byte $01, $00, $00
00C756  2  9F D2            .word $d29f
00C758  2  00               .byte $00
00C759  2               
00C759  2               UpdateGamesBeaten:
00C759  2  A9 07            lda #$07               ;set file sequential position
00C75B  2  20 39 E2         jsr FDSBIOS_WRITEFILE  ;save number of games beaten to SM2SAVE
00C75E  2  rr rr            .word DiskIDString
00C760  2  48 C7            .word SaveFileHeader
00C762  2               
00C762  2               ;execution continues here
00C762  2  F0 06            beq BackToNormal       ;if no error, continue
00C764  2  EE FC 07         inc DiskIOTask         ;otherwise move on to next disk task
00C767  2  4C rr rr         jmp DiskErrorHandler   ;and jump to disk error handler
00C76A  2               
00C76A  2               BackToNormal:
00C76A  2  A9 rr            lda #>SoundEngine        ;reset sound engine vector
00C76C  2  8D rr rr         sta SoundEngineJSRCode+2  ;to run the original one
00C76F  2  A9 rr            lda #<SoundEngine
00C771  2  8D rr rr         sta SoundEngineJSRCode+1
00C774  2  A9 00            lda #$00
00C776  2  8D FC 07         sta DiskIOTask           ;erase task numbers
00C779  2  8D 72 07         sta OperMode_Task
00C77C  2  AD FB 07         lda HardWorldFlag        ;if in world D, branch to end the game
00C77F  2  D0 07            bne EndTheGame
00C781  2  AD FA 07         lda CompletedWorlds      ;if completed all worlds without skipping over any
00C784  2  C9 FF            cmp #$ff                 ;then branch elsewhere (note warping backwards may
00C786  2  F0 0B            beq GoToWorld9           ;allow player to complete skipped worlds)
00C788  2               EndTheGame:
00C788  2  A9 00            lda #$00
00C78A  2  8D FA 07         sta CompletedWorlds      ;init completed worlds flag, go back to title screen mode
00C78D  2  8D 70 07         sta OperMode
00C790  2  4C rr rr         jmp AttractModeSubs      ;jump to title screen mode routines
00C793  2               GoToWorld9:
00C793  2  A9 00            lda #$00
00C795  2  8D FA 07         sta CompletedWorlds      ;init completed worlds flag
00C798  2  8D 5A 07         sta NumberofLives        ;give the player one life
00C79B  2  8D F5 07         sta FantasyW9MsgFlag
00C79E  2  4C rr rr         jmp NextWorld            ;run world 9
00C7A1  2               
00C7A1  2               FlashMRSpriteDataOfs:
00C7A1  2  50 B0 E0 68      .byte $50, $b0, $e0, $68, $98, $c8
00C7A5  2  98 C8        
00C7A7  2               
00C7A7  2               MRSpriteDataOfs:
00C7A7  2  80 50 68 80      .byte $80, $50, $68, $80, $98, $b0, $c8
00C7AB  2  98 B0 C8     
00C7AE  2               
00C7AE  2               MRetainerYPos:
00C7AE  2  E0 B8 90 70      .byte $e0, $b8, $90, $70, $68, $70, $90
00C7B2  2  68 70 90     
00C7B5  2               
00C7B5  2               MRetainerXPos:
00C7B5  2  B8 38 48 60      .byte $b8, $38, $48, $60, $80, $a0, $b8, $c8
00C7B9  2  80 A0 B8 C8  
00C7BD  2               
00C7BD  2               MushroomRetainersForW8:
00C7BD  2  AD 64 07         lda MushroomRetDelay        ;wait a bit unless waiting is already done
00C7C0  2  F0 04            beq DrawFlashMRetainers
00C7C2  2  CE 64 07         dec MushroomRetDelay
00C7C5  2  60               rts
00C7C6  2               
00C7C6  2               DrawFlashMRetainers:
00C7C6  2  20 rr rr         jsr MoveSpritesOffscreen   ;init sprites
00C7C9  2  AE 62 07         ldx MRetainerOffset
00C7CC  2  E0 07            cpx #$07                   ;if 7 mushroom retainers added, branch elsewhere
00C7CE  2  F0 11            beq FlashMRetainers
00C7D0  2  AD 61 07         lda EndControlCntr
00C7D3  2  29 1F            and #$1f                   ;execute this part once every 32 frames
00C7D5  2  D0 20            bne DrawMRetainers
00C7D7  2  EE 62 07         inc MRetainerOffset        ;add another mushroom retainer
00C7DA  2  A9 01            lda #Sfx_CoinGrab
00C7DC  2  85 FE            sta Square2SoundQueue      ;play the coin grab sound
00C7DE  2  4C F7 C7         jmp DrawMRetainers
00C7E1  2               
00C7E1  2               FlashMRetainers:
00C7E1  2  AD 61 07         lda EndControlCntr
00C7E4  2  29 1F            and #$1f                   ;execute this part once every 32 frames also
00C7E6  2  D0 0F            bne DrawMRetainers         ;after the counter reaches a certain point
00C7E8  2  EE 63 07         inc CurrentFlashMRet
00C7EB  2  AD 63 07         lda CurrentFlashMRet       ;increment what's now being used to select a
00C7EE  2  C9 0B            cmp #$0b                   ;mushroom retainer to flash, if not yet at $0b/11
00C7F0  2  90 05            bcc DrawMRetainers         ;then go ahead to next part
00C7F2  2  A9 04            lda #$04
00C7F4  2  8D 63 07         sta CurrentFlashMRet       ;otherwise reset to 4
00C7F7  2               DrawMRetainers:
00C7F7  2  EE 61 07         inc EndControlCntr         ;be sure to count frames
00C7FA  2  AD 5F 07         lda WorldNumber
00C7FD  2  48               pha                        ;save world number and initial retainer offset
00C7FE  2  AD 62 07         lda MRetainerOffset
00C801  2  48               pha
00C802  2  AA               tax                        ;use second counter as offset to one of the spr data offset lists
00C803  2               DrawMRetLoop:
00C803  2  AD 63 07         lda CurrentFlashMRet       ;if offset not yet at 4 (first time it starts at 0), branch to skip this
00C806  2  C9 04            cmp #$04                   ;thus adding a delay between the appearance
00C808  2  90 0B            bcc SetupMRet              ;of mushroom retainers and their "flashing"
00C80A  2  E9 04            sbc #$04
00C80C  2  A8               tay                        ;otherwise subtract 4 to get the offset proper
00C80D  2  B9 A1 C7         lda FlashMRSpriteDataOfs,y ;if the sprite obj data offset pointed at by the current flashing retainer
00C810  2  DD A7 C7         cmp MRSpriteDataOfs,x      ;matches the one pointed at by the offset of the retainer being checked
00C813  2  F0 1F            beq NextMRet               ;then branch to skip, do not draw that mushroom retainer
00C815  2               SetupMRet:
00C815  2  BC A7 C7         ldy MRSpriteDataOfs,x      ;get sprite data offset of the current mushroom retainer
00C818  2  8C E5 06         sty Enemy_SprDataOffset
00C81B  2  A9 35            lda #$35
00C81D  2  85 16            sta $16                    ;set mushroom retainer object ID
00C81F  2  BD AE C7         lda MRetainerYPos,x
00C822  2  85 CF            sta Enemy_Y_Position       ;use enemy object 0 for mushroom retainer temporarily
00C824  2  BD B5 C7         lda MRetainerXPos,x
00C827  2  8D AE 03         sta Enemy_Rel_XPos
00C82A  2  A2 00            ldx #$00                   ;set world number and object offset for the graphics handler
00C82C  2  8E 5F 07         stx WorldNumber            ;to prevent graphics handler from drawing princess instead
00C82F  2  86 08            stx ObjectOffset
00C831  2  20 rr rr         jsr EnemyGfxHandler        ;now draw the mushroom retainer
00C834  2               NextMRet:
00C834  2  CE 62 07         dec MRetainerOffset        ;move to next mushroom retainer using offset
00C837  2  AE 62 07         ldx MRetainerOffset
00C83A  2  D0 C7            bne DrawMRetLoop           ;if not drawn all retainers yet, loop to do so
00C83C  2  68               pla
00C83D  2  8D 62 07         sta MRetainerOffset        ;reset initial offset
00C840  2  68               pla
00C841  2  8D 5F 07         sta WorldNumber            ;return world number to what it was to draw princess
00C844  2  A9 30            lda #$30
00C846  2  8D E5 06         sta Enemy_SprDataOffset
00C849  2  A9 B8            lda #$b8                   ;return original settings princess uses (note X position
00C84B  2  85 CF            sta Enemy_Y_Position       ;will be returned later in enemy object core)
00C84D  2  60               rts
00C84E  2               
00C84E  2               EndPlayerNameData:
00C84E  2  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18
00C852  2  18           
00C853  2  15 1E 12 10      .byte $15, $1e, $12, $10, $12
00C857  2  12           
00C858  2               
00C858  2               WriteNameToVictoryMsg:
00C858  2  A9 00                lda #$00
00C85A  2  8D 3C 07             sta ScreenRoutineTask    ;init screen routine task
00C85D  2  A2 04                ldx #$04
00C85F  2  AD 53 07             lda SelectedPlayer       ;check selected player
00C862  2  F0 02                beq SNameL               ;if mario, use by default
00C864  2  A2 09                ldx #$09                 ;otherwise use luigi's name
00C866  2  A0 04        SNameL: ldy #$04
00C868  2  BD 4E C8     VMsgNL: lda EndPlayerNameData,x
00C86B  2  99 A0 C8             sta ThankYouMessageFinal+13,y  ;overwrite name of player in two
00C86E  2  99 E5 C8             sta HurrahMsg+14,y             ;of the victory messages
00C871  2  CA                   dex
00C872  2  88                   dey
00C873  2  10 F3                bpl VMsgNL
00C875  2  60                   rts
00C876  2               
00C876  2               ;-------------------------------------------------------------------------------------
00C876  2               
00C876  2               UnusedAttribData:
00C876  2  23 C0 48 55      .byte $23, $c0, $48, $55
00C87A  2  23 C2 01 D5      .byte $23, $c2, $01, $d5
00C87E  2  00               .byte $00
00C87F  2               
00C87F  2               FinalRoomPalette:
00C87F  2  3F 00 10         .byte $3f, $00, $10
00C882  2  0F 0F 0F 0F      .byte $0f, $0f, $0f, $0f, $0f, $30, $10, $00
00C886  2  0F 30 10 00  
00C88A  2  0F 21 12 02      .byte $0f, $21, $12, $02, $0f, $27, $17, $00
00C88E  2  0F 27 17 00  
00C892  2  00               .byte $00
00C893  2               
00C893  2               ThankYouMessageFinal:
00C893  2  20 E8 10         .byte $20, $e8, $10
00C896  2  1D 11 0A 17      .byte $1d, $11, $0a, $17, $14, $24, $22, $18, $1e, $24
00C89A  2  14 24 22 18  
00C89E  2  1E 24        
00C8A0  2  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18, $2b
00C8A4  2  18 2B        
00C8A6  2               
00C8A6  2  23 C8 48 05      .byte $23, $c8, $48, $05
00C8AA  2  00               .byte $00
00C8AB  2               
00C8AB  2               PeaceIsPavedMsg:
00C8AB  2  21 09 0E         .byte $21, $09, $0e
00C8AE  2  19 0E 0A 0C      .byte $19, $0e, $0a, $0c, $0e, $24, $12, $1c, $24
00C8B2  2  0E 24 12 1C  
00C8B6  2  24           
00C8B7  2  19 0A 1F 0E      .byte $19, $0a, $1f, $0e, $0d
00C8BB  2  0D           
00C8BC  2  23 D0 58 AA      .byte $23, $d0, $58, $aa
00C8C0  2  00               .byte $00
00C8C1  2               
00C8C1  2               WithKingdomSavedMsg:
00C8C1  2  21 47 12         .byte $21, $47, $12
00C8C4  2  20 12 1D 11      .byte $20, $12, $1d, $11, $24, $14, $12, $17, $10, $0d, $18, $16, $24
00C8C8  2  24 14 12 17  
00C8CC  2  10 0D 18 16  
00C8D1  2  1C 0A 1F 0E      .byte $1c, $0a, $1f, $0e, $0d
00C8D5  2  0D           
00C8D6  2  00               .byte $00
00C8D7  2               
00C8D7  2               HurrahMsg:
00C8D7  2  21 89 10         .byte $21, $89, $10
00C8DA  2  11 1E 1B 1B      .byte $11, $1e, $1b, $1b, $0a, $11, $24, $1d, $18, $24, $24, $16, $0a
00C8DE  2  0A 11 24 1D  
00C8E2  2  18 24 24 16  
00C8E7  2  1B 12 18         .byte $1b, $12, $18
00C8EA  2  00               .byte $00
00C8EB  2               
00C8EB  2               OurOnlyHeroMsg:
00C8EB  2  21 CA 0D         .byte $21, $ca, $0d
00C8EE  2  18 1E 1B 24      .byte $18, $1e, $1b, $24, $18, $17, $15, $22, $24, $11, $0e, $1b, $18
00C8F2  2  18 17 15 22  
00C8F6  2  24 11 0E 1B  
00C8FB  2  00               .byte $00
00C8FC  2               
00C8FC  2               ThisEndsYourTripMsg:
00C8FC  2  22 07 13         .byte $22, $07, $13
00C8FF  2  1D 11 12 1C      .byte $1d, $11, $12, $1c, $24, $0e, $17, $0d, $1c, $24, $22, $18, $1e
00C903  2  24 0E 17 0D  
00C907  2  1C 24 22 18  
00C90C  2  1B 24 1D 1B      .byte $1b, $24, $1d, $1b, $12, $19
00C910  2  12 19        
00C912  2  00               .byte $00
00C913  2               
00C913  2               OfALongFriendshipMsg:
00C913  2  22 46 14         .byte $22, $46, $14
00C916  2  18 0F 24 0A      .byte $18, $0f, $24, $0a, $24, $15, $18, $17, $10, $24, $0f, $1b, $12
00C91A  2  24 15 18 17  
00C91E  2  10 24 0F 1B  
00C923  2  0E 17 0D 1C      .byte $0e, $17, $0d, $1c, $11, $12, $19
00C927  2  11 12 19     
00C92A  2  00               .byte $00
00C92B  2               
00C92B  2               PointsAddedMsg:
00C92B  2  22 88 10         .byte $22, $88, $10
00C92E  2  01 00 00 00      .byte $01, $00, $00, $00, $00, $00, $24, $19, $1d, $1c, $af, $0a, $0d
00C932  2  00 00 24 19  
00C936  2  1D 1C AF 0A  
00C93B  2  0D 0E 0D         .byte $0d, $0e, $0d
00C93E  2               
00C93E  2  23 E8 48 FF      .byte $23, $e8, $48, $ff
00C942  2  00               .byte $00
00C943  2               
00C943  2               ForEachPlayerLeftMsg:
00C943  2  22 A6 15         .byte $22, $a6, $15
00C946  2  0F 18 1B 24      .byte $0f, $18, $1b, $24, $0e, $0a, $0c, $11, $24, $19, $15, $0a, $22
00C94A  2  0E 0A 0C 11  
00C94E  2  24 19 15 0A  
00C953  2  0E 1B 24 15      .byte $0e, $1b, $24, $15, $0e, $0f, $1d, $af
00C957  2  0E 0F 1D AF  
00C95B  2  00               .byte $00
00C95C  2               
00C95C  2               PrincessPeachsRoom:
00C95C  2  20 80 60 5E      .byte $20, $80, $60, $5e
00C960  2  20 A0 60 5D      .byte $20, $a0, $60, $5d
00C964  2  23 40 60 5E      .byte $23, $40, $60, $5e
00C968  2  23 60 60 5D      .byte $23, $60, $60, $5d
00C96C  2  23 80 60 5E      .byte $23, $80, $60, $5e
00C970  2  23 A0 60 5D      .byte $23, $a0, $60, $5d
00C974  2  23 C0 50 55      .byte $23, $c0, $50, $55
00C978  2  23 F0 50 55      .byte $23, $f0, $50, $55
00C97C  2  00               .byte $00
00C97D  2               
00C97D  2               FantasyWorld9Msg:
00C97D  2  22 24 18         .byte $22, $24, $18
00C980  2  20 0E 24 19      .byte $20, $0e, $24, $19, $1b, $0e, $1c, $0e, $17, $1d, $24, $0f, $0a
00C984  2  1B 0E 1C 0E  
00C988  2  17 1D 24 0F  
00C98D  2  17 1D 0A 1C      .byte $17, $1d, $0a, $1c, $22, $24, $20, $18, $1b, $15, $0d
00C991  2  22 24 20 18  
00C995  2  1B 15 0D     
00C998  2               
00C998  2  22 66 13         .byte $22, $66, $13
00C99B  2  15 0E 1D F2      .byte $15, $0e, $1d, $f2, $1c, $24, $1d, $1b, $22, $24, $76, $09, $24
00C99F  2  1C 24 1D 1B  
00C9A3  2  22 24 76 09  
00C9A8  2  20 18 1B 15      .byte $20, $18, $1b, $15, $0d, $75
00C9AC  2  0D 75        
00C9AE  2               
00C9AE  2  22 A9 0E         .byte $22, $a9, $0e
00C9B1  2  20 12 1D 11      .byte $20, $12, $1d, $11, $24, $18, $17, $0e, $24, $10, $0a, $16, $0e
00C9B5  2  24 18 17 0E  
00C9B9  2  24 10 0A 16  
00C9BE  2  AF               .byte $af
00C9BF  2  00               .byte $00
00C9C0  2               
00C9C0  2               SuperPlayerMsg:
00C9C0  2  21 E0 60 24      .byte $21, $e0, $60, $24
00C9C4  2  22 40 60 24      .byte $22, $40, $60, $24
00C9C8  2  22 25 16         .byte $22, $25, $16
00C9CB  2  22 18 1E F2      .byte $22, $18, $1e, $f2, $1b, $0e, $24, $0a, $24, $1c, $1e, $19, $0e
00C9CF  2  1B 0E 24 0A  
00C9D3  2  24 1C 1E 19  
00C9D8  2  1B 24 19 15      .byte $1b, $24, $19, $15, $0a, $22, $0e, $1b, $2b
00C9DC  2  0A 22 0E 1B  
00C9E0  2  2B           
00C9E1  2  22 69 0D         .byte $22, $69, $0d
00C9E4  2  20 0E 24 11      .byte $20, $0e, $24, $11, $18, $19, $0e, $24, $20, $0e, $f2, $15, $15
00C9E8  2  18 19 0E 24  
00C9EC  2  20 0E F2 15  
00C9F1  2  22 A9 0E         .byte $22, $a9, $0e
00C9F4  2  1C 0E 0E 24      .byte $1c, $0e, $0e, $24, $22, $18, $1e, $24, $0a, $10, $0a, $12, $17
00C9F8  2  22 18 1E 24  
00C9FC  2  0A 10 0A 12  
00CA01  2  AF               .byte $af
00CA02  2  22 E8 10         .byte $22, $e8, $10
00CA05  2  16 0A 1B 12      .byte $16, $0a, $1b, $12, $18, $24, $0a, $17, $0d, $24, $1c, $1d, $0a
00CA09  2  18 24 0A 17  
00CA0D  2  0D 24 1C 1D  
00CA12  2  0F 0F AF         .byte $0f, $0f, $af
00CA15  2  00               .byte $00
00CA16  2               
00CA16  2               ;-------------------------------------------------------------------------------------
00CA16  2               
00CA16  2               ; unused space
00CA16  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA1A  2  FF FF FF FF  
00CA1E  2  FF FF FF FF  
00CA26  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA2A  2  FF FF FF FF  
00CA2E  2  FF FF FF FF  
00CA36  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA3A  2  FF FF FF FF  
00CA3E  2  FF FF FF FF  
00CA46  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA4A  2  FF FF FF FF  
00CA4E  2  FF FF FF FF  
00CA56  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA5A  2  FF FF FF FF  
00CA5E  2  FF FF FF FF  
00CA66  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA6A  2  FF FF FF FF  
00CA6E  2  FF FF FF FF  
00CA76  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CA7A  2  FF FF FF FF  
00CA7E  2  FF FF        
00CA80  2               
00CA80  2               ;level 9-3
00CA80  2               E_CastleArea9:
00CA80  2  1F 01 0E 69      .byte $1f, $01, $0e, $69, $00, $1f, $0b, $78, $2d, $ff
00CA84  2  00 1F 0B 78  
00CA88  2  2D FF        
00CA8A  2               
00CA8A  2               ;cloud level used in level 9-3
00CA8A  2               E_CastleArea10:
00CA8A  2  1F 01 1E 68      .byte $1f, $01, $1e, $68, $06, $ff
00CA8E  2  06 FF        
00CA90  2               
00CA90  2               ;level 9-1 starting area
00CA90  2               E_GroundArea25:
00CA90  2  1E 05 00 FF      .byte $1e, $05, $00, $ff
00CA94  2               
00CA94  2               ;two unused levels that have the same enemy data address as a used level
00CA94  2               E_GroundArea26:
00CA94  2               E_GroundArea27:
00CA94  2               
00CA94  2               ;level 9-1 water area
00CA94  2               E_WaterArea6:
00CA94  2  26 8F 05 AC      .byte $26, $8f, $05, $ac, $46, $0f, $1f, $04, $e8, $10, $38, $90, $66, $11, $fb, $3c
00CA98  2  46 0F 1F 04  
00CA9C  2  E8 10 38 90  
00CAA4  2  9B B7 CB 85      .byte $9b, $b7, $cb, $85, $29, $87, $95, $07, $eb, $02, $0b, $82, $96, $0e, $c3, $0e
00CAA8  2  29 87 95 07  
00CAAC  2  EB 02 0B 82  
00CAB4  2  FF               .byte $ff
00CAB5  2               
00CAB5  2               ;level 9-2
00CAB5  2               E_WaterArea7:
00CAB5  2  1F 01 E6 11      .byte $1f, $01, $e6, $11, $ff
00CAB9  2  FF           
00CABA  2               
00CABA  2               ;level 9-4
00CABA  2               E_WaterArea8:
00CABA  2  3B 86 7B 00      .byte $3b, $86, $7b, $00, $bb, $02, $2b, $8e, $7a, $05, $57, $87, $27, $8f, $9a, $0c
00CABE  2  BB 02 2B 8E  
00CAC2  2  7A 05 57 87  
00CACA  2  FF               .byte $ff
00CACB  2               
00CACB  2               ;level 9-3
00CACB  2               L_CastleArea9:
00CACB  2  55 31 0D 01      .byte $55, $31, $0d, $01, $cf, $33, $fe, $39, $fe, $b2, $2e, $be, $fe, $31, $29, $8f
00CACF  2  CF 33 FE 39  
00CAD3  2  FE B2 2E BE  
00CADB  2  9E 43 FE 30      .byte $9e, $43, $fe, $30, $16, $b1, $23, $09, $4e, $31, $4e, $40, $d7, $e0, $e6, $61
00CADF  2  16 B1 23 09  
00CAE3  2  4E 31 4E 40  
00CAEB  2  FE 3E F5 62      .byte $fe, $3e, $f5, $62, $fa, $60, $0c, $df, $0c, $df, $0c, $d1, $1e, $3c, $2d, $40
00CAEF  2  FA 60 0C DF  
00CAF3  2  0C DF 0C D1  
00CAFB  2  4E 32 5E 36      .byte $4e, $32, $5e, $36, $5e, $42, $ce, $38, $0d, $0b, $8e, $36, $8e, $40, $87, $37
00CAFF  2  5E 42 CE 38  
00CB03  2  0D 0B 8E 36  
00CB0B  2  96 36 BE 3A      .byte $96, $36, $be, $3a, $cc, $5d, $06, $bd, $07, $3e, $a8, $64, $b8, $64, $c8, $64
00CB0F  2  CC 5D 06 BD  
00CB13  2  07 3E A8 64  
00CB1B  2  D8 64 E8 64      .byte $d8, $64, $e8, $64, $f8, $64, $fe, $31, $09, $e1, $1a, $60, $6d, $41, $9f, $26
00CB1F  2  F8 64 FE 31  
00CB23  2  09 E1 1A 60  
00CB2B  2  7D C7 FD         .byte $7d, $c7, $fd
00CB2E  2               
00CB2E  2               ;cloud level used by level 9-3
00CB2E  2               L_CastleArea10:
00CB2E  2  00 F1 FE B5      .byte $00, $f1, $fe, $b5, $0d, $02, $fe, $34, $07, $cf, $ce, $00, $0d, $05, $8d, $47
00CB32  2  0D 02 FE 34  
00CB36  2  07 CF CE 00  
00CB3E  2  FD               .byte $fd
00CB3F  2               
00CB3F  2               ;level 9-1 starting area
00CB3F  2               L_GroundArea25:
00CB3F  2  50 02 9F 38      .byte $50, $02, $9f, $38, $ee, $01, $12, $b9, $77, $7b, $de, $0f, $6d, $c7, $fd
00CB43  2  EE 01 12 B9  
00CB47  2  77 7B DE 0F  
00CB4E  2               
00CB4E  2               ;two unused levels
00CB4E  2               L_GroundArea26:
00CB4E  2  FD               .byte $fd
00CB4F  2               L_GroundArea27:
00CB4F  2  FD               .byte $fd
00CB50  2               
00CB50  2               ;level 9-1 water area
00CB50  2               L_WaterArea6:
00CB50  2  00 A1 0A 60      .byte $00, $a1, $0a, $60, $19, $61, $28, $62, $39, $71, $58, $62, $69, $61, $7a, $60
00CB54  2  19 61 28 62  
00CB58  2  39 71 58 62  
00CB60  2  7C F5 A5 11      .byte $7c, $f5, $a5, $11, $fe, $20, $1f, $80, $5e, $21, $80, $3f, $8f, $65, $d6, $74
00CB64  2  FE 20 1F 80  
00CB68  2  5E 21 80 3F  
00CB70  2  5E A0 6F 66      .byte $5e, $a0, $6f, $66, $9e, $21, $c3, $37, $47, $f3, $9e, $20, $fe, $21, $0d, $06
00CB74  2  9E 21 C3 37  
00CB78  2  47 F3 9E 20  
00CB80  2  57 32 64 11      .byte $57, $32, $64, $11, $66, $10, $83, $a7, $87, $27, $0d, $09, $1d, $4a, $5f, $38
00CB84  2  66 10 83 A7  
00CB88  2  87 27 0D 09  
00CB90  2  6D C1 AF 26      .byte $6d, $c1, $af, $26, $6d, $c7, $fd
00CB94  2  6D C7 FD     
00CB97  2               
00CB97  2               ;level 9-2
00CB97  2               L_WaterArea7:
00CB97  2  50 11 D7 73      .byte $50, $11, $d7, $73, $fe, $1a, $6f, $e2, $1f, $e5, $bf, $63, $c7, $a8, $df, $61
00CB9B  2  FE 1A 6F E2  
00CB9F  2  1F E5 BF 63  
00CBA7  2  15 F1 7F 62      .byte $15, $f1, $7f, $62, $9b, $2f, $a8, $72, $fe, $10, $69, $f1, $b7, $25, $c5, $71
00CBAB  2  9B 2F A8 72  
00CBAF  2  FE 10 69 F1  
00CBB7  2  33 AC 5F 71      .byte $33, $ac, $5f, $71, $8d, $4a, $aa, $14, $d1, $71, $17, $95, $26, $42, $72, $42
00CBBB  2  8D 4A AA 14  
00CBBF  2  D1 71 17 95  
00CBC7  2  73 12 7A 14      .byte $73, $12, $7a, $14, $c6, $14, $d5, $42, $fe, $11, $7f, $b8, $8d, $c1, $cf, $26
00CBCB  2  C6 14 D5 42  
00CBCF  2  FE 11 7F B8  
00CBD7  2  6D C7 FD         .byte $6d, $c7, $fd
00CBDA  2               
00CBDA  2               ;level 9-4
00CBDA  2               L_WaterArea8:
00CBDA  2  57 00 0B 3F      .byte $57, $00, $0b, $3f, $0b, $bf, $0b, $bf, $73, $36, $9a, $30, $a5, $64, $b6, $31
00CBDE  2  0B BF 0B BF  
00CBE2  2  73 36 9A 30  
00CBEA  2  D4 61 0B BF      .byte $d4, $61, $0b, $bf, $13, $63, $4a, $60, $53, $66, $a5, $34, $b3, $67, $e5, $65
00CBEE  2  13 63 4A 60  
00CBF2  2  53 66 A5 34  
00CBFA  2  F4 60 0B BF      .byte $f4, $60, $0b, $bf, $14, $60, $53, $67, $67, $32, $c4, $62, $d4, $31, $f3, $61
00CBFE  2  14 60 53 67  
00CC02  2  67 32 C4 62  
00CC0A  2  FA 60 0B BF      .byte $fa, $60, $0b, $bf, $04, $30, $09, $61, $14, $65, $63, $65, $6a, $60, $0b, $bf
00CC0E  2  04 30 09 61  
00CC12  2  14 65 63 65  
00CC1A  2  0F 38 0B BF      .byte $0f, $38, $0b, $bf, $1d, $41, $3e, $42, $5f, $20, $ce, $40, $0b, $bf, $3d, $47
00CC1E  2  1D 41 3E 42  
00CC22  2  5F 20 CE 40  
00CC2A  2  FD               .byte $fd
00CC2B  2               
00CC2B  2               ;-------------------------------------------------------------------------------------
00CC2B  2               
00CC2B  2               ; unused space
00CC2B  2               
00CC2B  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CC2F  2  FF FF FF FF  
00CC33  2  FF FF FF FF  
00CC39  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CC3D  2  FF FF FF FF  
00CC41  2  FF FF FF FF  
00CC47  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CC4B  2  FF FF FF FF  
00CC4F  2  FF FF FF FF  
00CC55  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00CC59  2  FF FF FF FF  
00CC5D  2  FF FF        
00CC5F  2               
00CC5F  2               AlternateSoundEngine:
00CC5F  2  AD 76 07         lda GamePauseStatus     ;check to see if game is paused
00CC62  2  F0 0A            beq RunAltSoundRoutines ;branch to play sfx and music if not
00CC64  2  A9 80            lda #$80
00CC66  2  8D 80 40         sta FDSSND_VOLUMECTRL   ;otherwise, silence everything
00CC69  2  4A               lsr
00CC6A  2  8D 15 40         sta SND_MASTERCTRL_REG
00CC6D  2  60               rts
00CC6E  2               
00CC6E  2               RunAltSoundRoutines:
00CC6E  2  A9 FF            lda #$ff                ;disable irqs from apu and set frame counter mode
00CC70  2  8D 17 40         sta JOYPAD_PORT2
00CC73  2  A9 0F            lda #$0f
00CC75  2  8D 15 40         sta SND_MASTERCTRL_REG  ;enable first four channels
00CC78  2  20 rr rr         jsr Square2SfxHandler   ;play sfx on square channel 2
00CC7B  2  20 88 CC         jsr AltMusicHandler
00CC7E  2  A9 00            lda #$00
00CC80  2  85 FB            sta AreaMusicQueue
00CC82  2  85 FE            sta Square2SoundQueue
00CC84  2  60               rts
00CC85  2               
00CC85  2               ContinueMusic:
00CC85  2  4C 01 CD         jmp HandleSquare2Music
00CC88  2               
00CC88  2               AltMusicHandler:
00CC88  2  A5 FB            lda AreaMusicQueue
00CC8A  2  D0 06            bne PlayMusic
00CC8C  2  AD 08 06         lda AltMusicBuffer
00CC8F  2  D0 F4            bne ContinueMusic
00CC91  2  60               rts
00CC92  2               
00CC92  2               PlayMusic:
00CC92  2  A0 00            ldy #$00                ;init song pattern number
00CC94  2  8C 1D 06         sty PatternNumber
00CC97  2  8D 08 06         sta AltMusicBuffer      ;dump queue contents into buffer
00CC9A  2               NextPattern:
00CC9A  2  EE 1D 06         inc PatternNumber
00CC9D  2  AC 1D 06         ldy PatternNumber
00CCA0  2  C0 0C            cpy #$0c
00CCA2  2  D0 03            bne LoadPatternHeader
00CCA4  2  4C 19 CD         jmp StopMusic
00CCA7  2               
00CCA7  2               LoadPatternHeader:
00CCA7  2  B9 F9 CF         lda MusicHeaderOffsetData-1,y  ;load pattern header offset using an address
00CCAA  2  A8               tay                            ;one byte behind (because Y starts at 1)
00CCAB  2  B9 FA CF         lda MusicHeaderData-$b,y
00CCAE  2  8D 09 06         sta NoteLengthTblAdder
00CCB1  2  B9 FB CF         lda MusicHeaderData-$a,y       ;now load the pattern header data using addresses
00CCB4  2  85 66            sta MusicDataLow               ;that are relative of where the offset data is
00CCB6  2  B9 FC CF         lda MusicHeaderData-9,y        ;plus the offset data itself that was loaded
00CCB9  2  85 67            sta MusicDataHigh
00CCBB  2  B9 FD CF         lda MusicHeaderData-8,y
00CCBE  2  8D 0C 06         sta MusicOffset_Triangle
00CCC1  2  B9 FE CF         lda MusicHeaderData-7,y
00CCC4  2  8D 0B 06         sta MusicOffset_Square1
00CCC7  2  B9 FF CF         lda MusicHeaderData-6,y
00CCCA  2  8D 0D 06         sta MusicOffset_Noise
00CCCD  2  8D 1B 06         sta NoiseDataLoopbackOfs
00CCD0  2  B9 00 D0         lda MusicHeaderData-5,y
00CCD3  2  8D 1F 06         sta MusicOffset_FDSSND
00CCD6  2  B9 01 D0         lda MusicHeaderData-4,y
00CCD9  2  8D 0E 06         sta WaveformID                 ;value here is not used, but retained (probably for testing)
00CCDC  2  85 01            sta $01
00CCDE  2  20 ED CE         jsr ProcessWaveformData
00CCE1  2  A9 01            lda #$01                       ;init note length counters
00CCE3  2  8D 11 06         sta Squ2_NoteLenCounter
00CCE6  2  8D 13 06         sta Squ1_NoteLenCounter
00CCE9  2  8D 16 06         sta Tri_NoteLenCounter
00CCEC  2  8D 17 06         sta Noise_BeatLenCounter
00CCEF  2  8D F1 05         sta FDSSND_LenCounter
00CCF2  2  A9 00            lda #$00
00CCF4  2  8D 0A 06         sta MusicOffset_Square2
00CCF7  2  A9 0B            lda #$0b
00CCF9  2  8D 15 40         sta SND_MASTERCTRL_REG         ;disable and reenable triangle channel
00CCFC  2  A9 0F            lda #$0f
00CCFE  2  8D 15 40         sta SND_MASTERCTRL_REG
00CD01  2               
00CD01  2               HandleSquare2Music:
00CD01  2  CE 11 06         dec Squ2_NoteLenCounter   ;if note length not expired, skip ahead to envelope
00CD04  2  D0 65            bne MiscSqu2MusicTasks
00CD06  2  AC 0A 06         ldy MusicOffset_Square2
00CD09  2  EE 0A 06         inc MusicOffset_Square2   ;get next byte in music data
00CD0C  2  B1 66            lda (MusicData),y
00CD0E  2  F0 04            beq EndPattern            ;if end terminator, branch to play the next pattern or stop
00CD10  2  10 3E            bpl Squ2NoteHandler       ;if positive, data is note, branch to play it
00CD12  2  D0 2E            bne Squ2LengthHandler     ;otherwise data is length, branch to process length
00CD14  2               EndPattern:
00CD14  2  AD 08 06         lda AltMusicBuffer        ;if music buffer still set, branch
00CD17  2  D0 26            bne NextPatternJump
00CD19  2               StopMusic:
00CD19  2  A9 00            lda #$00                  ;otherwise init sound and sound related variables
00CD1B  2  8D 08 06         sta AltMusicBuffer        ;to silence everything
00CD1E  2  8D 08 40         sta SND_TRIANGLE_REG
00CD21  2  85 67            sta MusicDataHigh
00CD23  2  85 66            sta MusicDataLow
00CD25  2  8D 0A 06         sta MusicOffset_Square2
00CD28  2  8D 0B 06         sta MusicOffset_Square1
00CD2B  2  8D 0C 06         sta MusicOffset_Triangle
00CD2E  2  8D 0D 06         sta MusicOffset_Noise
00CD31  2  A9 90            lda #$90
00CD33  2  8D 00 40         sta SND_SQUARE1_REG
00CD36  2  8D 04 40         sta SND_SQUARE2_REG
00CD39  2  A9 80            lda #$80
00CD3B  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CD3E  2  60               rts
00CD3F  2               
00CD3F  2               NextPatternJump:
00CD3F  2  4C 9A CC         jmp NextPattern
00CD42  2               
00CD42  2               Squ2LengthHandler:
00CD42  2  20 AC CF         jsr ProcessLengthData     ;store length of note
00CD45  2  8D 10 06         sta Squ2_NoteLenBuffer
00CD48  2  AC 0A 06         ldy MusicOffset_Square2
00CD4B  2  EE 0A 06         inc MusicOffset_Square2   ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00CD4E  2  B1 66            lda (MusicData),y
00CD50  2               
00CD50  2               Squ2NoteHandler:
00CD50  2  A6 F2            ldx Square2SoundBuffer    ;if playing sound on square 2 channel, skip
00CD52  2  D0 11            bne SkipFqL1
00CD54  2  20 DF CF         jsr SetFreq_Squ2          ;otherwise play a note on square 2
00CD57  2  F0 06            beq Rest
00CD59  2  A9 10            lda #$10                  ;set envelope counter and regs for square 2
00CD5B  2  A2 82            ldx #$82
00CD5D  2  A0 7F            ldy #$7f
00CD5F  2               Rest:
00CD5F  2  8D 12 06         sta Squ2_EnvelopeDataCtrl
00CD62  2  20 D5 CF         jsr Dump_Sq2_Regs
00CD65  2               SkipFqL1:
00CD65  2  AD 10 06         lda Squ2_NoteLenBuffer    ;save length to counter
00CD68  2  8D 11 06         sta Squ2_NoteLenCounter
00CD6B  2               
00CD6B  2               MiscSqu2MusicTasks:
00CD6B  2  A5 F2            lda Square2SoundBuffer    ;if playing sound on square 2 channel, skip
00CD6D  2  D0 0E            bne HandleSquare1Music
00CD6F  2  AC 12 06         ldy Squ2_EnvelopeDataCtrl ;get envelope counter
00CD72  2  F0 03            beq NoDecEnv1             ;use to update envelope on square 2 unless expired
00CD74  2  CE 12 06         dec Squ2_EnvelopeDataCtrl
00CD77  2               NoDecEnv1:
00CD77  2  B9 3C D2         lda VictoryMusEnvData,y
00CD7A  2  8D 04 40         sta SND_SQUARE2_REG
00CD7D  2               
00CD7D  2               HandleSquare1Music:
00CD7D  2  AC 0B 06         ldy MusicOffset_Square1   ;get offset, skip if none was ever loaded
00CD80  2  F0 3A            beq HandleTriangleMusic
00CD82  2  CE 13 06         dec Squ1_NoteLenCounter   ;if note length not expired, skip ahead to envelope
00CD85  2  D0 22            bne MiscSqu1MusicTasks
00CD87  2  AC 0B 06         ldy MusicOffset_Square1
00CD8A  2  EE 0B 06         inc MusicOffset_Square1
00CD8D  2  B1 66            lda (MusicData),y         ;get note and encoded length
00CD8F  2  20 A6 CF         jsr LengthDecoder         ;decode it
00CD92  2  8D 13 06         sta Squ1_NoteLenCounter   ;save length
00CD95  2  8A               txa
00CD96  2  29 3E            and #$3e
00CD98  2  20 C1 CF         jsr SetFreq_Squ1          ;play a note on square 1
00CD9B  2  F0 06            beq SkipCtrlL
00CD9D  2  A9 10            lda #$10                  ;set envelope counter and regs for square 1
00CD9F  2  A2 82            ldx #$82
00CDA1  2  A0 7F            ldy #$7f
00CDA3  2               SkipCtrlL:
00CDA3  2  8D 14 06         sta Squ1_EnvelopeDataCtrl
00CDA6  2  20 B7 CF         jsr Dump_Squ1_Regs
00CDA9  2               MiscSqu1MusicTasks:
00CDA9  2  AC 14 06         ldy Squ1_EnvelopeDataCtrl ;get envelope counter
00CDAC  2  F0 03            beq NoDecEnv2             ;use to update envelope on square 1
00CDAE  2  CE 14 06         dec Squ1_EnvelopeDataCtrl
00CDB1  2               NoDecEnv2:
00CDB1  2  B9 3C D2         lda VictoryMusEnvData,y
00CDB4  2  8D 00 40         sta SND_SQUARE1_REG
00CDB7  2  A9 7F            lda #$7f
00CDB9  2  8D 01 40         sta SND_SQUARE1_REG+1
00CDBC  2               
00CDBC  2               HandleTriangleMusic:
00CDBC  2  AD 0C 06         lda MusicOffset_Triangle  ;get offset, skip if none was ever loaded
00CDBF  2  F0 38            beq HandleFDSMusic
00CDC1  2  CE 16 06         dec Tri_NoteLenCounter    ;if note length not expired, skip ahead
00CDC4  2  D0 33            bne HandleFDSMusic
00CDC6  2  AC 0C 06         ldy MusicOffset_Triangle
00CDC9  2  EE 0C 06         inc MusicOffset_Triangle  ;get next byte in music data
00CDCC  2  B1 66            lda (MusicData),y
00CDCE  2  F0 26            beq LoadTriCtrlReg        ;if zero, skip all this and move on to the FDS channel
00CDD0  2  10 10            bpl TriNoteHandler        ;if positive, branch to process note
00CDD2  2  20 AC CF         jsr ProcessLengthData     ;otherwise process length
00CDD5  2  8D 15 06         sta Tri_NoteLenBuffer
00CDD8  2  AC 0C 06         ldy MusicOffset_Triangle
00CDDB  2  EE 0C 06         inc MusicOffset_Triangle  ;get next byte in music data (must not be length byte!)
00CDDE  2  B1 66            lda (MusicData),y
00CDE0  2  F0 14            beq LoadTriCtrlReg        ;if zero, skip, as before
00CDE2  2               TriNoteHandler:
00CDE2  2  20 E3 CF         jsr SetFreq_Tri           ;play a note on triangle
00CDE5  2  AE 15 06         ldx Tri_NoteLenBuffer
00CDE8  2  8E 16 06         stx Tri_NoteLenCounter    ;save length to counter
00CDEB  2  8A               txa
00CDEC  2  C9 12            cmp #$12                  ;if playing a note longer than 12 frames,
00CDEE  2  B0 04            bcs LongN                 ;branch to set triangle reg to $ff
00CDF0  2  A9 18            lda #$18
00CDF2  2  D0 02            bne LoadTriCtrlReg        ;otherwise set triangle reg to $18 for short notes
00CDF4  2               LongN:
00CDF4  2  A9 FF            lda #$ff
00CDF6  2               LoadTriCtrlReg:
00CDF6  2  8D 08 40         sta SND_TRIANGLE_REG
00CDF9  2               
00CDF9  2               HandleFDSMusic:
00CDF9  2  AD 1F 06         lda MusicOffset_FDSSND       ;if no offset loaded, skip to handle noise channel
00CDFC  2  D0 03            bne CheckForCutoff
00CDFE  2  4C BB CE         jmp HandleNoiseMusic
00CE01  2               
00CE01  2               CheckForCutoff:
00CE01  2  AD F1 05         lda FDSSND_LenCounter        ;check to see if length at specific point in note
00CE04  2  C9 02            cmp #$02                     ;if not, skip this part
00CE06  2  D0 05            bne RunFDSChannel
00CE08  2  A9 00            lda #$00                     ;otherwise perform note cutoff
00CE0A  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CE0D  2               RunFDSChannel:
00CE0D  2  CE F1 05         dec FDSSND_LenCounter        ;if length not expired, skip ahead
00CE10  2  D0 5C            bne FDSSND_EnvModRun
00CE12  2  AC 1F 06         ldy MusicOffset_FDSSND
00CE15  2  EE 1F 06         inc MusicOffset_FDSSND       ;get next byte in music data
00CE18  2  B1 66            lda (MusicData),y
00CE1A  2  10 0E            bpl FDSSND_NoteHandler       ;if positive, branch to process note
00CE1C  2  20 AC CF         jsr ProcessLengthData        ;otherwise process length
00CE1F  2  8D F2 05         sta FDSSND_LenBuffer
00CE22  2  AC 1F 06         ldy MusicOffset_FDSSND
00CE25  2  EE 1F 06         inc MusicOffset_FDSSND       ;get next byte in music data (must not be length byte!)
00CE28  2  B1 66            lda (MusicData),y
00CE2A  2               FDSSND_NoteHandler:
00CE2A  2  20 E7 CF         jsr SetFreq_FDS              ;play a note on the FDS channel
00CE2D  2  A8               tay
00CE2E  2  D0 07            bne FDSSND_EnvModStart       ;if frequency high was nonzero, branch
00CE30  2  A2 80            ldx #$80
00CE32  2  8E 80 40         stx FDSSND_VOLUMECTRL        ;otherwise play a rest, use zero from frequency low data
00CE35  2  D0 06            bne InitialEnvData           ;to be loaded into envelope timer
00CE37  2               FDSSND_EnvModStart:
00CE37  2  20 5D CF         jsr GetModulationTable       ;reload modulation table
00CE3A  2  AC F7 05         ldy FDSSND_MasterEnvSet
00CE3D  2               InitialEnvData:
00CE3D  2  8C F3 05         sty FDSSND_MasterEnvTimer    ;dump value from header data or zero if rest
00CE40  2  A0 00            ldy #$00                     ;as value into the timer
00CE42  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;init envelope and sweep counter offsets
00CE45  2  8C FB 05         sty FDSSND_SweepModOffset
00CE48  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get volume and sweep envelope data for the start of the note
00CE4A  2  8D 80 40         sta FDSSND_VOLUMECTRL
00CE4D  2  B1 6C            lda (FDSSND_SweepModData),y
00CE4F  2  8D 84 40         sta FDSSND_SWEEPCTRL
00CE52  2  A9 00            lda #$00
00CE54  2  8D 85 40         sta FDSSND_SWEEPBIAS         ;set no sweep bias
00CE57  2  C8               iny
00CE58  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get timing for volume and sweep envelopes
00CE5A  2  8D F8 05         sta FDSSND_VolumeEnvTimer
00CE5D  2  B1 6C            lda (FDSSND_SweepModData),y
00CE5F  2  8D FA 05         sta FDSSND_SweepModTimer
00CE62  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;set current offset
00CE65  2  8C FB 05         sty FDSSND_SweepModOffset
00CE68  2  AD F2 05         lda FDSSND_LenBuffer
00CE6B  2  8D F1 05         sta FDSSND_LenCounter        ;dump length of note
00CE6E  2               FDSSND_EnvModRun:
00CE6E  2  AD F3 05         lda FDSSND_MasterEnvTimer    ;get master counter, skip over this if at zero
00CE71  2  F0 48            beq HandleNoiseMusic
00CE73  2  CE F3 05         dec FDSSND_MasterEnvTimer    ;decrement the master counter
00CE76  2  CE F8 05         dec FDSSND_VolumeEnvTimer    ;if envelope counter not expired, branch to skip this
00CE79  2  D0 1B            bne SweepModCtrl
00CE7B  2               VolumeEnvCtrl:
00CE7B  2  EE F9 05         inc FDSSND_VolumeEnvOffset
00CE7E  2  AC F9 05         ldy FDSSND_VolumeEnvOffset   ;get next byte of data
00CE81  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;if positive, write and continue
00CE83  2  10 05            bpl VolumeEnvTiming
00CE85  2  8D 80 40         sta FDSSND_VOLUMECTRL        ;otherwise, write and loop to get another byte
00CE88  2  D0 F1            bne VolumeEnvCtrl
00CE8A  2               VolumeEnvTiming:
00CE8A  2  8D 80 40         sta FDSSND_VOLUMECTRL        ;write to control the envelope of FDS channel
00CE8D  2  C8               iny
00CE8E  2  B1 6A            lda (FDSSND_VolumeEnvData),y ;get another byte of data, set counter
00CE90  2  8D F8 05         sta FDSSND_VolumeEnvTimer
00CE93  2  8C F9 05         sty FDSSND_VolumeEnvOffset   ;save offset for later
00CE96  2               SweepModCtrl:
00CE96  2  CE FA 05         dec FDSSND_SweepModTimer
00CE99  2  D0 20            bne HandleNoiseMusic         ;decrement sweep/modulation counter, skip if not expired
00CE9B  2  EE FB 05         inc FDSSND_SweepModOffset
00CE9E  2  AC FB 05         ldy FDSSND_SweepModOffset    ;get some more data
00CEA1  2  B1 6C            lda (FDSSND_SweepModData),y  ;save to sweep control, and mod frequency low and high
00CEA3  2  8D 84 40         sta FDSSND_SWEEPCTRL
00CEA6  2  C8               iny
00CEA7  2  B1 6C            lda (FDSSND_SweepModData),y
00CEA9  2  8D 86 40         sta FDSSND_MODFREQLOW
00CEAC  2  C8               iny
00CEAD  2  B1 6C            lda (FDSSND_SweepModData),y
00CEAF  2  8D 87 40         sta FDSSND_MODFREQHIGH
00CEB2  2  C8               iny
00CEB3  2  B1 6C            lda (FDSSND_SweepModData),y  ;get another byte of data, set counter
00CEB5  2  8D FA 05         sta FDSSND_SweepModTimer
00CEB8  2  8C FB 05         sty FDSSND_SweepModOffset    ;save offset for later
00CEBB  2               
00CEBB  2               HandleNoiseMusic:
00CEBB  2  CE 17 06         dec Noise_BeatLenCounter     ;if length not expired, branch to leave
00CEBE  2  D0 2C            bne ExitMusicHandler
00CEC0  2               FetchNoiseBeatData:
00CEC0  2  AC 0D 06         ldy MusicOffset_Noise
00CEC3  2  EE 0D 06         inc MusicOffset_Noise        ;get next byte in beat data
00CEC6  2  B1 66            lda (MusicData),y
00CEC8  2  D0 08            bne ProcBeatData             ;if nonzero, branch to process beat data
00CECA  2  AD 1B 06         lda NoiseDataLoopbackOfs
00CECD  2  8D 0D 06         sta MusicOffset_Noise        ;otherwise zero is loop, dump offset to loop
00CED0  2  D0 EE            bne FetchNoiseBeatData       ;the pattern and loop back, refetch data
00CED2  2               ProcBeatData:
00CED2  2  20 A6 CF         jsr LengthDecoder            ;decode length and save it
00CED5  2  8D 17 06         sta Noise_BeatLenCounter
00CED8  2  8A               txa
00CED9  2  29 3E            and #$3e                     ;get beat data
00CEDB  2  F0 06            beq PlayBeat                 ;if none, branch to play silent beat
00CEDD  2  A9 1C            lda #$1c
00CEDF  2  A2 03            ldx #$03                     ;otherwise play only one kind of beat
00CEE1  2  A0 18            ldy #$18
00CEE3  2               PlayBeat:
00CEE3  2  8D 0C 40         sta SND_NOISE_REG
00CEE6  2  8E 0E 40         stx SND_NOISE_REG+2          ;dump to noise regs
00CEE9  2  8C 0F 40         sty SND_NOISE_REG+3
00CEEC  2               ExitMusicHandler:
00CEEC  2  60               rts
00CEED  2               
00CEED  2               ProcessWaveformData:
00CEED  2  A5 01            lda $01                ;if last value in header was set to zero, leave
00CEEF  2  D0 01            bne GetWaveformHeader  ;otherwise, use to load header for waveform
00CEF1  2  60               rts                    ;and data for the envelope and modulation
00CEF2  2               
00CEF2  2               GetWaveformHeader:
00CEF2  2  A0 00            ldy #$00
00CEF4  2               FindHeader:
00CEF4  2  C8               iny
00CEF5  2  4A               lsr                           ;increment offset for every clear bit in value loaded
00CEF6  2  90 FC            bcc FindHeader
00CEF8  2  B9 4B D2         lda WaveformHeaderOffsets-1,y ;get offset to header
00CEFB  2  A8               tay
00CEFC  2  B9 4C D2         lda WaveformHeaderData-2,y
00CEFF  2  85 68            sta WaveformData              ;get header
00CF01  2  B9 4D D2         lda WaveformHeaderData-1,y
00CF04  2  85 69            sta WaveformData+1
00CF06  2  B9 4E D2         lda WaveformHeaderData,y
00CF09  2  8D F7 05         sta FDSSND_MasterEnvSet
00CF0C  2  B9 4F D2         lda WaveformHeaderData+1,y
00CF0F  2  85 6A            sta FDSSND_VolumeEnvData
00CF11  2  B9 50 D2         lda WaveformHeaderData+2,y
00CF14  2  85 6B            sta FDSSND_VolumeEnvData+1
00CF16  2  B9 51 D2         lda WaveformHeaderData+3,y
00CF19  2  85 6C            sta FDSSND_SweepModData
00CF1B  2  B9 52 D2         lda WaveformHeaderData+4,y
00CF1E  2  85 6D            sta FDSSND_SweepModData+1
00CF20  2  B9 53 D2         lda WaveformHeaderData+5,y
00CF23  2  8D F6 05         sta FDSSND_ModTableNumber
00CF26  2  20 2F CF         jsr GetWaveformData
00CF29  2  A9 02            lda #$02                      ;set volume, overwriting the setting from sub
00CF2B  2  8D 89 40         sta FDSSND_WAVEENABLEWR       ;that just got returned from
00CF2E  2  60               rts
00CF2F  2               
00CF2F  2               GetWaveformData:
00CF2F  2  A9 80                  lda #$80                ;enable writes to FDS waveform RAM
00CF31  2  8D 89 40               sta FDSSND_WAVEENABLEWR
00CF34  2  A9 00                  lda #$00                ;init first byte of it
00CF36  2  8D 40 40               sta FDSSND_WAVERAM
00CF39  2  A0 00                  ldy #$00
00CF3B  2  A2 3F                  ldx #$3f
00CF3D  2  B1 68        GWDLoop:  lda (WaveformData),y    ;write each byte of data to the waveform RAM
00CF3F  2  99 41 40               sta FDSSND_WAVERAM+1,y  ;both from start to middle and from end to middle
00CF42  2  C8                     iny                     ;so that the data eventually converge and mirror
00CF43  2  C0 20                  cpy #$20
00CF45  2  F0 06                  beq SetWMVol
00CF47  2  9D 40 40               sta FDSSND_WAVERAM,x
00CF4A  2  CA                     dex
00CF4B  2  D0 F0                  bne GWDLoop
00CF4D  2  AD 08 06     SetWMVol: lda AltMusicBuffer      ;if d6 was clear, branch to lower the volume
00CF50  2  29 40                  and #$40                ;otherwise set for full volume
00CF52  2  F0 04                  beq LowV
00CF54  2  A9 00                  lda #$00                ;this may have been used once for testing but is
00CF56  2  F0 02                  beq FullV               ;irrelevant now because the setting is overwritten
00CF58  2  A9 03        LowV:     lda #$03
00CF5A  2  8D 89 40     FullV:    sta FDSSND_WAVEENABLEWR ;then fall through to next routine
00CF5D  2               
00CF5D  2               GetModulationTable:
00CF5D  2  A9 80                 lda #$80                  ;disable modulation
00CF5F  2  8D 87 40              sta FDSSND_MODFREQHIGH
00CF62  2  A9 00                 lda #$00
00CF64  2  8D 85 40              sta FDSSND_SWEEPBIAS      ;set no sweep bias
00CF67  2  A2 20                 ldx #$20
00CF69  2  AC F6 05              ldy FDSSND_ModTableNumber ;get value from header
00CF6C  2  84 02                 sty $02
00CF6E  2  A5 02        MTableL: lda $02                   ;divide loaded value by 2, use as counter and offset
00CF70  2  4A                    lsr                       ;(original value is * 2 because it shifts LSB for odd/even)
00CF71  2  A8                    tay
00CF72  2  B9 86 CF              lda ModTableData,y        ;get data, use lower nybble on every odd count
00CF75  2  B0 04                 bcs OddT                  ;and the upper nybble on every even count
00CF77  2  4A                    lsr
00CF78  2  4A                    lsr                       ;otherwise shift upper nybble to use it instead
00CF79  2  4A                    lsr
00CF7A  2  4A                    lsr
00CF7B  2  29 0F        OddT:    and #$0f                  ;write to modulation table
00CF7D  2  8D 88 40              sta FDSSND_MODTBLAPPEND
00CF80  2  E6 02                 inc $02                   ;increment loaded value
00CF82  2  CA                    dex
00CF83  2  D0 E9                 bne MTableL
00CF85  2  60                    rts
00CF86  2               
00CF86  2               ModTableData:
00CF86  2  07 07 07 07  ModTable1: .byte $07, $07, $07, $07, $01, $01, $01, $01, $01, $01, $01, $01, $07, $07, $07, $07
00CF8A  2  01 01 01 01  
00CF8E  2  01 01 01 01  
00CF96  2  77 77 77 77  ModTable2: .byte $77, $77, $77, $77, $11, $11, $11, $11, $11, $11, $11, $11, $77, $77, $77, $77
00CF9A  2  11 11 11 11  
00CF9E  2  11 11 11 11  
00CFA6  2               
00CFA6  2               LengthDecoder:
00CFA6  2  AA               tax
00CFA7  2  6A               ror
00CFA8  2  8A               txa
00CFA9  2  2A               rol
00CFAA  2  2A               rol
00CFAB  2  2A               rol
00CFAC  2               ProcessLengthData:
00CFAC  2  29 07            and #$07                     ;save 3 LSB, add to header data loaded earlier
00CFAE  2  18               clc                          ;then use as offset to load note length
00CFAF  2  6D 09 06         adc NoteLengthTblAdder
00CFB2  2  A8               tay
00CFB3  2  B9 8F D2         lda MusicLengthLookupTbl,y
00CFB6  2  60               rts
00CFB7  2               
00CFB7  2               Dump_Squ1_Regs:
00CFB7  2  8C 01 40         sty SND_SQUARE1_REG+1    ;set regs for envelope on square 1 channel
00CFBA  2  8E 00 40         stx SND_SQUARE1_REG
00CFBD  2  60               rts
00CFBE  2               
00CFBE  2  20 B7 CF         jsr Dump_Squ1_Regs       ;dead code, nothing branches here
00CFC1  2               SetFreq_Squ1:
00CFC1  2  A2 00            ldx #$00
00CFC3  2               Dump_Freq_Regs:
00CFC3  2  A8               tay
00CFC4  2  B9 rr rr         lda FreqRegLookupTbl+1,y
00CFC7  2  F0 0B            beq NoTone
00CFC9  2  9D 02 40         sta SND_REGISTER+2,x
00CFCC  2  B9 rr rr         lda FreqRegLookupTbl,y
00CFCF  2  09 08            ora #$08
00CFD1  2  9D 03 40         sta SND_REGISTER+3,x
00CFD4  2               NoTone:
00CFD4  2  60               rts
00CFD5  2               
00CFD5  2               Dump_Sq2_Regs:
00CFD5  2  8E 04 40         stx SND_SQUARE2_REG       ;set regs for envelope on square 2 channel
00CFD8  2  8C 05 40         sty SND_SQUARE2_REG+1
00CFDB  2  60               rts
00CFDC  2               
00CFDC  2  20 D5 CF         jsr Dump_Sq2_Regs         ;dead code, nothing branches here
00CFDF  2               SetFreq_Squ2:
00CFDF  2  A2 04            ldx #$04                  ;set frequency regs for square 2 channel to play note
00CFE1  2  D0 E0            bne Dump_Freq_Regs
00CFE3  2               SetFreq_Tri:
00CFE3  2  A2 08            ldx #$08                  ;if branched here, do that for triangle channel
00CFE5  2  D0 DC            bne Dump_Freq_Regs
00CFE7  2               SetFreq_FDS:
00CFE7  2  A2 80            ldx #$80                  ;if branched here, start off by silencing the FDS channel
00CFE9  2  8E 83 40         stx FDSSND_FREQHIGH
00CFEC  2  A8               tay
00CFED  2  B9 00 D2         lda FDSFreqLookupTbl,y    ;now set the frequency regs for FDS channel
00CFF0  2  8D 83 40         sta FDSSND_FREQHIGH
00CFF3  2  B9 01 D2         lda FDSFreqLookupTbl+1,y
00CFF6  2  8D 82 40         sta FDSSND_FREQLOW
00CFF9  2  60               rts
00CFFA  2               
00CFFA  2               ;-------------------------------------------------------------------------------------
00CFFA  2               
00CFFA  2               MusicHeaderOffsetData:
00CFFA  2  0B 0B 13 0B      .byte VictoryPart1AHdr-MHD, VictoryPart1AHdr-MHD, VictoryPart1BHdr-MHD, VictoryPart1AHdr-MHD
00CFFE  2  1B 33 1B 33      .byte VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2BHdr-MHD
00D002  2  23 1B 2B         .byte VictoryPart2CHdr-MHD, VictoryPart2AHdr-MHD, VictoryPart2DHdr-MHD
00D005  2               
00D005  2               ;header format here is as follows:
00D005  2               ;1 byte - length byte offset
00D005  2               ;2 bytes - music data address
00D005  2               ;1 byte - triangle data offset
00D005  2               ;1 byte - square 1 data offset
00D005  2               ;1 byte - noise data offset
00D005  2               ;these two are unique to the sound engine in this file
00D005  2               ;1 byte - FDS channel data offset
00D005  2               ;1 byte - waveform ID
00D005  2               
00D005  2               MusicHeaderData:
00D005  2  00 38 D0 3E  VictoryPart1AHdr: .byte $00, <VictoryM_P1AData, >VictoryM_P1AData, $3e, $14, $b0, $24, $01
00D009  2  14 B0 24 01  
00D00D  2  00 87 D0 50  VictoryPart1BHdr: .byte $00, <VictoryM_P1BData, >VictoryM_P1BData, $50, $21, $61, $31, $02
00D011  2  21 61 31 02  
00D015  2  00 EF D0 43  VictoryPart2AHdr: .byte $00, <VictoryM_P2AData, >VictoryM_P2AData, $43, $1c, $b5, $29, $01
00D019  2  1C B5 29 01  
00D01D  2  00 43 D1 50  VictoryPart2CHdr: .byte $00, <VictoryM_P2CData, >VictoryM_P2CData, $50, $20, $61, $31, $02
00D021  2  20 61 31 02  
00D025  2  08 AB D1 09  VictoryPart2DHdr: .byte $08, <VictoryM_P2DData, >VictoryM_P2DData, $09, $04, $1e, $06, $01
00D029  2  04 1E 06 01  
00D02D  2  08 06 D1 3A  VictoryPart2BHdr: .byte $08, <VictoryM_P2BData, >VictoryM_P2BData, $3a, $10, $9e, $28, $01
00D031  2  10 9E 28 01  
00D035  2               
00D035  2               ;residual data, probably from an old header
00D035  2  00 4B D0         .byte $00, $4b, $d0
00D038  2               
00D038  2               ;music data format here is the same as in sm2main file
00D038  2               ;with a few exceptions: the value $00 does nothing special
00D038  2               ;for square 1, and noise data format plays only one kind of
00D038  2               ;beat for d5-d1 = nonzero, or rest for d5-d1 = 0
00D038  2               
00D038  2               VictoryM_P1AData:
00D038  2               ;square 2
00D038  2  84 12 86 0C      .byte $84, $12, $86, $0c, $84, $62, $10, $86
00D03C  2  84 62 10 86  
00D040  2  12 84 1C 22      .byte $12, $84, $1c, $22, $1e, $22, $26, $18
00D044  2  1E 22 26 18  
00D048  2  1E 04 1C 00      .byte $1e, $04, $1c, $00
00D04C  2               ;square 1
00D04C  2  E2 E0 E2 9D      .byte $e2, $e0, $e2, $9d, $1f, $21, $a3, $2d
00D050  2  1F 21 A3 2D  
00D054  2  74 F4 31 35      .byte $74, $f4, $31, $35, $37, $2b, $b1, $2d
00D058  2  37 2B B1 2D  
00D05C  2               ;FDS sound
00D05C  2  83 16 14 16      .byte $83, $16, $14, $16, $86, $10, $84, $12
00D060  2  86 10 84 12  
00D064  2  14 86 16 84      .byte $14, $86, $16, $84, $20, $81, $28, $83
00D068  2  20 81 28 83  
00D06C  2  28 84 24 28      .byte $28, $84, $24, $28, $2a, $1e, $86, $24
00D070  2  2A 1E 86 24  
00D074  2  84 20            .byte $84, $20
00D076  2               ;triangle
00D076  2  84 12 14 04      .byte $84, $12, $14, $04, $18, $1a, $1c, $14
00D07A  2  18 1A 1C 14  
00D07E  2  26 22 1E 1C      .byte $26, $22, $1e, $1c, $18, $1e, $22, $0c
00D082  2  18 1E 22 0C  
00D086  2  14               .byte $14
00D087  2               
00D087  2               VictoryM_P1BData:
00D087  2               ;square 2
00D087  2  81 22 83 22      .byte $81, $22, $83, $22, $86, $24, $85, $18
00D08B  2  86 24 85 18  
00D08F  2  82 1E 80 1E      .byte $82, $1e, $80, $1e, $83, $1c, $83, $18
00D093  2  83 1C 83 18  
00D097  2  84 1C 81 26      .byte $84, $1c, $81, $26, $83, $26, $86, $26
00D09B  2  83 26 86 26  
00D09F  2  85 1E 82 24      .byte $85, $1e, $82, $24, $86, $22, $84, $1e
00D0A3  2  86 22 84 1E  
00D0A7  2  00               .byte $00
00D0A8  2               ;square 1
00D0A8  2  74 F4 B5 6B      .byte $74, $f4, $b5, $6b, $b0, $30, $ec, $ea
00D0AC  2  B0 30 EC EA  
00D0B0  2  2D 76 F6 B7      .byte $2d, $76, $f6, $b7, $6d, $b0, $b5, $31
00D0B4  2  6D B0 B5 31  
00D0B8  2               ;FDS sound
00D0B8  2  81 10 83 10      .byte $81, $10, $83, $10, $86, $10, $85, $08
00D0BC  2  86 10 85 08  
00D0C0  2  82 0C 80 0C      .byte $82, $0c, $80, $0c, $83, $0a, $08, $84
00D0C4  2  83 0A 08 84  
00D0C8  2  0A 81 12 83      .byte $0a, $81, $12, $83, $12, $86, $12, $85
00D0CC  2  12 86 12 85  
00D0D0  2  0A 82 0C 86      .byte $0a, $82, $0c, $86, $10, $84, $0c
00D0D4  2  10 84 0C     
00D0D7  2               ;triangle
00D0D7  2  84 12 1C 20      .byte $84, $12, $1c, $20, $24, $2a, $26, $24
00D0DB  2  24 2A 26 24  
00D0DF  2  26 22 1E 22      .byte $26, $22, $1e, $22, $24, $1e, $22, $0c
00D0E3  2  24 1E 22 0C  
00D0E7  2  1E               .byte $1e
00D0E8  2               ;noise (also used by part 1A)
00D0E8  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D0EC  2  D0 11 00     
00D0EF  2               
00D0EF  2               VictoryM_P2AData:
00D0EF  2               ;square 2
00D0EF  2  83 2C 2A 2C      .byte $83, $2c, $2a, $2c, $86, $26, $84, $28
00D0F3  2  86 26 84 28  
00D0F7  2  2A 86 2C 84      .byte $2a, $86, $2c, $84, $36, $81, $40, $83
00D0FB  2  36 81 40 83  
00D0FF  2  40 84 3A 40      .byte $40, $84, $3a, $40, $3e, $34, $00
00D103  2  3E 34 00     
00D106  2               
00D106  2               VictoryM_P2BData:
00D106  2               ;square 2
00D106  2  86 3A 84 36      .byte $86, $3a, $84, $36, $00
00D10A  2  00           
00D10B  2               ;square 1 of part 2A
00D10B  2  1D 95 19 1B      .byte $1d, $95, $19, $1b, $9d, $27, $2d, $29
00D10F  2  9D 27 2D 29  
00D113  2  2D 31 23         .byte $2d, $31, $23
00D116  2               ;square 1 of part 2B
00D116  2  A9 27            .byte $a9, $27
00D118  2               ;FDS sound of part 2A
00D118  2  83 20 1E 20      .byte $83, $20, $1e, $20, $86, $1a, $84, $1c
00D11C  2  86 1A 84 1C  
00D120  2  1E 86 20 84      .byte $1e, $86, $20, $84, $2a, $81, $32, $83
00D124  2  2A 81 32 83  
00D128  2  32 84 2E 32      .byte $32, $84, $2e, $32, $34, $28
00D12C  2  34 28        
00D12E  2               ;FDS sound of part 2B
00D12E  2  86 2E 84 2A      .byte $86, $2e, $84, $2a
00D132  2               ;triangle of part 2A
00D132  2  84 1C 1E 04      .byte $84, $1c, $1e, $04, $22, $24, $26, $1e
00D136  2  22 24 26 1E  
00D13A  2  30 2C 28 26      .byte $30, $2c, $28, $26, $22, $28
00D13E  2  22 28        
00D140  2               ;triangle of part 2B
00D140  2  2C 14 1E         .byte $2c, $14, $1e
00D143  2               
00D143  2               VictoryM_P2CData:
00D143  2               ;square 2
00D143  2  81 40 83 40      .byte $81, $40, $83, $40, $86, $40, $85, $34
00D147  2  86 40 85 34  
00D14B  2  82 3A 80 3A      .byte $82, $3a, $80, $3a, $83, $36, $34, $84
00D14F  2  83 36 34 84  
00D153  2  36 81 3E 83      .byte $36, $81, $3e, $83, $3e, $86, $3e, $85
00D157  2  3E 86 3E 85  
00D15B  2  36 82 3A 86      .byte $36, $82, $3a, $86, $40, $84, $3a, $00
00D15F  2  40 84 3A 00  
00D163  2               ;square 1
00D163  2  6C EC AF 63      .byte $6c, $ec, $af, $63, $a8, $29, $c4, $e6
00D167  2  A8 29 C4 E6  
00D16B  2  E2 27 70 F0      .byte $e2, $27, $70, $f0, $b1, $69, $ae, $ad
00D16F  2  B1 69 AE AD  
00D173  2  29               .byte $29
00D174  2               ;FDS sound
00D174  2  81 1A 83 1A      .byte $81, $1a, $83, $1a, $86, $1a, $85, $10
00D178  2  86 1A 85 10  
00D17C  2  82 16 80 16      .byte $82, $16, $80, $16, $83, $12, $10, $84
00D180  2  83 12 10 84  
00D184  2  12 81 1C 83      .byte $12, $81, $1c, $83, $1c, $86, $1c, $85
00D188  2  1C 86 1C 85  
00D18C  2  12 82 16 86      .byte $12, $82, $16, $86, $1a, $84, $16
00D190  2  1A 84 16     
00D193  2               ;triangle
00D193  2  84 1C 26 2A      .byte $84, $1c, $26, $2a, $2e, $34, $30, $2e
00D197  2  2E 34 30 2E  
00D19B  2  30 2C 28 2C      .byte $30, $2c, $28, $2c, $2e, $28, $2c, $14
00D19F  2  2E 28 2C 14  
00D1A3  2  28               .byte $28
00D1A4  2               ;noise of part 2A, 2B and 2C
00D1A4  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D1A8  2  D0 11 00     
00D1AB  2               
00D1AB  2               VictoryM_P2DData:
00D1AB  2               ;square 2
00D1AB  2  87 3A 36 00      .byte $87, $3a, $36, $00
00D1AF  2               ;square 1
00D1AF  2  E9 E7            .byte $e9, $e7
00D1B1  2               ;FDS sound
00D1B1  2  87 2E 2A         .byte $87, $2e, $2a
00D1B4  2               ;triangle
00D1B4  2  83 16 1C 22      .byte $83, $16, $1c, $22, $28, $2e, $34, $84
00D1B8  2  28 2E 34 84  
00D1BC  2  3A 83 34 22      .byte $3a, $83, $34, $22, $34, $84, $36, $83
00D1C0  2  34 84 36 83  
00D1C4  2  1E 1E 1E 86      .byte $1e, $1e, $1e, $86, $1e
00D1C8  2  1E           
00D1C9  2               ;noise of part 2D
00D1C9  2  11 11 D0 D0      .byte $11, $11, $d0, $d0, $d0, $11, $00
00D1CD  2  D0 11 00     
00D1D0  2               
00D1D0  2               WaveformData2:
00D1D0  2  10 2C 2E 27      .byte $10, $2c, $2e, $27, $29, $2b, $2a, $28
00D1D4  2  29 2B 2A 28  
00D1D8  2  25 29 2F 2D      .byte $25, $29, $2f, $2d, $2c, $2a, $22, $24
00D1DC  2  2C 2A 22 24  
00D1E0  2  34 3F 31 2D      .byte $34, $3f, $31, $2d, $3a, $3b, $27, $12
00D1E4  2  3A 3B 27 12  
00D1E8  2  0A 1F 2C 27      .byte $0a, $1f, $2c, $27, $23, $28, $22, $1e
00D1EC  2  23 28 22 1E  
00D1F0  2               
00D1F0  2               VolEnvData2:
00D1F0  2  A0 04 18 60      .byte $a0, $04, $18, $60
00D1F4  2               VolEnvData1:
00D1F4  2  94 02 44 30      .byte $94, $02, $44, $30, $0a, $50, $a0, $02
00D1F8  2  0A 50 A0 02  
00D1FC  2  36 35 80 34      .byte $36, $35, $80, $34
00D200  2               
00D200  2               FDSFreqLookupTbl:
00D200  2  01 44 01 58      .byte $01, $44, $01, $58, $01, $99, $02, $22
00D204  2  01 99 02 22  
00D208  2  02 42 02 65      .byte $02, $42, $02, $65, $02, $b0, $02, $d9
00D20C  2  02 B0 02 D9  
00D210  2  03 04 03 32      .byte $03, $04, $03, $32, $03, $63, $03, $96
00D214  2  03 63 03 96  
00D218  2  03 CD 04 07      .byte $03, $cd, $04, $07, $04, $44, $04, $85
00D21C  2  04 44 04 85  
00D220  2  04 CA 05 13      .byte $04, $ca, $05, $13, $05, $60, $05, $b2
00D224  2  05 60 05 B2  
00D228  2  06 08 06 64      .byte $06, $08, $06, $64, $06, $c6, $07, $2d
00D22C  2  06 C6 07 2D  
00D230  2  07 9A 08 0E      .byte $07, $9a, $08, $0e, $08, $88, $09, $95
00D234  2  08 88 09 95  
00D238  2  0A 26 00 00      .byte $0a, $26, $00, $00
00D23C  2               
00D23C  2               VictoryMusEnvData:
00D23C  2  97 98 9A 9B      .byte $97, $98, $9a, $9b, $9b, $9a, $9a, $99
00D240  2  9B 9A 9A 99  
00D244  2  99 98 98 97      .byte $99, $98, $98, $97, $97, $96, $96, $95
00D248  2  97 96 96 95  
00D24C  2               
00D24C  2               ;header format here is as follows:
00D24C  2               ;2 bytes - waveform data address
00D24C  2               ;1 byte  - master envelope timing (used with both volume envelope and sweep/modulation)
00D24C  2               ;2 bytes - volume envelope data address
00D24C  2               ;2 bytes - sweep envelope/mod frequency data address
00D24C  2               ;1 byte  - modulation table data offset * 2
00D24C  2               
00D24C  2               WaveformHeaderOffsets:
00D24C  2  02 0A            .byte Wave1Hdr-WaveformHeaderOffsets, Wave2Hdr-WaveformHeaderOffsets
00D24E  2               
00D24E  2               WaveformHeaderData:
00D24E  2  5F D2 44 F4  Wave1Hdr:     .byte <WaveformData1, >WaveformData1, $44, <VolEnvData1
00D252  2  D1 7F D2 20                .byte >VolEnvData1, <SweepModData1, >SweepModData1, (ModTable2-ModTableData) * 2
00D256  2  D0 D1 60 F0  Wave2Hdr:     .byte <WaveformData2, >WaveformData2, $60, <VolEnvData2
00D25A  2  D1 89 D2 00                .byte >VolEnvData2, <SweepModData2, >SweepModData2, (ModTable1-ModTableData) * 2
00D25E  2  00                         .byte $00
00D25F  2               
00D25F  2               WaveformData1:
00D25F  2  01 02 03 04      .byte $01, $02, $03, $04, $06, $07, $09, $0b
00D263  2  06 07 09 0B  
00D267  2  0E 10 13 18      .byte $0e, $10, $13, $18, $20, $2b, $34, $3c
00D26B  2  20 2B 34 3C  
00D26F  2  3F 3F 3E 3D      .byte $3f, $3f, $3e, $3d, $3a, $36, $32, $2f
00D273  2  3A 36 32 2F  
00D277  2  2C 29 26 24      .byte $2c, $29, $26, $24, $21, $1e, $18, $19
00D27B  2  21 1E 18 19  
00D27F  2               
00D27F  2               SweepModData1:
00D27F  2  80 1B 81 0A      .byte $80, $1b, $81, $0a, $00, $04, $82, $10, $00, $60
00D283  2  00 04 82 10  
00D287  2  00 60        
00D289  2               SweepModData2:
00D289  2  80 02 80 00      .byte $80, $02, $80, $00, $00, $60
00D28D  2  00 60        
00D28F  2               
00D28F  2               MusicLengthLookupTbl:
00D28F  2  24 12 0D 09      .byte $24, $12, $0d, $09, $1b, $28, $36, $12
00D293  2  1B 28 36 12  
00D297  2  24 12 0D 09      .byte $24, $12, $0d, $09, $1b, $28, $36, $6c
00D29B  2  1B 28 36 6C  
00D29F  2               
00D29F  1               .reloc
00BCBEr 1               .endscope
00BCBEr 1               Data3End:
00BCBEr 1               
00BCBEr 1  03           .byte FileHeaderBlock
00BCBFr 1  06 40        .byte $06,$40
00BCC1r 1  53 4D 32 44  .byte "SM2DATA4"
00BCC5r 1  41 54 41 34  
00BCC9r 1  B4 C2        .word $c2b4
00BCCBr 1  4C 0F        .word Data4End-Data4Start
00BCCDr 1  00 04        .byte PRG,FileDataBlock
00BCCFr 1               Data4Start:
00BCCFr 1               .scope FILE_SM2DATA4
00BCCFr 1               .org $C2B4
00C2B4  1               .include "sm2data4.asm"
00C2B4  2               ;SMB2J DISASSEMBLY (SM2DATA4 portion)
00C2B4  2               
00C2B4  2               ;-------------------------------------------------------------------------------------
00C2B4  2               ;DEFINES
00C2B4  2               
00C2B4  2               AreaData              = $e7
00C2B4  2               AreaDataLow           = $e7
00C2B4  2               AreaDataHigh          = $e8
00C2B4  2               EnemyData             = $e9
00C2B4  2               EnemyDataLow          = $e9
00C2B4  2               EnemyDataHigh         = $ea
00C2B4  2               
00C2B4  2               FrameCounter          = $09
00C2B4  2               Enemy_State           = $1e
00C2B4  2               Enemy_Y_Position      = $cf
00C2B4  2               PiranhaPlantUpYPos    = $0417
00C2B4  2               PiranhaPlantDownYPos  = $0434
00C2B4  2               PiranhaPlant_Y_Speed  = $58
00C2B4  2               PiranhaPlant_MoveFlag = $a0
00C2B4  2               
00C2B4  2               Player_X_Scroll       = $06ff
00C2B4  2               
00C2B4  2               Player_PageLoc        = $6d
00C2B4  2               Player_X_Position     = $86
00C2B4  2               
00C2B4  2               AreaObjectLength      = $0730
00C2B4  2               WindFlag              = $07f9
00C2B4  2               
00C2B4  2               TimerControl          = $0747
00C2B4  2               EnemyFrameTimer       = $078a
00C2B4  2               
00C2B4  2               Sprite_Y_Position     = $0200
00C2B4  2               Sprite_Tilenumber     = $0201
00C2B4  2               Sprite_Attributes     = $0202
00C2B4  2               Sprite_X_Position     = $0203
00C2B4  2               
00C2B4  2               Alt_SprDataOffset     = $06ec
00C2B4  2               
00C2B4  2               NoiseSoundQueue       = $fd
00C2B4  2               
00C2B4  2               TerrainControl        = $0727
00C2B4  2               AreaStyle             = $0733
00C2B4  2               ForegroundScenery     = $0741
00C2B4  2               BackgroundScenery     = $0742
00C2B4  2               CloudTypeOverride     = $0743
00C2B4  2               BackgroundColorCtrl   = $0744
00C2B4  2               AreaType              = $074e
00C2B4  2               AreaAddrsLOffset      = $074f
00C2B4  2               AreaPointer           = $0750
00C2B4  2               
00C2B4  2               PlayerEntranceCtrl    = $0710
00C2B4  2               GameTimerSetting      = $0715
00C2B4  2               AltEntranceControl    = $0752
00C2B4  2               EntrancePage          = $0751
00C2B4  2               
00C2B4  2               WorldNumber           = $075f
00C2B4  2               AreaNumber            = $0760 ;internal number used to find areas
00C2B4  2               
00C2B4  2               ; imports from other files
00C2B4  2               .import HalfwayPageNybbles
00C2B4  2               .import GetPipeHeight
00C2B4  2               .import FindEmptyEnemySlot
00C2B4  2               .import SetupPiranhaPlant
00C2B4  2               .import VerticalPipeData
00C2B4  2               .import RenderUnderPart
00C2B4  2               .import MetatileBuffer
00C2B4  2               .import GetAreaType
00C2B4  2               .import E_GroundArea21
00C2B4  2               .import E_GroundArea28
00C2B4  2               .import L_GroundArea10
00C2B4  2               .import L_GroundArea28
00C2B4  2               
00C2B4  2               ; exports to other files
00C2B4  2               .export UpsideDownPipe_High
00C2B4  2               .export UpsideDownPipe_Low
00C2B4  2               .export WindOn
00C2B4  2               .export WindOff
00C2B4  2               .export SimulateWind
00C2B4  2               .export BlowPlayerAround
00C2B4  2               .export MoveUpsideDownPiranhaP
00C2B4  2               .export ChangeHalfwayPages
00C2B4  2               
00C2B4  2               ;-------------------------------------------------------------------------------------------------
00C2B4  2               
00C2B4  2               FindAreaPointer:
00C2B4  2  AC 5F 07           ldy WorldNumber        ;load offset from world variable
00C2B7  2  B9 57 C3           lda WorldAddrOffsets,y
00C2BA  2  18                 clc                    ;add area number used to find data
00C2BB  2  6D 60 07           adc AreaNumber
00C2BE  2  A8                 tay
00C2BF  2  B9 60 C3           lda AreaAddrOffsets,y  ;from there we have our area pointer
00C2C2  2  60                 rts
00C2C3  2               
00C2C3  2               GetAreaDataAddrs:
00C2C3  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
00C2C6  2  20 rr rr                 jsr GetAreaType
00C2C9  2  A8                       tay
00C2CA  2  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
00C2CD  2  29 1F                    and #%00011111
00C2CF  2  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
00C2D2  2  B9 72 C3                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
00C2D5  2  18                       clc                      ;then add base value to 5 LSB, result
00C2D6  2  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
00C2D9  2  0A                       asl
00C2DA  2  A8                       tay
00C2DB  2  B9 77 C3                 lda EnemyDataAddrs+1,y   ;use offset to load pointer
00C2DE  2  85 EA                    sta EnemyDataHigh
00C2E0  2  B9 76 C3                 lda EnemyDataAddrs,y
00C2E3  2  85 E9                    sta EnemyDataLow
00C2E5  2  AC 4E 07                 ldy AreaType             ;use area type as offset
00C2E8  2  B9 A0 C3                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
00C2EB  2  18                       clc
00C2EC  2  6D 4F 07                 adc AreaAddrsLOffset
00C2EF  2  0A                       asl
00C2F0  2  A8                       tay
00C2F1  2  B9 A5 C3                 lda AreaDataAddrs+1,y    ;use this offset to load another pointer
00C2F4  2  85 E8                    sta AreaDataHigh
00C2F6  2  B9 A4 C3                 lda AreaDataAddrs,y
00C2F9  2  85 E7                    sta AreaDataLow
00C2FB  2  A0 00                    ldy #$00                 ;load first byte of header
00C2FD  2  B1 E7                    lda (AreaData),y
00C2FF  2  48                       pha                      ;save it to the stack for now
00C300  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
00C302  2  C9 04                    cmp #$04
00C304  2  90 05                    bcc StoreFore
00C306  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
00C309  2  A9 00                    lda #$00
00C30B  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
00C30E  2  68                       pla                      ;pull byte from stack and push it back
00C30F  2  48                       pha
00C310  2  29 38                    and #%00111000           ;save player entrance control bits
00C312  2  4A                       lsr                      ;shift bits over to LSBs
00C313  2  4A                       lsr
00C314  2  4A                       lsr
00C315  2  8D 10 07                 sta PlayerEntranceCtrl   ;save value here as player entrance control
00C318  2  68                       pla                      ;pull byte again but do not push it back
00C319  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
00C31B  2  18                       clc
00C31C  2  2A                       rol                      ;rotate bits over to LSBs
00C31D  2  2A                       rol
00C31E  2  2A                       rol
00C31F  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
00C322  2  C8                       iny
00C323  2  B1 E7                    lda (AreaData),y         ;load second byte of header
00C325  2  48                       pha                      ;save to stack
00C326  2  29 0F                    and #%00001111           ;mask out all but lower nybble
00C328  2  8D 27 07                 sta TerrainControl
00C32B  2  68                       pla                      ;pull and push byte to copy it to A
00C32C  2  48                       pha
00C32D  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
00C32F  2  4A                       lsr
00C330  2  4A                       lsr                      ;shift bits to LSBs
00C331  2  4A                       lsr
00C332  2  4A                       lsr
00C333  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
00C336  2  68                       pla
00C337  2  29 C0                    and #%11000000
00C339  2  18                       clc
00C33A  2  2A                       rol                      ;rotate bits over to LSBs
00C33B  2  2A                       rol
00C33C  2  2A                       rol
00C33D  2  C9 03                    cmp #%00000011           ;if set to 3, store here
00C33F  2  D0 05                    bne StoreStyle           ;and nullify other value
00C341  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
00C344  2  A9 00                    lda #$00
00C346  2  8D 33 07     StoreStyle: sta AreaStyle
00C349  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
00C34B  2  18                       clc
00C34C  2  69 02                    adc #$02
00C34E  2  85 E7                    sta AreaDataLow
00C350  2  A5 E8                    lda AreaDataHigh
00C352  2  69 00                    adc #$00
00C354  2  85 E8                    sta AreaDataHigh
00C356  2  60                       rts
00C357  2               
00C357  2               WorldAddrOffsets:
00C357  2  00 05             .byte WorldAAreas-AreaAddrOffsets, WorldBAreas-AreaAddrOffsets
00C359  2  0A 0E             .byte WorldCAreas-AreaAddrOffsets, WorldDAreas-AreaAddrOffsets
00C35B  2  00 00 00 00       .byte 0,0,0,0,0
00C35F  2  00           
00C360  2               
00C360  2               AreaAddrOffsets:
00C360  2  20 2C 40 21  WorldAAreas: .byte $20, $2c, $40, $21, $60
00C364  2  60           
00C365  2  22 2C 00 23  WorldBAreas: .byte $22, $2c, $00, $23, $61
00C369  2  61           
00C36A  2  24 25 26 62  WorldCAreas: .byte $24, $25, $26, $62
00C36E  2  27 28 29 63  WorldDAreas: .byte $27, $28, $29, $63
00C372  2               
00C372  2               EnemyAddrHOffsets:
00C372  2  14 04 12 00       .byte $14, $04, $12, $00
00C376  2               
00C376  2               EnemyDataAddrs:
00C376  2  D0 C5 F5 C5       .word E_CastleArea11, E_CastleArea12, E_CastleArea13, E_CastleArea14, E_GroundArea30, E_GroundArea31
00C37A  2  1C C6 5D C6  
00C37E  2  8C C6 C7 C6  
00C382  2  D6 C6 04 C7       .word E_GroundArea32, E_GroundArea33, E_GroundArea34, E_GroundArea35, E_GroundArea36, E_GroundArea37
00C386  2  29 C7 4C C7  
00C38A  2  6B C7 8A C7  
00C38E  2  AA C7 CB C7       .word E_GroundArea38, E_GroundArea39, E_GroundArea40, E_GroundArea41, E_GroundArea21, E_GroundArea28
00C392  2  E2 C7 F2 C7  
00C396  2  rr rr rr rr  
00C39A  2  01 C8 1B C8       .word E_UndergroundArea6, E_UndergroundArea7, E_WaterArea9
00C39E  2  2F C8        
00C3A0  2               
00C3A0  2               AreaDataHOffsets:
00C3A0  2  14 04 12 00       .byte $14, $04, $12, $00
00C3A4  2               
00C3A4  2               AreaDataAddrs:
00C3A4  2  53 C8 C6 C8       .word L_CastleArea11, L_CastleArea12, L_CastleArea13, L_CastleArea14, L_GroundArea30, L_GroundArea31
00C3A8  2  43 C9 DE C9  
00C3AC  2  6D CA FC CA  
00C3B0  2  55 CB E6 CB       .word L_GroundArea32, L_GroundArea33, L_GroundArea34, L_GroundArea35, L_GroundArea36, L_GroundArea37
00C3B4  2  45 CC BC CC  
00C3B8  2  17 CD 94 CD  
00C3BC  2  11 CE 5C CE       .word L_GroundArea38, L_GroundArea39, L_GroundArea40, L_GroundArea41, L_GroundArea10, L_GroundArea28
00C3C0  2  C7 CE EA CE  
00C3C4  2  rr rr rr rr  
00C3C8  2  07 CF 7C CF       .word L_UndergroundArea6, L_UndergroundArea7, L_WaterArea9
00C3CC  2  DB CF        
00C3CE  2               
00C3CE  2               AtoDHalfwayPages:
00C3CE  2  76 50             .byte $76, $50
00C3D0  2  65 50             .byte $65, $50
00C3D2  2  75 B0             .byte $75, $b0
00C3D4  2  00 00             .byte $00, $00
00C3D6  2               
00C3D6  2               ChangeHalfwayPages:
00C3D6  2  A0 07                ldy #$07
00C3D8  2  B9 CE C3     CHalfL: lda AtoDHalfwayPages,y     ;load new halfway nybbles over the old ones
00C3DB  2  99 rr rr             sta HalfwayPageNybbles,y
00C3DE  2  88                   dey
00C3DF  2  10 F7                bpl CHalfL
00C3E1  2  60                   rts
00C3E2  2               
00C3E2  2               ; unused space
00C3E2  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3E6  2  FF FF FF FF  
00C3EA  2  FF FF FF FF  
00C3F2  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C3F6  2  FF FF FF FF  
00C3FA  2  FF FF FF FF  
00C402  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C406  2  FF FF FF FF  
00C40A  2  FF FF FF FF  
00C412  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C416  2  FF FF FF FF  
00C41A  2  FF FF FF FF  
00C422  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C426  2  FF FF FF FF  
00C42A  2  FF FF FF FF  
00C432  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C436  2  FF FF FF FF  
00C43A  2  FF FF FF FF  
00C442  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C446  2  FF FF FF FF  
00C44A  2  FF FF FF FF  
00C452  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C456  2  FF FF FF FF  
00C45A  2  FF FF FF FF  
00C462  2  FF FF FF FF  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
00C466  2  FF FF FF FF  
00C46A  2  FF FF FF FF  
00C470  2               
00C470  2               ;-------------------------------------------------------------------------------------------------
00C470  2               ;$06 - used to store vertical length of pipe
00C470  2               ;$07 - starts with adder from area parser, used to store row offset
00C470  2               
00C470  2               UpsideDownPipe_High:
00C470  2  A9 01               lda #$01                     ;start at second row
00C472  2  48                  pha
00C473  2  D0 03               bne UDP
00C475  2               UpsideDownPipe_Low:
00C475  2  A9 04               lda #$04                     ;start at fifth row
00C477  2  48                  pha
00C478  2  20 rr rr     UDP:   jsr GetPipeHeight            ;get pipe height from object byte
00C47B  2  68                  pla
00C47C  2  85 07               sta $07                      ;save buffer offset temporarily
00C47E  2  98                  tya
00C47F  2  48                  pha                          ;save pipe height temporarily
00C480  2  BC 30 07            ldy AreaObjectLength,x       ;if on second column of pipe, skip this
00C483  2  F0 23               beq NoUDP
00C485  2  20 rr rr            jsr FindEmptyEnemySlot       ;otherwise try to insert upside-down
00C488  2  B0 1E               bcs NoUDP                    ;piranha plant, if no empty slots, skip this
00C48A  2  A9 04               lda #$04
00C48C  2  20 rr rr            jsr SetupPiranhaPlant        ;set up upside-down piranha plant
00C48F  2  A5 06               lda $06
00C491  2  0A                  asl
00C492  2  0A                  asl                          ;multiply height of pipe by 16
00C493  2  0A                  asl                          ;and add enemy Y position previously set up
00C494  2  0A                  asl                          ;then subtract 10 pixels, save as new Y position
00C495  2  18                  clc
00C496  2  75 CF               adc Enemy_Y_Position,x
00C498  2  38                  sec
00C499  2  E9 0A               sbc #$0a
00C49B  2  95 CF               sta Enemy_Y_Position,x
00C49D  2  9D 34 04            sta PiranhaPlantDownYPos,x   ;set as "down" position, which in this case is up
00C4A0  2  18                  clc                          ;add 24 pixels, save as "up" position
00C4A1  2  69 18               adc #$18                     ;note up and down here are reversed
00C4A3  2  9D 17 04            sta PiranhaPlantUpYPos,x
00C4A6  2  F6 A0               inc PiranhaPlant_MoveFlag,x  ;set movement flag
00C4A8  2  68           NoUDP: pla
00C4A9  2  A8                  tay                          ;return tile offset
00C4AA  2  48                  pha
00C4AB  2  A6 07               ldx $07
00C4AD  2  B9 rr rr            lda VerticalPipeData+2,y
00C4B0  2  A4 06               ldy $06                      ;render the pipe shaft
00C4B2  2  88                  dey
00C4B3  2  20 rr rr            jsr RenderUnderPart
00C4B6  2  68                  pla
00C4B7  2  A8                  tay
00C4B8  2  B9 rr rr            lda VerticalPipeData,y       ;and render the pipe end
00C4BB  2  9D rr rr            sta MetatileBuffer,x
00C4BE  2  60                  rts
00C4BF  2               
00C4BF  2  60                  rts                       ;unused, nothing jumps here
00C4C0  2               
00C4C0  2               MoveUpsideDownPiranhaP:
00C4C0  2  B5 1E              lda Enemy_State,x           ;check enemy state
00C4C2  2  D0 39              bne ExMoveUDPP              ;if set at all, branch to leave
00C4C4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00C4C7  2  D0 34              bne ExMoveUDPP              ;branch to end if not yet expired
00C4C9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00C4CB  2  D0 0B              bne SetupToMovePPlant       ;if moving, skip to part ahead
00C4CD  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4CF  2  49 FF              eor #$ff
00C4D1  2  18                 clc                         ;change to two's compliment
00C4D2  2  69 01              adc #$01
00C4D4  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00C4D6  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00C4D8  2               
00C4D8  2               SetupToMovePPlant:
00C4D8  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;get original vertical coordinate (lowest point)
00C4DB  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00C4DD  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00C4DF  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;otherwise get other vertical coordinate (highest point)
00C4E2  2               
00C4E2  2               RiseFallPiranhaPlant:
00C4E2  2  85 00               sta $00                     ;save vertical coordinate here
00C4E4  2  AD 47 07            lda TimerControl            ;get master timer control
00C4E7  2  D0 14               bne ExMoveUDPP              ;branch to leave if set (likely not necessary)
00C4E9  2  B5 CF               lda Enemy_Y_Position,x      ;get current vertical coordinate
00C4EB  2  18                  clc
00C4EC  2  75 58               adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00C4EE  2  95 CF               sta Enemy_Y_Position,x      ;save as new vertical coordinate
00C4F0  2  C5 00               cmp $00                     ;compare against low or high coordinate
00C4F2  2  D0 09               bne ExMoveUDPP              ;branch to leave if not yet reached
00C4F4  2  A9 00               lda #$00
00C4F6  2  95 A0               sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00C4F8  2  A9 20               lda #$20
00C4FA  2  9D 8A 07            sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00C4FD  2               ExMoveUDPP:
00C4FD  2  60                  rts
00C4FE  2               
00C4FE  2               ;-------------------------------------------------------------------------------------
00C4FE  2               
00C4FE  2               BlowPlayerAround:
00C4FE  2  AD F9 07             lda WindFlag            ;if wind is turned off, just exit
00C501  2  F0 28                beq ExBlow
00C503  2  AD 4E 07             lda AreaType            ;don't blow the player around unless
00C506  2  C9 01                cmp #$01                ;the area is ground type
00C508  2  D0 21                bne ExBlow
00C50A  2  A0 01                ldy #$01
00C50C  2  A5 09                lda FrameCounter
00C50E  2  0A                   asl
00C50F  2  B0 02                bcs BThr
00C511  2  A0 03                ldy #$03
00C513  2  84 00        BThr:   sty $00
00C515  2  A5 09                lda FrameCounter
00C517  2  25 00                and $00
00C519  2  D0 10                bne ExBlow
00C51B  2  A5 86                lda Player_X_Position   ;move player slightly to the right
00C51D  2  18                   clc                     ;to simulate the wind moving the player
00C51E  2  69 01                adc #$01
00C520  2  85 86                sta Player_X_Position
00C522  2  A5 6D                lda Player_PageLoc
00C524  2  69 00                adc #$00
00C526  2  85 6D                sta Player_PageLoc
00C528  2  EE FF 06             inc Player_X_Scroll     ;add one to movement speed for scroll
00C52B  2  60           ExBlow: rts
00C52C  2               
00C52C  2               ;note the position data values are overwritten in RAM
00C52C  2               LeavesYPos:
00C52C  2  30 70 B8 50          .byte $30, $70, $b8, $50, $98, $30
00C530  2  98 30        
00C532  2  70 B8 50 98          .byte $70, $b8, $50, $98, $30, $70
00C536  2  30 70        
00C538  2               
00C538  2               LeavesXPos:
00C538  2  30 30 30 60          .byte $30, $30, $30, $60, $60, $a0
00C53C  2  60 A0        
00C53E  2  A0 A0 D0 D0          .byte $a0, $a0, $d0, $d0, $d0, $60
00C542  2  D0 60        
00C544  2               
00C544  2               LeavesTile:
00C544  2  7B 7B 7B 7B          .byte $7b, $7b, $7b, $7b, $7a, $7a
00C548  2  7A 7A        
00C54A  2  7B 7B 7B 7A          .byte $7b, $7b, $7b, $7a, $7b, $7a
00C54E  2  7B 7A        
00C550  2               
00C550  2               SimulateWind:
00C550  2  AD F9 07               lda WindFlag             ;if no wind, branch to leave
00C553  2  F0 33                  beq ExSimW
00C555  2  A9 04                  lda #$04                 ;play wind sfx
00C557  2  85 FD                  sta NoiseSoundQueue
00C559  2  20 A1 C5               jsr ModifyLeavesPos      ;modify X and Y position data of leaves
00C55C  2  A2 00                  ldx #$00
00C55E  2  AC EB 06               ldy Alt_SprDataOffset-1  ;use first sprite data offset for first six leaves
00C561  2  BD 2C C5     DrawLeaf: lda LeavesYPos,x
00C564  2  99 00 02               sta Sprite_Y_Position,y  ;set up sprite data in OAM memory
00C567  2  BD 44 C5               lda LeavesTile,x
00C56A  2  99 01 02               sta Sprite_Tilenumber,y
00C56D  2  A9 41                  lda #$41
00C56F  2  99 02 02               sta Sprite_Attributes,y
00C572  2  BD 38 C5               lda LeavesXPos,x
00C575  2  99 03 02               sta Sprite_X_Position,y
00C578  2  C8                     iny
00C579  2  C8                     iny
00C57A  2  C8                     iny
00C57B  2  C8                     iny
00C57C  2  E8                     inx
00C57D  2  E0 06                  cpx #$06                 ;if still on first six leaves, continue
00C57F  2  D0 03                  bne DLLoop               ;using the first sprite data offset
00C581  2  AC EC 06               ldy Alt_SprDataOffset    ;otherwise use the second one instead
00C584  2  E0 0C        DLLoop:   cpx #$0c                 ;continue until done putting twelve leaves on the screen
00C586  2  D0 D9                  bne DrawLeaf
00C588  2  60           ExSimW:   rts
00C589  2               
00C589  2               LeavesPosAdder:
00C589  2  57 57 56 56     .byte $57, $57, $56, $56, $58, $58, $56, $56, $57, $58, $57, $58
00C58D  2  58 58 56 56  
00C591  2  57 58 57 58  
00C595  2  59 59 58 58     .byte $59, $59, $58, $58, $5a, $5a, $58, $58, $59, $5a, $59, $5a
00C599  2  5A 5A 58 58  
00C59D  2  59 5A 59 5A  
00C5A1  2               
00C5A1  2               ModifyLeavesPos:
00C5A1  2  A2 0B                 ldx #$0b
00C5A3  2  BD 38 C5     MLPLoop: lda LeavesXPos,x     ;add each adder to each X position twice
00C5A6  2  18                    clc                  ;and to each Y position once
00C5A7  2  7D 89 C5              adc LeavesPosAdder,x
00C5AA  2  7D 89 C5              adc LeavesPosAdder,x
00C5AD  2  9D 38 C5              sta LeavesXPos,x
00C5B0  2  BD 2C C5              lda LeavesYPos,x
00C5B3  2  18                    clc
00C5B4  2  7D 89 C5              adc LeavesPosAdder,x
00C5B7  2  9D 2C C5              sta LeavesYPos,x
00C5BA  2  CA                    dex
00C5BB  2  10 E6                 bpl MLPLoop
00C5BD  2  60                    rts
00C5BE  2               
00C5BE  2               WindOn:
00C5BE  2  A9 01             lda #$01       ;branch to turn the wind on
00C5C0  2  D0 02             bne WOn
00C5C2  2               WindOff:
00C5C2  2  A9 00             lda #$00       ;turn the wind off
00C5C4  2  8D F9 07     WOn: sta WindFlag
00C5C7  2  60                rts
00C5C8  2               
00C5C8  2               ;some unused bytes
00C5C8  2  FF FF FF FF     .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00C5CC  2  FF FF FF FF  
00C5D0  2               
00C5D0  2               ;--------------------------------------------------
00C5D0  2               
00C5D0  2               ;level A-4
00C5D0  2               E_CastleArea11:
00C5D0  2  2A 9E 6B 0C    .byte $2a, $9e, $6b, $0c, $8d, $1c, $ea, $1f, $1b, $8c, $e6, $1c, $8c, $9c, $bb, $0c
00C5D4  2  8D 1C EA 1F  
00C5D8  2  1B 8C E6 1C  
00C5E0  2  F3 83 9B 8C    .byte $f3, $83, $9b, $8c, $db, $0c, $1b, $8c, $6b, $0c, $bb, $0c, $0f, $09, $40, $15
00C5E4  2  DB 0C 1B 8C  
00C5E8  2  6B 0C BB 0C  
00C5F0  2  78 AD 90 B5    .byte $78, $ad, $90, $b5, $ff
00C5F4  2  FF           
00C5F5  2               
00C5F5  2               ;level B-4
00C5F5  2               E_CastleArea12:
00C5F5  2  0F 02 38 1D    .byte $0f, $02, $38, $1d, $d9, $1b, $6e, $e1, $21, $3a, $a8, $18, $9d, $0f, $07, $18
00C5F9  2  D9 1B 6E E1  
00C5FD  2  21 3A A8 18  
00C605  2  1D 0F 09 18    .byte $1d, $0f, $09, $18, $1d, $0f, $0b, $18, $1d, $7b, $15, $8e, $21, $2e, $b9, $9d
00C609  2  1D 0F 0B 18  
00C60D  2  1D 7B 15 8E  
00C615  2  0F 0E 78 2D    .byte $0f, $0e, $78, $2d, $90, $b5, $ff
00C619  2  90 B5 FF     
00C61C  2               
00C61C  2               ;level C-4
00C61C  2               E_CastleArea13:
00C61C  2  05 9D 65 1D    .byte $05, $9d, $65, $1d, $0d, $a8, $dd, $1d, $07, $ac, $54, $2c, $a2, $2c, $f4, $2c
00C620  2  0D A8 DD 1D  
00C624  2  07 AC 54 2C  
00C62C  2  42 AC 26 9D    .byte $42, $ac, $26, $9d, $d4, $03, $24, $83, $64, $03, $2b, $82, $4b, $02, $7b, $02
00C630  2  D4 03 24 83  
00C634  2  64 03 2B 82  
00C63C  2  9B 02 5B 82    .byte $9b, $02, $5b, $82, $7b, $02, $0b, $82, $2b, $02, $c6, $1b, $28, $82, $48, $02
00C640  2  7B 02 0B 82  
00C644  2  2B 02 C6 1B  
00C64C  2  A6 1B 7B 95    .byte $a6, $1b, $7b, $95, $85, $0c, $9d, $9b, $0f, $0e, $78, $2d, $7a, $1d, $90, $b5
00C650  2  85 0C 9D 9B  
00C654  2  0F 0E 78 2D  
00C65C  2  FF             .byte $ff
00C65D  2               
00C65D  2               ;level D-4
00C65D  2               E_CastleArea14:
00C65D  2  19 9F 99 1B    .byte $19, $9f, $99, $1b, $2c, $8c, $59, $1b, $c5, $0f, $0f, $04, $09, $29, $bd, $1d
00C661  2  2C 8C 59 1B  
00C665  2  C5 0F 0F 04  
00C66D  2  0F 06 6E 2A    .byte $0f, $06, $6e, $2a, $61, $0f, $09, $48, $2d, $46, $87, $79, $07, $8e, $63, $60
00C671  2  61 0F 09 48  
00C675  2  2D 46 87 79  
00C67D  2  A5 07 B8 85    .byte $a5, $07, $b8, $85, $57, $a5, $8c, $8c, $76, $9d, $78, $2d, $90, $b5, $ff
00C681  2  57 A5 8C 8C  
00C685  2  76 9D 78 2D  
00C68C  2               
00C68C  2               ;level A-1
00C68C  2               E_GroundArea30:
00C68C  2  07 83 37 03    .byte $07, $83, $37, $03, $6b, $0e, $e0, $3d, $20, $be, $6e, $2b, $00, $a7, $85, $d3
00C690  2  6B 0E E0 3D  
00C694  2  20 BE 6E 2B  
00C69C  2  05 E7 83 24    .byte $05, $e7, $83, $24, $83, $27, $03, $49, $00, $59, $00, $10, $bb, $b0, $3b, $6e
00C6A0  2  83 27 03 49  
00C6A4  2  00 59 00 10  
00C6AC  2  C1 00 17 85    .byte $c1, $00, $17, $85, $53, $05, $36, $8e, $76, $0e, $b6, $0e, $e7, $83, $63, $83
00C6B0  2  53 05 36 8E  
00C6B4  2  76 0E B6 0E  
00C6BC  2  68 03 29 83    .byte $68, $03, $29, $83, $57, $03, $85, $03, $b5, $29, $ff
00C6C0  2  57 03 85 03  
00C6C4  2  B5 29 FF     
00C6C7  2               
00C6C7  2               ;level A-3
00C6C7  2               E_GroundArea31:
00C6C7  2  0F 04 66 07    .byte $0f, $04, $66, $07, $0f, $06, $86, $10, $0f, $08, $55, $0f, $e5, $8f, $ff
00C6CB  2  0F 06 86 10  
00C6CF  2  0F 08 55 0F  
00C6D6  2               
00C6D6  2               ;level B-1
00C6D6  2               E_GroundArea32:
00C6D6  2  70 B7 CA 00    .byte $70, $b7, $ca, $00, $66, $80, $0f, $04, $79, $0e, $ab, $0e, $ee, $2b, $20, $eb
00C6DA  2  66 80 0F 04  
00C6DE  2  79 0E AB 0E  
00C6E6  2  80 40 BB FB    .byte $80, $40, $bb, $fb, $00, $40, $b7, $cb, $0e, $0f, $09, $4b, $00, $76, $00, $d8
00C6EA  2  00 40 B7 CB  
00C6EE  2  0E 0F 09 4B  
00C6F6  2  00 6B 8E 73    .byte $00, $6b, $8e, $73, $06, $83, $06, $c7, $0e, $36, $90, $c5, $06, $ff
00C6FA  2  06 83 06 C7  
00C6FE  2  0E 36 90 C5  
00C704  2               
00C704  2               ;level B-3
00C704  2               E_GroundArea33:
00C704  2  84 8F A7 24    .byte $84, $8f, $a7, $24, $d3, $0f, $ea, $24, $45, $a9, $d5, $28, $45, $a9, $84, $25
00C708  2  D3 0F EA 24  
00C70C  2  45 A9 D5 28  
00C714  2  B4 8F 09 90    .byte $b4, $8f, $09, $90, $b5, $a8, $5b, $97, $cd, $28, $b5, $a4, $09, $a4, $65, $28
00C718  2  B5 A8 5B 97  
00C71C  2  CD 28 B5 A4  
00C724  2  92 90 E3 83    .byte $92, $90, $e3, $83, $ff
00C728  2  FF           
00C729  2               
00C729  2               ;level C-1
00C729  2               E_GroundArea34:
00C729  2  3A 8E 5B 0E    .byte $3a, $8e, $5b, $0e, $c3, $8e, $ca, $8e, $0b, $8e, $4a, $0e, $de, $c1, $44, $0f
00C72D  2  C3 8E CA 8E  
00C731  2  0B 8E 4A 0E  
00C739  2  08 49 0E EB    .byte $08, $49, $0e, $eb, $0e, $8a, $90, $ab, $85, $0f, $0c, $03, $0f, $2e, $2b, $40
00C73D  2  0E 8A 90 AB  
00C741  2  85 0F 0C 03  
00C749  2  67 86 FF       .byte $67, $86, $ff
00C74C  2               
00C74C  2               ;level C-2
00C74C  2               E_GroundArea35:
00C74C  2  15 8F 54 07    .byte $15, $8f, $54, $07, $aa, $83, $f8, $07, $0f, $04, $14, $07, $96, $10, $0f, $07
00C750  2  AA 83 F8 07  
00C754  2  0F 04 14 07  
00C75C  2  95 0F 9D A8    .byte $95, $0f, $9d, $a8, $0b, $97, $09, $a9, $55, $24, $a9, $24, $bb, $17, $ff
00C760  2  0B 97 09 A9  
00C764  2  55 24 A9 24  
00C76B  2               
00C76B  2               ;level C-3
00C76B  2               E_GroundArea36:
00C76B  2  0F 03 A6 11    .byte $0f, $03, $a6, $11, $a3, $90, $a6, $91, $0f, $08, $a6, $11, $e3, $a9, $0f, $0d
00C76F  2  A3 90 A6 91  
00C773  2  0F 08 A6 11  
00C77B  2  55 24 A9 24    .byte $55, $24, $a9, $24, $0f, $11, $59, $1d, $a9, $1b, $23, $8f, $15, $9b, $ff
00C77F  2  0F 11 59 1D  
00C783  2  A9 1B 23 8F  
00C78A  2               
00C78A  2               ;level D-1
00C78A  2               E_GroundArea37:
00C78A  2  87 85 9B 05    .byte $87, $85, $9b, $05, $18, $90, $a4, $8f, $6e, $c1, $60, $9b, $02, $d0, $3b, $80
00C78E  2  18 90 A4 8F  
00C792  2  6E C1 60 9B  
00C79A  2  B8 03 8E 1B    .byte $b8, $03, $8e, $1b, $02, $3b, $02, $0f, $08, $03, $10, $f7, $05, $6b, $85, $ff
00C79E  2  02 3B 02 0F  
00C7A2  2  08 03 10 F7  
00C7AA  2               
00C7AA  2               ;level D-2
00C7AA  2               E_GroundArea38:
00C7AA  2  DB 82 F3 03    .byte $db, $82, $f3, $03, $10, $b7, $80, $37, $1a, $8e, $4b, $0e, $7a, $0e, $ab, $0e
00C7AE  2  10 B7 80 37  
00C7B2  2  1A 8E 4B 0E  
00C7BA  2  0F 05 F9 0E    .byte $0f, $05, $f9, $0e, $d0, $be, $2e, $c1, $62, $d4, $8f, $64, $8f, $7e, $2b, $60
00C7BE  2  D0 BE 2E C1  
00C7C2  2  62 D4 8F 64  
00C7CA  2  FF             .byte $ff
00C7CB  2               
00C7CB  2               ;level D-3
00C7CB  2               E_GroundArea39:
00C7CB  2  0F 03 AB 05    .byte $0f, $03, $ab, $05, $1b, $85, $a3, $85, $d7, $05, $0f, $08, $33, $03, $0b, $85
00C7CF  2  1B 85 A3 85  
00C7D3  2  D7 05 0F 08  
00C7DB  2  FB 85 8B 85    .byte $fb, $85, $8b, $85, $3a, $8e, $ff
00C7DF  2  3A 8E FF     
00C7E2  2               
00C7E2  2               ;ground level area used with level D-4
00C7E2  2               E_GroundArea40:
00C7E2  2  0F 02 09 05    .byte $0f, $02, $09, $05, $3e, $41, $64, $2b, $8e, $58, $0e, $ca, $07, $34, $87, $ff
00C7E6  2  3E 41 64 2B  
00C7EA  2  8E 58 0E CA  
00C7F2  2               
00C7F2  2               ;cloud level used with levels A-1, B-1 and D-2
00C7F2  2               E_GroundArea41:
00C7F2  2  0A AA 1E 20    .byte $0a, $aa, $1e, $20, $03, $1e, $22, $27, $2e, $24, $48, $2e, $28, $67, $ff
00C7F6  2  03 1E 22 27  
00C7FA  2  2E 24 48 2E  
00C801  2               
00C801  2               ;level A-2
00C801  2               E_UndergroundArea6:
00C801  2  BB A9 1B A9    .byte $bb, $a9, $1b, $a9, $69, $29, $b8, $29, $59, $a9, $8d, $a8, $0f, $07, $15, $29
00C805  2  69 29 B8 29  
00C809  2  59 A9 8D A8  
00C811  2  55 AC 6B 85    .byte $55, $ac, $6b, $85, $0e, $ad, $01, $67, $34, $ff
00C815  2  0E AD 01 67  
00C819  2  34 FF        
00C81B  2               
00C81B  2               ;underground bonus rooms used with worlds A-D
00C81B  2               E_UndergroundArea7:
00C81B  2  1E A0 09 1E    .byte $1e, $a0, $09, $1e, $27, $67, $0f, $03, $1e, $28, $68, $0f, $05, $1e, $24, $48
00C81F  2  27 67 0F 03  
00C823  2  1E 28 68 0F  
00C82B  2  1E 63 68 FF    .byte $1e, $63, $68, $ff
00C82F  2               
00C82F  2               ;level B-2
00C82F  2               E_WaterArea9:
00C82F  2  EE AD 21 26    .byte $ee, $ad, $21, $26, $87, $f3, $0e, $66, $87, $cb, $00, $65, $87, $0f, $06, $06
00C833  2  87 F3 0E 66  
00C837  2  87 CB 00 65  
00C83F  2  0E 97 07 CB    .byte $0e, $97, $07, $cb, $00, $75, $87, $d3, $27, $d9, $27, $0f, $09, $77, $1f, $46
00C843  2  00 75 87 D3  
00C847  2  27 D9 27 0F  
00C84F  2  87 B1 0F FF    .byte $87, $b1, $0f, $ff
00C853  2               
00C853  2               ;level A-4
00C853  2               L_CastleArea11:
00C853  2  9B 87 05 32    .byte $9b, $87, $05, $32, $06, $33, $07, $34, $ee, $0a, $0e, $86, $28, $0e, $3e, $0a
00C857  2  06 33 07 34  
00C85B  2  EE 0A 0E 86  
00C863  2  6E 02 8B 0E    .byte $6e, $02, $8b, $0e, $97, $00, $9e, $0a, $ce, $06, $e8, $0e, $fe, $0a, $2e, $86
00C867  2  97 00 9E 0A  
00C86B  2  CE 06 E8 0E  
00C873  2  6E 0A 8E 08    .byte $6e, $0a, $8e, $08, $e4, $0e, $1e, $82, $8a, $0e, $8e, $0a, $fe, $02, $1a, $e0
00C877  2  E4 0E 1E 82  
00C87B  2  8A 0E 8E 0A  
00C883  2  29 61 2E 06    .byte $29, $61, $2e, $06, $3e, $09, $56, $60, $65, $61, $6e, $0c, $83, $60, $7e, $8a
00C887  2  3E 09 56 60  
00C88B  2  65 61 6E 0C  
00C893  2  BB 61 F9 63    .byte $bb, $61, $f9, $63, $27, $e5, $88, $64, $eb, $61, $fe, $05, $68, $90, $0a, $90
00C897  2  27 E5 88 64  
00C89B  2  EB 61 FE 05  
00C8A3  2  FE 02 3A 90    .byte $fe, $02, $3a, $90, $3e, $0a, $ae, $02, $da, $60, $e9, $61, $f8, $62, $fe, $0a
00C8A7  2  3E 0A AE 02  
00C8AB  2  DA 60 E9 61  
00C8B3  2  0D C4 A1 62    .byte $0d, $c4, $a1, $62, $b1, $62, $cd, $43, $ce, $09, $de, $0b, $dd, $42, $fe, $02
00C8B7  2  B1 62 CD 43  
00C8BB  2  CE 09 DE 0B  
00C8C3  2  5D C7 FD       .byte $5d, $c7, $fd
00C8C6  2               
00C8C6  2               ;level B-4
00C8C6  2               L_CastleArea12:
00C8C6  2  9B 07 05 32    .byte $9b, $07, $05, $32, $06, $33, $07, $33, $3e, $0a, $41, $3b, $42, $3b, $58, $64
00C8CA  2  06 33 07 33  
00C8CE  2  3E 0A 41 3B  
00C8D6  2  7A 62 C8 31    .byte $7a, $62, $c8, $31, $18, $e4, $39, $73, $5e, $09, $66, $3c, $0e, $82, $28, $07
00C8DA  2  18 E4 39 73  
00C8DE  2  5E 09 66 3C  
00C8E6  2  36 0E 3E 0A    .byte $36, $0e, $3e, $0a, $ae, $02, $d7, $0e, $fe, $0c, $fe, $8a, $11, $e5, $21, $65
00C8EA  2  AE 02 D7 0E  
00C8EE  2  FE 0C FE 8A  
00C8F6  2  31 65 4E 0C    .byte $31, $65, $4e, $0c, $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e
00C8FA  2  FE 02 16 8E  
00C8FE  2  2E 0E FE 02  
00C906  2  FE 02 16 8E    .byte $fe, $02, $16, $8e, $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e
00C90A  2  2E 0E FE 02  
00C90E  2  18 FA 3E 0E  
00C916  2  2E 0E FE 02    .byte $2e, $0e, $fe, $02, $18, $fa, $3e, $0e, $fe, $02, $16, $8e, $2e, $0e, $fe, $02
00C91A  2  18 FA 3E 0E  
00C91E  2  FE 02 16 8E  
00C926  2  18 FA 5E 0A    .byte $18, $fa, $5e, $0a, $6e, $02, $7e, $0a, $b7, $0e, $ee, $07, $fe, $8a, $0d, $c4
00C92A  2  6E 02 7E 0A  
00C92E  2  B7 0E EE 07  
00C936  2  CD 43 CE 09    .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00C93A  2  DD 42 DE 0B  
00C93E  2  FE 02 5D C7  
00C943  2               
00C943  2               ;level C-4
00C943  2               L_CastleArea13:
00C943  2  98 07 05 35    .byte $98, $07, $05, $35, $06, $3d, $07, $3d, $be, $06, $de, $0c, $f3, $3d, $03, $8e
00C947  2  06 3D 07 3D  
00C94B  2  BE 06 DE 0C  
00C953  2  63 0E 6E 43    .byte $63, $0e, $6e, $43, $ce, $0a, $e1, $67, $f1, $67, $01, $e7, $11, $67, $1e, $05
00C957  2  CE 0A E1 67  
00C95B  2  F1 67 01 E7  
00C963  2  28 39 6E 40    .byte $28, $39, $6e, $40, $be, $01, $c7, $06, $db, $0e, $de, $00, $1f, $80, $6f, $00
00C967  2  BE 01 C7 06  
00C96B  2  DB 0E DE 00  
00C973  2  BF 00 0F 80    .byte $bf, $00, $0f, $80, $5f, $00, $7e, $05, $a8, $37, $fe, $02, $24, $8e, $34, $30
00C977  2  5F 00 7E 05  
00C97B  2  A8 37 FE 02  
00C983  2  3E 0C 4E 43    .byte $3e, $0c, $4e, $43, $ae, $0a, $be, $0c, $ee, $0a, $fe, $0c, $2e, $8a, $3e, $0c
00C987  2  AE 0A BE 0C  
00C98B  2  EE 0A FE 0C  
00C993  2  7E 02 8E 0E    .byte $7e, $02, $8e, $0e, $98, $36, $b9, $34, $08, $bf, $09, $3f, $0e, $82, $2e, $86
00C997  2  98 36 B9 34  
00C99B  2  08 BF 09 3F  
00C9A3  2  4E 0C 9E 09    .byte $4e, $0c, $9e, $09, $a6, $60, $c1, $62, $c4, $0e, $ee, $0c, $0e, $86, $5e, $0c
00C9A7  2  A6 60 C1 62  
00C9AB  2  C4 0E EE 0C  
00C9B3  2  7E 09 86 60    .byte $7e, $09, $86, $60, $a1, $62, $a4, $0e, $c6, $60, $ce, $0c, $fe, $0a, $28, $b4
00C9B7  2  A1 62 A4 0E  
00C9BB  2  C6 60 CE 0C  
00C9C3  2  A6 31 E8 34    .byte $a6, $31, $e8, $34, $8b, $b2, $9b, $0e, $fe, $07, $fe, $8a, $0d, $c4, $cd, $43
00C9C7  2  8B B2 9B 0E  
00C9CB  2  FE 07 FE 8A  
00C9D3  2  CE 09 DD 42    .byte $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00C9D7  2  DE 0B FE 02  
00C9DB  2  5D C7 FD     
00C9DE  2               
00C9DE  2               ;level D-4
00C9DE  2               L_CastleArea14:
00C9DE  2  5B 03 05 34    .byte $5b, $03, $05, $34, $06, $35, $39, $71, $6e, $02, $ae, $0a, $fe, $05, $17, $8e
00C9E2  2  06 35 39 71  
00C9E6  2  6E 02 AE 0A  
00C9EE  2  97 0E 9E 02    .byte $97, $0e, $9e, $02, $a6, $06, $fa, $30, $fe, $0a, $4e, $82, $57, $0e, $58, $62
00C9F2  2  A6 06 FA 30  
00C9F6  2  FE 0A 4E 82  
00C9FE  2  68 62 79 61    .byte $68, $62, $79, $61, $8a, $60, $8e, $0a, $f5, $31, $f9, $73, $39, $f3, $b5, $71
00CA02  2  8A 60 8E 0A  
00CA06  2  F5 31 F9 73  
00CA0E  2  B7 31 4D C8    .byte $b7, $31, $4d, $c8, $8a, $62, $9a, $62, $ae, $05, $bb, $0e, $cd, $4a, $fe, $82
00CA12  2  8A 62 9A 62  
00CA16  2  AE 05 BB 0E  
00CA1E  2  77 FB DE 0F    .byte $77, $fb, $de, $0f, $4e, $82, $6d, $47, $39, $f3, $0c, $ea, $08, $3f, $b3, $00
00CA22  2  4E 82 6D 47  
00CA26  2  39 F3 0C EA  
00CA2E  2  CC 63 F9 30    .byte $cc, $63, $f9, $30, $69, $f9, $ea, $60, $f9, $61, $fe, $07, $de, $84, $e4, $62
00CA32  2  69 F9 EA 60  
00CA36  2  F9 61 FE 07  
00CA3E  2  E9 61 F4 62    .byte $e9, $61, $f4, $62, $fa, $60, $04, $e2, $14, $62, $24, $62, $34, $62, $3e, $0a
00CA42  2  FA 60 04 E2  
00CA46  2  14 62 24 62  
00CA4E  2  7E 0C 7E 8A    .byte $7e, $0c, $7e, $8a, $8e, $08, $94, $36, $fe, $0a, $0d, $c4, $61, $64, $71, $64
00CA52  2  8E 08 94 36  
00CA56  2  FE 0A 0D C4  
00CA5E  2  81 64 CD 43    .byte $81, $64, $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02, $5d, $c7, $fd
00CA62  2  CE 09 DD 42  
00CA66  2  DE 0B FE 02  
00CA6D  2               
00CA6D  2               ;level A-1
00CA6D  2               L_GroundArea30:
00CA6D  2  52 71 0F 20    .byte $52, $71, $0f, $20, $6e, $70, $e3, $64, $fc, $61, $fc, $71, $13, $86, $2c, $61
00CA71  2  6E 70 E3 64  
00CA75  2  FC 61 FC 71  
00CA7D  2  2C 71 43 64    .byte $2c, $71, $43, $64, $b2, $22, $b5, $62, $c7, $28, $22, $a2, $52, $09, $56, $61
00CA81  2  B2 22 B5 62  
00CA85  2  C7 28 22 A2  
00CA8D  2  6C 03 DB 71    .byte $6c, $03, $db, $71, $fc, $03, $f3, $20, $03, $a4, $0f, $71, $40, $0c, $8c, $74
00CA91  2  FC 03 F3 20  
00CA95  2  03 A4 0F 71  
00CA9D  2  9C 66 D7 01    .byte $9c, $66, $d7, $01, $ec, $71, $89, $e1, $b6, $61, $b9, $2a, $c7, $26, $f4, $23
00CAA1  2  EC 71 89 E1  
00CAA5  2  B6 61 B9 2A  
00CAAD  2  67 E2 E8 F2    .byte $67, $e2, $e8, $f2, $78, $82, $88, $01, $98, $02, $a8, $02, $b8, $02, $03, $a6
00CAB1  2  78 82 88 01  
00CAB5  2  98 02 A8 02  
00CABD  2  07 26 21 79    .byte $07, $26, $21, $79, $4b, $71, $cf, $33, $06, $e4, $16, $2a, $39, $71, $58, $45
00CAC1  2  4B 71 CF 33  
00CAC5  2  06 E4 16 2A  
00CACD  2  5A 45 C6 07    .byte $5a, $45, $c6, $07, $dc, $04, $3f, $e7, $3b, $71, $8c, $71, $ac, $01, $e7, $63
00CAD1  2  DC 04 3F E7  
00CAD5  2  3B 71 8C 71  
00CADD  2  39 8F 63 20    .byte $39, $8f, $63, $20, $65, $0b, $68, $62, $8c, $00, $0c, $81, $29, $63, $3c, $01
00CAE1  2  65 0B 68 62  
00CAE5  2  8C 00 0C 81  
00CAED  2  57 65 6C 01    .byte $57, $65, $6c, $01, $85, $67, $9c, $04, $1d, $c1, $5f, $26, $3d, $c7, $fd
00CAF1  2  85 67 9C 04  
00CAF5  2  1D C1 5F 26  
00CAFC  2               
00CAFC  2               ;level A-3
00CAFC  2               L_GroundArea31:
00CAFC  2  50 50 0B 1F    .byte $50, $50, $0b, $1f, $0f, $26, $19, $96, $84, $43, $b7, $1f, $5d, $cc, $6d, $48
00CB00  2  0F 26 19 96  
00CB04  2  84 43 B7 1F  
00CB0C  2  E0 42 E3 12    .byte $e0, $42, $e3, $12, $39, $9c, $56, $43, $47, $9b, $a4, $12, $c1, $06, $ed, $4d
00CB10  2  39 9C 56 43  
00CB14  2  47 9B A4 12  
00CB1C  2  F4 42 1B 98    .byte $f4, $42, $1b, $98, $b7, $13, $02, $c2, $03, $12, $47, $1f, $ad, $48, $63, $9c
00CB20  2  B7 13 02 C2  
00CB24  2  03 12 47 1F  
00CB2C  2  82 48 76 93    .byte $82, $48, $76, $93, $08, $94, $8e, $11, $b0, $03, $c9, $0f, $1d, $c1, $2d, $4a
00CB30  2  08 94 8E 11  
00CB34  2  B0 03 C9 0F  
00CB3C  2  4E 42 6F 20    .byte $4e, $42, $6f, $20, $0d, $0e, $0e, $40, $39, $71, $7f, $37, $f2, $68, $01, $e9
00CB40  2  0D 0E 0E 40  
00CB44  2  39 71 7F 37  
00CB4C  2  11 39 68 7A    .byte $11, $39, $68, $7a, $de, $1f, $6d, $c5, $fd
00CB50  2  DE 1F 6D C5  
00CB54  2  FD           
00CB55  2               
00CB55  2               ;level B-1
00CB55  2               L_GroundArea32:
00CB55  2  52 21 0F 20    .byte $52, $21, $0f, $20, $6e, $60, $6c, $f6, $ca, $30, $dc, $02, $08, $f2, $37, $04
00CB59  2  6E 60 6C F6  
00CB5D  2  CA 30 DC 02  
00CB65  2  56 74 7C 00    .byte $56, $74, $7c, $00, $dc, $01, $e7, $25, $47, $8b, $49, $20, $6c, $02, $96, $74
00CB69  2  DC 01 E7 25  
00CB6D  2  47 8B 49 20  
00CB75  2  06 82 36 02    .byte $06, $82, $36, $02, $66, $00, $a7, $22, $dc, $02, $0a, $e0, $63, $22, $78, $72
00CB79  2  66 00 A7 22  
00CB7D  2  DC 02 0A E0  
00CB85  2  93 09 97 03    .byte $93, $09, $97, $03, $a3, $25, $a7, $03, $b6, $24, $03, $a2, $5c, $75, $65, $71
00CB89  2  A3 25 A7 03  
00CB8D  2  B6 24 03 A2  
00CB95  2  7C 00 9C 00    .byte $7c, $00, $9c, $00, $63, $a2, $67, $20, $77, $03, $87, $20, $93, $0a, $97, $03
00CB99  2  63 A2 67 20  
00CB9D  2  77 03 87 20  
00CBA5  2  A3 22 A7 20    .byte $a3, $22, $a7, $20, $b7, $03, $bc, $00, $c7, $20, $dc, $00, $fc, $01, $19, $8f
00CBA9  2  B7 03 BC 00  
00CBAD  2  C7 20 DC 00  
00CBB5  2  1E 20 46 22    .byte $1e, $20, $46, $22, $4c, $61, $63, $00, $8e, $21, $d7, $73, $46, $a6, $4c, $62
00CBB9  2  4C 61 63 00  
00CBBD  2  8E 21 D7 73  
00CBC5  2  68 62 73 01    .byte $68, $62, $73, $01, $8c, $62, $d8, $62, $43, $a9, $c7, $73, $ec, $06, $57, $f3
00CBC9  2  8C 62 D8 62  
00CBCD  2  43 A9 C7 73  
00CBD5  2  7C 00 B5 65    .byte $7c, $00, $b5, $65, $c5, $65, $dc, $00, $e3, $67, $7d, $c1, $bf, $26, $ad, $c7
00CBD9  2  C5 65 DC 00  
00CBDD  2  E3 67 7D C1  
00CBE5  2  FD             .byte $fd
00CBE6  2               
00CBE6  2               ;level B-3
00CBE6  2               L_GroundArea33:
00CBE6  2  90 10 0B 1B    .byte $90, $10, $0b, $1b, $0f, $26, $07, $94, $bc, $14, $bf, $13, $c7, $40, $ff, $16
00CBEA  2  0F 26 07 94  
00CBEE  2  BC 14 BF 13  
00CBF6  2  D1 80 C3 94    .byte $d1, $80, $c3, $94, $cb, $17, $c2, $44, $29, $8f, $77, $31, $0b, $96, $76, $32
00CBFA  2  CB 17 C2 44  
00CBFE  2  29 8F 77 31  
00CC06  2  C7 75 13 F7    .byte $c7, $75, $13, $f7, $1b, $61, $2b, $61, $4b, $12, $59, $0f, $3b, $b0, $3a, $40
00CC0A  2  1B 61 2B 61  
00CC0E  2  4B 12 59 0F  
00CC16  2  43 12 7A 40    .byte $43, $12, $7a, $40, $7b, $30, $b5, $41, $b6, $20, $c6, $07, $f3, $13, $03, $92
00CC1A  2  7B 30 B5 41  
00CC1E  2  B6 20 C6 07  
00CC26  2  6B 12 79 0F    .byte $6b, $12, $79, $0f, $cc, $15, $cf, $11, $1f, $95, $c3, $14, $b3, $95, $a3, $95
00CC2A  2  CC 15 CF 11  
00CC2E  2  1F 95 C3 14  
00CC36  2  4D CA 6B 61    .byte $4d, $ca, $6b, $61, $7e, $11, $8d, $41, $be, $42, $df, $20, $bd, $c7, $fd
00CC3A  2  7E 11 8D 41  
00CC3E  2  BE 42 DF 20  
00CC45  2               
00CC45  2               ;level C-1
00CC45  2               L_GroundArea34:
00CC45  2  52 31 0F 20    .byte $52, $31, $0f, $20, $6e, $74, $0d, $02, $03, $33, $1f, $72, $39, $71, $65, $04
00CC49  2  6E 74 0D 02  
00CC4D  2  03 33 1F 72  
00CC55  2  6C 70 77 01    .byte $6c, $70, $77, $01, $84, $72, $8c, $72, $b3, $34, $ec, $01, $ef, $72, $0d, $04
00CC59  2  84 72 8C 72  
00CC5D  2  B3 34 EC 01  
00CC65  2  AC 67 CC 01    .byte $ac, $67, $cc, $01, $cf, $71, $e7, $22, $17, $88, $23, $00, $27, $23, $3c, $62
00CC69  2  CF 71 E7 22  
00CC6D  2  17 88 23 00  
00CC75  2  65 71 67 33    .byte $65, $71, $67, $33, $8c, $61, $dc, $01, $08, $fa, $45, $75, $63, $0a, $73, $23
00CC79  2  8C 61 DC 01  
00CC7D  2  08 FA 45 75  
00CC85  2  7C 02 8F 72    .byte $7c, $02, $8f, $72, $73, $a9, $9f, $74, $bf, $74, $ef, $73, $39, $f1, $fc, $0a
00CC89  2  73 A9 9F 74  
00CC8D  2  BF 74 EF 73  
00CC95  2  0D 0B 13 25    .byte $0d, $0b, $13, $25, $4c, $01, $4f, $72, $73, $0b, $77, $03, $dc, $08, $23, $a2
00CC99  2  4C 01 4F 72  
00CC9D  2  73 0B 77 03  
00CCA5  2  53 09 56 03    .byte $53, $09, $56, $03, $63, $24, $8c, $02, $3f, $b3, $77, $63, $96, $74, $b3, $77
00CCA9  2  63 24 8C 02  
00CCAD  2  3F B3 77 63  
00CCB5  2  5D C1 8F 26    .byte $5d, $c1, $8f, $26, $7d, $c7, $fd
00CCB9  2  7D C7 FD     
00CCBC  2               
00CCBC  2               ;level C-2
00CCBC  2               L_GroundArea35:
00CCBC  2  54 11 0F 26    .byte $54, $11, $0f, $26, $cf, $32, $f8, $62, $fe, $10, $3c, $b2, $bd, $48, $ea, $62
00CCC0  2  CF 32 F8 62  
00CCC4  2  FE 10 3C B2  
00CCCC  2  FC 4D FC 4D    .byte $fc, $4d, $fc, $4d, $17, $c9, $da, $62, $0b, $97, $b7, $12, $2c, $b1, $33, $43
00CCD0  2  17 C9 DA 62  
00CCD4  2  0B 97 B7 12  
00CCDC  2  6C 31 AC 41    .byte $6c, $31, $ac, $41, $0b, $98, $ad, $4a, $db, $30, $27, $b0, $b7, $14, $c6, $42
00CCE0  2  0B 98 AD 4A  
00CCE4  2  DB 30 27 B0  
00CCEC  2  C7 96 D6 44    .byte $c7, $96, $d6, $44, $2b, $92, $39, $0f, $72, $41, $a7, $00, $1b, $95, $97, $13
00CCF0  2  2B 92 39 0F  
00CCF4  2  72 41 A7 00  
00CCFC  2  6C 95 6F 11    .byte $6c, $95, $6f, $11, $a2, $40, $bf, $15, $c2, $40, $0b, $9a, $62, $42, $63, $12
00CD00  2  A2 40 BF 15  
00CD04  2  C2 40 0B 9A  
00CD0C  2  AD 4A 0E 91    .byte $ad, $4a, $0e, $91, $1d, $41, $4f, $26, $4d, $c7, $fd
00CD10  2  1D 41 4F 26  
00CD14  2  4D C7 FD     
00CD17  2               
00CD17  2               ;level C-3
00CD17  2               L_GroundArea36:
00CD17  2  57 11 0F 26    .byte $57, $11, $0f, $26, $fe, $10, $4b, $92, $59, $0f, $ad, $4c, $d3, $93, $0b, $94
00CD1B  2  FE 10 4B 92  
00CD1F  2  59 0F AD 4C  
00CD27  2  29 0F 7B 93    .byte $29, $0f, $7b, $93, $99, $0f, $0d, $06, $27, $12, $35, $0f, $23, $b1, $57, $75
00CD2B  2  99 0F 0D 06  
00CD2F  2  27 12 35 0F  
00CD37  2  A3 31 AB 71    .byte $a3, $31, $ab, $71, $f7, $75, $23, $b1, $87, $13, $95, $0f, $0d, $0a, $23, $35
00CD3B  2  F7 75 23 B1  
00CD3F  2  87 13 95 0F  
00CD47  2  38 13 55 00    .byte $38, $13, $55, $00, $9b, $16, $0b, $96, $c7, $75, $dd, $4a, $3b, $92, $49, $0f
00CD4B  2  9B 16 0B 96  
00CD4F  2  C7 75 DD 4A  
00CD57  2  AD 4C 29 92    .byte $ad, $4c, $29, $92, $52, $40, $6c, $15, $6f, $11, $72, $40, $bf, $15, $03, $93
00CD5B  2  52 40 6C 15  
00CD5F  2  6F 11 72 40  
00CD67  2  0A 13 12 41    .byte $0a, $13, $12, $41, $8b, $12, $99, $0f, $0d, $10, $47, $16, $46, $45, $b3, $32
00CD6B  2  8B 12 99 0F  
00CD6F  2  0D 10 47 16  
00CD77  2  13 B1 57 0E    .byte $13, $b1, $57, $0e, $a7, $0e, $d3, $31, $53, $b1, $a6, $31, $03, $b2, $13, $0e
00CD7B  2  A7 0E D3 31  
00CD7F  2  53 B1 A6 31  
00CD87  2  8D 4D AE 11    .byte $8d, $4d, $ae, $11, $bd, $41, $ee, $52, $0f, $a0, $dd, $47, $fd
00CD8B  2  BD 41 EE 52  
00CD8F  2  0F A0 DD 47  
00CD94  2               
00CD94  2               ;level D-1
00CD94  2               L_GroundArea37:
00CD94  2  52 A1 0F 20    .byte $52, $a1, $0f, $20, $6e, $65, $04, $a0, $14, $07, $24, $2d, $57, $25, $bc, $09
00CD98  2  6E 65 04 A0  
00CD9C  2  14 07 24 2D  
00CDA4  2  4C 80 6F 33    .byte $4c, $80, $6f, $33, $a5, $11, $a7, $63, $b7, $63, $e7, $20, $35, $a0, $59, $11
00CDA8  2  A5 11 A7 63  
00CDAC  2  B7 63 E7 20  
00CDB4  2  B4 08 C0 04    .byte $b4, $08, $c0, $04, $05, $82, $15, $02, $25, $02, $3a, $10, $4c, $01, $6c, $79
00CDB8  2  05 82 15 02  
00CDBC  2  25 02 3A 10  
00CDC4  2  95 79 73 A7    .byte $95, $79, $73, $a7, $8f, $74, $f3, $0a, $03, $a0, $93, $08, $97, $73, $e3, $20
00CDC8  2  8F 74 F3 0A  
00CDCC  2  03 A0 93 08  
00CDD4  2  39 F1 94 07    .byte $39, $f1, $94, $07, $aa, $30, $bc, $5c, $c7, $30, $24, $f2, $27, $31, $8f, $33
00CDD8  2  AA 30 BC 5C  
00CDDC  2  C7 30 24 F2  
00CDE4  2  C6 10 C7 63    .byte $c6, $10, $c7, $63, $d7, $63, $e7, $63, $f7, $63, $03, $a5, $07, $25, $aa, $10
00CDE8  2  D7 63 E7 63  
00CDEC  2  F7 63 03 A5  
00CDF4  2  03 BF 4F 74    .byte $03, $bf, $4f, $74, $6c, $00, $df, $74, $fc, $00, $5c, $81, $77, $73, $9d, $4c
00CDF8  2  6C 00 DF 74  
00CDFC  2  FC 00 5C 81  
00CE04  2  C5 30 E3 30    .byte $c5, $30, $e3, $30, $7d, $c1, $bd, $4d, $bf, $26, $ad, $c7, $fd
00CE08  2  7D C1 BD 4D  
00CE0C  2  BF 26 AD C7  
00CE11  2               
00CE11  2               ;level D-2
00CE11  2               L_GroundArea38:
00CE11  2  55 A1 0F 26    .byte $55, $a1, $0f, $26, $9c, $01, $4f, $b6, $b3, $34, $c9, $3f, $13, $ba, $a3, $b3
00CE15  2  9C 01 4F B6  
00CE19  2  B3 34 C9 3F  
00CE21  2  BF 74 0C 84    .byte $bf, $74, $0c, $84, $83, $3f, $9f, $74, $ef, $72, $ec, $01, $2f, $f2, $2c, $01
00CE25  2  83 3F 9F 74  
00CE29  2  EF 72 EC 01  
00CE31  2  6F 72 6C 01    .byte $6f, $72, $6c, $01, $a8, $91, $aa, $10, $03, $b7, $61, $79, $6f, $75, $39, $f1
00CE35  2  A8 91 AA 10  
00CE39  2  03 B7 61 79  
00CE41  2  DB 71 03 A2    .byte $db, $71, $03, $a2, $17, $22, $33, $09, $43, $20, $5b, $71, $48, $8f, $4a, $30
00CE45  2  17 22 33 09  
00CE49  2  43 20 5B 71  
00CE51  2  5C 5C A3 30    .byte $5c, $5c, $a3, $30, $2d, $c1, $5f, $26, $3d, $c7, $fd
00CE55  2  2D C1 5F 26  
00CE59  2  3D C7 FD     
00CE5C  2               
00CE5C  2               ;level D-3
00CE5C  2               L_GroundArea39:
00CE5C  2  55 A1 0F 26    .byte $55, $a1, $0f, $26, $39, $91, $68, $12, $a7, $12, $aa, $10, $c7, $07, $e8, $12
00CE60  2  39 91 68 12  
00CE64  2  A7 12 AA 10  
00CE6C  2  19 91 6C 00    .byte $19, $91, $6c, $00, $78, $74, $0e, $c2, $76, $a8, $fe, $40, $29, $91, $73, $29
00CE70  2  78 74 0E C2  
00CE74  2  76 A8 FE 40  
00CE7C  2  77 53 8C 77    .byte $77, $53, $8c, $77, $59, $91, $87, $13, $b6, $14, $ba, $10, $e8, $12, $38, $92
00CE80  2  59 91 87 13  
00CE84  2  B6 14 BA 10  
00CE8C  2  19 8F 2C 00    .byte $19, $8f, $2c, $00, $33, $67, $4e, $42, $68, $0b, $2e, $c0, $38, $72, $a8, $11
00CE90  2  33 67 4E 42  
00CE94  2  68 0B 2E C0  
00CE9C  2  AA 10 49 91    .byte $aa, $10, $49, $91, $6e, $42, $de, $40, $e7, $22, $0e, $c2, $4e, $c0, $6c, $00
00CEA0  2  6E 42 DE 40  
00CEA4  2  E7 22 0E C2  
00CEAC  2  79 11 8C 01    .byte $79, $11, $8c, $01, $a7, $13, $bc, $01, $d5, $15, $ec, $01, $03, $97, $0e, $00
00CEB0  2  A7 13 BC 01  
00CEB4  2  D5 15 EC 01  
00CEBC  2  6E 01 9D 41    .byte $6e, $01, $9d, $41, $ce, $42, $ff, $20, $9d, $c7, $fd
00CEC0  2  CE 42 FF 20  
00CEC4  2  9D C7 FD     
00CEC7  2               
00CEC7  2               ;ground level area used with level D-4
00CEC7  2               L_GroundArea40:
00CEC7  2  10 21 39 F1    .byte $10, $21, $39, $f1, $09, $f1, $ad, $4c, $7c, $83, $96, $30, $5b, $f1, $c8, $05
00CECB  2  09 F1 AD 4C  
00CECF  2  7C 83 96 30  
00CED7  2  1F B7 93 67    .byte $1f, $b7, $93, $67, $a3, $67, $b3, $67, $bd, $4d, $cc, $08, $54, $fe, $6e, $2f
00CEDB  2  A3 67 B3 67  
00CEDF  2  BD 4D CC 08  
00CEE7  2  6D C7 FD       .byte $6d, $c7, $fd
00CEEA  2               
00CEEA  2               ;cloud level used with levels A-1, B-1 and D-2
00CEEA  2               L_GroundArea41:
00CEEA  2  00 C1 4C 00    .byte $00, $c1, $4c, $00, $02, $c9, $ba, $49, $62, $c9, $a4, $20, $a5, $20, $1a, $c9
00CEEE  2  02 C9 BA 49  
00CEF2  2  62 C9 A4 20  
00CEFA  2  A3 2C B2 49    .byte $a3, $2c, $b2, $49, $56, $c2, $6e, $00, $95, $41, $ad, $c7, $fd
00CEFE  2  56 C2 6E 00  
00CF02  2  95 41 AD C7  
00CF07  2               
00CF07  2               ;level A-2
00CF07  2               L_UndergroundArea6:
00CF07  2  48 8F 1E 01    .byte $48, $8f, $1e, $01, $4e, $02, $00, $8c, $09, $0f, $6e, $0a, $ee, $82, $2e, $80
00CF0B  2  4E 02 00 8C  
00CF0F  2  09 0F 6E 0A  
00CF17  2  30 20 7E 01    .byte $30, $20, $7e, $01, $87, $27, $07, $87, $17, $23, $3e, $00, $9e, $05, $5b, $f1
00CF1B  2  87 27 07 87  
00CF1F  2  17 23 3E 00  
00CF27  2  8B 71 BB 71    .byte $8b, $71, $bb, $71, $eb, $71, $3e, $82, $7f, $38, $fe, $0a, $3e, $84, $47, $29
00CF2B  2  EB 71 3E 82  
00CF2F  2  7F 38 FE 0A  
00CF37  2  48 2E AF 71    .byte $48, $2e, $af, $71, $cb, $71, $e7, $0a, $f7, $23, $2b, $f1, $37, $51, $3e, $00
00CF3B  2  CB 71 E7 0A  
00CF3F  2  F7 23 2B F1  
00CF47  2  6F 00 8E 04    .byte $6f, $00, $8e, $04, $df, $32, $9c, $82, $ca, $12, $dc, $00, $e8, $14, $fc, $00
00CF4B  2  DF 32 9C 82  
00CF4F  2  CA 12 DC 00  
00CF57  2  FE 08 4E 8A    .byte $fe, $08, $4e, $8a, $88, $74, $9e, $01, $a8, $52, $bf, $47, $b8, $52, $c8, $52
00CF5B  2  88 74 9E 01  
00CF5F  2  A8 52 BF 47  
00CF67  2  D8 52 E8 52    .byte $d8, $52, $e8, $52, $ee, $0f, $4d, $c7, $0d, $0d, $0e, $02, $68, $7a, $be, $01
00CF6B  2  EE 0F 4D C7  
00CF6F  2  0D 0D 0E 02  
00CF77  2  EE 0F 6D C5    .byte $ee, $0f, $6d, $c5, $fd
00CF7B  2  FD           
00CF7C  2               
00CF7C  2               ;underground bonus rooms used with worlds A-D
00CF7C  2               L_UndergroundArea7:
00CF7C  2  08 0F 0E 01    .byte $08, $0f, $0e, $01, $2e, $05, $38, $20, $3e, $04, $48, $07, $55, $45, $57, $45
00CF80  2  2E 05 38 20  
00CF84  2  3E 04 48 07  
00CF8C  2  58 25 B8 08    .byte $58, $25, $b8, $08, $be, $05, $c8, $20, $ce, $01, $df, $4a, $6d, $c7, $0e, $81
00CF90  2  BE 05 C8 20  
00CF94  2  CE 01 DF 4A  
00CF9C  2  00 5A 2E 02    .byte $00, $5a, $2e, $02, $34, $42, $36, $42, $37, $22, $73, $54, $83, $0b, $87, $20
00CFA0  2  34 42 36 42  
00CFA4  2  37 22 73 54  
00CFAC  2  93 54 90 07    .byte $93, $54, $90, $07, $b4, $41, $b6, $41, $b7, $21, $df, $4a, $6d, $c7, $0e, $81
00CFB0  2  B4 41 B6 41  
00CFB4  2  B7 21 DF 4A  
00CFBC  2  00 5A 14 56    .byte $00, $5a, $14, $56, $24, $56, $2e, $0c, $33, $43, $6e, $09, $8e, $0b, $96, $48
00CFC0  2  24 56 2E 0C  
00CFC4  2  33 43 6E 09  
00CFCC  2  1E 84 3E 05    .byte $1e, $84, $3e, $05, $4a, $48, $47, $0b, $ce, $01, $df, $4a, $6d, $c7, $fd
00CFD0  2  4A 48 47 0B  
00CFD4  2  CE 01 DF 4A  
00CFDB  2               
00CFDB  2               ;level B-2
00CFDB  2               L_WaterArea9:
00CFDB  2  41 01 DA 60    .byte $41, $01, $da, $60, $e9, $61, $f8, $62, $fe, $0b, $fe, $81, $47, $d3, $8a, $60
00CFDF  2  E9 61 F8 62  
00CFE3  2  FE 0B FE 81  
00CFEB  2  99 61 A8 62    .byte $99, $61, $a8, $62, $b7, $63, $c6, $64, $d5, $65, $e4, $66, $ed, $49, $f3, $67
00CFEF  2  B7 63 C6 64  
00CFF3  2  D5 65 E4 66  
00CFFB  2  1A CB E3 67    .byte $1a, $cb, $e3, $67, $f3, $67, $fe, $02, $31, $d6, $3c, $02, $77, $53, $ac, $02
00CFFF  2  F3 67 FE 02  
00D003  2  31 D6 3C 02  
00D00B  2  B1 56 E7 53    .byte $b1, $56, $e7, $53, $fe, $01, $77, $b9, $a3, $43, $00, $bf, $29, $51, $39, $48
00D00F  2  FE 01 77 B9  
00D013  2  A3 43 00 BF  
00D01B  2  61 55 D2 44    .byte $61, $55, $d2, $44, $d6, $54, $0c, $82, $2e, $02, $31, $66, $44, $47, $47, $32
00D01F  2  D6 54 0C 82  
00D023  2  2E 02 31 66  
00D02B  2  4A 47 97 32    .byte $4a, $47, $97, $32, $c1, $66, $ce, $01, $dc, $02, $fe, $0e, $0c, $8f, $08, $4f
00D02F  2  C1 66 CE 01  
00D033  2  DC 02 FE 0E  
00D03B  2  FE 02 75 E0    .byte $fe, $02, $75, $e0, $fe, $01, $0c, $87, $9a, $60, $a9, $61, $b8, $62, $c7, $63
00D03F  2  FE 01 0C 87  
00D043  2  9A 60 A9 61  
00D04B  2  CE 0F D5 0D    .byte $ce, $0f, $d5, $0d, $6d, $ca, $7d, $47, $fd
00D04F  2  6D CA 7D 47  
00D053  2  FD           
00D054  2               
00D054  2               ;a bunch of unused space tacked on for no apparent reason
00D054  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D058  2  FF FF FF FF  
00D05C  2  FF FF FF FF  
00D064  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D068  2  FF FF FF FF  
00D06C  2  FF FF FF FF  
00D074  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D078  2  FF FF FF FF  
00D07C  2  FF FF FF FF  
00D084  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D088  2  FF FF FF FF  
00D08C  2  FF FF FF FF  
00D094  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D098  2  FF FF FF FF  
00D09C  2  FF FF FF FF  
00D0A4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0A8  2  FF FF FF FF  
00D0AC  2  FF FF FF FF  
00D0B4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0B8  2  FF FF FF FF  
00D0BC  2  FF FF FF FF  
00D0C4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0C8  2  FF FF FF FF  
00D0CC  2  FF FF FF FF  
00D0D4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0D8  2  FF FF FF FF  
00D0DC  2  FF FF FF FF  
00D0E4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0E8  2  FF FF FF FF  
00D0EC  2  FF FF FF FF  
00D0F4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D0F8  2  FF FF FF FF  
00D0FC  2  FF FF FF FF  
00D104  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D108  2  FF FF FF FF  
00D10C  2  FF FF FF FF  
00D114  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D118  2  FF FF FF FF  
00D11C  2  FF FF FF FF  
00D124  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D128  2  FF FF FF FF  
00D12C  2  FF FF FF FF  
00D134  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D138  2  FF FF FF FF  
00D13C  2  FF FF FF FF  
00D144  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D148  2  FF FF FF FF  
00D14C  2  FF FF FF FF  
00D154  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D158  2  FF FF FF FF  
00D15C  2  FF FF FF FF  
00D164  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D168  2  FF FF FF FF  
00D16C  2  FF FF FF FF  
00D174  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D178  2  FF FF FF FF  
00D17C  2  FF FF FF FF  
00D184  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D188  2  FF FF FF FF  
00D18C  2  FF FF FF FF  
00D194  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D198  2  FF FF FF FF  
00D19C  2  FF FF FF FF  
00D1A4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1A8  2  FF FF FF FF  
00D1AC  2  FF FF FF FF  
00D1B4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1B8  2  FF FF FF FF  
00D1BC  2  FF FF FF FF  
00D1C4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1C8  2  FF FF FF FF  
00D1CC  2  FF FF FF FF  
00D1D4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1D8  2  FF FF FF FF  
00D1DC  2  FF FF FF FF  
00D1E4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1E8  2  FF FF FF FF  
00D1EC  2  FF FF FF FF  
00D1F4  2  FF FF FF FF    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
00D1F8  2  FF FF FF FF  
00D1FC  2  FF FF FF FF  
00D200  2               
00D200  1               .reloc
00CC1Br 1               .endscope
00CC1Br 1               Data4End:
00CC1Br 1               
00CC1Br 1  03           .byte FileHeaderBlock
00CC1Cr 1  07 0F        .byte $07,$0f
00CC1Er 1  53 4D 32 53  .byte "SM2SAVE "
00CC22r 1  41 56 45 20  
00CC26r 1  9F D2 01 00  .word $d29f, 1
00CC2Ar 1  00 04        .byte PRG,FileDataBlock
00CC2Cr 1  00           .byte 0
00CC2Cr 1               
