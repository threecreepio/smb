ca65 V2.16 - Ubuntu 2.16-2
Main file   : main.asm
Current file: main.asm

000000r 1               .segment "INES"
000000r 1  4E 45 53 1A  	.byte "NES",$1A
000004r 1  02           	.byte 2 ; prg
000005r 1  01             .byte 1 ; chr
000006r 1  01           	.byte %00000001 ; flags 6
000007r 1               
000007r 1               .segment "SMBPRG"
000000r 1               .include "smb.asm"
000000r 2               ;SMBDIS.ASM - A COMPREHENSIVE SUPER MARIO BROS. DISASSEMBLY
000000r 2               ;by doppelganger (doppelheathen@gmail.com)
000000r 2               
000000r 2               ;This file is provided for your own use as-is.  It will require the character rom data
000000r 2               ;and an iNES file header to get it to work.
000000r 2               
000000r 2               ;There are so many people I have to thank for this, that taking all the credit for
000000r 2               ;myself would be an unforgivable act of arrogance. Without their help this would
000000r 2               ;probably not be possible.  So I thank all the peeps in the nesdev scene whose insight into
000000r 2               ;the 6502 and the NES helped me learn how it works (you guys know who you are, there's no
000000r 2               ;way I could have done this without your help), as well as the authors of x816 and SMB
000000r 2               ;Utility, and the reverse-engineers who did the original Super Mario Bros. Hacking Project,
000000r 2               ;which I compared notes with but did not copy from.  Last but certainly not least, I thank
000000r 2               ;Nintendo for creating this game and the NES, without which this disassembly would
000000r 2               ;only be theory.
000000r 2               
000000r 2               ;Assembles with x816.
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;DEFINES
000000r 2               
000000r 2               ;NES specific hardware defines
000000r 2               
000000r 2               PPU_CTRL_REG1         = $2000
000000r 2               PPU_CTRL_REG2         = $2001
000000r 2               PPU_STATUS            = $2002
000000r 2               PPU_SPR_ADDR          = $2003
000000r 2               PPU_SPR_DATA          = $2004
000000r 2               PPU_SCROLL_REG        = $2005
000000r 2               PPU_ADDRESS           = $2006
000000r 2               PPU_DATA              = $2007
000000r 2               
000000r 2               SND_REGISTER          = $4000
000000r 2               SND_SQUARE1_REG       = $4000
000000r 2               SND_SQUARE2_REG       = $4004
000000r 2               SND_TRIANGLE_REG      = $4008
000000r 2               SND_NOISE_REG         = $400c
000000r 2               SND_DELTA_REG         = $4010
000000r 2               SND_MASTERCTRL_REG    = $4015
000000r 2               
000000r 2               SPR_DMA               = $4014
000000r 2               JOYPAD_PORT           = $4016
000000r 2               JOYPAD_PORT1          = $4016
000000r 2               JOYPAD_PORT2          = $4017
000000r 2               
000000r 2               ; GAME SPECIFIC DEFINES
000000r 2               
000000r 2               ObjectOffset          = $08
000000r 2               
000000r 2               FrameCounter          = $09
000000r 2               
000000r 2               SavedJoypadBits       = $06fc
000000r 2               SavedJoypad1Bits      = $06fc
000000r 2               SavedJoypad2Bits      = $06fd
000000r 2               JoypadBitMask         = $074a
000000r 2               JoypadOverride        = $0758
000000r 2               
000000r 2               A_B_Buttons           = $0a
000000r 2               PreviousA_B_Buttons   = $0d
000000r 2               Up_Down_Buttons       = $0b
000000r 2               Left_Right_Buttons    = $0c
000000r 2               
000000r 2               GameEngineSubroutine  = $0e
000000r 2               
000000r 2               Mirror_PPU_CTRL_REG1  = $0778
000000r 2               Mirror_PPU_CTRL_REG2  = $0779
000000r 2               
000000r 2               OperMode              = $0770
000000r 2               OperMode_Task         = $0772
000000r 2               ScreenRoutineTask     = $073c
000000r 2               
000000r 2               GamePauseStatus       = $0776
000000r 2               GamePauseTimer        = $0777
000000r 2               
000000r 2               DemoAction            = $0717
000000r 2               DemoActionTimer       = $0718
000000r 2               
000000r 2               TimerControl          = $0747
000000r 2               IntervalTimerControl  = $077f
000000r 2               
000000r 2               Timers                = $0780
000000r 2               SelectTimer           = $0780
000000r 2               PlayerAnimTimer       = $0781
000000r 2               JumpSwimTimer         = $0782
000000r 2               RunningTimer          = $0783
000000r 2               BlockBounceTimer      = $0784
000000r 2               SideCollisionTimer    = $0785
000000r 2               JumpspringTimer       = $0786
000000r 2               GameTimerCtrlTimer    = $0787
000000r 2               ClimbSideTimer        = $0789
000000r 2               EnemyFrameTimer       = $078a
000000r 2               FrenzyEnemyTimer      = $078f
000000r 2               BowserFireBreathTimer = $0790
000000r 2               StompTimer            = $0791
000000r 2               AirBubbleTimer        = $0792
000000r 2               ScrollIntervalTimer   = $0795
000000r 2               EnemyIntervalTimer    = $0796
000000r 2               BrickCoinTimer        = $079d
000000r 2               InjuryTimer           = $079e
000000r 2               StarInvincibleTimer   = $079f
000000r 2               ScreenTimer           = $07a0
000000r 2               WorldEndTimer         = $07a1
000000r 2               DemoTimer             = $07a2
000000r 2               
000000r 2               Sprite_Data           = $0200
000000r 2               
000000r 2               Sprite_Y_Position     = $0200
000000r 2               Sprite_Tilenumber     = $0201
000000r 2               Sprite_Attributes     = $0202
000000r 2               Sprite_X_Position     = $0203
000000r 2               
000000r 2               ScreenEdge_PageLoc    = $071a
000000r 2               ScreenEdge_X_Pos      = $071c
000000r 2               ScreenLeft_PageLoc    = $071a
000000r 2               ScreenRight_PageLoc   = $071b
000000r 2               ScreenLeft_X_Pos      = $071c
000000r 2               ScreenRight_X_Pos     = $071d
000000r 2               
000000r 2               PlayerFacingDir       = $33
000000r 2               DestinationPageLoc    = $34
000000r 2               VictoryWalkControl    = $35
000000r 2               ScrollFractional      = $0768
000000r 2               PrimaryMsgCounter     = $0719
000000r 2               SecondaryMsgCounter   = $0749
000000r 2               
000000r 2               HorizontalScroll      = $073f
000000r 2               VerticalScroll        = $0740
000000r 2               ScrollLock            = $0723
000000r 2               ScrollThirtyTwo       = $073d
000000r 2               Player_X_Scroll       = $06ff
000000r 2               Player_Pos_ForScroll  = $0755
000000r 2               ScrollAmount          = $0775
000000r 2               
000000r 2               AreaData              = $e7
000000r 2               AreaDataLow           = $e7
000000r 2               AreaDataHigh          = $e8
000000r 2               EnemyData             = $e9
000000r 2               EnemyDataLow          = $e9
000000r 2               EnemyDataHigh         = $ea
000000r 2               
000000r 2               AreaParserTaskNum     = $071f
000000r 2               ColumnSets            = $071e
000000r 2               CurrentPageLoc        = $0725
000000r 2               CurrentColumnPos      = $0726
000000r 2               BackloadingFlag       = $0728
000000r 2               BehindAreaParserFlag  = $0729
000000r 2               AreaObjectPageLoc     = $072a
000000r 2               AreaObjectPageSel     = $072b
000000r 2               AreaDataOffset        = $072c
000000r 2               AreaObjOffsetBuffer   = $072d
000000r 2               AreaObjectLength      = $0730
000000r 2               StaircaseControl      = $0734
000000r 2               AreaObjectHeight      = $0735
000000r 2               MushroomLedgeHalfLen  = $0736
000000r 2               EnemyDataOffset       = $0739
000000r 2               EnemyObjectPageLoc    = $073a
000000r 2               EnemyObjectPageSel    = $073b
000000r 2               MetatileBuffer        = $06a1
000000r 2               BlockBufferColumnPos  = $06a0
000000r 2               CurrentNTAddr_Low     = $0721
000000r 2               CurrentNTAddr_High    = $0720
000000r 2               AttributeBuffer       = $03f9
000000r 2               
000000r 2               LoopCommand           = $0745
000000r 2               
000000r 2               DisplayDigits         = $07d7
000000r 2               TopScoreDisplay       = $07d7
000000r 2               ScoreAndCoinDisplay   = $07dd
000000r 2               PlayerScoreDisplay    = $07dd
000000r 2               GameTimerDisplay      = $07f8
000000r 2               DigitModifier         = $0134
000000r 2               
000000r 2               VerticalFlipFlag      = $0109
000000r 2               FloateyNum_Control    = $0110
000000r 2               ShellChainCounter     = $0125
000000r 2               FloateyNum_Timer      = $012c
000000r 2               FloateyNum_X_Pos      = $0117
000000r 2               FloateyNum_Y_Pos      = $011e
000000r 2               FlagpoleFNum_Y_Pos    = $010d
000000r 2               FlagpoleFNum_YMFDummy = $010e
000000r 2               FlagpoleScore         = $010f
000000r 2               FlagpoleCollisionYPos = $070f
000000r 2               StompChainCounter     = $0484
000000r 2               
000000r 2               VRAM_Buffer1_Offset   = $0300
000000r 2               VRAM_Buffer1          = $0301
000000r 2               VRAM_Buffer2_Offset   = $0340
000000r 2               VRAM_Buffer2          = $0341
000000r 2               VRAM_Buffer_AddrCtrl  = $0773
000000r 2               Sprite0HitDetectFlag  = $0722
000000r 2               DisableScreenFlag     = $0774
000000r 2               DisableIntermediate   = $0769
000000r 2               ColorRotateOffset     = $06d4
000000r 2               
000000r 2               TerrainControl        = $0727
000000r 2               AreaStyle             = $0733
000000r 2               ForegroundScenery     = $0741
000000r 2               BackgroundScenery     = $0742
000000r 2               CloudTypeOverride     = $0743
000000r 2               BackgroundColorCtrl   = $0744
000000r 2               AreaType              = $074e
000000r 2               AreaAddrsLOffset      = $074f
000000r 2               AreaPointer           = $0750
000000r 2               
000000r 2               PlayerEntranceCtrl    = $0710
000000r 2               GameTimerSetting      = $0715
000000r 2               AltEntranceControl    = $0752
000000r 2               EntrancePage          = $0751
000000r 2               NumberOfPlayers       = $077a
000000r 2               WarpZoneControl       = $06d6
000000r 2               ChangeAreaTimer       = $06de
000000r 2               
000000r 2               MultiLoopCorrectCntr  = $06d9
000000r 2               MultiLoopPassCntr     = $06da
000000r 2               
000000r 2               FetchNewGameTimerFlag = $0757
000000r 2               GameTimerExpiredFlag  = $0759
000000r 2               
000000r 2               PrimaryHardMode       = $076a
000000r 2               SecondaryHardMode     = $06cc
000000r 2               WorldSelectNumber     = $076b
000000r 2               WorldSelectEnableFlag = $07fc
000000r 2               ContinueWorld         = $07fd
000000r 2               
000000r 2               CurrentPlayer         = $0753
000000r 2               PlayerSize            = $0754
000000r 2               PlayerStatus          = $0756
000000r 2               
000000r 2               OnscreenPlayerInfo    = $075a
000000r 2               NumberofLives         = $075a ;used by current player
000000r 2               HalfwayPage           = $075b
000000r 2               LevelNumber           = $075c ;the actual dash number
000000r 2               Hidden1UpFlag         = $075d
000000r 2               CoinTally             = $075e
000000r 2               WorldNumber           = $075f
000000r 2               AreaNumber            = $0760 ;internal number used to find areas
000000r 2               
000000r 2               CoinTallyFor1Ups      = $0748
000000r 2               
000000r 2               OffscreenPlayerInfo   = $0761
000000r 2               OffScr_NumberofLives  = $0761 ;used by offscreen player
000000r 2               OffScr_HalfwayPage    = $0762
000000r 2               OffScr_LevelNumber    = $0763
000000r 2               OffScr_Hidden1UpFlag  = $0764
000000r 2               OffScr_CoinTally      = $0765
000000r 2               OffScr_WorldNumber    = $0766
000000r 2               OffScr_AreaNumber     = $0767
000000r 2               
000000r 2               BalPlatformAlignment  = $03a0
000000r 2               Platform_X_Scroll     = $03a1
000000r 2               PlatformCollisionFlag = $03a2
000000r 2               YPlatformTopYPos      = $0401
000000r 2               YPlatformCenterYPos   = $58
000000r 2               
000000r 2               BrickCoinTimerFlag    = $06bc
000000r 2               StarFlagTaskControl   = $0746
000000r 2               
000000r 2               PseudoRandomBitReg    = $07a7
000000r 2               WarmBootValidation    = $07ff
000000r 2               
000000r 2               SprShuffleAmtOffset   = $06e0
000000r 2               SprShuffleAmt         = $06e1
000000r 2               SprDataOffset         = $06e4
000000r 2               Player_SprDataOffset  = $06e4
000000r 2               Enemy_SprDataOffset   = $06e5
000000r 2               Block_SprDataOffset   = $06ec
000000r 2               Alt_SprDataOffset     = $06ec
000000r 2               Bubble_SprDataOffset  = $06ee
000000r 2               FBall_SprDataOffset   = $06f1
000000r 2               Misc_SprDataOffset    = $06f3
000000r 2               SprDataOffset_Ctrl    = $03ee
000000r 2               
000000r 2               Player_State          = $1d
000000r 2               Enemy_State           = $1e
000000r 2               Fireball_State        = $24
000000r 2               Block_State           = $26
000000r 2               Misc_State            = $2a
000000r 2               
000000r 2               Player_MovingDir      = $45
000000r 2               Enemy_MovingDir       = $46
000000r 2               
000000r 2               SprObject_X_Speed     = $57
000000r 2               Player_X_Speed        = $57
000000r 2               Enemy_X_Speed         = $58
000000r 2               Fireball_X_Speed      = $5e
000000r 2               Block_X_Speed         = $60
000000r 2               Misc_X_Speed          = $64
000000r 2               
000000r 2               Jumpspring_FixedYPos  = $58
000000r 2               JumpspringAnimCtrl    = $070e
000000r 2               JumpspringForce       = $06db
000000r 2               
000000r 2               SprObject_PageLoc     = $6d
000000r 2               Player_PageLoc        = $6d
000000r 2               Enemy_PageLoc         = $6e
000000r 2               Fireball_PageLoc      = $74
000000r 2               Block_PageLoc         = $76
000000r 2               Misc_PageLoc          = $7a
000000r 2               Bubble_PageLoc        = $83
000000r 2               
000000r 2               SprObject_X_Position  = $86
000000r 2               Player_X_Position     = $86
000000r 2               Enemy_X_Position      = $87
000000r 2               Fireball_X_Position   = $8d
000000r 2               Block_X_Position      = $8f
000000r 2               Misc_X_Position       = $93
000000r 2               Bubble_X_Position     = $9c
000000r 2               
000000r 2               SprObject_Y_Speed     = $9f
000000r 2               Player_Y_Speed        = $9f
000000r 2               Enemy_Y_Speed         = $a0
000000r 2               Fireball_Y_Speed      = $a6
000000r 2               Block_Y_Speed         = $a8
000000r 2               Misc_Y_Speed          = $ac
000000r 2               
000000r 2               SprObject_Y_HighPos   = $b5
000000r 2               Player_Y_HighPos      = $b5
000000r 2               Enemy_Y_HighPos       = $b6
000000r 2               Fireball_Y_HighPos    = $bc
000000r 2               Block_Y_HighPos       = $be
000000r 2               Misc_Y_HighPos        = $c2
000000r 2               Bubble_Y_HighPos      = $cb
000000r 2               
000000r 2               SprObject_Y_Position  = $ce
000000r 2               Player_Y_Position     = $ce
000000r 2               Enemy_Y_Position      = $cf
000000r 2               Fireball_Y_Position   = $d5
000000r 2               Block_Y_Position      = $d7
000000r 2               Misc_Y_Position       = $db
000000r 2               Bubble_Y_Position     = $e4
000000r 2               
000000r 2               SprObject_Rel_XPos    = $03ad
000000r 2               Player_Rel_XPos       = $03ad
000000r 2               Enemy_Rel_XPos        = $03ae
000000r 2               Fireball_Rel_XPos     = $03af
000000r 2               Bubble_Rel_XPos       = $03b0
000000r 2               Block_Rel_XPos        = $03b1
000000r 2               Misc_Rel_XPos         = $03b3
000000r 2               
000000r 2               SprObject_Rel_YPos    = $03b8
000000r 2               Player_Rel_YPos       = $03b8
000000r 2               Enemy_Rel_YPos        = $03b9
000000r 2               Fireball_Rel_YPos     = $03ba
000000r 2               Bubble_Rel_YPos       = $03bb
000000r 2               Block_Rel_YPos        = $03bc
000000r 2               Misc_Rel_YPos         = $03be
000000r 2               
000000r 2               SprObject_SprAttrib   = $03c4
000000r 2               Player_SprAttrib      = $03c4
000000r 2               Enemy_SprAttrib       = $03c5
000000r 2               
000000r 2               SprObject_X_MoveForce = $0400
000000r 2               Enemy_X_MoveForce     = $0401
000000r 2               
000000r 2               SprObject_YMF_Dummy   = $0416
000000r 2               Player_YMF_Dummy      = $0416
000000r 2               Enemy_YMF_Dummy       = $0417
000000r 2               Bubble_YMF_Dummy      = $042c
000000r 2               
000000r 2               SprObject_Y_MoveForce = $0433
000000r 2               Player_Y_MoveForce    = $0433
000000r 2               Enemy_Y_MoveForce     = $0434
000000r 2               Block_Y_MoveForce     = $043c
000000r 2               
000000r 2               DisableCollisionDet   = $0716
000000r 2               Player_CollisionBits  = $0490
000000r 2               Enemy_CollisionBits   = $0491
000000r 2               
000000r 2               SprObj_BoundBoxCtrl   = $0499
000000r 2               Player_BoundBoxCtrl   = $0499
000000r 2               Enemy_BoundBoxCtrl    = $049a
000000r 2               Fireball_BoundBoxCtrl = $04a0
000000r 2               Misc_BoundBoxCtrl     = $04a2
000000r 2               
000000r 2               EnemyFrenzyBuffer     = $06cb
000000r 2               EnemyFrenzyQueue      = $06cd
000000r 2               Enemy_Flag            = $0f
000000r 2               Enemy_ID              = $16
000000r 2               
000000r 2               PlayerGfxOffset       = $06d5
000000r 2               Player_XSpeedAbsolute = $0700
000000r 2               FrictionAdderHigh     = $0701
000000r 2               FrictionAdderLow      = $0702
000000r 2               RunningSpeed          = $0703
000000r 2               SwimmingFlag          = $0704
000000r 2               Player_X_MoveForce    = $0705
000000r 2               DiffToHaltJump        = $0706
000000r 2               JumpOrigin_Y_HighPos  = $0707
000000r 2               JumpOrigin_Y_Position = $0708
000000r 2               VerticalForce         = $0709
000000r 2               VerticalForceDown     = $070a
000000r 2               PlayerChangeSizeFlag  = $070b
000000r 2               PlayerAnimTimerSet    = $070c
000000r 2               PlayerAnimCtrl        = $070d
000000r 2               DeathMusicLoaded      = $0712
000000r 2               FlagpoleSoundQueue    = $0713
000000r 2               CrouchingFlag         = $0714
000000r 2               MaximumLeftSpeed      = $0450
000000r 2               MaximumRightSpeed     = $0456
000000r 2               
000000r 2               SprObject_OffscrBits  = $03d0
000000r 2               Player_OffscreenBits  = $03d0
000000r 2               Enemy_OffscreenBits   = $03d1
000000r 2               FBall_OffscreenBits   = $03d2
000000r 2               Bubble_OffscreenBits  = $03d3
000000r 2               Block_OffscreenBits   = $03d4
000000r 2               Misc_OffscreenBits    = $03d6
000000r 2               EnemyOffscrBitsMasked = $03d8
000000r 2               
000000r 2               Cannon_Offset         = $046a
000000r 2               Cannon_PageLoc        = $046b
000000r 2               Cannon_X_Position     = $0471
000000r 2               Cannon_Y_Position     = $0477
000000r 2               Cannon_Timer          = $047d
000000r 2               
000000r 2               Whirlpool_Offset      = $046a
000000r 2               Whirlpool_PageLoc     = $046b
000000r 2               Whirlpool_LeftExtent  = $0471
000000r 2               Whirlpool_Length      = $0477
000000r 2               Whirlpool_Flag        = $047d
000000r 2               
000000r 2               VineFlagOffset        = $0398
000000r 2               VineHeight            = $0399
000000r 2               VineObjOffset         = $039a
000000r 2               VineStart_Y_Position  = $039d
000000r 2               
000000r 2               Block_Orig_YPos       = $03e4
000000r 2               Block_BBuf_Low        = $03e6
000000r 2               Block_Metatile        = $03e8
000000r 2               Block_PageLoc2        = $03ea
000000r 2               Block_RepFlag         = $03ec
000000r 2               Block_ResidualCounter = $03f0
000000r 2               Block_Orig_XPos       = $03f1
000000r 2               
000000r 2               BoundingBox_UL_XPos   = $04ac
000000r 2               BoundingBox_UL_YPos   = $04ad
000000r 2               BoundingBox_DR_XPos   = $04ae
000000r 2               BoundingBox_DR_YPos   = $04af
000000r 2               BoundingBox_UL_Corner = $04ac
000000r 2               BoundingBox_LR_Corner = $04ae
000000r 2               EnemyBoundingBoxCoord = $04b0
000000r 2               
000000r 2               PowerUpType           = $39
000000r 2               
000000r 2               FireballBouncingFlag  = $3a
000000r 2               FireballCounter       = $06ce
000000r 2               FireballThrowingTimer = $0711
000000r 2               
000000r 2               HammerEnemyOffset     = $06ae
000000r 2               JumpCoinMiscOffset    = $06b7
000000r 2               
000000r 2               Block_Buffer_1        = $0500
000000r 2               Block_Buffer_2        = $05d0
000000r 2               
000000r 2               HammerThrowingTimer   = $03a2
000000r 2               HammerBroJumpTimer    = $3c
000000r 2               Misc_Collision_Flag   = $06be
000000r 2               
000000r 2               RedPTroopaOrigXPos    = $0401
000000r 2               RedPTroopaCenterYPos  = $58
000000r 2               
000000r 2               XMovePrimaryCounter   = $a0
000000r 2               XMoveSecondaryCounter = $58
000000r 2               
000000r 2               CheepCheepMoveMFlag   = $58
000000r 2               CheepCheepOrigYPos    = $0434
000000r 2               BitMFilter            = $06dd
000000r 2               
000000r 2               LakituReappearTimer   = $06d1
000000r 2               LakituMoveSpeed       = $58
000000r 2               LakituMoveDirection   = $a0
000000r 2               
000000r 2               FirebarSpinState_Low  = $58
000000r 2               FirebarSpinState_High = $a0
000000r 2               FirebarSpinSpeed      = $0388
000000r 2               FirebarSpinDirection  = $34
000000r 2               
000000r 2               DuplicateObj_Offset   = $06cf
000000r 2               NumberofGroupEnemies  = $06d3
000000r 2               
000000r 2               BlooperMoveCounter    = $a0
000000r 2               BlooperMoveSpeed      = $58
000000r 2               
000000r 2               BowserBodyControls    = $0363
000000r 2               BowserFeetCounter     = $0364
000000r 2               BowserMovementSpeed   = $0365
000000r 2               BowserOrigXPos        = $0366
000000r 2               BowserFlameTimerCtrl  = $0367
000000r 2               BowserFront_Offset    = $0368
000000r 2               BridgeCollapseOffset  = $0369
000000r 2               BowserGfxFlag         = $036a
000000r 2               BowserHitPoints       = $0483
000000r 2               MaxRangeFromOrigin    = $06dc
000000r 2               
000000r 2               BowserFlamePRandomOfs = $0417
000000r 2               
000000r 2               PiranhaPlantUpYPos    = $0417
000000r 2               PiranhaPlantDownYPos  = $0434
000000r 2               PiranhaPlant_Y_Speed  = $58
000000r 2               PiranhaPlant_MoveFlag = $a0
000000r 2               
000000r 2               FireworksCounter      = $06d7
000000r 2               ExplosionGfxCounter   = $58
000000r 2               ExplosionTimerCounter = $a0
000000r 2               
000000r 2               ;sound related defines
000000r 2               Squ2_NoteLenBuffer    = $07b3
000000r 2               Squ2_NoteLenCounter   = $07b4
000000r 2               Squ2_EnvelopeDataCtrl = $07b5
000000r 2               Squ1_NoteLenCounter   = $07b6
000000r 2               Squ1_EnvelopeDataCtrl = $07b7
000000r 2               Tri_NoteLenBuffer     = $07b8
000000r 2               Tri_NoteLenCounter    = $07b9
000000r 2               Noise_BeatLenCounter  = $07ba
000000r 2               Squ1_SfxLenCounter    = $07bb
000000r 2               Squ2_SfxLenCounter    = $07bd
000000r 2               Sfx_SecondaryCounter  = $07be
000000r 2               Noise_SfxLenCounter   = $07bf
000000r 2               
000000r 2               PauseSoundQueue       = $fa
000000r 2               Square1SoundQueue     = $ff
000000r 2               Square2SoundQueue     = $fe
000000r 2               NoiseSoundQueue       = $fd
000000r 2               AreaMusicQueue        = $fb
000000r 2               EventMusicQueue       = $fc
000000r 2               
000000r 2               Square1SoundBuffer    = $f1
000000r 2               Square2SoundBuffer    = $f2
000000r 2               NoiseSoundBuffer      = $f3
000000r 2               AreaMusicBuffer       = $f4
000000r 2               EventMusicBuffer      = $07b1
000000r 2               PauseSoundBuffer      = $07b2
000000r 2               
000000r 2               MusicData             = $f5
000000r 2               MusicDataLow          = $f5
000000r 2               MusicDataHigh         = $f6
000000r 2               MusicOffset_Square2   = $f7
000000r 2               MusicOffset_Square1   = $f8
000000r 2               MusicOffset_Triangle  = $f9
000000r 2               MusicOffset_Noise     = $07b0
000000r 2               
000000r 2               NoteLenLookupTblOfs   = $f0
000000r 2               DAC_Counter           = $07c0
000000r 2               NoiseDataLoopbackOfs  = $07c1
000000r 2               NoteLengthTblAdder    = $07c4
000000r 2               AreaMusicBuffer_Alt   = $07c5
000000r 2               PauseModeFlag         = $07c6
000000r 2               GroundMusicHeaderOfs  = $07c7
000000r 2               AltRegContentFlag     = $07ca
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;CONSTANTS
000000r 2               
000000r 2               ;sound effects constants
000000r 2               Sfx_SmallJump         = %10000000
000000r 2               Sfx_Flagpole          = %01000000
000000r 2               Sfx_Fireball          = %00100000
000000r 2               Sfx_PipeDown_Injury   = %00010000
000000r 2               Sfx_EnemySmack        = %00001000
000000r 2               Sfx_EnemyStomp        = %00000100
000000r 2               Sfx_Bump              = %00000010
000000r 2               Sfx_BigJump           = %00000001
000000r 2               
000000r 2               Sfx_BowserFall        = %10000000
000000r 2               Sfx_ExtraLife         = %01000000
000000r 2               Sfx_PowerUpGrab       = %00100000
000000r 2               Sfx_TimerTick         = %00010000
000000r 2               Sfx_Blast             = %00001000
000000r 2               Sfx_GrowVine          = %00000100
000000r 2               Sfx_GrowPowerUp       = %00000010
000000r 2               Sfx_CoinGrab          = %00000001
000000r 2               
000000r 2               Sfx_BowserFlame       = %00000010
000000r 2               Sfx_BrickShatter      = %00000001
000000r 2               
000000r 2               ;music constants
000000r 2               Silence               = %10000000
000000r 2               
000000r 2               StarPowerMusic        = %01000000
000000r 2               PipeIntroMusic        = %00100000
000000r 2               CloudMusic            = %00010000
000000r 2               CastleMusic           = %00001000
000000r 2               UndergroundMusic      = %00000100
000000r 2               WaterMusic            = %00000010
000000r 2               GroundMusic           = %00000001
000000r 2               
000000r 2               TimeRunningOutMusic   = %01000000
000000r 2               EndOfLevelMusic       = %00100000
000000r 2               AltGameOverMusic      = %00010000
000000r 2               EndOfCastleMusic      = %00001000
000000r 2               VictoryMusic          = %00000100
000000r 2               GameOverMusic         = %00000010
000000r 2               DeathMusic            = %00000001
000000r 2               
000000r 2               ;enemy object constants
000000r 2               GreenKoopa            = $00
000000r 2               BuzzyBeetle           = $02
000000r 2               RedKoopa              = $03
000000r 2               HammerBro             = $05
000000r 2               Goomba                = $06
000000r 2               Bloober               = $07
000000r 2               BulletBill_FrenzyVar  = $08
000000r 2               GreyCheepCheep        = $0a
000000r 2               RedCheepCheep         = $0b
000000r 2               Podoboo               = $0c
000000r 2               PiranhaPlant          = $0d
000000r 2               GreenParatroopaJump   = $0e
000000r 2               RedParatroopa         = $0f
000000r 2               GreenParatroopaFly    = $10
000000r 2               Lakitu                = $11
000000r 2               Spiny                 = $12
000000r 2               FlyCheepCheepFrenzy   = $14
000000r 2               FlyingCheepCheep      = $14
000000r 2               BowserFlame           = $15
000000r 2               Fireworks             = $16
000000r 2               BBill_CCheep_Frenzy   = $17
000000r 2               Stop_Frenzy           = $18
000000r 2               Bowser                = $2d
000000r 2               PowerUpObject         = $2e
000000r 2               VineObject            = $2f
000000r 2               FlagpoleFlagObject    = $30
000000r 2               StarFlagObject        = $31
000000r 2               JumpspringObject      = $32
000000r 2               BulletBill_CannonVar  = $33
000000r 2               RetainerObject        = $35
000000r 2               TallEnemy             = $09
000000r 2               
000000r 2               ;other constants
000000r 2               World1 = 0
000000r 2               World2 = 1
000000r 2               World3 = 2
000000r 2               World4 = 3
000000r 2               World5 = 4
000000r 2               World6 = 5
000000r 2               World7 = 6
000000r 2               World8 = 7
000000r 2               Level1 = 0
000000r 2               Level2 = 1
000000r 2               Level3 = 2
000000r 2               Level4 = 3
000000r 2               
000000r 2               WarmBootOffset        = <$07d6
000000r 2               ColdBootOffset        = <$07fe
000000r 2               TitleScreenDataOffset = $1ec0
000000r 2               SoundMemory           = $07b0
000000r 2               SwimTileRepOffset     = PlayerGraphicsTable + $9e
000000r 2               MusicHeaderOffsetData = MusicHeaderData - 1
000000r 2               MHD                   = MusicHeaderData
000000r 2               
000000r 2               A_Button              = %10000000
000000r 2               B_Button              = %01000000
000000r 2               Select_Button         = %00100000
000000r 2               Start_Button          = %00010000
000000r 2               Up_Dir                = %00001000
000000r 2               Down_Dir              = %00000100
000000r 2               Left_Dir              = %00000010
000000r 2               Right_Dir             = %00000001
000000r 2               
000000r 2               TitleScreenModeValue  = 0
000000r 2               GameModeValue         = 1
000000r 2               VictoryModeValue      = 2
000000r 2               GameOverModeValue     = 3
000000r 2               
000000r 2               ;-------------------------------------------------------------------------------------
000000r 2               ;DIRECTIVES
000000r 2               
000000r 2                      .org $8000
008000  2               
008000  2               ;-------------------------------------------------------------------------------------
008000  2               
008000  2               Start:
008000  2  78                        sei                          ;pretty standard 6502 type init here
008001  2  D8                        cld
008002  2  A9 10                     lda #%00010000               ;init PPU control register 1
008004  2  8D 00 20                  sta PPU_CTRL_REG1
008007  2  A2 FF                     ldx #$ff                     ;reset stack pointer
008009  2  9A                        txs
00800A  2  AD 02 20     VBlank1:     lda PPU_STATUS               ;wait two frames
00800D  2  10 FB                     bpl VBlank1
00800F  2  AD 02 20     VBlank2:     lda PPU_STATUS
008012  2  10 FB                     bpl VBlank2
008014  2  A0 FE                     ldy #ColdBootOffset          ;load default cold boot pointer
008016  2  A2 05                     ldx #$05                     ;this is where we check for a warm boot
008018  2  BD D7 07     WBootCheck:  lda TopScoreDisplay,x        ;check each score digit in the top score
00801B  2  C9 0A                     cmp #10                      ;to see if we have a valid digit
00801D  2  B0 0C                     bcs ColdBoot                 ;if not, give up and proceed with cold boot
00801F  2  CA                        dex
008020  2  10 F6                     bpl WBootCheck
008022  2  AD FF 07                  lda WarmBootValidation       ;second checkpoint, check to see if
008025  2  C9 A5                     cmp #$a5                     ;another location has a specific value
008027  2  D0 02                     bne ColdBoot
008029  2  A0 D6                     ldy #WarmBootOffset          ;if passed both, load warm boot pointer
00802B  2  20 CC 90     ColdBoot:    jsr InitializeMemory         ;clear memory using pointer in Y
00802E  2  8D 11 40                  sta SND_DELTA_REG+1          ;reset delta counter load register
008031  2  8D 70 07                  sta OperMode                 ;reset primary mode of operation
008034  2  A9 A5                     lda #$a5                     ;set warm boot flag
008036  2  8D FF 07                  sta WarmBootValidation
008039  2  8D A7 07                  sta PseudoRandomBitReg       ;set seed for pseudorandom register
00803C  2  A9 0F                     lda #%00001111
00803E  2  8D 15 40                  sta SND_MASTERCTRL_REG       ;enable all sound channels except dmc
008041  2  A9 06                     lda #%00000110
008043  2  8D 01 20                  sta PPU_CTRL_REG2            ;turn off clipping for OAM and background
008046  2  20 20 82                  jsr MoveAllSpritesOffscreen
008049  2  20 19 8E                  jsr InitializeNameTables     ;initialize both name tables
00804C  2  EE 74 07                  inc DisableScreenFlag        ;set flag to disable screen output
00804F  2  AD 78 07                  lda Mirror_PPU_CTRL_REG1
008052  2  09 80                     ora #%10000000               ;enable NMIs
008054  2  20 ED 8E                  jsr WritePPUReg1
008057  2  4C 57 80     EndlessLoop: jmp EndlessLoop              ;endless loop, need I say more?
00805A  2               
00805A  2               ;-------------------------------------------------------------------------------------
00805A  2               ;$00 - vram buffer address table low, also used for pseudorandom bit
00805A  2               ;$01 - vram buffer address table high
00805A  2               
00805A  2               VRAM_AddrTable_Low:
00805A  2  01 A4 C8           .byte <VRAM_Buffer1, <WaterPaletteData, <GroundPaletteData
00805D  2  EC 10 00           .byte <UndergroundPaletteData, <CastlePaletteData, <VRAM_Buffer1_Offset
008060  2  41 41 4C           .byte <VRAM_Buffer2, <VRAM_Buffer2, <BowserPaletteData
008063  2  34 3C 44           .byte <DaySnowPaletteData, <NightSnowPaletteData, <MushroomPaletteData
008066  2  54 68 7C           .byte <MarioThanksMessage, <LuigiThanksMessage, <MushroomRetainerSaved
008069  2  A8 BF DE           .byte <PrincessSaved1, <PrincessSaved2, <WorldSelectMessage1
00806C  2  EF                 .byte <WorldSelectMessage2
00806D  2               
00806D  2               VRAM_AddrTable_High:
00806D  2  03 8C 8C           .byte >VRAM_Buffer1, >WaterPaletteData, >GroundPaletteData
008070  2  8C 8D 03           .byte >UndergroundPaletteData, >CastlePaletteData, >VRAM_Buffer1_Offset
008073  2  03 03 8D           .byte >VRAM_Buffer2, >VRAM_Buffer2, >BowserPaletteData
008076  2  8D 8D 8D           .byte >DaySnowPaletteData, >NightSnowPaletteData, >MushroomPaletteData
008079  2  8D 8D 8D           .byte >MarioThanksMessage, >LuigiThanksMessage, >MushroomRetainerSaved
00807C  2  8D 8D 8D           .byte >PrincessSaved1, >PrincessSaved2, >WorldSelectMessage1
00807F  2  8D                 .byte >WorldSelectMessage2
008080  2               
008080  2               VRAM_Buffer_Offset:
008080  2  00 40              .byte <VRAM_Buffer1_Offset, <VRAM_Buffer2_Offset
008082  2               
008082  2               NonMaskableInterrupt:
008082  2  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;disable NMIs in mirror reg
008085  2  29 7F                       and #%01111111            ;save all other bits
008087  2  8D 78 07                    sta Mirror_PPU_CTRL_REG1
00808A  2  29 7E                       and #%01111110            ;alter name table address to be $2800
00808C  2  8D 00 20                    sta PPU_CTRL_REG1         ;(essentially $2000) but save other bits
00808F  2  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;disable OAM and background display by default
008092  2  29 E6                       and #%11100110
008094  2  AC 74 07                    ldy DisableScreenFlag     ;get screen disable flag
008097  2  D0 05                       bne ScreenOff             ;if set, used bits as-is
008099  2  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;otherwise reenable bits and save them
00809C  2  09 1E                       ora #%00011110
00809E  2  8D 79 07     ScreenOff:     sta Mirror_PPU_CTRL_REG2  ;save bits for later but not in register at the moment
0080A1  2  29 E7                       and #%11100111            ;disable screen for now
0080A3  2  8D 01 20                    sta PPU_CTRL_REG2
0080A6  2  AE 02 20                    ldx PPU_STATUS            ;reset flip-flop and reset scroll registers to zero
0080A9  2  A9 00                       lda #$00
0080AB  2  20 E6 8E                    jsr InitScroll
0080AE  2  8D 03 20                    sta PPU_SPR_ADDR          ;reset spr-ram address register
0080B1  2  A9 02                       lda #$02                  ;perform spr-ram DMA access on $0200-$02ff
0080B3  2  8D 14 40                    sta SPR_DMA
0080B6  2  AE 73 07                    ldx VRAM_Buffer_AddrCtrl  ;load control for pointer to buffer contents
0080B9  2  BD 5A 80                    lda VRAM_AddrTable_Low,x  ;set indirect at $00 to pointer
0080BC  2  85 00                       sta $00
0080BE  2  BD 6D 80                    lda VRAM_AddrTable_High,x
0080C1  2  85 01                       sta $01
0080C3  2  20 DD 8E                    jsr UpdateScreen          ;update screen with buffer contents
0080C6  2  A0 00                       ldy #$00
0080C8  2  AE 73 07                    ldx VRAM_Buffer_AddrCtrl  ;check for usage of $0341
0080CB  2  E0 06                       cpx #$06
0080CD  2  D0 01                       bne InitBuffer
0080CF  2  C8                          iny                       ;get offset based on usage
0080D0  2  BE 80 80     InitBuffer:    ldx VRAM_Buffer_Offset,y
0080D3  2  A9 00                       lda #$00                  ;clear buffer header at last location
0080D5  2  9D 00 03                    sta VRAM_Buffer1_Offset,x
0080D8  2  9D 01 03                    sta VRAM_Buffer1,x
0080DB  2  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;reinit address control to $0301
0080DE  2  AD 79 07                    lda Mirror_PPU_CTRL_REG2  ;copy mirror of $2001 to register
0080E1  2  8D 01 20                    sta PPU_CTRL_REG2
0080E4  2  20 D0 F2                    jsr SoundEngine           ;play sound
0080E7  2  20 5C 8E                    jsr ReadJoypads           ;read joypads
0080EA  2  20 82 81                    jsr PauseRoutine          ;handle pause
0080ED  2  20 97 8F                    jsr UpdateTopScore
0080F0  2  AD 76 07                    lda GamePauseStatus       ;check for pause status
0080F3  2  4A                          lsr
0080F4  2  B0 25                       bcs PauseSkip
0080F6  2  AD 47 07                    lda TimerControl          ;if master timer control not set, decrement
0080F9  2  F0 05                       beq DecTimers             ;all frame and interval timers
0080FB  2  CE 47 07                    dec TimerControl
0080FE  2  D0 19                       bne NoDecTimers
008100  2  A2 14        DecTimers:     ldx #$14                  ;load end offset for end of frame timers
008102  2  CE 7F 07                    dec IntervalTimerControl  ;decrement interval timer control,
008105  2  10 07                       bpl DecTimersLoop         ;if not expired, only frame timers will decrement
008107  2  A9 14                       lda #$14
008109  2  8D 7F 07                    sta IntervalTimerControl  ;if control for interval timers expired,
00810C  2  A2 23                       ldx #$23                  ;interval timers will decrement along with frame timers
00810E  2  BD 80 07     DecTimersLoop: lda Timers,x              ;check current timer
008111  2  F0 03                       beq SkipExpTimer          ;if current timer expired, branch to skip,
008113  2  DE 80 07                    dec Timers,x              ;otherwise decrement the current timer
008116  2  CA           SkipExpTimer:  dex                       ;move onto next timer
008117  2  10 F5                       bpl DecTimersLoop         ;do this until all timers are dealt with
008119  2  E6 09        NoDecTimers:   inc FrameCounter          ;increment frame counter
00811B  2  A2 00        PauseSkip:     ldx #$00
00811D  2  A0 07                       ldy #$07
00811F  2  AD A7 07                    lda PseudoRandomBitReg    ;get first memory location of LSFR bytes
008122  2  29 02                       and #%00000010            ;mask out all but d1
008124  2  85 00                       sta $00                   ;save here
008126  2  AD A8 07                    lda PseudoRandomBitReg+1  ;get second memory location
008129  2  29 02                       and #%00000010            ;mask out all but d1
00812B  2  45 00                       eor $00                   ;perform exclusive-OR on d1 from first and second bytes
00812D  2  18                          clc                       ;if neither or both are set, carry will be clear
00812E  2  F0 01                       beq RotPRandomBit
008130  2  38                          sec                       ;if one or the other is set, carry will be set
008131  2  7E A7 07     RotPRandomBit: ror PseudoRandomBitReg,x  ;rotate carry into d7, and rotate last bit into carry
008134  2  E8                          inx                       ;increment to next byte
008135  2  88                          dey                       ;decrement for loop
008136  2  D0 F9                       bne RotPRandomBit
008138  2  AD 22 07                    lda Sprite0HitDetectFlag  ;check for flag here
00813B  2  F0 1F                       beq SkipSprite0
00813D  2  AD 02 20     Sprite0Clr:    lda PPU_STATUS            ;wait for sprite 0 flag to clear, which will
008140  2  29 40                       and #%01000000            ;not happen until vblank has ended
008142  2  D0 F9                       bne Sprite0Clr
008144  2  AD 76 07                    lda GamePauseStatus       ;if in pause mode, do not bother with sprites at all
008147  2  4A                          lsr
008148  2  B0 06                       bcs Sprite0Hit
00814A  2  20 23 82                    jsr MoveSpritesOffscreen
00814D  2  20 C6 81                    jsr SpriteShuffler
008150  2  AD 02 20     Sprite0Hit:    lda PPU_STATUS            ;do sprite #0 hit detection
008153  2  29 40                       and #%01000000
008155  2  F0 F9                       beq Sprite0Hit
008157  2  A0 14                       ldy #$14                  ;small delay, to wait until we hit horizontal blank time
008159  2  88           HBlankDelay:   dey
00815A  2  D0 FD                       bne HBlankDelay
00815C  2  AD 3F 07     SkipSprite0:   lda HorizontalScroll      ;set scroll registers from variables
00815F  2  8D 05 20                    sta PPU_SCROLL_REG
008162  2  AD 40 07                    lda VerticalScroll
008165  2  8D 05 20                    sta PPU_SCROLL_REG
008168  2  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load saved mirror of $2000
00816B  2  48                          pha
00816C  2  8D 00 20                    sta PPU_CTRL_REG1
00816F  2  AD 76 07                    lda GamePauseStatus       ;if in pause mode, do not perform operation mode stuff
008172  2  4A                          lsr
008173  2  B0 03                       bcs SkipMainOper
008175  2  20 12 82                    jsr OperModeExecutionTree ;otherwise do one of many, many possible subroutines
008178  2  AD 02 20     SkipMainOper:  lda PPU_STATUS            ;reset flip-flop
00817B  2  68                          pla
00817C  2  09 80                       ora #%10000000            ;reactivate NMIs
00817E  2  8D 00 20                    sta PPU_CTRL_REG1
008181  2  40                          rti                       ;we are done until the next frame!
008182  2               
008182  2               ;-------------------------------------------------------------------------------------
008182  2               
008182  2               PauseRoutine:
008182  2  AD 70 07                    lda OperMode           ;are we in victory mode?
008185  2  C9 02                       cmp #VictoryModeValue  ;if so, go ahead
008187  2  F0 0B                       beq ChkPauseTimer
008189  2  C9 01                       cmp #GameModeValue     ;are we in game mode?
00818B  2  D0 38                       bne ExitPause          ;if not, leave
00818D  2  AD 72 07                    lda OperMode_Task      ;if we are in game mode, are we running game engine?
008190  2  C9 03                       cmp #$03
008192  2  D0 31                       bne ExitPause          ;if not, leave
008194  2  AD 77 07     ChkPauseTimer: lda GamePauseTimer     ;check if pause timer is still counting down
008197  2  F0 04                       beq ChkStart
008199  2  CE 77 07                    dec GamePauseTimer     ;if so, decrement and leave
00819C  2  60                          rts
00819D  2  AD FC 06     ChkStart:      lda SavedJoypad1Bits   ;check to see if start is pressed
0081A0  2  29 10                       and #Start_Button      ;on controller 1
0081A2  2  F0 19                       beq ClrPauseTimer
0081A4  2  AD 76 07                    lda GamePauseStatus    ;check to see if timer flag is set
0081A7  2  29 80                       and #%10000000         ;and if so, do not reset timer (residual,
0081A9  2  D0 1A                       bne ExitPause          ;joypad reading routine makes this unnecessary)
0081AB  2  A9 2B                       lda #$2b               ;set pause timer
0081AD  2  8D 77 07                    sta GamePauseTimer
0081B0  2  AD 76 07                    lda GamePauseStatus
0081B3  2  A8                          tay
0081B4  2  C8                          iny                    ;set pause sfx queue for next pause mode
0081B5  2  84 FA                       sty PauseSoundQueue
0081B7  2  49 01                       eor #%00000001         ;invert d0 and set d7
0081B9  2  09 80                       ora #%10000000
0081BB  2  D0 05                       bne SetPause           ;unconditional branch
0081BD  2  AD 76 07     ClrPauseTimer: lda GamePauseStatus    ;clear timer flag if timer is at zero and start button
0081C0  2  29 7F                       and #%01111111         ;is not pressed
0081C2  2  8D 76 07     SetPause:      sta GamePauseStatus
0081C5  2  60           ExitPause:     rts
0081C6  2               
0081C6  2               ;-------------------------------------------------------------------------------------
0081C6  2               ;$00 - used for preset value
0081C6  2               
0081C6  2               SpriteShuffler:
0081C6  2  AC 4E 07                    ldy AreaType                ;load level type, likely residual code
0081C9  2  A9 28                       lda #$28                    ;load preset value which will put it at
0081CB  2  85 00                       sta $00                     ;sprite #10
0081CD  2  A2 0E                       ldx #$0e                    ;start at the end of OAM data offsets
0081CF  2  BD E4 06     ShuffleLoop:   lda SprDataOffset,x         ;check for offset value against
0081D2  2  C5 00                       cmp $00                     ;the preset value
0081D4  2  90 0F                       bcc NextSprOffset           ;if less, skip this part
0081D6  2  AC E0 06                    ldy SprShuffleAmtOffset     ;get current offset to preset value we want to add
0081D9  2  18                          clc
0081DA  2  79 E1 06                    adc SprShuffleAmt,y         ;get shuffle amount, add to current sprite offset
0081DD  2  90 03                       bcc StrSprOffset            ;if not exceeded $ff, skip second add
0081DF  2  18                          clc
0081E0  2  65 00                       adc $00                     ;otherwise add preset value $28 to offset
0081E2  2  9D E4 06     StrSprOffset:  sta SprDataOffset,x         ;store new offset here or old one if branched to here
0081E5  2  CA           NextSprOffset: dex                         ;move backwards to next one
0081E6  2  10 E7                       bpl ShuffleLoop
0081E8  2  AE E0 06                    ldx SprShuffleAmtOffset     ;load offset
0081EB  2  E8                          inx
0081EC  2  E0 03                       cpx #$03                    ;check if offset + 1 goes to 3
0081EE  2  D0 02                       bne SetAmtOffset            ;if offset + 1 not 3, store
0081F0  2  A2 00                       ldx #$00                    ;otherwise, init to 0
0081F2  2  8E E0 06     SetAmtOffset:  stx SprShuffleAmtOffset
0081F5  2  A2 08                       ldx #$08                    ;load offsets for values and storage
0081F7  2  A0 02                       ldy #$02
0081F9  2  B9 E9 06     SetMiscOffset: lda SprDataOffset+5,y       ;load one of three OAM data offsets
0081FC  2  9D F1 06                    sta Misc_SprDataOffset-2,x  ;store first one unmodified, but
0081FF  2  18                          clc                         ;add eight to the second and eight
008200  2  69 08                       adc #$08                    ;more to the third one
008202  2  9D F2 06                    sta Misc_SprDataOffset-1,x  ;note that due to the way X is set up,
008205  2  18                          clc                         ;this code loads into the misc sprite offsets
008206  2  69 08                       adc #$08
008208  2  9D F3 06                    sta Misc_SprDataOffset,x
00820B  2  CA                          dex
00820C  2  CA                          dex
00820D  2  CA                          dex
00820E  2  88                          dey
00820F  2  10 E8                       bpl SetMiscOffset           ;do this until all misc spr offsets are loaded
008211  2  60                          rts
008212  2               
008212  2               ;-------------------------------------------------------------------------------------
008212  2               
008212  2               OperModeExecutionTree:
008212  2  AD 70 07           lda OperMode     ;this is the heart of the entire program,
008215  2  20 04 8E           jsr JumpEngine   ;most of what goes on starts here
008218  2               
008218  2  31 82              .word TitleScreenMode
00821A  2  DC AE              .word GameMode
00821C  2  8B 83              .word VictoryMode
00821E  2  18 92              .word GameOverMode
008220  2               
008220  2               ;-------------------------------------------------------------------------------------
008220  2               
008220  2               MoveAllSpritesOffscreen:
008220  2  A0 00                      ldy #$00                ;this routine moves all sprites off the screen
008222  2  2C                         .byte $2c                 ;BIT instruction opcode
008223  2               
008223  2               MoveSpritesOffscreen:
008223  2  A0 04                      ldy #$04                ;this routine moves all but sprite 0
008225  2  A9 F8                      lda #$f8                ;off the screen
008227  2  99 00 02     SprInitLoop:  sta Sprite_Y_Position,y ;write 248 into OAM data's Y coordinate
00822A  2  C8                         iny                     ;which will move it off the screen
00822B  2  C8                         iny
00822C  2  C8                         iny
00822D  2  C8                         iny
00822E  2  D0 F7                      bne SprInitLoop
008230  2  60                         rts
008231  2               
008231  2               ;-------------------------------------------------------------------------------------
008231  2               
008231  2               TitleScreenMode:
008231  2  AD 72 07           lda OperMode_Task
008234  2  20 04 8E           jsr JumpEngine
008237  2               
008237  2  CF 8F              .word InitializeGame
008239  2  67 85              .word ScreenRoutines
00823B  2  61 90              .word PrimaryGameSetup
00823D  2  45 82              .word GameMenuRoutine
00823F  2               
00823F  2               ;-------------------------------------------------------------------------------------
00823F  2               
00823F  2               WSelectBufferTemplate:
00823F  2  04 20 73 01        .byte $04, $20, $73, $01, $00, $00
008243  2  00 00        
008245  2               
008245  2               GameMenuRoutine:
008245  2  A0 00                      ldy #$00
008247  2  AD FC 06                   lda SavedJoypad1Bits        ;check to see if either player pressed
00824A  2  0D FD 06                   ora SavedJoypad2Bits        ;only the start button (either joypad)
00824D  2  C9 10                      cmp #Start_Button
00824F  2  F0 04                      beq StartGame
008251  2  C9 90                      cmp #A_Button+Start_Button  ;check to see if A + start was pressed
008253  2  D0 03                      bne ChkSelect               ;if not, branch to check select button
008255  2  4C D8 82     StartGame:    jmp ChkContinue             ;if either start or A + start, execute here
008258  2  C9 20        ChkSelect:    cmp #Select_Button          ;check to see if the select button was pressed
00825A  2  F0 1A                      beq SelectBLogic            ;if so, branch reset demo timer
00825C  2  AE A2 07                   ldx DemoTimer               ;otherwise check demo timer
00825F  2  D0 0B                      bne ChkWorldSel             ;if demo timer not expired, branch to check world selection
008261  2  8D 80 07                   sta SelectTimer             ;set controller bits here if running demo
008264  2  20 6B 83                   jsr DemoEngine              ;run through the demo actions
008267  2  B0 60                      bcs ResetTitle              ;if carry flag set, demo over, thus branch
008269  2  4C C0 82                   jmp RunDemo                 ;otherwise, run game engine for demo
00826C  2  AE FC 07     ChkWorldSel:  ldx WorldSelectEnableFlag   ;check to see if world selection has been enabled
00826F  2  F0 4A                      beq NullJoypad
008271  2  C9 40                      cmp #B_Button               ;if so, check to see if the B button was pressed
008273  2  D0 46                      bne NullJoypad
008275  2  C8                         iny                         ;if so, increment Y and execute same code as select
008276  2  AD A2 07     SelectBLogic: lda DemoTimer               ;if select or B pressed, check demo timer one last time
008279  2  F0 4E                      beq ResetTitle              ;if demo timer expired, branch to reset title screen mode
00827B  2  A9 18                      lda #$18                    ;otherwise reset demo timer
00827D  2  8D A2 07                   sta DemoTimer
008280  2  AD 80 07                   lda SelectTimer             ;check select/B button timer
008283  2  D0 36                      bne NullJoypad              ;if not expired, branch
008285  2  A9 10                      lda #$10                    ;otherwise reset select button timer
008287  2  8D 80 07                   sta SelectTimer
00828A  2  C0 01                      cpy #$01                    ;was the B button pressed earlier?  if so, branch
00828C  2  F0 0E                      beq IncWorldSel             ;note this will not be run if world selection is disabled
00828E  2  AD 7A 07                   lda NumberOfPlayers         ;if no, must have been the select button, therefore
008291  2  49 01                      eor #%00000001              ;change number of players and draw icon accordingly
008293  2  8D 7A 07                   sta NumberOfPlayers
008296  2  20 25 83                   jsr DrawMushroomIcon
008299  2  4C BB 82                   jmp NullJoypad
00829C  2  AE 6B 07     IncWorldSel:  ldx WorldSelectNumber       ;increment world select number
00829F  2  E8                         inx
0082A0  2  8A                         txa
0082A1  2  29 07                      and #%00000111              ;mask out higher bits
0082A3  2  8D 6B 07                   sta WorldSelectNumber       ;store as current world select number
0082A6  2  20 0E 83                   jsr GoContinue
0082A9  2  BD 3F 82     UpdateShroom: lda WSelectBufferTemplate,x ;write template for world select in vram buffer
0082AC  2  9D 00 03                   sta VRAM_Buffer1-1,x        ;do this until all bytes are written
0082AF  2  E8                         inx
0082B0  2  E0 06                      cpx #$06
0082B2  2  30 F5                      bmi UpdateShroom
0082B4  2  AC 5F 07                   ldy WorldNumber             ;get world number from variable and increment for
0082B7  2  C8                         iny                         ;proper display, and put in blank byte before
0082B8  2  8C 04 03                   sty VRAM_Buffer1+3          ;null terminator
0082BB  2  A9 00        NullJoypad:   lda #$00                    ;clear joypad bits for player 1
0082BD  2  8D FC 06                   sta SavedJoypad1Bits
0082C0  2  20 EA AE     RunDemo:      jsr GameCoreRoutine         ;run game engine
0082C3  2  A5 0E                      lda GameEngineSubroutine    ;check to see if we're running lose life routine
0082C5  2  C9 06                      cmp #$06
0082C7  2  D0 44                      bne ExitMenu                ;if not, do not do all the resetting below
0082C9  2  A9 00        ResetTitle:   lda #$00                    ;reset game modes, disable
0082CB  2  8D 70 07                   sta OperMode                ;sprite 0 check and disable
0082CE  2  8D 72 07                   sta OperMode_Task           ;screen output
0082D1  2  8D 22 07                   sta Sprite0HitDetectFlag
0082D4  2  EE 74 07                   inc DisableScreenFlag
0082D7  2  60                         rts
0082D8  2  AC A2 07     ChkContinue:  ldy DemoTimer               ;if timer for demo has expired, reset modes
0082DB  2  F0 EC                      beq ResetTitle
0082DD  2  0A                         asl                         ;check to see if A button was also pushed
0082DE  2  90 06                      bcc StartWorld1             ;if not, don't load continue function's world number
0082E0  2  AD FD 07                   lda ContinueWorld           ;load previously saved world number for secret
0082E3  2  20 0E 83                   jsr GoContinue              ;continue function when pressing A + start
0082E6  2  20 03 9C     StartWorld1:  jsr LoadAreaPointer
0082E9  2  EE 5D 07                   inc Hidden1UpFlag           ;set 1-up box flag for both players
0082EC  2  EE 64 07                   inc OffScr_Hidden1UpFlag
0082EF  2  EE 57 07                   inc FetchNewGameTimerFlag   ;set fetch new game timer flag
0082F2  2  EE 70 07                   inc OperMode                ;set next game mode
0082F5  2  AD FC 07                   lda WorldSelectEnableFlag   ;if world select flag is on, then primary
0082F8  2  8D 6A 07                   sta PrimaryHardMode         ;hard mode must be on as well
0082FB  2  A9 00                      lda #$00
0082FD  2  8D 72 07                   sta OperMode_Task           ;set game mode here, and clear demo timer
008300  2  8D A2 07                   sta DemoTimer
008303  2  A2 17                      ldx #$17
008305  2  A9 00                      lda #$00
008307  2  9D DD 07     InitScores:   sta ScoreAndCoinDisplay,x   ;clear player scores and coin displays
00830A  2  CA                         dex
00830B  2  10 FA                      bpl InitScores
00830D  2  60           ExitMenu:     rts
00830E  2  8D 5F 07     GoContinue:   sta WorldNumber             ;start both players at the first area
008311  2  8D 66 07                   sta OffScr_WorldNumber      ;of the previously saved world number
008314  2  A2 00                      ldx #$00                    ;note that on power-up using this function
008316  2  8E 60 07                   stx AreaNumber              ;will make no difference
008319  2  8E 67 07                   stx OffScr_AreaNumber
00831C  2  60                         rts
00831D  2               
00831D  2               ;-------------------------------------------------------------------------------------
00831D  2               
00831D  2               MushroomIconData:
00831D  2  07 22 49 83        .byte $07, $22, $49, $83, $ce, $24, $24, $00
008321  2  CE 24 24 00  
008325  2               
008325  2               DrawMushroomIcon:
008325  2  A0 07                      ldy #$07                ;read eight bytes to be read by transfer routine
008327  2  B9 1D 83     IconDataRead: lda MushroomIconData,y  ;note that the default position is set for a
00832A  2  99 00 03                   sta VRAM_Buffer1-1,y    ;1-player game
00832D  2  88                         dey
00832E  2  10 F7                      bpl IconDataRead
008330  2  AD 7A 07                   lda NumberOfPlayers     ;check number of players
008333  2  F0 0A                      beq ExitIcon            ;if set to 1-player game, we're done
008335  2  A9 24                      lda #$24                ;otherwise, load blank tile in 1-player position
008337  2  8D 04 03                   sta VRAM_Buffer1+3
00833A  2  A9 CE                      lda #$ce                ;then load shroom icon tile in 2-player position
00833C  2  8D 06 03                   sta VRAM_Buffer1+5
00833F  2  60           ExitIcon:     rts
008340  2               
008340  2               ;-------------------------------------------------------------------------------------
008340  2               
008340  2               DemoActionData:
008340  2  01 80 02 81        .byte $01, $80, $02, $81, $41, $80, $01
008344  2  41 80 01     
008347  2  42 C2 02 80        .byte $42, $c2, $02, $80, $41, $c1, $41, $c1
00834B  2  41 C1 41 C1  
00834F  2  01 C1 01 02        .byte $01, $c1, $01, $02, $80, $00
008353  2  80 00        
008355  2               
008355  2               DemoTimingData:
008355  2  9B 10 18 05        .byte $9b, $10, $18, $05, $2c, $20, $24
008359  2  2C 20 24     
00835C  2  15 5A 10 20        .byte $15, $5a, $10, $20, $28, $30, $20, $10
008360  2  28 30 20 10  
008364  2  80 20 30 30        .byte $80, $20, $30, $30, $01, $ff, $00
008368  2  01 FF 00     
00836B  2               
00836B  2               DemoEngine:
00836B  2  AE 17 07               ldx DemoAction         ;load current demo action
00836E  2  AD 18 07               lda DemoActionTimer    ;load current action timer
008371  2  D0 0D                  bne DoAction           ;if timer still counting down, skip
008373  2  E8                     inx
008374  2  EE 17 07               inc DemoAction         ;if expired, increment action, X, and
008377  2  38                     sec                    ;set carry by default for demo over
008378  2  BD 54 83               lda DemoTimingData-1,x ;get next timer
00837B  2  8D 18 07               sta DemoActionTimer    ;store as current timer
00837E  2  F0 0A                  beq DemoOver           ;if timer already at zero, skip
008380  2  BD 3F 83     DoAction: lda DemoActionData-1,x ;get and perform action (current or next)
008383  2  8D FC 06               sta SavedJoypad1Bits
008386  2  CE 18 07               dec DemoActionTimer    ;decrement action timer
008389  2  18                     clc                    ;clear carry if demo still going
00838A  2  60           DemoOver: rts
00838B  2               
00838B  2               ;-------------------------------------------------------------------------------------
00838B  2               
00838B  2               VictoryMode:
00838B  2  20 A0 83                 jsr VictoryModeSubroutines  ;run victory mode subroutines
00838E  2  AD 72 07                 lda OperMode_Task           ;get current task of victory mode
008391  2  F0 07                    beq AutoPlayer              ;if on bridge collapse, skip enemy processing
008393  2  A2 00                    ldx #$00
008395  2  86 08                    stx ObjectOffset            ;otherwise reset enemy object offset
008397  2  20 47 C0                 jsr EnemiesAndLoopsCore     ;and run enemy code
00839A  2  20 2A F1     AutoPlayer: jsr RelativePlayerPosition  ;get player's relative coordinates
00839D  2  4C E9 EE                 jmp PlayerGfxHandler        ;draw the player, then leave
0083A0  2               
0083A0  2               VictoryModeSubroutines:
0083A0  2  AD 72 07           lda OperMode_Task
0083A3  2  20 04 8E           jsr JumpEngine
0083A6  2               
0083A6  2  EC CF              .word BridgeCollapse
0083A8  2  B0 83              .word SetupVictoryMode
0083AA  2  BD 83              .word PlayerVictoryWalk
0083AC  2  F6 83              .word PrintVictoryMessages
0083AE  2  61 84              .word PlayerEndWorld
0083B0  2               
0083B0  2               ;-------------------------------------------------------------------------------------
0083B0  2               
0083B0  2               SetupVictoryMode:
0083B0  2  AE 1B 07           ldx ScreenRight_PageLoc  ;get page location of right side of screen
0083B3  2  E8                 inx                      ;increment to next page
0083B4  2  86 34              stx DestinationPageLoc   ;store here
0083B6  2  A9 08              lda #EndOfCastleMusic
0083B8  2  85 FC              sta EventMusicQueue      ;play win castle music
0083BA  2  4C 4E 87           jmp IncModeTask_B        ;jump to set next major task in victory mode
0083BD  2               
0083BD  2               ;-------------------------------------------------------------------------------------
0083BD  2               
0083BD  2               PlayerVictoryWalk:
0083BD  2  A0 00                     ldy #$00                ;set value here to not walk player by default
0083BF  2  84 35                     sty VictoryWalkControl
0083C1  2  A5 6D                     lda Player_PageLoc      ;get player's page location
0083C3  2  C5 34                     cmp DestinationPageLoc  ;compare with destination page location
0083C5  2  D0 06                     bne PerformWalk         ;if page locations don't match, branch
0083C7  2  A5 86                     lda Player_X_Position   ;otherwise get player's horizontal position
0083C9  2  C9 60                     cmp #$60                ;compare with preset horizontal position
0083CB  2  B0 03                     bcs DontWalk            ;if still on other page, branch ahead
0083CD  2  E6 35        PerformWalk: inc VictoryWalkControl  ;otherwise increment value and Y
0083CF  2  C8                        iny                     ;note Y will be used to walk the player
0083D0  2  98           DontWalk:    tya                     ;put contents of Y in A and
0083D1  2  20 E6 B0                  jsr AutoControlPlayer   ;use A to move player to the right or not
0083D4  2  AD 1A 07                  lda ScreenLeft_PageLoc  ;check page location of left side of screen
0083D7  2  C5 34                     cmp DestinationPageLoc  ;against set value here
0083D9  2  F0 16                     beq ExitVWalk           ;branch if equal to change modes if necessary
0083DB  2  AD 68 07                  lda ScrollFractional
0083DE  2  18                        clc                     ;do fixed point math on fractional part of scroll
0083DF  2  69 80                     adc #$80
0083E1  2  8D 68 07                  sta ScrollFractional    ;save fractional movement amount
0083E4  2  A9 01                     lda #$01                ;set 1 pixel per frame
0083E6  2  69 00                     adc #$00                ;add carry from previous addition
0083E8  2  A8                        tay                     ;use as scroll amount
0083E9  2  20 C4 AF                  jsr ScrollScreen        ;do sub to scroll the screen
0083EC  2  20 6F AF                  jsr UpdScrollVar        ;do another sub to update screen and scroll variables
0083EF  2  E6 35                     inc VictoryWalkControl  ;increment value to stay in this routine
0083F1  2  A5 35        ExitVWalk:   lda VictoryWalkControl  ;load value set here
0083F3  2  F0 68                     beq IncModeTask_A       ;if zero, branch to change modes
0083F5  2  60                        rts                     ;otherwise leave
0083F6  2               
0083F6  2               ;-------------------------------------------------------------------------------------
0083F6  2               
0083F6  2               PrintVictoryMessages:
0083F6  2  AD 49 07                    lda SecondaryMsgCounter   ;load secondary message counter
0083F9  2  D0 48                       bne IncMsgCounter         ;if set, branch to increment message counters
0083FB  2  AD 19 07                    lda PrimaryMsgCounter     ;otherwise load primary message counter
0083FE  2  F0 18                       beq ThankPlayer           ;if set to zero, branch to print first message
008400  2  C9 09                       cmp #$09                  ;if at 9 or above, branch elsewhere (this comparison
008402  2  B0 3F                       bcs IncMsgCounter         ;is residual code, counter never reaches 9)
008404  2  AC 5F 07                    ldy WorldNumber           ;check world number
008407  2  C0 07                       cpy #World8
008409  2  D0 09                       bne MRetainerMsg          ;if not at world 8, skip to next part
00840B  2  C9 03                       cmp #$03                  ;check primary message counter again
00840D  2  90 34                       bcc IncMsgCounter         ;if not at 3 yet (world 8 only), branch to increment
00840F  2  E9 01                       sbc #$01                  ;otherwise subtract one
008411  2  4C 18 84                    jmp ThankPlayer           ;and skip to next part
008414  2  C9 02        MRetainerMsg:  cmp #$02                  ;check primary message counter
008416  2  90 2B                       bcc IncMsgCounter         ;if not at 2 yet (world 1-7 only), branch
008418  2  A8           ThankPlayer:   tay                       ;put primary message counter into Y
008419  2  D0 08                       bne SecondPartMsg         ;if counter nonzero, skip this part, do not print first message
00841B  2  AD 53 07                    lda CurrentPlayer         ;otherwise get player currently on the screen
00841E  2  F0 14                       beq EvalForMusic          ;if mario, branch
008420  2  C8                          iny                       ;otherwise increment Y once for luigi and
008421  2  D0 11                       bne EvalForMusic          ;do an unconditional branch to the same place
008423  2  C8           SecondPartMsg: iny                       ;increment Y to do world 8's message
008424  2  AD 5F 07                    lda WorldNumber
008427  2  C9 07                       cmp #World8               ;check world number
008429  2  F0 09                       beq EvalForMusic          ;if at world 8, branch to next part
00842B  2  88                          dey                       ;otherwise decrement Y for world 1-7's message
00842C  2  C0 04                       cpy #$04                  ;if counter at 4 (world 1-7 only)
00842E  2  B0 26                       bcs SetEndTimer           ;branch to set victory end timer
008430  2  C0 03                       cpy #$03                  ;if counter at 3 (world 1-7 only)
008432  2  B0 0F                       bcs IncMsgCounter         ;branch to keep counting
008434  2  C0 03        EvalForMusic:  cpy #$03                  ;if counter not yet at 3 (world 8 only), branch
008436  2  D0 04                       bne PrintMsg              ;to print message only (note world 1-7 will only
008438  2  A9 04                       lda #VictoryMusic         ;reach this code if counter = 0, and will always branch)
00843A  2  85 FC                       sta EventMusicQueue       ;otherwise load victory music first (world 8 only)
00843C  2  98           PrintMsg:      tya                       ;put primary message counter in A
00843D  2  18                          clc                       ;add $0c or 12 to counter thus giving an appropriate value,
00843E  2  69 0C                       adc #$0c                  ;($0c-$0d = first), ($0e = world 1-7's), ($0f-$12 = world 8's)
008440  2  8D 73 07                    sta VRAM_Buffer_AddrCtrl  ;write message counter to vram address controller
008443  2  AD 49 07     IncMsgCounter: lda SecondaryMsgCounter
008446  2  18                          clc
008447  2  69 04                       adc #$04                      ;add four to secondary message counter
008449  2  8D 49 07                    sta SecondaryMsgCounter
00844C  2  AD 19 07                    lda PrimaryMsgCounter
00844F  2  69 00                       adc #$00                      ;add carry to primary message counter
008451  2  8D 19 07                    sta PrimaryMsgCounter
008454  2  C9 07                       cmp #$07                      ;check primary counter one more time
008456  2  90 08        SetEndTimer:   bcc ExitMsgs                  ;if not reached value yet, branch to leave
008458  2  A9 06                       lda #$06
00845A  2  8D A1 07                    sta WorldEndTimer             ;otherwise set world end timer
00845D  2  EE 72 07     IncModeTask_A: inc OperMode_Task             ;move onto next task in mode
008460  2  60           ExitMsgs:      rts                           ;leave
008461  2               
008461  2               ;-------------------------------------------------------------------------------------
008461  2               
008461  2               PlayerEndWorld:
008461  2  AD A1 07                    lda WorldEndTimer          ;check to see if world end timer expired
008464  2  D0 20                       bne EndExitOne             ;branch to leave if not
008466  2  AC 5F 07                    ldy WorldNumber            ;check world number
008469  2  C0 07                       cpy #World8                ;if on world 8, player is done with game,
00846B  2  B0 1A                       bcs EndChkBButton          ;thus branch to read controller
00846D  2  A9 00                       lda #$00
00846F  2  8D 60 07                    sta AreaNumber             ;otherwise initialize area number used as offset
008472  2  8D 5C 07                    sta LevelNumber            ;and level number control to start at area 1
008475  2  8D 72 07                    sta OperMode_Task          ;initialize secondary mode of operation
008478  2  EE 5F 07                    inc WorldNumber            ;increment world number to move onto the next world
00847B  2  20 03 9C                    jsr LoadAreaPointer        ;get area address offset for the next area
00847E  2  EE 57 07                    inc FetchNewGameTimerFlag  ;set flag to load game timer from header
008481  2  A9 01                       lda #GameModeValue
008483  2  8D 70 07                    sta OperMode               ;set mode of operation to game mode
008486  2  60           EndExitOne:    rts                        ;and leave
008487  2  AD FC 06     EndChkBButton: lda SavedJoypad1Bits
00848A  2  0D FD 06                    ora SavedJoypad2Bits       ;check to see if B button was pressed on
00848D  2  29 40                       and #B_Button              ;either controller
00848F  2  F0 0D                       beq EndExitTwo             ;branch to leave if not
008491  2  A9 01                       lda #$01                   ;otherwise set world selection flag
008493  2  8D FC 07                    sta WorldSelectEnableFlag
008496  2  A9 FF                       lda #$ff                   ;remove onscreen player's lives
008498  2  8D 5A 07                    sta NumberofLives
00849B  2  20 48 92                    jsr TerminateGame          ;do sub to continue other player or end game
00849E  2  60           EndExitTwo:    rts                        ;leave
00849F  2               
00849F  2               ;-------------------------------------------------------------------------------------
00849F  2               
00849F  2               ;data is used as tiles for numbers
00849F  2               ;that appear when you defeat enemies
00849F  2               FloateyNumTileData:
00849F  2  FF FF              .byte $ff, $ff ;dummy
0084A1  2  F6 FB              .byte $f6, $fb ; "100"
0084A3  2  F7 FB              .byte $f7, $fb ; "200"
0084A5  2  F8 FB              .byte $f8, $fb ; "400"
0084A7  2  F9 FB              .byte $f9, $fb ; "500"
0084A9  2  FA FB              .byte $fa, $fb ; "800"
0084AB  2  F6 50              .byte $f6, $50 ; "1000"
0084AD  2  F7 50              .byte $f7, $50 ; "2000"
0084AF  2  F8 50              .byte $f8, $50 ; "4000"
0084B1  2  F9 50              .byte $f9, $50 ; "5000"
0084B3  2  FA 50              .byte $fa, $50 ; "8000"
0084B5  2  FD FE              .byte $fd, $fe ; "1-UP"
0084B7  2               
0084B7  2               ;high nybble is digit number, low nybble is number to
0084B7  2               ;add to the digit of the player's score
0084B7  2               ScoreUpdateData:
0084B7  2  FF                 .byte $ff ;dummy
0084B8  2  41 42 44 45        .byte $41, $42, $44, $45, $48
0084BC  2  48           
0084BD  2  31 32 34 35        .byte $31, $32, $34, $35, $38, $00
0084C1  2  38 00        
0084C3  2               
0084C3  2               FloateyNumbersRoutine:
0084C3  2  BD 10 01                   lda FloateyNum_Control,x     ;load control for floatey number
0084C6  2  F0 BE                      beq EndExitOne               ;if zero, branch to leave
0084C8  2  C9 0B                      cmp #$0b                     ;if less than $0b, branch
0084CA  2  90 05                      bcc ChkNumTimer
0084CC  2  A9 0B                      lda #$0b                     ;otherwise set to $0b, thus keeping
0084CE  2  9D 10 01                   sta FloateyNum_Control,x     ;it in range
0084D1  2  A8           ChkNumTimer:  tay                          ;use as Y
0084D2  2  BD 2C 01                   lda FloateyNum_Timer,x       ;check value here
0084D5  2  D0 04                      bne DecNumTimer              ;if nonzero, branch ahead
0084D7  2  9D 10 01                   sta FloateyNum_Control,x     ;initialize floatey number control and leave
0084DA  2  60                         rts
0084DB  2  DE 2C 01     DecNumTimer:  dec FloateyNum_Timer,x       ;decrement value here
0084DE  2  C9 2B                      cmp #$2b                     ;if not reached a certain point, branch
0084E0  2  D0 1E                      bne ChkTallEnemy
0084E2  2  C0 0B                      cpy #$0b                     ;check offset for $0b
0084E4  2  D0 07                      bne LoadNumTiles             ;branch ahead if not found
0084E6  2  EE 5A 07                   inc NumberofLives            ;give player one extra life (1-up)
0084E9  2  A9 40                      lda #Sfx_ExtraLife
0084EB  2  85 FE                      sta Square2SoundQueue        ;and play the 1-up sound
0084ED  2  B9 B7 84     LoadNumTiles: lda ScoreUpdateData,y        ;load point value here
0084F0  2  4A                         lsr                          ;move high nybble to low
0084F1  2  4A                         lsr
0084F2  2  4A                         lsr
0084F3  2  4A                         lsr
0084F4  2  AA                         tax                          ;use as X offset, essentially the digit
0084F5  2  B9 B7 84                   lda ScoreUpdateData,y        ;load again and this time
0084F8  2  29 0F                      and #%00001111               ;mask out the high nybble
0084FA  2  9D 34 01                   sta DigitModifier,x          ;store as amount to add to the digit
0084FD  2  20 27 BC                   jsr AddToScore               ;update the score accordingly
008500  2  BC E5 06     ChkTallEnemy: ldy Enemy_SprDataOffset,x    ;get OAM data offset for enemy object
008503  2  B5 16                      lda Enemy_ID,x               ;get enemy object identifier
008505  2  C9 12                      cmp #Spiny
008507  2  F0 22                      beq FloateyPart              ;branch if spiny
008509  2  C9 0D                      cmp #PiranhaPlant
00850B  2  F0 1E                      beq FloateyPart              ;branch if piranha plant
00850D  2  C9 05                      cmp #HammerBro
00850F  2  F0 12                      beq GetAltOffset             ;branch elsewhere if hammer bro
008511  2  C9 0A                      cmp #GreyCheepCheep
008513  2  F0 16                      beq FloateyPart              ;branch if cheep-cheep of either color
008515  2  C9 0B                      cmp #RedCheepCheep
008517  2  F0 12                      beq FloateyPart
008519  2  C9 09                      cmp #TallEnemy
00851B  2  B0 06                      bcs GetAltOffset             ;branch elsewhere if enemy object => $09
00851D  2  B5 1E                      lda Enemy_State,x
00851F  2  C9 02                      cmp #$02                     ;if enemy state defeated or otherwise
008521  2  B0 08                      bcs FloateyPart              ;$02 or greater, branch beyond this part
008523  2  AE EE 03     GetAltOffset: ldx SprDataOffset_Ctrl       ;load some kind of control bit
008526  2  BC EC 06                   ldy Alt_SprDataOffset,x      ;get alternate OAM data offset
008529  2  A6 08                      ldx ObjectOffset             ;get enemy object offset again
00852B  2  BD 1E 01     FloateyPart:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate for
00852E  2  C9 18                      cmp #$18                     ;floatey number, if coordinate in the
008530  2  90 05                      bcc SetupNumSpr              ;status bar, branch
008532  2  E9 01                      sbc #$01
008534  2  9D 1E 01                   sta FloateyNum_Y_Pos,x       ;otherwise subtract one and store as new
008537  2  BD 1E 01     SetupNumSpr:  lda FloateyNum_Y_Pos,x       ;get vertical coordinate
00853A  2  E9 08                      sbc #$08                     ;subtract eight and dump into the
00853C  2  20 C1 E5                   jsr DumpTwoSpr               ;left and right sprite's Y coordinates
00853F  2  BD 17 01                   lda FloateyNum_X_Pos,x       ;get horizontal coordinate
008542  2  99 03 02                   sta Sprite_X_Position,y      ;store into X coordinate of left sprite
008545  2  18                         clc
008546  2  69 08                      adc #$08                     ;add eight pixels and store into X
008548  2  99 07 02                   sta Sprite_X_Position+4,y    ;coordinate of right sprite
00854B  2  A9 02                      lda #$02
00854D  2  99 02 02                   sta Sprite_Attributes,y      ;set palette control in attribute bytes
008550  2  99 06 02                   sta Sprite_Attributes+4,y    ;of left and right sprites
008553  2  BD 10 01                   lda FloateyNum_Control,x
008556  2  0A                         asl                          ;multiply our floatey number control by 2
008557  2  AA                         tax                          ;and use as offset for look-up table
008558  2  BD 9F 84                   lda FloateyNumTileData,x
00855B  2  99 01 02                   sta Sprite_Tilenumber,y      ;display first half of number of points
00855E  2  BD A0 84                   lda FloateyNumTileData+1,x
008561  2  99 05 02                   sta Sprite_Tilenumber+4,y    ;display the second half
008564  2  A6 08                      ldx ObjectOffset             ;get enemy object offset and leave
008566  2  60                         rts
008567  2               
008567  2               ;-------------------------------------------------------------------------------------
008567  2               
008567  2               ScreenRoutines:
008567  2  AD 3C 07           lda ScreenRoutineTask        ;run one of the following subroutines
00856A  2  20 04 8E           jsr JumpEngine
00856D  2               
00856D  2  8B 85              .word InitScreen
00856F  2  9B 85              .word SetupIntermediate
008571  2  52 86              .word WriteTopStatusLine
008573  2  5A 86              .word WriteBottomStatusLine
008575  2  93 86              .word DisplayTimeUp
008577  2  9D 88              .word ResetSpritesAndScreenTimer
008579  2  A8 86              .word DisplayIntermediate
00857B  2  9D 88              .word ResetSpritesAndScreenTimer
00857D  2  E6 86              .word AreaParserTaskControl
00857F  2  BF 85              .word GetAreaPalette
008581  2  E3 85              .word GetBackgroundColor
008583  2  43 86              .word GetAlternatePalette1
008585  2  FF 86              .word DrawTitleScreen
008587  2  32 87              .word ClearBuffersDrawIcon
008589  2  49 87              .word WriteTopScore
00858B  2               
00858B  2               ;-------------------------------------------------------------------------------------
00858B  2               
00858B  2               InitScreen:
00858B  2  20 20 82           jsr MoveAllSpritesOffscreen ;initialize all sprites including sprite #0
00858E  2  20 19 8E           jsr InitializeNameTables    ;and erase both name and attribute tables
008591  2  AD 70 07           lda OperMode
008594  2  F0 32              beq NextSubtask             ;if mode still 0, do not load
008596  2  A2 03              ldx #$03                    ;into buffer pointer
008598  2  4C C5 85           jmp SetVRAMAddr_A
00859B  2               
00859B  2               ;-------------------------------------------------------------------------------------
00859B  2               
00859B  2               SetupIntermediate:
00859B  2  AD 44 07           lda BackgroundColorCtrl  ;save current background color control
00859E  2  48                 pha                      ;and player status to stack
00859F  2  AD 56 07           lda PlayerStatus
0085A2  2  48                 pha
0085A3  2  A9 00              lda #$00                 ;set background color to black
0085A5  2  8D 56 07           sta PlayerStatus         ;and player status to not fiery
0085A8  2  A9 02              lda #$02                 ;this is the ONLY time background color control
0085AA  2  8D 44 07           sta BackgroundColorCtrl  ;is set to less than 4
0085AD  2  20 F1 85           jsr GetPlayerColors
0085B0  2  68                 pla                      ;we only execute this routine for
0085B1  2  8D 56 07           sta PlayerStatus         ;the intermediate lives display
0085B4  2  68                 pla                      ;and once we're done, we return bg
0085B5  2  8D 44 07           sta BackgroundColorCtrl  ;color ctrl and player status from stack
0085B8  2  4C 45 87           jmp IncSubtask           ;then move onto the next task
0085BB  2               
0085BB  2               ;-------------------------------------------------------------------------------------
0085BB  2               
0085BB  2               AreaPalette:
0085BB  2  01 02 03 04        .byte $01, $02, $03, $04
0085BF  2               
0085BF  2               GetAreaPalette:
0085BF  2  AC 4E 07                    ldy AreaType             ;select appropriate palette to load
0085C2  2  BE BB 85                    ldx AreaPalette,y        ;based on area type
0085C5  2  8E 73 07     SetVRAMAddr_A: stx VRAM_Buffer_AddrCtrl ;store offset into buffer control
0085C8  2  4C 45 87     NextSubtask:   jmp IncSubtask           ;move onto next task
0085CB  2               
0085CB  2               ;-------------------------------------------------------------------------------------
0085CB  2               ;$00 - used as temp counter in GetPlayerColors
0085CB  2               
0085CB  2               BGColorCtrl_Addr:
0085CB  2  00 09 0A 04        .byte $00, $09, $0a, $04
0085CF  2               
0085CF  2               BackgroundColors:
0085CF  2  22 22 0F 0F        .byte $22, $22, $0f, $0f ;used by area type if bg color ctrl not set
0085D3  2  0F 22 0F 0F        .byte $0f, $22, $0f, $0f ;used by background color control if set
0085D7  2               
0085D7  2               PlayerColors:
0085D7  2  22 16 27 18        .byte $22, $16, $27, $18 ;mario's colors
0085DB  2  22 30 27 19        .byte $22, $30, $27, $19 ;luigi's colors
0085DF  2  22 37 27 16        .byte $22, $37, $27, $16 ;fiery (used by both)
0085E3  2               
0085E3  2               GetBackgroundColor:
0085E3  2  AC 44 07                ldy BackgroundColorCtrl   ;check background color control
0085E6  2  F0 06                   beq NoBGColor             ;if not set, increment task and fetch palette
0085E8  2  B9 C7 85                lda BGColorCtrl_Addr-4,y  ;put appropriate palette into vram
0085EB  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;note that if set to 5-7, $0301 will not be read
0085EE  2  EE 3C 07     NoBGColor: inc ScreenRoutineTask     ;increment to next subtask and plod on through
0085F1  2               
0085F1  2               GetPlayerColors:
0085F1  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;get current buffer offset
0085F4  2  A0 00                       ldy #$00
0085F6  2  AD 53 07                    lda CurrentPlayer        ;check which player is on the screen
0085F9  2  F0 02                       beq ChkFiery
0085FB  2  A0 04                       ldy #$04                 ;load offset for luigi
0085FD  2  AD 56 07     ChkFiery:      lda PlayerStatus         ;check player status
008600  2  C9 02                       cmp #$02
008602  2  D0 02                       bne StartClrGet          ;if fiery, load alternate offset for fiery player
008604  2  A0 08                       ldy #$08
008606  2  A9 03        StartClrGet:   lda #$03                 ;do four colors
008608  2  85 00                       sta $00
00860A  2  B9 D7 85     ClrGetLoop:    lda PlayerColors,y       ;fetch player colors and store them
00860D  2  9D 04 03                    sta VRAM_Buffer1+3,x     ;in the buffer
008610  2  C8                          iny
008611  2  E8                          inx
008612  2  C6 00                       dec $00
008614  2  10 F4                       bpl ClrGetLoop
008616  2  AE 00 03                    ldx VRAM_Buffer1_Offset  ;load original offset from before
008619  2  AC 44 07                    ldy BackgroundColorCtrl  ;if this value is four or greater, it will be set
00861C  2  D0 03                       bne SetBGColor           ;therefore use it as offset to background color
00861E  2  AC 4E 07                    ldy AreaType             ;otherwise use area type bits from area offset as offset
008621  2  B9 CF 85     SetBGColor:    lda BackgroundColors,y   ;to background color instead
008624  2  9D 04 03                    sta VRAM_Buffer1+3,x
008627  2  A9 3F                       lda #$3f                 ;set for sprite palette address
008629  2  9D 01 03                    sta VRAM_Buffer1,x       ;save to buffer
00862C  2  A9 10                       lda #$10
00862E  2  9D 02 03                    sta VRAM_Buffer1+1,x
008631  2  A9 04                       lda #$04                 ;write length byte to buffer
008633  2  9D 03 03                    sta VRAM_Buffer1+2,x
008636  2  A9 00                       lda #$00                 ;now the null terminator
008638  2  9D 08 03                    sta VRAM_Buffer1+7,x
00863B  2  8A                          txa                      ;move the buffer pointer ahead 7 bytes
00863C  2  18                          clc                      ;in case we want to write anything else later
00863D  2  69 07                       adc #$07
00863F  2  8D 00 03     SetVRAMOffset: sta VRAM_Buffer1_Offset  ;store as new vram buffer offset
008642  2  60                          rts
008643  2               
008643  2               ;-------------------------------------------------------------------------------------
008643  2               
008643  2               GetAlternatePalette1:
008643  2  AD 33 07                    lda AreaStyle            ;check for mushroom level style
008646  2  C9 01                       cmp #$01
008648  2  D0 05                       bne NoAltPal
00864A  2  A9 0B                       lda #$0b                 ;if found, load appropriate palette
00864C  2  8D 73 07     SetVRAMAddr_B: sta VRAM_Buffer_AddrCtrl
00864F  2  4C 45 87     NoAltPal:      jmp IncSubtask           ;now onto the next task
008652  2               
008652  2               ;-------------------------------------------------------------------------------------
008652  2               
008652  2               WriteTopStatusLine:
008652  2  A9 00              lda #$00          ;select main status bar
008654  2  20 08 88           jsr WriteGameText ;output it
008657  2  4C 45 87           jmp IncSubtask    ;onto the next task
00865A  2               
00865A  2               ;-------------------------------------------------------------------------------------
00865A  2               
00865A  2               WriteBottomStatusLine:
00865A  2  20 30 BC           jsr GetSBNybbles        ;write player's score and coin tally to screen
00865D  2  AE 00 03           ldx VRAM_Buffer1_Offset
008660  2  A9 20              lda #$20                ;write address for world-area number on screen
008662  2  9D 01 03           sta VRAM_Buffer1,x
008665  2  A9 73              lda #$73
008667  2  9D 02 03           sta VRAM_Buffer1+1,x
00866A  2  A9 03              lda #$03                ;write length for it
00866C  2  9D 03 03           sta VRAM_Buffer1+2,x
00866F  2  AC 5F 07           ldy WorldNumber         ;first the world number
008672  2  C8                 iny
008673  2  98                 tya
008674  2  9D 04 03           sta VRAM_Buffer1+3,x
008677  2  A9 28              lda #$28                ;next the dash
008679  2  9D 05 03           sta VRAM_Buffer1+4,x
00867C  2  AC 5C 07           ldy LevelNumber         ;next the level number
00867F  2  C8                 iny                     ;increment for proper number display
008680  2  98                 tya
008681  2  9D 06 03           sta VRAM_Buffer1+5,x
008684  2  A9 00              lda #$00                ;put null terminator on
008686  2  9D 07 03           sta VRAM_Buffer1+6,x
008689  2  8A                 txa                     ;move the buffer offset up by 6 bytes
00868A  2  18                 clc
00868B  2  69 06              adc #$06
00868D  2  8D 00 03           sta VRAM_Buffer1_Offset
008690  2  4C 45 87           jmp IncSubtask
008693  2               
008693  2               ;-------------------------------------------------------------------------------------
008693  2               
008693  2               DisplayTimeUp:
008693  2  AD 59 07               lda GameTimerExpiredFlag  ;if game timer not expired, increment task
008696  2  F0 0A                  beq NoTimeUp              ;control 2 tasks forward, otherwise, stay here
008698  2  A9 00                  lda #$00
00869A  2  8D 59 07               sta GameTimerExpiredFlag  ;reset timer expiration flag
00869D  2  A9 02                  lda #$02                  ;output time-up screen to buffer
00869F  2  4C C7 86               jmp OutputInter
0086A2  2  EE 3C 07     NoTimeUp: inc ScreenRoutineTask     ;increment control task 2 tasks forward
0086A5  2  4C 45 87               jmp IncSubtask
0086A8  2               
0086A8  2               ;-------------------------------------------------------------------------------------
0086A8  2               
0086A8  2               DisplayIntermediate:
0086A8  2  AD 70 07                    lda OperMode                 ;check primary mode of operation
0086AB  2  F0 33                       beq NoInter                  ;if in title screen mode, skip this
0086AD  2  C9 03                       cmp #GameOverModeValue       ;are we in game over mode?
0086AF  2  F0 22                       beq GameOverInter            ;if so, proceed to display game over screen
0086B1  2  AD 52 07                    lda AltEntranceControl       ;otherwise check for mode of alternate entry
0086B4  2  D0 2A                       bne NoInter                  ;and branch if found
0086B6  2  AC 4E 07                    ldy AreaType                 ;check if we are on castle level
0086B9  2  C0 03                       cpy #$03                     ;and if so, branch (possibly residual)
0086BB  2  F0 05                       beq PlayerInter
0086BD  2  AD 69 07                    lda DisableIntermediate      ;if this flag is set, skip intermediate lives display
0086C0  2  D0 1E                       bne NoInter                  ;and jump to specific task, otherwise
0086C2  2  20 A4 EF     PlayerInter:   jsr DrawPlayer_Intermediate  ;put player in appropriate place for
0086C5  2  A9 01                       lda #$01                     ;lives display, then output lives display to buffer
0086C7  2  20 08 88     OutputInter:   jsr WriteGameText
0086CA  2  20 A5 88                    jsr ResetScreenTimer
0086CD  2  A9 00                       lda #$00
0086CF  2  8D 74 07                    sta DisableScreenFlag        ;reenable screen output
0086D2  2  60                          rts
0086D3  2  A9 12        GameOverInter: lda #$12                     ;set screen timer
0086D5  2  8D A0 07                    sta ScreenTimer
0086D8  2  A9 03                       lda #$03                     ;output game over screen to buffer
0086DA  2  20 08 88                    jsr WriteGameText
0086DD  2  4C 4E 87                    jmp IncModeTask_B
0086E0  2  A9 08        NoInter:       lda #$08                     ;set for specific task and leave
0086E2  2  8D 3C 07                    sta ScreenRoutineTask
0086E5  2  60                          rts
0086E6  2               
0086E6  2               ;-------------------------------------------------------------------------------------
0086E6  2               
0086E6  2               AreaParserTaskControl:
0086E6  2  EE 74 07                inc DisableScreenFlag     ;turn off screen
0086E9  2  20 B0 92     TaskLoop:  jsr AreaParserTaskHandler ;render column set of current area
0086EC  2  AD 1F 07                lda AreaParserTaskNum     ;check number of tasks
0086EF  2  D0 F8                   bne TaskLoop              ;if tasks still not all done, do another one
0086F1  2  CE 1E 07                dec ColumnSets            ;do we need to render more column sets?
0086F4  2  10 03                   bpl OutputCol
0086F6  2  EE 3C 07                inc ScreenRoutineTask     ;if not, move on to the next task
0086F9  2  A9 06        OutputCol: lda #$06                  ;set vram buffer to output rendered column set
0086FB  2  8D 73 07                sta VRAM_Buffer_AddrCtrl  ;on next NMI
0086FE  2  60                      rts
0086FF  2               
0086FF  2               ;-------------------------------------------------------------------------------------
0086FF  2               
0086FF  2               ;$00 - vram buffer address table low
0086FF  2               ;$01 - vram buffer address table high
0086FF  2               
0086FF  2               DrawTitleScreen:
0086FF  2  AD 70 07                 lda OperMode                 ;are we in title screen mode?
008702  2  D0 4A                    bne IncModeTask_B            ;if not, exit
008704  2  A9 1E                    lda #>TitleScreenDataOffset  ;load address $1ec0 into
008706  2  8D 06 20                 sta PPU_ADDRESS              ;the vram address register
008709  2  A9 C0                    lda #<TitleScreenDataOffset
00870B  2  8D 06 20                 sta PPU_ADDRESS
00870E  2  A9 03                    lda #$03                     ;put address $0300 into
008710  2  85 01                    sta $01                      ;the indirect at $00
008712  2  A0 00                    ldy #$00
008714  2  84 00                    sty $00
008716  2  AD 07 20                 lda PPU_DATA                 ;do one garbage read
008719  2  AD 07 20     OutputTScr: lda PPU_DATA                 ;get title screen from chr-rom
00871C  2  91 00                    sta ($00),y                  ;store 256 bytes into buffer
00871E  2  C8                       iny
00871F  2  D0 02                    bne ChkHiByte                ;if not past 256 bytes, do not increment
008721  2  E6 01                    inc $01                      ;otherwise increment high byte of indirect
008723  2  A5 01        ChkHiByte:  lda $01                      ;check high byte?
008725  2  C9 04                    cmp #$04                     ;at $0400?
008727  2  D0 F0                    bne OutputTScr               ;if not, loop back and do another
008729  2  C0 3A                    cpy #$3a                     ;check if offset points past end of data
00872B  2  90 EC                    bcc OutputTScr               ;if not, loop back and do another
00872D  2  A9 05                    lda #$05                     ;set buffer transfer control to $0300,
00872F  2  4C 4C 86                 jmp SetVRAMAddr_B            ;increment task and exit
008732  2               
008732  2               ;-------------------------------------------------------------------------------------
008732  2               
008732  2               ClearBuffersDrawIcon:
008732  2  AD 70 07                  lda OperMode               ;check game mode
008735  2  D0 17                     bne IncModeTask_B          ;if not title screen mode, leave
008737  2  A2 00                     ldx #$00                   ;otherwise, clear buffer space
008739  2  9D 00 03     TScrClear:   sta VRAM_Buffer1-1,x
00873C  2  9D 00 04                  sta VRAM_Buffer1-1+$100,x
00873F  2  CA                        dex
008740  2  D0 F7                     bne TScrClear
008742  2  20 25 83                  jsr DrawMushroomIcon       ;draw player select icon
008745  2  EE 3C 07     IncSubtask:  inc ScreenRoutineTask      ;move onto next task
008748  2  60                        rts
008749  2               
008749  2               ;-------------------------------------------------------------------------------------
008749  2               
008749  2               WriteTopScore:
008749  2  A9 FA                       lda #$fa           ;run display routine to display top score on title
00874B  2  20 36 BC                    jsr UpdateNumber
00874E  2  EE 72 07     IncModeTask_B: inc OperMode_Task  ;move onto next mode
008751  2  60                          rts
008752  2               
008752  2               ;-------------------------------------------------------------------------------------
008752  2               
008752  2               GameText:
008752  2               TopStatusBarLine:
008752  2  20 43 05 16    .byte $20, $43, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
008756  2  0A 1B 12 18  
00875A  2  20 52 0B 20    .byte $20, $52, $0b, $20, $18, $1b, $15, $0d ; "WORLD  TIME"
00875E  2  18 1B 15 0D  
008762  2  24 24 1D 12    .byte $24, $24, $1d, $12, $16, $0e
008766  2  16 0E        
008768  2  20 68 05 00    .byte $20, $68, $05, $00, $24, $24, $2e, $29 ; score trailing digit and coin display
00876C  2  24 24 2E 29  
008770  2  23 C0 7F AA    .byte $23, $c0, $7f, $aa ; attribute table data, clears name table 0 to palette 2
008774  2  23 C2 01 EA    .byte $23, $c2, $01, $ea ; attribute table data, used for coin icon in status bar
008778  2  FF             .byte $ff ; end of data block
008779  2               
008779  2               WorldLivesDisplay:
008779  2  21 CD 07 24    .byte $21, $cd, $07, $24, $24 ; cross with spaces used on
00877D  2  24           
00877E  2  29 24 24 24    .byte $29, $24, $24, $24, $24 ; lives display
008782  2  24           
008783  2  21 4B 09 20    .byte $21, $4b, $09, $20, $18 ; "WORLD  - " used on lives display
008787  2  18           
008788  2  1B 15 0D 24    .byte $1b, $15, $0d, $24, $24, $28, $24
00878C  2  24 28 24     
00878F  2  22 0C 47 24    .byte $22, $0c, $47, $24 ; possibly used to clear time up
008793  2  23 DC 01 BA    .byte $23, $dc, $01, $ba ; attribute table data for crown if more than 9 lives
008797  2  FF             .byte $ff
008798  2               
008798  2               TwoPlayerTimeUp:
008798  2  21 CD 05 16    .byte $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
00879C  2  0A 1B 12 18  
0087A0  2               OnePlayerTimeUp:
0087A0  2  22 0C 07 1D    .byte $22, $0c, $07, $1d, $12, $16, $0e, $24, $1e, $19 ; "TIME UP"
0087A4  2  12 16 0E 24  
0087A8  2  1E 19        
0087AA  2  FF             .byte $ff
0087AB  2               
0087AB  2               TwoPlayerGameOver:
0087AB  2  21 CD 05 16    .byte $21, $cd, $05, $16, $0a, $1b, $12, $18 ; "MARIO"
0087AF  2  0A 1B 12 18  
0087B3  2               OnePlayerGameOver:
0087B3  2  22 0B 09 10    .byte $22, $0b, $09, $10, $0a, $16, $0e, $24 ; "GAME OVER"
0087B7  2  0A 16 0E 24  
0087BB  2  18 1F 0E 1B    .byte $18, $1f, $0e, $1b
0087BF  2  FF             .byte $ff
0087C0  2               
0087C0  2               WarpZoneWelcome:
0087C0  2  25 84 15 20    .byte $25, $84, $15, $20, $0e, $15, $0c, $18, $16 ; "WELCOME TO WARP ZONE!"
0087C4  2  0E 15 0C 18  
0087C8  2  16           
0087C9  2  0E 24 1D 18    .byte $0e, $24, $1d, $18, $24, $20, $0a, $1b, $19
0087CD  2  24 20 0A 1B  
0087D1  2  19           
0087D2  2  24 23 18 17    .byte $24, $23, $18, $17, $0e, $2b
0087D6  2  0E 2B        
0087D8  2  26 25 01 24    .byte $26, $25, $01, $24         ; placeholder for left pipe
0087DC  2  26 2D 01 24    .byte $26, $2d, $01, $24         ; placeholder for middle pipe
0087E0  2  26 35 01 24    .byte $26, $35, $01, $24         ; placeholder for right pipe
0087E4  2  27 D9 46 AA    .byte $27, $d9, $46, $aa         ; attribute data
0087E8  2  27 E1 45 AA    .byte $27, $e1, $45, $aa
0087EC  2  FF             .byte $ff
0087ED  2               
0087ED  2               LuigiName:
0087ED  2  15 1E 12 10    .byte $15, $1e, $12, $10, $12    ; "LUIGI", no address or length
0087F1  2  12           
0087F2  2               
0087F2  2               WarpZoneNumbers:
0087F2  2  04 03 02 00    .byte $04, $03, $02, $00         ; warp zone numbers, note spaces on middle
0087F6  2  24 05 24 00    .byte $24, $05, $24, $00         ; zone, partly responsible for
0087FA  2  08 07 06 00    .byte $08, $07, $06, $00         ; the minus world
0087FE  2               
0087FE  2               GameTextOffsets:
0087FE  2  00 00          .byte TopStatusBarLine-GameText, TopStatusBarLine-GameText
008800  2  27 27          .byte WorldLivesDisplay-GameText, WorldLivesDisplay-GameText
008802  2  46 4E          .byte TwoPlayerTimeUp-GameText, OnePlayerTimeUp-GameText
008804  2  59 61          .byte TwoPlayerGameOver-GameText, OnePlayerGameOver-GameText
008806  2  6E 6E          .byte WarpZoneWelcome-GameText, WarpZoneWelcome-GameText
008808  2               
008808  2               WriteGameText:
008808  2  48                          pha                      ;save text number to stack
008809  2  0A                          asl
00880A  2  A8                          tay                      ;multiply by 2 and use as offset
00880B  2  C0 04                       cpy #$04                 ;if set to do top status bar or world/lives display,
00880D  2  90 0C                       bcc LdGameText           ;branch to use current offset as-is
00880F  2  C0 08                       cpy #$08                 ;if set to do time-up or game over,
008811  2  90 02                       bcc Chk2Players          ;branch to check players
008813  2  A0 08                       ldy #$08                 ;otherwise warp zone, therefore set offset
008815  2  AD 7A 07     Chk2Players:   lda NumberOfPlayers      ;check for number of players
008818  2  D0 01                       bne LdGameText           ;if there are two, use current offset to also print name
00881A  2  C8                          iny                      ;otherwise increment offset by one to not print name
00881B  2  BE FE 87     LdGameText:    ldx GameTextOffsets,y    ;get offset to message we want to print
00881E  2  A0 00                       ldy #$00
008820  2  BD 52 87     GameTextLoop:  lda GameText,x           ;load message data
008823  2  C9 FF                       cmp #$ff                 ;check for terminator
008825  2  F0 07                       beq EndGameText          ;branch to end text if found
008827  2  99 01 03                    sta VRAM_Buffer1,y       ;otherwise write data to buffer
00882A  2  E8                          inx                      ;and increment increment
00882B  2  C8                          iny
00882C  2  D0 F2                       bne GameTextLoop         ;do this for 256 bytes if no terminator found
00882E  2  A9 00        EndGameText:   lda #$00                 ;put null terminator at end
008830  2  99 01 03                    sta VRAM_Buffer1,y
008833  2  68                          pla                      ;pull original text number from stack
008834  2  AA                          tax
008835  2  C9 04                       cmp #$04                 ;are we printing warp zone?
008837  2  B0 49                       bcs PrintWarpZoneNumbers
008839  2  CA                          dex                      ;are we printing the world/lives display?
00883A  2  D0 23                       bne CheckPlayerName      ;if not, branch to check player's name
00883C  2  AD 5A 07                    lda NumberofLives        ;otherwise, check number of lives
00883F  2  18                          clc                      ;and increment by one for display
008840  2  69 01                       adc #$01
008842  2  C9 0A                       cmp #10                  ;more than 9 lives?
008844  2  90 07                       bcc PutLives
008846  2  E9 0A                       sbc #10                  ;if so, subtract 10 and put a crown tile
008848  2  A0 9F                       ldy #$9f                 ;next to the difference...strange things happen if
00884A  2  8C 08 03                    sty VRAM_Buffer1+7       ;the number of lives exceeds 19
00884D  2  8D 09 03     PutLives:      sta VRAM_Buffer1+8
008850  2  AC 5F 07                    ldy WorldNumber          ;write world and level numbers (incremented for display)
008853  2  C8                          iny                      ;to the buffer in the spaces surrounding the dash
008854  2  8C 14 03                    sty VRAM_Buffer1+19
008857  2  AC 5C 07                    ldy LevelNumber
00885A  2  C8                          iny
00885B  2  8C 16 03                    sty VRAM_Buffer1+21      ;we're done here
00885E  2  60                          rts
00885F  2               
00885F  2               CheckPlayerName:
00885F  2  AD 7A 07                  lda NumberOfPlayers    ;check number of players
008862  2  F0 1D                     beq ExitChkName        ;if only 1 player, leave
008864  2  AD 53 07                  lda CurrentPlayer      ;load current player
008867  2  CA                        dex                    ;check to see if current message number is for time up
008868  2  D0 09                     bne ChkLuigi
00886A  2  AC 70 07                  ldy OperMode           ;check for game over mode
00886D  2  C0 03                     cpy #GameOverModeValue
00886F  2  F0 02                     beq ChkLuigi
008871  2  49 01                     eor #%00000001         ;if not, must be time up, invert d0 to do other player
008873  2  4A           ChkLuigi:    lsr
008874  2  90 0B                     bcc ExitChkName        ;if mario is current player, do not change the name
008876  2  A0 04                     ldy #$04
008878  2  B9 ED 87     NameLoop:    lda LuigiName,y        ;otherwise, replace "MARIO" with "LUIGI"
00887B  2  99 04 03                  sta VRAM_Buffer1+3,y
00887E  2  88                        dey
00887F  2  10 F7                     bpl NameLoop           ;do this until each letter is replaced
008881  2  60           ExitChkName: rts
008882  2               
008882  2               PrintWarpZoneNumbers:
008882  2  E9 04                     sbc #$04               ;subtract 4 and then shift to the left
008884  2  0A                        asl                    ;twice to get proper warp zone number
008885  2  0A                        asl                    ;offset
008886  2  AA                        tax
008887  2  A0 00                     ldy #$00
008889  2  BD F2 87     WarpNumLoop: lda WarpZoneNumbers,x  ;print warp zone numbers into the
00888C  2  99 1C 03                  sta VRAM_Buffer1+27,y  ;placeholders from earlier
00888F  2  E8                        inx
008890  2  C8                        iny                    ;put a number in every fourth space
008891  2  C8                        iny
008892  2  C8                        iny
008893  2  C8                        iny
008894  2  C0 0C                     cpy #$0c
008896  2  90 F1                     bcc WarpNumLoop
008898  2  A9 2C                     lda #$2c               ;load new buffer pointer at end of message
00889A  2  4C 3F 86                  jmp SetVRAMOffset
00889D  2               
00889D  2               ;-------------------------------------------------------------------------------------
00889D  2               
00889D  2               ResetSpritesAndScreenTimer:
00889D  2  AD A0 07              lda ScreenTimer             ;check if screen timer has expired
0088A0  2  D0 0B                 bne NoReset                 ;if not, branch to leave
0088A2  2  20 20 82              jsr MoveAllSpritesOffscreen ;otherwise reset sprites now
0088A5  2               
0088A5  2               ResetScreenTimer:
0088A5  2  A9 07                 lda #$07                    ;reset timer again
0088A7  2  8D A0 07              sta ScreenTimer
0088AA  2  EE 3C 07              inc ScreenRoutineTask       ;move onto next task
0088AD  2  60           NoReset: rts
0088AE  2               
0088AE  2               ;-------------------------------------------------------------------------------------
0088AE  2               ;$00 - temp vram buffer offset
0088AE  2               ;$01 - temp metatile buffer offset
0088AE  2               ;$02 - temp metatile graphics table offset
0088AE  2               ;$03 - used to store attribute bits
0088AE  2               ;$04 - used to determine attribute table row
0088AE  2               ;$05 - used to determine attribute table column
0088AE  2               ;$06 - metatile graphics table address low
0088AE  2               ;$07 - metatile graphics table address high
0088AE  2               
0088AE  2               RenderAreaGraphics:
0088AE  2  AD 26 07                 lda CurrentColumnPos         ;store LSB of where we're at
0088B1  2  29 01                    and #$01
0088B3  2  85 05                    sta $05
0088B5  2  AC 40 03                 ldy VRAM_Buffer2_Offset      ;store vram buffer offset
0088B8  2  84 00                    sty $00
0088BA  2  AD 21 07                 lda CurrentNTAddr_Low        ;get current name table address we're supposed to render
0088BD  2  99 42 03                 sta VRAM_Buffer2+1,y
0088C0  2  AD 20 07                 lda CurrentNTAddr_High
0088C3  2  99 41 03                 sta VRAM_Buffer2,y
0088C6  2  A9 9A                    lda #$9a                     ;store length byte of 26 here with d7 set
0088C8  2  99 43 03                 sta VRAM_Buffer2+2,y         ;to increment by 32 (in columns)
0088CB  2  A9 00                    lda #$00                     ;init attribute row
0088CD  2  85 04                    sta $04
0088CF  2  AA                       tax
0088D0  2  86 01        DrawMTLoop: stx $01                      ;store init value of 0 or incremented offset for buffer
0088D2  2  BD A1 06                 lda MetatileBuffer,x         ;get first metatile number, and mask out all but 2 MSB
0088D5  2  29 C0                    and #%11000000
0088D7  2  85 03                    sta $03                      ;store attribute table bits here
0088D9  2  0A                       asl                          ;note that metatile format is:
0088DA  2  2A                       rol                          ;%xx000000 - attribute table bits,
0088DB  2  2A                       rol                          ;%00xxxxxx - metatile number
0088DC  2  A8                       tay                          ;rotate bits to d1-d0 and use as offset here
0088DD  2  B9 08 8B                 lda MetatileGraphics_Low,y   ;get address to graphics table from here
0088E0  2  85 06                    sta $06
0088E2  2  B9 0C 8B                 lda MetatileGraphics_High,y
0088E5  2  85 07                    sta $07
0088E7  2  BD A1 06                 lda MetatileBuffer,x         ;get metatile number again
0088EA  2  0A                       asl                          ;multiply by 4 and use as tile offset
0088EB  2  0A                       asl
0088EC  2  85 02                    sta $02
0088EE  2  AD 1F 07                 lda AreaParserTaskNum        ;get current task number for level processing and
0088F1  2  29 01                    and #%00000001               ;mask out all but LSB, then invert LSB, multiply by 2
0088F3  2  49 01                    eor #%00000001               ;to get the correct column position in the metatile,
0088F5  2  0A                       asl                          ;then add to the tile offset so we can draw either side
0088F6  2  65 02                    adc $02                      ;of the metatiles
0088F8  2  A8                       tay
0088F9  2  A6 00                    ldx $00                      ;use vram buffer offset from before as X
0088FB  2  B1 06                    lda ($06),y
0088FD  2  9D 44 03                 sta VRAM_Buffer2+3,x         ;get first tile number (top left or top right) and store
008900  2  C8                       iny
008901  2  B1 06                    lda ($06),y                  ;now get the second (bottom left or bottom right) and store
008903  2  9D 45 03                 sta VRAM_Buffer2+4,x
008906  2  A4 04                    ldy $04                      ;get current attribute row
008908  2  A5 05                    lda $05                      ;get LSB of current column where we're at, and
00890A  2  D0 0E                    bne RightCheck               ;branch if set (clear = left attrib, set = right)
00890C  2  A5 01                    lda $01                      ;get current row we're rendering
00890E  2  4A                       lsr                          ;branch if LSB set (clear = top left, set = bottom left)
00890F  2  B0 19                    bcs LLeft
008911  2  26 03                    rol $03                      ;rotate attribute bits 3 to the left
008913  2  26 03                    rol $03                      ;thus in d1-d0, for upper left square
008915  2  26 03                    rol $03
008917  2  4C 30 89                 jmp SetAttrib
00891A  2  A5 01        RightCheck: lda $01                      ;get LSB of current row we're rendering
00891C  2  4A                       lsr                          ;branch if set (clear = top right, set = bottom right)
00891D  2  B0 0F                    bcs NextMTRow
00891F  2  46 03                    lsr $03                      ;shift attribute bits 4 to the right
008921  2  46 03                    lsr $03                      ;thus in d3-d2, for upper right square
008923  2  46 03                    lsr $03
008925  2  46 03                    lsr $03
008927  2  4C 30 89                 jmp SetAttrib
00892A  2  46 03        LLeft:      lsr $03                      ;shift attribute bits 2 to the right
00892C  2  46 03                    lsr $03                      ;thus in d5-d4 for lower left square
00892E  2  E6 04        NextMTRow:  inc $04                      ;move onto next attribute row
008930  2  B9 F9 03     SetAttrib:  lda AttributeBuffer,y        ;get previously saved bits from before
008933  2  05 03                    ora $03                      ;if any, and put new bits, if any, onto
008935  2  99 F9 03                 sta AttributeBuffer,y        ;the old, and store
008938  2  E6 00                    inc $00                      ;increment vram buffer offset by 2
00893A  2  E6 00                    inc $00
00893C  2  A6 01                    ldx $01                      ;get current gfx buffer row, and check for
00893E  2  E8                       inx                          ;the bottom of the screen
00893F  2  E0 0D                    cpx #$0d
008941  2  90 8D                    bcc DrawMTLoop               ;if not there yet, loop back
008943  2  A4 00                    ldy $00                      ;get current vram buffer offset, increment by 3
008945  2  C8                       iny                          ;(for name table address and length bytes)
008946  2  C8                       iny
008947  2  C8                       iny
008948  2  A9 00                    lda #$00
00894A  2  99 41 03                 sta VRAM_Buffer2,y           ;put null terminator at end of data for name table
00894D  2  8C 40 03                 sty VRAM_Buffer2_Offset      ;store new buffer offset
008950  2  EE 21 07                 inc CurrentNTAddr_Low        ;increment name table address low
008953  2  AD 21 07                 lda CurrentNTAddr_Low        ;check current low byte
008956  2  29 1F                    and #%00011111               ;if no wraparound, just skip this part
008958  2  D0 0D                    bne ExitDrawM
00895A  2  A9 80                    lda #$80                     ;if wraparound occurs, make sure low byte stays
00895C  2  8D 21 07                 sta CurrentNTAddr_Low        ;just under the status bar
00895F  2  AD 20 07                 lda CurrentNTAddr_High       ;and then invert d2 of the name table address high
008962  2  49 04                    eor #%00000100               ;to move onto the next appropriate name table
008964  2  8D 20 07                 sta CurrentNTAddr_High
008967  2  4C BD 89     ExitDrawM:  jmp SetVRAMCtrl              ;jump to set buffer to $0341 and leave
00896A  2               
00896A  2               ;-------------------------------------------------------------------------------------
00896A  2               ;$00 - temp attribute table address high (big endian order this time!)
00896A  2               ;$01 - temp attribute table address low
00896A  2               
00896A  2               RenderAttributeTables:
00896A  2  AD 21 07                  lda CurrentNTAddr_Low    ;get low byte of next name table address
00896D  2  29 1F                     and #%00011111           ;to be written to, mask out all but 5 LSB,
00896F  2  38                        sec                      ;subtract four
008970  2  E9 04                     sbc #$04
008972  2  29 1F                     and #%00011111           ;mask out bits again and store
008974  2  85 01                     sta $01
008976  2  AD 20 07                  lda CurrentNTAddr_High   ;get high byte and branch if borrow not set
008979  2  B0 02                     bcs SetATHigh
00897B  2  49 04                     eor #%00000100           ;otherwise invert d2
00897D  2  29 04        SetATHigh:   and #%00000100           ;mask out all other bits
00897F  2  09 23                     ora #$23                 ;add $2300 to the high byte and store
008981  2  85 00                     sta $00
008983  2  A5 01                     lda $01                  ;get low byte - 4, divide by 4, add offset for
008985  2  4A                        lsr                      ;attribute table and store
008986  2  4A                        lsr
008987  2  69 C0                     adc #$c0                 ;we should now have the appropriate block of
008989  2  85 01                     sta $01                  ;attribute table in our temp address
00898B  2  A2 00                     ldx #$00
00898D  2  AC 40 03                  ldy VRAM_Buffer2_Offset  ;get buffer offset
008990  2  A5 00        AttribLoop:  lda $00
008992  2  99 41 03                  sta VRAM_Buffer2,y       ;store high byte of attribute table address
008995  2  A5 01                     lda $01
008997  2  18                        clc                      ;get low byte, add 8 because we want to start
008998  2  69 08                     adc #$08                 ;below the status bar, and store
00899A  2  99 42 03                  sta VRAM_Buffer2+1,y
00899D  2  85 01                     sta $01                  ;also store in temp again
00899F  2  BD F9 03                  lda AttributeBuffer,x    ;fetch current attribute table byte and store
0089A2  2  99 44 03                  sta VRAM_Buffer2+3,y     ;in the buffer
0089A5  2  A9 01                     lda #$01
0089A7  2  99 43 03                  sta VRAM_Buffer2+2,y     ;store length of 1 in buffer
0089AA  2  4A                        lsr
0089AB  2  9D F9 03                  sta AttributeBuffer,x    ;clear current byte in attribute buffer
0089AE  2  C8                        iny                      ;increment buffer offset by 4 bytes
0089AF  2  C8                        iny
0089B0  2  C8                        iny
0089B1  2  C8                        iny
0089B2  2  E8                        inx                      ;increment attribute offset and check to see
0089B3  2  E0 07                     cpx #$07                 ;if we're at the end yet
0089B5  2  90 D9                     bcc AttribLoop
0089B7  2  99 41 03                  sta VRAM_Buffer2,y       ;put null terminator at the end
0089BA  2  8C 40 03                  sty VRAM_Buffer2_Offset  ;store offset in case we want to do any more
0089BD  2  A9 06        SetVRAMCtrl: lda #$06
0089BF  2  8D 73 07                  sta VRAM_Buffer_AddrCtrl ;set buffer to $0341 and leave
0089C2  2  60                        rts
0089C3  2               
0089C3  2               ;-------------------------------------------------------------------------------------
0089C3  2               
0089C3  2               ;$00 - used as temporary counter in ColorRotation
0089C3  2               
0089C3  2               ColorRotatePalette:
0089C3  2  27 27 27 17         .byte $27, $27, $27, $17, $07, $17
0089C7  2  07 17        
0089C9  2               
0089C9  2               BlankPalette:
0089C9  2  3F 0C 04 FF         .byte $3f, $0c, $04, $ff, $ff, $ff, $ff, $00
0089CD  2  FF FF FF 00  
0089D1  2               
0089D1  2               ;used based on area type
0089D1  2               Palette3Data:
0089D1  2  0F 07 12 0F         .byte $0f, $07, $12, $0f
0089D5  2  0F 07 17 0F         .byte $0f, $07, $17, $0f
0089D9  2  0F 07 17 1C         .byte $0f, $07, $17, $1c
0089DD  2  0F 07 17 00         .byte $0f, $07, $17, $00
0089E1  2               
0089E1  2               ColorRotation:
0089E1  2  A5 09                      lda FrameCounter         ;get frame counter
0089E3  2  29 07                      and #$07                 ;mask out all but three LSB
0089E5  2  D0 51                      bne ExitColorRot         ;branch if not set to zero to do this every eighth frame
0089E7  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;check vram buffer offset
0089EA  2  E0 31                      cpx #$31
0089EC  2  B0 4A                      bcs ExitColorRot         ;if offset over 48 bytes, branch to leave
0089EE  2  A8                         tay                      ;otherwise use frame counter's 3 LSB as offset here
0089EF  2  B9 C9 89     GetBlankPal:  lda BlankPalette,y       ;get blank palette for palette 3
0089F2  2  9D 01 03                   sta VRAM_Buffer1,x       ;store it in the vram buffer
0089F5  2  E8                         inx                      ;increment offsets
0089F6  2  C8                         iny
0089F7  2  C0 08                      cpy #$08
0089F9  2  90 F4                      bcc GetBlankPal          ;do this until all bytes are copied
0089FB  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
0089FE  2  A9 03                      lda #$03
008A00  2  85 00                      sta $00                  ;set counter here
008A02  2  AD 4E 07                   lda AreaType             ;get area type
008A05  2  0A                         asl                      ;multiply by 4 to get proper offset
008A06  2  0A                         asl
008A07  2  A8                         tay                      ;save as offset here
008A08  2  B9 D1 89     GetAreaPal:   lda Palette3Data,y       ;fetch palette to be written based on area type
008A0B  2  9D 04 03                   sta VRAM_Buffer1+3,x     ;store it to overwrite blank palette in vram buffer
008A0E  2  C8                         iny
008A0F  2  E8                         inx
008A10  2  C6 00                      dec $00                  ;decrement counter
008A12  2  10 F4                      bpl GetAreaPal           ;do this until the palette is all copied
008A14  2  AE 00 03                   ldx VRAM_Buffer1_Offset  ;get current vram buffer offset
008A17  2  AC D4 06                   ldy ColorRotateOffset    ;get color cycling offset
008A1A  2  B9 C3 89                   lda ColorRotatePalette,y
008A1D  2  9D 05 03                   sta VRAM_Buffer1+4,x     ;get and store current color in second slot of palette
008A20  2  AD 00 03                   lda VRAM_Buffer1_Offset
008A23  2  18                         clc                      ;add seven bytes to vram buffer offset
008A24  2  69 07                      adc #$07
008A26  2  8D 00 03                   sta VRAM_Buffer1_Offset
008A29  2  EE D4 06                   inc ColorRotateOffset    ;increment color cycling offset
008A2C  2  AD D4 06                   lda ColorRotateOffset
008A2F  2  C9 06                      cmp #$06                 ;check to see if it's still in range
008A31  2  90 05                      bcc ExitColorRot         ;if so, branch to leave
008A33  2  A9 00                      lda #$00
008A35  2  8D D4 06                   sta ColorRotateOffset    ;otherwise, init to keep it in range
008A38  2  60           ExitColorRot: rts                      ;leave
008A39  2               
008A39  2               ;-------------------------------------------------------------------------------------
008A39  2               ;$00 - temp store for offset control bit
008A39  2               ;$01 - temp vram buffer offset
008A39  2               ;$02 - temp store for vertical high nybble in block buffer routine
008A39  2               ;$03 - temp adder for high byte of name table address
008A39  2               ;$04, $05 - name table address low/high
008A39  2               ;$06, $07 - block buffer address low/high
008A39  2               
008A39  2               BlockGfxData:
008A39  2  45 45 47 47         .byte $45, $45, $47, $47
008A3D  2  47 47 47 47         .byte $47, $47, $47, $47
008A41  2  57 58 59 5A         .byte $57, $58, $59, $5a
008A45  2  24 24 24 24         .byte $24, $24, $24, $24
008A49  2  26 26 26 26         .byte $26, $26, $26, $26
008A4D  2               
008A4D  2               RemoveCoin_Axe:
008A4D  2  A0 41                      ldy #$41                 ;set low byte so offset points to $0341
008A4F  2  A9 03                      lda #$03                 ;load offset for default blank metatile
008A51  2  AE 4E 07                   ldx AreaType             ;check area type
008A54  2  D0 02                      bne WriteBlankMT         ;if not water type, use offset
008A56  2  A9 04                      lda #$04                 ;otherwise load offset for blank metatile used in water
008A58  2  20 97 8A     WriteBlankMT: jsr PutBlockMetatile     ;do a sub to write blank metatile to vram buffer
008A5B  2  A9 06                      lda #$06
008A5D  2  8D 73 07                   sta VRAM_Buffer_AddrCtrl ;set vram address controller to $0341 and leave
008A60  2  60                         rts
008A61  2               
008A61  2               ReplaceBlockMetatile:
008A61  2  20 6D 8A            jsr WriteBlockMetatile    ;write metatile to vram buffer to replace block object
008A64  2  EE F0 03            inc Block_ResidualCounter ;increment unused counter (residual code)
008A67  2  DE EC 03            dec Block_RepFlag,x       ;decrement flag (residual code)
008A6A  2  60                  rts                       ;leave
008A6B  2               
008A6B  2               DestroyBlockMetatile:
008A6B  2  A9 00               lda #$00       ;force blank metatile if branched/jumped to this point
008A6D  2               
008A6D  2               WriteBlockMetatile:
008A6D  2  A0 03                     ldy #$03                ;load offset for blank metatile
008A6F  2  C9 00                     cmp #$00                ;check contents of A for blank metatile
008A71  2  F0 14                     beq UseBOffset          ;branch if found (unconditional if branched from 8a6b)
008A73  2  A0 00                     ldy #$00                ;load offset for brick metatile w/ line
008A75  2  C9 58                     cmp #$58
008A77  2  F0 0E                     beq UseBOffset          ;use offset if metatile is brick with coins (w/ line)
008A79  2  C9 51                     cmp #$51
008A7B  2  F0 0A                     beq UseBOffset          ;use offset if metatile is breakable brick w/ line
008A7D  2  C8                        iny                     ;increment offset for brick metatile w/o line
008A7E  2  C9 5D                     cmp #$5d
008A80  2  F0 05                     beq UseBOffset          ;use offset if metatile is brick with coins (w/o line)
008A82  2  C9 52                     cmp #$52
008A84  2  F0 01                     beq UseBOffset          ;use offset if metatile is breakable brick w/o line
008A86  2  C8                        iny                     ;if any other metatile, increment offset for empty block
008A87  2  98           UseBOffset:  tya                     ;put Y in A
008A88  2  AC 00 03                  ldy VRAM_Buffer1_Offset ;get vram buffer offset
008A8B  2  C8                        iny                     ;move onto next byte
008A8C  2  20 97 8A                  jsr PutBlockMetatile    ;get appropriate block data and write to vram buffer
008A8F  2  88           MoveVOffset: dey                     ;decrement vram buffer offset
008A90  2  98                        tya                     ;add 10 bytes to it
008A91  2  18                        clc
008A92  2  69 0A                     adc #10
008A94  2  4C 3F 86                  jmp SetVRAMOffset       ;branch to store as new vram buffer offset
008A97  2               
008A97  2               PutBlockMetatile:
008A97  2  86 00                    stx $00               ;store control bit from SprDataOffset_Ctrl
008A99  2  84 01                    sty $01               ;store vram buffer offset for next byte
008A9B  2  0A                       asl
008A9C  2  0A                       asl                   ;multiply A by four and use as X
008A9D  2  AA                       tax
008A9E  2  A0 20                    ldy #$20              ;load high byte for name table 0
008AA0  2  A5 06                    lda $06               ;get low byte of block buffer pointer
008AA2  2  C9 D0                    cmp #$d0              ;check to see if we're on odd-page block buffer
008AA4  2  90 02                    bcc SaveHAdder        ;if not, use current high byte
008AA6  2  A0 24                    ldy #$24              ;otherwise load high byte for name table 1
008AA8  2  84 03        SaveHAdder: sty $03               ;save high byte here
008AAA  2  29 0F                    and #$0f              ;mask out high nybble of block buffer pointer
008AAC  2  0A                       asl                   ;multiply by 2 to get appropriate name table low byte
008AAD  2  85 04                    sta $04               ;and then store it here
008AAF  2  A9 00                    lda #$00
008AB1  2  85 05                    sta $05               ;initialize temp high byte
008AB3  2  A5 02                    lda $02               ;get vertical high nybble offset used in block buffer routine
008AB5  2  18                       clc
008AB6  2  69 20                    adc #$20              ;add 32 pixels for the status bar
008AB8  2  0A                       asl
008AB9  2  26 05                    rol $05               ;shift and rotate d7 onto d0 and d6 into carry
008ABB  2  0A                       asl
008ABC  2  26 05                    rol $05               ;shift and rotate d6 onto d0 and d5 into carry
008ABE  2  65 04                    adc $04               ;add low byte of name table and carry to vertical high nybble
008AC0  2  85 04                    sta $04               ;and store here
008AC2  2  A5 05                    lda $05               ;get whatever was in d7 and d6 of vertical high nybble
008AC4  2  69 00                    adc #$00              ;add carry
008AC6  2  18                       clc
008AC7  2  65 03                    adc $03               ;then add high byte of name table
008AC9  2  85 05                    sta $05               ;store here
008ACB  2  A4 01                    ldy $01               ;get vram buffer offset to be used
008ACD  2  BD 39 8A     RemBridge:  lda BlockGfxData,x    ;write top left and top right
008AD0  2  99 03 03                 sta VRAM_Buffer1+2,y  ;tile numbers into first spot
008AD3  2  BD 3A 8A                 lda BlockGfxData+1,x
008AD6  2  99 04 03                 sta VRAM_Buffer1+3,y
008AD9  2  BD 3B 8A                 lda BlockGfxData+2,x  ;write bottom left and bottom
008ADC  2  99 08 03                 sta VRAM_Buffer1+7,y  ;right tiles numbers into
008ADF  2  BD 3C 8A                 lda BlockGfxData+3,x  ;second spot
008AE2  2  99 09 03                 sta VRAM_Buffer1+8,y
008AE5  2  A5 04                    lda $04
008AE7  2  99 01 03                 sta VRAM_Buffer1,y    ;write low byte of name table
008AEA  2  18                       clc                   ;into first slot as read
008AEB  2  69 20                    adc #$20              ;add 32 bytes to value
008AED  2  99 06 03                 sta VRAM_Buffer1+5,y  ;write low byte of name table
008AF0  2  A5 05                    lda $05               ;plus 32 bytes into second slot
008AF2  2  99 00 03                 sta VRAM_Buffer1-1,y  ;write high byte of name
008AF5  2  99 05 03                 sta VRAM_Buffer1+4,y  ;table address to both slots
008AF8  2  A9 02                    lda #$02
008AFA  2  99 02 03                 sta VRAM_Buffer1+1,y  ;put length of 2 in
008AFD  2  99 07 03                 sta VRAM_Buffer1+6,y  ;both slots
008B00  2  A9 00                    lda #$00
008B02  2  99 0A 03                 sta VRAM_Buffer1+9,y  ;put null terminator at end
008B05  2  A6 00                    ldx $00               ;get offset control bit here
008B07  2  60                       rts                   ;and leave
008B08  2               
008B08  2               ;-------------------------------------------------------------------------------------
008B08  2               ;METATILE GRAPHICS TABLE
008B08  2               
008B08  2               MetatileGraphics_Low:
008B08  2  10 AC 64 8C    .byte <Palette0_MTiles, <Palette1_MTiles, <Palette2_MTiles, <Palette3_MTiles
008B0C  2               
008B0C  2               MetatileGraphics_High:
008B0C  2  8B 8B 8C 8C    .byte >Palette0_MTiles, >Palette1_MTiles, >Palette2_MTiles, >Palette3_MTiles
008B10  2               
008B10  2               Palette0_MTiles:
008B10  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank
008B14  2  27 27 27 27    .byte $27, $27, $27, $27 ;black metatile
008B18  2  24 24 24 35    .byte $24, $24, $24, $35 ;bush left
008B1C  2  36 25 37 25    .byte $36, $25, $37, $25 ;bush middle
008B20  2  24 38 24 24    .byte $24, $38, $24, $24 ;bush right
008B24  2  24 30 30 26    .byte $24, $30, $30, $26 ;mountain left
008B28  2  26 26 34 26    .byte $26, $26, $34, $26 ;mountain left bottom/middle center
008B2C  2  24 31 24 32    .byte $24, $31, $24, $32 ;mountain middle top
008B30  2  33 26 24 33    .byte $33, $26, $24, $33 ;mountain right
008B34  2  34 26 26 26    .byte $34, $26, $26, $26 ;mountain right bottom
008B38  2  26 26 26 26    .byte $26, $26, $26, $26 ;mountain middle bottom
008B3C  2  24 C0 24 C0    .byte $24, $c0, $24, $c0 ;bridge guardrail
008B40  2  24 7F 7F 24    .byte $24, $7f, $7f, $24 ;chain
008B44  2  B8 BA B9 BB    .byte $b8, $ba, $b9, $bb ;tall tree top, top half
008B48  2  B8 BC B9 BD    .byte $b8, $bc, $b9, $bd ;short tree top
008B4C  2  BA BC BB BD    .byte $ba, $bc, $bb, $bd ;tall tree top, bottom half
008B50  2  60 64 61 65    .byte $60, $64, $61, $65 ;warp pipe end left, points up
008B54  2  62 66 63 67    .byte $62, $66, $63, $67 ;warp pipe end right, points up
008B58  2  60 64 61 65    .byte $60, $64, $61, $65 ;decoration pipe end left, points up
008B5C  2  62 66 63 67    .byte $62, $66, $63, $67 ;decoration pipe end right, points up
008B60  2  68 68 69 69    .byte $68, $68, $69, $69 ;pipe shaft left
008B64  2  26 26 6A 6A    .byte $26, $26, $6a, $6a ;pipe shaft right
008B68  2  4B 4C 4D 4E    .byte $4b, $4c, $4d, $4e ;tree ledge left edge
008B6C  2  4D 4F 4D 4F    .byte $4d, $4f, $4d, $4f ;tree ledge middle
008B70  2  4D 4E 50 51    .byte $4d, $4e, $50, $51 ;tree ledge right edge
008B74  2  6B 70 2C 2D    .byte $6b, $70, $2c, $2d ;mushroom left edge
008B78  2  6C 71 6D 72    .byte $6c, $71, $6d, $72 ;mushroom middle
008B7C  2  6E 73 6F 74    .byte $6e, $73, $6f, $74 ;mushroom right edge
008B80  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;sideways pipe end top
008B84  2  88 8C 88 8C    .byte $88, $8c, $88, $8c ;sideways pipe shaft top
008B88  2  89 8D 69 69    .byte $89, $8d, $69, $69 ;sideways pipe joint top
008B8C  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;sideways pipe end bottom
008B90  2  26 93 26 93    .byte $26, $93, $26, $93 ;sideways pipe shaft bottom
008B94  2  90 94 69 69    .byte $90, $94, $69, $69 ;sideways pipe joint bottom
008B98  2  A4 E9 EA EB    .byte $a4, $e9, $ea, $eb ;seaplant
008B9C  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used on bricks or blocks that are hit
008BA0  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flagpole ball
008BA4  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;flagpole shaft
008BA8  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank, used in conjunction with vines
008BAC  2               
008BAC  2               Palette1_MTiles:
008BAC  2  A2 A2 A3 A3    .byte $a2, $a2, $a3, $a3 ;vertical rope
008BB0  2  99 24 99 24    .byte $99, $24, $99, $24 ;horizontal rope
008BB4  2  24 A2 3E 3F    .byte $24, $a2, $3e, $3f ;left pulley
008BB8  2  5B 5C 24 A3    .byte $5b, $5c, $24, $a3 ;right pulley
008BBC  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for balance rope
008BC0  2  9D 47 9E 47    .byte $9d, $47, $9e, $47 ;castle top
008BC4  2  47 47 27 27    .byte $47, $47, $27, $27 ;castle window left
008BC8  2  47 47 47 47    .byte $47, $47, $47, $47 ;castle brick wall
008BCC  2  27 27 47 47    .byte $27, $27, $47, $47 ;castle window right
008BD0  2  A9 47 AA 47    .byte $a9, $47, $aa, $47 ;castle top w/ brick
008BD4  2  9B 27 9C 27    .byte $9b, $27, $9c, $27 ;entrance top
008BD8  2  27 27 27 27    .byte $27, $27, $27, $27 ;entrance bottom
008BDC  2  52 52 52 52    .byte $52, $52, $52, $52 ;green ledge stump
008BE0  2  80 A0 81 A1    .byte $80, $a0, $81, $a1 ;fence
008BE4  2  BE BE BF BF    .byte $be, $be, $bf, $bf ;tree trunk
008BE8  2  75 BA 76 BB    .byte $75, $ba, $76, $bb ;mushroom stump top
008BEC  2  BA BA BB BB    .byte $ba, $ba, $bb, $bb ;mushroom stump bottom
008BF0  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick w/ line
008BF4  2  47 47 47 47    .byte $47, $47, $47, $47 ;breakable brick
008BF8  2  45 47 45 47    .byte $45, $47, $45, $47 ;breakable brick (not used)
008BFC  2  B4 B6 B5 B7    .byte $b4, $b6, $b5, $b7 ;cracked rock terrain
008C00  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (power-up)
008C04  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (vine)
008C08  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (star)
008C0C  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (coins)
008C10  2  45 47 45 47    .byte $45, $47, $45, $47 ;brick with line (1-up)
008C14  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (power-up)
008C18  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (vine)
008C1C  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (star)
008C20  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (coins)
008C24  2  47 47 47 47    .byte $47, $47, $47, $47 ;brick (1-up)
008C28  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1 coin)
008C2C  2  24 24 24 24    .byte $24, $24, $24, $24 ;hidden block (1-up)
008C30  2  AB AC AD AE    .byte $ab, $ac, $ad, $ae ;solid block (3-d block)
008C34  2  5D 5E 5D 5E    .byte $5d, $5e, $5d, $5e ;solid block (white wall)
008C38  2  C1 24 C1 24    .byte $c1, $24, $c1, $24 ;bridge
008C3C  2  C6 C8 C7 C9    .byte $c6, $c8, $c7, $c9 ;bullet bill cannon barrel
008C40  2  CA CC CB CD    .byte $ca, $cc, $cb, $cd ;bullet bill cannon top
008C44  2  2A 2A 40 40    .byte $2a, $2a, $40, $40 ;bullet bill cannon bottom
008C48  2  24 24 24 24    .byte $24, $24, $24, $24 ;blank used for jumpspring
008C4C  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick used for jumpspring
008C50  2  82 83 84 85    .byte $82, $83, $84, $85 ;solid block (water level, green rock)
008C54  2  24 47 24 47    .byte $24, $47, $24, $47 ;half brick (???)
008C58  2  86 8A 87 8B    .byte $86, $8a, $87, $8b ;water pipe top
008C5C  2  8E 91 8F 92    .byte $8e, $91, $8f, $92 ;water pipe bottom
008C60  2  24 2F 24 3D    .byte $24, $2f, $24, $3d ;flag ball (residual object)
008C64  2               
008C64  2               Palette2_MTiles:
008C64  2  24 24 24 35    .byte $24, $24, $24, $35 ;cloud left
008C68  2  36 25 37 25    .byte $36, $25, $37, $25 ;cloud middle
008C6C  2  24 38 24 24    .byte $24, $38, $24, $24 ;cloud right
008C70  2  24 24 39 24    .byte $24, $24, $39, $24 ;cloud bottom left
008C74  2  3A 24 3B 24    .byte $3a, $24, $3b, $24 ;cloud bottom middle
008C78  2  3C 24 24 24    .byte $3c, $24, $24, $24 ;cloud bottom right
008C7C  2  41 26 41 26    .byte $41, $26, $41, $26 ;water/lava top
008C80  2  26 26 26 26    .byte $26, $26, $26, $26 ;water/lava
008C84  2  B0 B1 B2 B3    .byte $b0, $b1, $b2, $b3 ;cloud level terrain
008C88  2  77 79 77 79    .byte $77, $79, $77, $79 ;bowser's bridge
008C8C  2               
008C8C  2               Palette3_MTiles:
008C8C  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (coin)
008C90  2  53 55 54 56    .byte $53, $55, $54, $56 ;question block (power-up)
008C94  2  A5 A7 A6 A8    .byte $a5, $a7, $a6, $a8 ;coin
008C98  2  C2 C4 C3 C5    .byte $c2, $c4, $c3, $c5 ;underwater coin
008C9C  2  57 59 58 5A    .byte $57, $59, $58, $5a ;empty block
008CA0  2  7B 7D 7C 7E    .byte $7b, $7d, $7c, $7e ;axe
008CA4  2               
008CA4  2               ;-------------------------------------------------------------------------------------
008CA4  2               ;VRAM BUFFER DATA FOR LOCATIONS IN PRG-ROM
008CA4  2               
008CA4  2               WaterPaletteData:
008CA4  2  3F 00 20       .byte $3f, $00, $20
008CA7  2  0F 15 12 25    .byte $0f, $15, $12, $25
008CAB  2  0F 3A 1A 0F    .byte $0f, $3a, $1a, $0f
008CAF  2  0F 30 12 0F    .byte $0f, $30, $12, $0f
008CB3  2  0F 27 12 0F    .byte $0f, $27, $12, $0f
008CB7  2  22 16 27 18    .byte $22, $16, $27, $18
008CBB  2  0F 10 30 27    .byte $0f, $10, $30, $27
008CBF  2  0F 16 30 27    .byte $0f, $16, $30, $27
008CC3  2  0F 0F 30 10    .byte $0f, $0f, $30, $10
008CC7  2  00             .byte $00
008CC8  2               
008CC8  2               GroundPaletteData:
008CC8  2  3F 00 20       .byte $3f, $00, $20
008CCB  2  0F 29 1A 0F    .byte $0f, $29, $1a, $0f
008CCF  2  0F 36 17 0F    .byte $0f, $36, $17, $0f
008CD3  2  0F 30 21 0F    .byte $0f, $30, $21, $0f
008CD7  2  0F 27 17 0F    .byte $0f, $27, $17, $0f
008CDB  2  0F 16 27 18    .byte $0f, $16, $27, $18
008CDF  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
008CE3  2  0F 16 30 27    .byte $0f, $16, $30, $27
008CE7  2  0F 0F 36 17    .byte $0f, $0f, $36, $17
008CEB  2  00             .byte $00
008CEC  2               
008CEC  2               UndergroundPaletteData:
008CEC  2  3F 00 20       .byte $3f, $00, $20
008CEF  2  0F 29 1A 09    .byte $0f, $29, $1a, $09
008CF3  2  0F 3C 1C 0F    .byte $0f, $3c, $1c, $0f
008CF7  2  0F 30 21 1C    .byte $0f, $30, $21, $1c
008CFB  2  0F 27 17 1C    .byte $0f, $27, $17, $1c
008CFF  2  0F 16 27 18    .byte $0f, $16, $27, $18
008D03  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
008D07  2  0F 16 30 27    .byte $0f, $16, $30, $27
008D0B  2  0F 0C 3C 1C    .byte $0f, $0c, $3c, $1c
008D0F  2  00             .byte $00
008D10  2               
008D10  2               CastlePaletteData:
008D10  2  3F 00 20       .byte $3f, $00, $20
008D13  2  0F 30 10 00    .byte $0f, $30, $10, $00
008D17  2  0F 30 10 00    .byte $0f, $30, $10, $00
008D1B  2  0F 30 16 00    .byte $0f, $30, $16, $00
008D1F  2  0F 27 17 00    .byte $0f, $27, $17, $00
008D23  2  0F 16 27 18    .byte $0f, $16, $27, $18
008D27  2  0F 1C 36 17    .byte $0f, $1c, $36, $17
008D2B  2  0F 16 30 27    .byte $0f, $16, $30, $27
008D2F  2  0F 00 30 10    .byte $0f, $00, $30, $10
008D33  2  00             .byte $00
008D34  2               
008D34  2               DaySnowPaletteData:
008D34  2  3F 00 04       .byte $3f, $00, $04
008D37  2  22 30 00 10    .byte $22, $30, $00, $10
008D3B  2  00             .byte $00
008D3C  2               
008D3C  2               NightSnowPaletteData:
008D3C  2  3F 00 04       .byte $3f, $00, $04
008D3F  2  0F 30 00 10    .byte $0f, $30, $00, $10
008D43  2  00             .byte $00
008D44  2               
008D44  2               MushroomPaletteData:
008D44  2  3F 00 04       .byte $3f, $00, $04
008D47  2  22 27 16 0F    .byte $22, $27, $16, $0f
008D4B  2  00             .byte $00
008D4C  2               
008D4C  2               BowserPaletteData:
008D4C  2  3F 14 04       .byte $3f, $14, $04
008D4F  2  0F 1A 30 27    .byte $0f, $1a, $30, $27
008D53  2  00             .byte $00
008D54  2               
008D54  2               MarioThanksMessage:
008D54  2               ;"THANK YOU MARIO!"
008D54  2  25 48 10       .byte $25, $48, $10
008D57  2  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24
008D5B  2  14 24        
008D5D  2  22 18 1E 24    .byte $22, $18, $1e, $24
008D61  2  16 0A 1B 12    .byte $16, $0a, $1b, $12, $18, $2b
008D65  2  18 2B        
008D67  2  00             .byte $00
008D68  2               
008D68  2               LuigiThanksMessage:
008D68  2               ;"THANK YOU LUIGI!"
008D68  2  25 48 10       .byte $25, $48, $10
008D6B  2  1D 11 0A 17    .byte $1d, $11, $0a, $17, $14, $24
008D6F  2  14 24        
008D71  2  22 18 1E 24    .byte $22, $18, $1e, $24
008D75  2  15 1E 12 10    .byte $15, $1e, $12, $10, $12, $2b
008D79  2  12 2B        
008D7B  2  00             .byte $00
008D7C  2               
008D7C  2               MushroomRetainerSaved:
008D7C  2               ;"BUT OUR PRINCESS IS IN"
008D7C  2  25 C5 16       .byte $25, $c5, $16
008D7F  2  0B 1E 1D 24    .byte $0b, $1e, $1d, $24, $18, $1e, $1b, $24
008D83  2  18 1E 1B 24  
008D87  2  19 1B 12 17    .byte $19, $1b, $12, $17, $0c, $0e, $1c, $1c, $24
008D8B  2  0C 0E 1C 1C  
008D8F  2  24           
008D90  2  12 1C 24 12    .byte $12, $1c, $24, $12, $17
008D94  2  17           
008D95  2               ;"ANOTHER CASTLE!"
008D95  2  26 05 0F       .byte $26, $05, $0f
008D98  2  0A 17 18 1D    .byte $0a, $17, $18, $1d, $11, $0e, $1b, $24
008D9C  2  11 0E 1B 24  
008DA0  2  0C 0A 1C 1D    .byte $0c, $0a, $1c, $1d, $15, $0e, $2b, $00
008DA4  2  15 0E 2B 00  
008DA8  2               
008DA8  2               PrincessSaved1:
008DA8  2               ;"YOUR QUEST IS OVER."
008DA8  2  25 A7 13       .byte $25, $a7, $13
008DAB  2  22 18 1E 1B    .byte $22, $18, $1e, $1b, $24
008DAF  2  24           
008DB0  2  1A 1E 0E 1C    .byte $1a, $1e, $0e, $1c, $1d, $24
008DB4  2  1D 24        
008DB6  2  12 1C 24 18    .byte $12, $1c, $24, $18, $1f, $0e, $1b, $af
008DBA  2  1F 0E 1B AF  
008DBE  2  00             .byte $00
008DBF  2               
008DBF  2               PrincessSaved2:
008DBF  2               ;"WE PRESENT YOU A NEW QUEST."
008DBF  2  25 E3 1B       .byte $25, $e3, $1b
008DC2  2  20 0E 24       .byte $20, $0e, $24
008DC5  2  19 1B 0E 1C    .byte $19, $1b, $0e, $1c, $0e, $17, $1d, $24
008DC9  2  0E 17 1D 24  
008DCD  2  22 18 1E 24    .byte $22, $18, $1e, $24, $0a, $24, $17, $0e, $20, $24
008DD1  2  0A 24 17 0E  
008DD5  2  20 24        
008DD7  2  1A 1E 0E 1C    .byte $1a, $1e, $0e, $1c, $1d, $af
008DDB  2  1D AF        
008DDD  2  00             .byte $00
008DDE  2               
008DDE  2               WorldSelectMessage1:
008DDE  2               ;"PUSH BUTTON B"
008DDE  2  26 4A 0D       .byte $26, $4a, $0d
008DE1  2  19 1E 1C 11    .byte $19, $1e, $1c, $11, $24
008DE5  2  24           
008DE6  2  0B 1E 1D 1D    .byte $0b, $1e, $1d, $1d, $18, $17, $24, $0b
008DEA  2  18 17 24 0B  
008DEE  2  00             .byte $00
008DEF  2               
008DEF  2               WorldSelectMessage2:
008DEF  2               ;"TO SELECT A WORLD"
008DEF  2  26 88 11       .byte $26, $88, $11
008DF2  2  1D 18 24 1C    .byte $1d, $18, $24, $1c, $0e, $15, $0e, $0c, $1d, $24
008DF6  2  0E 15 0E 0C  
008DFA  2  1D 24        
008DFC  2  0A 24 20 18    .byte $0a, $24, $20, $18, $1b, $15, $0d
008E00  2  1B 15 0D     
008E03  2  00             .byte $00
008E04  2               
008E04  2               ;-------------------------------------------------------------------------------------
008E04  2               ;$04 - address low to jump address
008E04  2               ;$05 - address high to jump address
008E04  2               ;$06 - jump address low
008E04  2               ;$07 - jump address high
008E04  2               
008E04  2               JumpEngine:
008E04  2  0A                  asl          ;shift bit from contents of A
008E05  2  A8                  tay
008E06  2  68                  pla          ;pull saved return address from stack
008E07  2  85 04               sta $04      ;save to indirect
008E09  2  68                  pla
008E0A  2  85 05               sta $05
008E0C  2  C8                  iny
008E0D  2  B1 04               lda ($04),y  ;load pointer from indirect
008E0F  2  85 06               sta $06      ;note that if an RTS is performed in next routine
008E11  2  C8                  iny          ;it will return to the execution before the sub
008E12  2  B1 04               lda ($04),y  ;that called this routine
008E14  2  85 07               sta $07
008E16  2  6C 06 00            jmp ($06)    ;jump to the address we loaded
008E19  2               
008E19  2               ;-------------------------------------------------------------------------------------
008E19  2               
008E19  2               InitializeNameTables:
008E19  2  AD 02 20                   lda PPU_STATUS            ;reset flip-flop
008E1C  2  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;load mirror of ppu reg $2000
008E1F  2  09 10                      ora #%00010000            ;set sprites for first 4k and background for second 4k
008E21  2  29 F0                      and #%11110000            ;clear rest of lower nybble, leave higher alone
008E23  2  20 ED 8E                   jsr WritePPUReg1
008E26  2  A9 24                      lda #$24                  ;set vram address to start of name table 1
008E28  2  20 2D 8E                   jsr WriteNTAddr
008E2B  2  A9 20                      lda #$20                  ;and then set it to name table 0
008E2D  2  8D 06 20     WriteNTAddr:  sta PPU_ADDRESS
008E30  2  A9 00                      lda #$00
008E32  2  8D 06 20                   sta PPU_ADDRESS
008E35  2  A2 04                      ldx #$04                  ;clear name table with blank tile #24
008E37  2  A0 C0                      ldy #$c0
008E39  2  A9 24                      lda #$24
008E3B  2  8D 07 20     InitNTLoop:   sta PPU_DATA              ;count out exactly 768 tiles
008E3E  2  88                         dey
008E3F  2  D0 FA                      bne InitNTLoop
008E41  2  CA                         dex
008E42  2  D0 F7                      bne InitNTLoop
008E44  2  A0 40                      ldy #64                   ;now to clear the attribute table (with zero this time)
008E46  2  8A                         txa
008E47  2  8D 00 03                   sta VRAM_Buffer1_Offset   ;init vram buffer 1 offset
008E4A  2  8D 01 03                   sta VRAM_Buffer1          ;init vram buffer 1
008E4D  2  8D 07 20     InitATLoop:   sta PPU_DATA
008E50  2  88                         dey
008E51  2  D0 FA                      bne InitATLoop
008E53  2  8D 3F 07                   sta HorizontalScroll      ;reset scroll variables
008E56  2  8D 40 07                   sta VerticalScroll
008E59  2  4C E6 8E                   jmp InitScroll            ;initialize scroll registers to zero
008E5C  2               
008E5C  2               ;-------------------------------------------------------------------------------------
008E5C  2               ;$00 - temp joypad bit
008E5C  2               
008E5C  2               ReadJoypads:
008E5C  2  A9 01                      lda #$01               ;reset and clear strobe of joypad ports
008E5E  2  8D 16 40                   sta JOYPAD_PORT
008E61  2  4A                         lsr
008E62  2  AA                         tax                    ;start with joypad 1's port
008E63  2  8D 16 40                   sta JOYPAD_PORT
008E66  2  20 6A 8E                   jsr ReadPortBits
008E69  2  E8                         inx                    ;increment for joypad 2's port
008E6A  2  A0 08        ReadPortBits: ldy #$08
008E6C  2  48           PortLoop:     pha                    ;push previous bit onto stack
008E6D  2  BD 16 40                   lda JOYPAD_PORT,x      ;read current bit on joypad port
008E70  2  85 00                      sta $00                ;check d1 and d0 of port output
008E72  2  4A                         lsr                    ;this is necessary on the old
008E73  2  05 00                      ora $00                ;famicom systems in japan
008E75  2  4A                         lsr
008E76  2  68                         pla                    ;read bits from stack
008E77  2  2A                         rol                    ;rotate bit from carry flag
008E78  2  88                         dey
008E79  2  D0 F1                      bne PortLoop           ;count down bits left
008E7B  2  9D FC 06                   sta SavedJoypadBits,x  ;save controller status here always
008E7E  2  48                         pha
008E7F  2  29 30                      and #%00110000         ;check for select or start
008E81  2  3D 4A 07                   and JoypadBitMask,x    ;if neither saved state nor current state
008E84  2  F0 07                      beq Save8Bits          ;have any of these two set, branch
008E86  2  68                         pla
008E87  2  29 CF                      and #%11001111         ;otherwise store without select
008E89  2  9D FC 06                   sta SavedJoypadBits,x  ;or start bits and leave
008E8C  2  60                         rts
008E8D  2  68           Save8Bits:    pla
008E8E  2  9D 4A 07                   sta JoypadBitMask,x    ;save with all bits in another place and leave
008E91  2  60                         rts
008E92  2               
008E92  2               ;-------------------------------------------------------------------------------------
008E92  2               ;$00 - vram buffer address table low
008E92  2               ;$01 - vram buffer address table high
008E92  2               
008E92  2               WriteBufferToScreen:
008E92  2  8D 06 20                    sta PPU_ADDRESS           ;store high byte of vram address
008E95  2  C8                          iny
008E96  2  B1 00                       lda ($00),y               ;load next byte (second)
008E98  2  8D 06 20                    sta PPU_ADDRESS           ;store low byte of vram address
008E9B  2  C8                          iny
008E9C  2  B1 00                       lda ($00),y               ;load next byte (third)
008E9E  2  0A                          asl                       ;shift to left and save in stack
008E9F  2  48                          pha
008EA0  2  AD 78 07                    lda Mirror_PPU_CTRL_REG1  ;load mirror of $2000,
008EA3  2  09 04                       ora #%00000100            ;set ppu to increment by 32 by default
008EA5  2  B0 02                       bcs SetupWrites           ;if d7 of third byte was clear, ppu will
008EA7  2  29 FB                       and #%11111011            ;only increment by 1
008EA9  2  20 ED 8E     SetupWrites:   jsr WritePPUReg1          ;write to register
008EAC  2  68                          pla                       ;pull from stack and shift to left again
008EAD  2  0A                          asl
008EAE  2  90 03                       bcc GetLength             ;if d6 of third byte was clear, do not repeat byte
008EB0  2  09 02                       ora #%00000010            ;otherwise set d1 and increment Y
008EB2  2  C8                          iny
008EB3  2  4A           GetLength:     lsr                       ;shift back to the right to get proper length
008EB4  2  4A                          lsr                       ;note that d1 will now be in carry
008EB5  2  AA                          tax
008EB6  2  B0 01        OutputToVRAM:  bcs RepeatByte            ;if carry set, repeat loading the same byte
008EB8  2  C8                          iny                       ;otherwise increment Y to load next byte
008EB9  2  B1 00        RepeatByte:    lda ($00),y               ;load more data from buffer and write to vram
008EBB  2  8D 07 20                    sta PPU_DATA
008EBE  2  CA                          dex                       ;done writing?
008EBF  2  D0 F5                       bne OutputToVRAM
008EC1  2  38                          sec
008EC2  2  98                          tya
008EC3  2  65 00                       adc $00                   ;add end length plus one to the indirect at $00
008EC5  2  85 00                       sta $00                   ;to allow this routine to read another set of updates
008EC7  2  A9 00                       lda #$00
008EC9  2  65 01                       adc $01
008ECB  2  85 01                       sta $01
008ECD  2  A9 3F                       lda #$3f                  ;sets vram address to $3f00
008ECF  2  8D 06 20                    sta PPU_ADDRESS
008ED2  2  A9 00                       lda #$00
008ED4  2  8D 06 20                    sta PPU_ADDRESS
008ED7  2  8D 06 20                    sta PPU_ADDRESS           ;then reinitializes it for some reason
008EDA  2  8D 06 20                    sta PPU_ADDRESS
008EDD  2  AE 02 20     UpdateScreen:  ldx PPU_STATUS            ;reset flip-flop
008EE0  2  A0 00                       ldy #$00                  ;load first byte from indirect as a pointer
008EE2  2  B1 00                       lda ($00),y
008EE4  2  D0 AC                       bne WriteBufferToScreen   ;if byte is zero we have no further updates to make here
008EE6  2  8D 05 20     InitScroll:    sta PPU_SCROLL_REG        ;store contents of A into scroll registers
008EE9  2  8D 05 20                    sta PPU_SCROLL_REG        ;and end whatever subroutine led us here
008EEC  2  60                          rts
008EED  2               
008EED  2               ;-------------------------------------------------------------------------------------
008EED  2               
008EED  2               WritePPUReg1:
008EED  2  8D 00 20                    sta PPU_CTRL_REG1         ;write contents of A to PPU register 1
008EF0  2  8D 78 07                    sta Mirror_PPU_CTRL_REG1  ;and its mirror
008EF3  2  60                          rts
008EF4  2               
008EF4  2               ;-------------------------------------------------------------------------------------
008EF4  2               ;$00 - used to store status bar nybbles
008EF4  2               ;$02 - used as temp vram offset
008EF4  2               ;$03 - used to store length of status bar number
008EF4  2               
008EF4  2               ;status bar name table offset and length data
008EF4  2               StatusBarData:
008EF4  2  F0 06              .byte $f0, $06 ; top score display on title screen
008EF6  2  62 06              .byte $62, $06 ; player score
008EF8  2  62 06              .byte $62, $06
008EFA  2  6D 02              .byte $6d, $02 ; coin tally
008EFC  2  6D 02              .byte $6d, $02
008EFE  2  7A 03              .byte $7a, $03 ; game timer
008F00  2               
008F00  2               StatusBarOffset:
008F00  2  06 0C 12 18        .byte $06, $0c, $12, $18, $1e, $24
008F04  2  1E 24        
008F06  2               
008F06  2               PrintStatusBarNumbers:
008F06  2  85 00              sta $00            ;store player-specific offset
008F08  2  20 11 8F           jsr OutputNumbers  ;use first nybble to print the coin display
008F0B  2  A5 00              lda $00            ;move high nybble to low
008F0D  2  4A                 lsr                ;and print to score display
008F0E  2  4A                 lsr
008F0F  2  4A                 lsr
008F10  2  4A                 lsr
008F11  2               
008F11  2               OutputNumbers:
008F11  2  18                        clc                      ;add 1 to low nybble
008F12  2  69 01                     adc #$01
008F14  2  29 0F                     and #%00001111           ;mask out high nybble
008F16  2  C9 06                     cmp #$06
008F18  2  B0 44                     bcs ExitOutputN
008F1A  2  48                        pha                      ;save incremented value to stack for now and
008F1B  2  0A                        asl                      ;shift to left and use as offset
008F1C  2  A8                        tay
008F1D  2  AE 00 03                  ldx VRAM_Buffer1_Offset  ;get current buffer pointer
008F20  2  A9 20                     lda #$20                 ;put at top of screen by default
008F22  2  C0 00                     cpy #$00                 ;are we writing top score on title screen?
008F24  2  D0 02                     bne SetupNums
008F26  2  A9 22                     lda #$22                 ;if so, put further down on the screen
008F28  2  9D 01 03     SetupNums:   sta VRAM_Buffer1,x
008F2B  2  B9 F4 8E                  lda StatusBarData,y      ;write low vram address and length of thing
008F2E  2  9D 02 03                  sta VRAM_Buffer1+1,x     ;we're printing to the buffer
008F31  2  B9 F5 8E                  lda StatusBarData+1,y
008F34  2  9D 03 03                  sta VRAM_Buffer1+2,x
008F37  2  85 03                     sta $03                  ;save length byte in counter
008F39  2  86 02                     stx $02                  ;and buffer pointer elsewhere for now
008F3B  2  68                        pla                      ;pull original incremented value from stack
008F3C  2  AA                        tax
008F3D  2  BD 00 8F                  lda StatusBarOffset,x    ;load offset to value we want to write
008F40  2  38                        sec
008F41  2  F9 F5 8E                  sbc StatusBarData+1,y    ;subtract from length byte we read before
008F44  2  A8                        tay                      ;use value as offset to display digits
008F45  2  A6 02                     ldx $02
008F47  2  B9 D7 07     DigitPLoop:  lda DisplayDigits,y      ;write digits to the buffer
008F4A  2  9D 04 03                  sta VRAM_Buffer1+3,x
008F4D  2  E8                        inx
008F4E  2  C8                        iny
008F4F  2  C6 03                     dec $03                  ;do this until all the digits are written
008F51  2  D0 F4                     bne DigitPLoop
008F53  2  A9 00                     lda #$00                 ;put null terminator at end
008F55  2  9D 04 03                  sta VRAM_Buffer1+3,x
008F58  2  E8                        inx                      ;increment buffer pointer by 3
008F59  2  E8                        inx
008F5A  2  E8                        inx
008F5B  2  8E 00 03                  stx VRAM_Buffer1_Offset  ;store it in case we want to use it again
008F5E  2  60           ExitOutputN: rts
008F5F  2               
008F5F  2               ;-------------------------------------------------------------------------------------
008F5F  2               
008F5F  2               DigitsMathRoutine:
008F5F  2  AD 70 07                 lda OperMode              ;check mode of operation
008F62  2  C9 00                    cmp #TitleScreenModeValue
008F64  2  F0 16                    beq EraseDMods            ;if in title screen mode, branch to lock score
008F66  2  A2 05                    ldx #$05
008F68  2  BD 34 01     AddModLoop: lda DigitModifier,x       ;load digit amount to increment
008F6B  2  18                       clc
008F6C  2  79 D7 07                 adc DisplayDigits,y       ;add to current digit
008F6F  2  30 16                    bmi BorrowOne             ;if result is a negative number, branch to subtract
008F71  2  C9 0A                    cmp #10
008F73  2  B0 19                    bcs CarryOne              ;if digit greater than $09, branch to add
008F75  2  99 D7 07     StoreNewD:  sta DisplayDigits,y       ;store as new score or game timer digit
008F78  2  88                       dey                       ;move onto next digits in score or game timer
008F79  2  CA                       dex                       ;and digit amounts to increment
008F7A  2  10 EC                    bpl AddModLoop            ;loop back if we're not done yet
008F7C  2  A9 00        EraseDMods: lda #$00                  ;store zero here
008F7E  2  A2 06                    ldx #$06                  ;start with the last digit
008F80  2  9D 33 01     EraseMLoop: sta DigitModifier-1,x     ;initialize the digit amounts to increment
008F83  2  CA                       dex
008F84  2  10 FA                    bpl EraseMLoop            ;do this until they're all reset, then leave
008F86  2  60                       rts
008F87  2  DE 33 01     BorrowOne:  dec DigitModifier-1,x     ;decrement the previous digit, then put $09 in
008F8A  2  A9 09                    lda #$09                  ;the game timer digit we're currently on to "borrow
008F8C  2  D0 E7                    bne StoreNewD             ;the one", then do an unconditional branch back
008F8E  2  38           CarryOne:   sec                       ;subtract ten from our digit to make it a
008F8F  2  E9 0A                    sbc #10                   ;proper BCD number, then increment the digit
008F91  2  FE 33 01                 inc DigitModifier-1,x     ;preceding current digit to "carry the one" properly
008F94  2  4C 75 8F                 jmp StoreNewD             ;go back to just after we branched here
008F97  2               
008F97  2               ;-------------------------------------------------------------------------------------
008F97  2               
008F97  2               UpdateTopScore:
008F97  2  A2 05              ldx #$05          ;start with mario's score
008F99  2  20 9E 8F           jsr TopScoreCheck
008F9C  2  A2 0B              ldx #$0b          ;now do luigi's score
008F9E  2               
008F9E  2               TopScoreCheck:
008F9E  2  A0 05                      ldy #$05                 ;start with the lowest digit
008FA0  2  38                         sec
008FA1  2  BD DD 07     GetScoreDiff: lda PlayerScoreDisplay,x ;subtract each player digit from each high score digit
008FA4  2  F9 D7 07                   sbc TopScoreDisplay,y    ;from lowest to highest, if any top score digit exceeds
008FA7  2  CA                         dex                      ;any player digit, borrow will be set until a subsequent
008FA8  2  88                         dey                      ;subtraction clears it (player digit is higher than top)
008FA9  2  10 F6                      bpl GetScoreDiff
008FAB  2  90 0E                      bcc NoTopSc              ;check to see if borrow is still set, if so, no new high score
008FAD  2  E8                         inx                      ;increment X and Y once to the start of the score
008FAE  2  C8                         iny
008FAF  2  BD DD 07     CopyScore:    lda PlayerScoreDisplay,x ;store player's score digits into high score memory area
008FB2  2  99 D7 07                   sta TopScoreDisplay,y
008FB5  2  E8                         inx
008FB6  2  C8                         iny
008FB7  2  C0 06                      cpy #$06                 ;do this until we have stored them all
008FB9  2  90 F4                      bcc CopyScore
008FBB  2  60           NoTopSc:      rts
008FBC  2               
008FBC  2               ;-------------------------------------------------------------------------------------
008FBC  2               
008FBC  2               DefaultSprOffsets:
008FBC  2  04 30 48 60        .byte $04, $30, $48, $60, $78, $90, $a8, $c0
008FC0  2  78 90 A8 C0  
008FC4  2  D8 E8 24 F8        .byte $d8, $e8, $24, $f8, $fc, $28, $2c
008FC8  2  FC 28 2C     
008FCB  2               
008FCB  2               Sprite0Data:
008FCB  2  18 FF 23 58        .byte $18, $ff, $23, $58
008FCF  2               
008FCF  2               ;-------------------------------------------------------------------------------------
008FCF  2               
008FCF  2               InitializeGame:
008FCF  2  A0 6F                     ldy #$6f              ;clear all memory as in initialization procedure,
008FD1  2  20 CC 90                  jsr InitializeMemory  ;but this time, clear only as far as $076f
008FD4  2  A0 1F                     ldy #$1f
008FD6  2  99 B0 07     ClrSndLoop:  sta SoundMemory,y     ;clear out memory used
008FD9  2  88                        dey                   ;by the sound engines
008FDA  2  10 FA                     bpl ClrSndLoop
008FDC  2  A9 18                     lda #$18              ;set demo timer
008FDE  2  8D A2 07                  sta DemoTimer
008FE1  2  20 03 9C                  jsr LoadAreaPointer
008FE4  2               
008FE4  2               InitializeArea:
008FE4  2  A0 4B                       ldy #$4b                 ;clear all memory again, only as far as $074b
008FE6  2  20 CC 90                    jsr InitializeMemory     ;this is only necessary if branching from
008FE9  2  A2 21                       ldx #$21
008FEB  2  A9 00                       lda #$00
008FED  2  9D 80 07     ClrTimersLoop: sta Timers,x             ;clear out memory between
008FF0  2  CA                          dex                      ;$0780 and $07a1
008FF1  2  10 FA                       bpl ClrTimersLoop
008FF3  2  AD 5B 07                    lda HalfwayPage
008FF6  2  AC 52 07                    ldy AltEntranceControl   ;if AltEntranceControl not set, use halfway page, if any found
008FF9  2  F0 03                       beq StartPage
008FFB  2  AD 51 07                    lda EntrancePage         ;otherwise use saved entry page number here
008FFE  2  8D 1A 07     StartPage:     sta ScreenLeft_PageLoc   ;set as value here
009001  2  8D 25 07                    sta CurrentPageLoc       ;also set as current page
009004  2  8D 28 07                    sta BackloadingFlag      ;set flag here if halfway page or saved entry page number found
009007  2  20 38 B0                    jsr GetScreenPosition    ;get pixel coordinates for screen borders
00900A  2  A0 20                       ldy #$20                 ;if on odd numbered page, use $2480 as start of rendering
00900C  2  29 01                       and #%00000001           ;otherwise use $2080, this address used later as name table
00900E  2  F0 02                       beq SetInitNTHigh        ;address for rendering of game area
009010  2  A0 24                       ldy #$24
009012  2  8C 20 07     SetInitNTHigh: sty CurrentNTAddr_High   ;store name table address
009015  2  A0 80                       ldy #$80
009017  2  8C 21 07                    sty CurrentNTAddr_Low
00901A  2  0A                          asl                      ;store LSB of page number in high nybble
00901B  2  0A                          asl                      ;of block buffer column position
00901C  2  0A                          asl
00901D  2  0A                          asl
00901E  2  8D A0 06                    sta BlockBufferColumnPos
009021  2  CE 30 07                    dec AreaObjectLength     ;set area object lengths for all empty
009024  2  CE 31 07                    dec AreaObjectLength+1
009027  2  CE 32 07                    dec AreaObjectLength+2
00902A  2  A9 0B                       lda #$0b                 ;set value for renderer to update 12 column sets
00902C  2  8D 1E 07                    sta ColumnSets           ;12 column sets = 24 metatile columns = 1 1/2 screens
00902F  2  20 22 9C                    jsr GetAreaDataAddrs     ;get enemy and level addresses and load header
009032  2  AD 6A 07                    lda PrimaryHardMode      ;check to see if primary hard mode has been activated
009035  2  D0 10                       bne SetSecHard           ;if so, activate the secondary no matter where we're at
009037  2  AD 5F 07                    lda WorldNumber          ;otherwise check world number
00903A  2  C9 04                       cmp #World5              ;if less than 5, do not activate secondary
00903C  2  90 0C                       bcc CheckHalfway
00903E  2  D0 07                       bne SetSecHard           ;if not equal to, then world > 5, thus activate
009040  2  AD 5C 07                    lda LevelNumber          ;otherwise, world 5, so check level number
009043  2  C9 02                       cmp #Level3              ;if 1 or 2, do not set secondary hard mode flag
009045  2  90 03                       bcc CheckHalfway
009047  2  EE CC 06     SetSecHard:    inc SecondaryHardMode    ;set secondary hard mode flag for areas 5-3 and beyond
00904A  2  AD 5B 07     CheckHalfway:  lda HalfwayPage
00904D  2  F0 05                       beq DoneInitArea
00904F  2  A9 02                       lda #$02                 ;if halfway page set, overwrite start position from header
009051  2  8D 10 07                    sta PlayerEntranceCtrl
009054  2  A9 80        DoneInitArea:  lda #Silence             ;silence music
009056  2  85 FB                       sta AreaMusicQueue
009058  2  A9 01                       lda #$01                 ;disable screen output
00905A  2  8D 74 07                    sta DisableScreenFlag
00905D  2  EE 72 07                    inc OperMode_Task        ;increment one of the modes
009060  2  60                          rts
009061  2               
009061  2               ;-------------------------------------------------------------------------------------
009061  2               
009061  2               PrimaryGameSetup:
009061  2  A9 01              lda #$01
009063  2  8D 57 07           sta FetchNewGameTimerFlag   ;set flag to load game timer from header
009066  2  8D 54 07           sta PlayerSize              ;set player's size to small
009069  2  A9 02              lda #$02
00906B  2  8D 5A 07           sta NumberofLives           ;give each player three lives
00906E  2  8D 61 07           sta OffScr_NumberofLives
009071  2               
009071  2               SecondaryGameSetup:
009071  2  A9 00                     lda #$00
009073  2  8D 74 07                  sta DisableScreenFlag     ;enable screen output
009076  2  A8                        tay
009077  2  99 00 03     ClearVRLoop: sta VRAM_Buffer1-1,y      ;clear buffer at $0300-$03ff
00907A  2  C8                        iny
00907B  2  D0 FA                     bne ClearVRLoop
00907D  2  8D 59 07                  sta GameTimerExpiredFlag  ;clear game timer exp flag
009080  2  8D 69 07                  sta DisableIntermediate   ;clear skip lives display flag
009083  2  8D 28 07                  sta BackloadingFlag       ;clear value here
009086  2  A9 FF                     lda #$ff
009088  2  8D A0 03                  sta BalPlatformAlignment  ;initialize balance platform assignment flag
00908B  2  AD 1A 07                  lda ScreenLeft_PageLoc    ;get left side page location
00908E  2  4E 78 07                  lsr Mirror_PPU_CTRL_REG1  ;shift LSB of ppu register #1 mirror out
009091  2  29 01                     and #$01                  ;mask out all but LSB of page location
009093  2  6A                        ror                       ;rotate LSB of page location into carry then onto mirror
009094  2  2E 78 07                  rol Mirror_PPU_CTRL_REG1  ;this is to set the proper PPU name table
009097  2  20 ED 90                  jsr GetAreaMusic          ;load proper music into queue
00909A  2  A9 38                     lda #$38                  ;load sprite shuffle amounts to be used later
00909C  2  8D E3 06                  sta SprShuffleAmt+2
00909F  2  A9 48                     lda #$48
0090A1  2  8D E2 06                  sta SprShuffleAmt+1
0090A4  2  A9 58                     lda #$58
0090A6  2  8D E1 06                  sta SprShuffleAmt
0090A9  2  A2 0E                     ldx #$0e                  ;load default OAM offsets into $06e4-$06f2
0090AB  2  BD BC 8F     ShufAmtLoop: lda DefaultSprOffsets,x
0090AE  2  9D E4 06                  sta SprDataOffset,x
0090B1  2  CA                        dex                       ;do this until they're all set
0090B2  2  10 F7                     bpl ShufAmtLoop
0090B4  2  A0 03                     ldy #$03                  ;set up sprite #0
0090B6  2  B9 CB 8F     ISpr0Loop:   lda Sprite0Data,y
0090B9  2  99 00 02                  sta Sprite_Data,y
0090BC  2  88                        dey
0090BD  2  10 F7                     bpl ISpr0Loop
0090BF  2  20 AF 92                  jsr DoNothing2            ;these jsrs doesn't do anything useful
0090C2  2  20 AA 92                  jsr DoNothing1
0090C5  2  EE 22 07                  inc Sprite0HitDetectFlag  ;set sprite #0 check flag
0090C8  2  EE 72 07                  inc OperMode_Task         ;increment to next task
0090CB  2  60                        rts
0090CC  2               
0090CC  2               ;-------------------------------------------------------------------------------------
0090CC  2               
0090CC  2               ;$06 - RAM address low
0090CC  2               ;$07 - RAM address high
0090CC  2               
0090CC  2               InitializeMemory:
0090CC  2  A2 07                      ldx #$07          ;set initial high byte to $0700-$07ff
0090CE  2  A9 00                      lda #$00          ;set initial low byte to start of page (at $00 of page)
0090D0  2  85 06                      sta $06
0090D2  2  86 07        InitPageLoop: stx $07
0090D4  2  E0 01        InitByteLoop: cpx #$01          ;check to see if we're on the stack ($0100-$01ff)
0090D6  2  D0 04                      bne InitByte      ;if not, go ahead anyway
0090D8  2  C0 60                      cpy #$60          ;otherwise, check to see if we're at $0160-$01ff
0090DA  2  B0 02                      bcs SkipByte      ;if so, skip write
0090DC  2  91 06        InitByte:     sta ($06),y       ;otherwise, initialize byte with current low byte in Y
0090DE  2  88           SkipByte:     dey
0090DF  2  C0 FF                      cpy #$ff          ;do this until all bytes in page have been erased
0090E1  2  D0 F1                      bne InitByteLoop
0090E3  2  CA                         dex               ;go onto the next page
0090E4  2  10 EC                      bpl InitPageLoop  ;do this until all pages of memory have been erased
0090E6  2  60                         rts
0090E7  2               
0090E7  2               ;-------------------------------------------------------------------------------------
0090E7  2               
0090E7  2               MusicSelectData:
0090E7  2  02 01 04 08        .byte WaterMusic, GroundMusic, UndergroundMusic, CastleMusic
0090EB  2  10 20              .byte CloudMusic, PipeIntroMusic
0090ED  2               
0090ED  2               GetAreaMusic:
0090ED  2  AD 70 07                  lda OperMode           ;if in title screen mode, leave
0090F0  2  F0 23                     beq ExitGetM
0090F2  2  AD 52 07                  lda AltEntranceControl ;check for specific alternate mode of entry
0090F5  2  C9 02                     cmp #$02               ;if found, branch without checking starting position
0090F7  2  F0 0D                     beq ChkAreaType        ;from area object data header
0090F9  2  A0 05                     ldy #$05               ;select music for pipe intro scene by default
0090FB  2  AD 10 07                  lda PlayerEntranceCtrl ;check value from level header for certain values
0090FE  2  C9 06                     cmp #$06
009100  2  F0 0E                     beq StoreMusic         ;load music for pipe intro scene if header
009102  2  C9 07                     cmp #$07               ;start position either value $06 or $07
009104  2  F0 0A                     beq StoreMusic
009106  2  AC 4E 07     ChkAreaType: ldy AreaType           ;load area type as offset for music bit
009109  2  AD 43 07                  lda CloudTypeOverride
00910C  2  F0 02                     beq StoreMusic         ;check for cloud type override
00910E  2  A0 04                     ldy #$04               ;select music for cloud type level if found
009110  2  B9 E7 90     StoreMusic:  lda MusicSelectData,y  ;otherwise select appropriate music for level type
009113  2  85 FB                     sta AreaMusicQueue     ;store in queue and leave
009115  2  60           ExitGetM:    rts
009116  2               
009116  2               ;-------------------------------------------------------------------------------------
009116  2               
009116  2               PlayerStarting_X_Pos:
009116  2  28 18              .byte $28, $18
009118  2  38 28              .byte $38, $28
00911A  2               
00911A  2               AltYPosOffset:
00911A  2  08 00              .byte $08, $00
00911C  2               
00911C  2               PlayerStarting_Y_Pos:
00911C  2  00 20 B0 50        .byte $00, $20, $b0, $50, $00, $00, $b0, $b0
009120  2  00 00 B0 B0  
009124  2  F0                 .byte $f0
009125  2               
009125  2               PlayerBGPriorityData:
009125  2  00 20 00 00        .byte $00, $20, $00, $00, $00, $00, $00, $00
009129  2  00 00 00 00  
00912D  2               
00912D  2               GameTimerData:
00912D  2  20                 .byte $20 ;dummy byte, used as part of bg priority data
00912E  2  04 03 02           .byte $04, $03, $02
009131  2               
009131  2               Entrance_GameTimerSetup:
009131  2  AD 1A 07               lda ScreenLeft_PageLoc      ;set current page for area objects
009134  2  85 6D                  sta Player_PageLoc          ;as page location for player
009136  2  A9 28                  lda #$28                    ;store value here
009138  2  8D 0A 07               sta VerticalForceDown       ;for fractional movement downwards if necessary
00913B  2  A9 01                  lda #$01                    ;set high byte of player position and
00913D  2  85 33                  sta PlayerFacingDir         ;set facing direction so that player faces right
00913F  2  85 B5                  sta Player_Y_HighPos
009141  2  A9 00                  lda #$00                    ;set player state to on the ground by default
009143  2  85 1D                  sta Player_State
009145  2  CE 90 04               dec Player_CollisionBits    ;initialize player's collision bits
009148  2  A0 00                  ldy #$00                    ;initialize halfway page
00914A  2  8C 5B 07               sty HalfwayPage
00914D  2  AD 4E 07               lda AreaType                ;check area type
009150  2  D0 01                  bne ChkStPos                ;if water type, set swimming flag, otherwise do not set
009152  2  C8                     iny
009153  2  8C 04 07     ChkStPos: sty SwimmingFlag
009156  2  AE 10 07               ldx PlayerEntranceCtrl      ;get starting position loaded from header
009159  2  AC 52 07               ldy AltEntranceControl      ;check alternate mode of entry flag for 0 or 1
00915C  2  F0 07                  beq SetStPos
00915E  2  C0 01                  cpy #$01
009160  2  F0 03                  beq SetStPos
009162  2  BE 18 91               ldx AltYPosOffset-2,y       ;if not 0 or 1, override $0710 with new offset in X
009165  2  B9 16 91     SetStPos: lda PlayerStarting_X_Pos,y  ;load appropriate horizontal position
009168  2  85 86                  sta Player_X_Position       ;and vertical positions for the player, using
00916A  2  BD 1C 91               lda PlayerStarting_Y_Pos,x  ;AltEntranceControl as offset for horizontal and either $0710
00916D  2  85 CE                  sta Player_Y_Position       ;or value that overwrote $0710 as offset for vertical
00916F  2  BD 25 91               lda PlayerBGPriorityData,x
009172  2  8D C4 03               sta Player_SprAttrib        ;set player sprite attributes using offset in X
009175  2  20 F1 85               jsr GetPlayerColors         ;get appropriate player palette
009178  2  AC 15 07               ldy GameTimerSetting        ;get timer control value from header
00917B  2  F0 1A                  beq ChkOverR                ;if set to zero, branch (do not use dummy byte for this)
00917D  2  AD 57 07               lda FetchNewGameTimerFlag   ;do we need to set the game timer? if not, use
009180  2  F0 15                  beq ChkOverR                ;old game timer setting
009182  2  B9 2D 91               lda GameTimerData,y         ;if game timer is set and game timer flag is also set,
009185  2  8D F8 07               sta GameTimerDisplay        ;use value of game timer control for first digit of game timer
009188  2  A9 01                  lda #$01
00918A  2  8D FA 07               sta GameTimerDisplay+2      ;set last digit of game timer to 1
00918D  2  4A                     lsr
00918E  2  8D F9 07               sta GameTimerDisplay+1      ;set second digit of game timer
009191  2  8D 57 07               sta FetchNewGameTimerFlag   ;clear flag for game timer reset
009194  2  8D 9F 07               sta StarInvincibleTimer     ;clear star mario timer
009197  2  AC 58 07     ChkOverR: ldy JoypadOverride          ;if controller bits not set, branch to skip this part
00919A  2  F0 14                  beq ChkSwimE
00919C  2  A9 03                  lda #$03                    ;set player state to climbing
00919E  2  85 1D                  sta Player_State
0091A0  2  A2 00                  ldx #$00                    ;set offset for first slot, for block object
0091A2  2  20 84 BD               jsr InitBlock_XY_Pos
0091A5  2  A9 F0                  lda #$f0                    ;set vertical coordinate for block object
0091A7  2  85 D7                  sta Block_Y_Position
0091A9  2  A2 05                  ldx #$05                    ;set offset in X for last enemy object buffer slot
0091AB  2  A0 00                  ldy #$00                    ;set offset in Y for object coordinates used earlier
0091AD  2  20 1E B9               jsr Setup_Vine              ;do a sub to grow vine
0091B0  2  AC 4E 07     ChkSwimE: ldy AreaType                ;if level not water-type,
0091B3  2  D0 03                  bne SetPESub                ;skip this subroutine
0091B5  2  20 0B B7               jsr SetupBubble             ;otherwise, execute sub to set up air bubbles
0091B8  2  A9 07        SetPESub: lda #$07                    ;set to run player entrance subroutine
0091BA  2  85 0E                  sta GameEngineSubroutine    ;on the next frame of game engine
0091BC  2  60                     rts
0091BD  2               
0091BD  2               ;-------------------------------------------------------------------------------------
0091BD  2               
0091BD  2               ;page numbers are in order from -1 to -4
0091BD  2               HalfwayPageNybbles:
0091BD  2  56 40              .byte $56, $40
0091BF  2  65 70              .byte $65, $70
0091C1  2  66 40              .byte $66, $40
0091C3  2  66 40              .byte $66, $40
0091C5  2  66 40              .byte $66, $40
0091C7  2  66 60              .byte $66, $60
0091C9  2  65 70              .byte $65, $70
0091CB  2  00 00              .byte $00, $00
0091CD  2               
0091CD  2               PlayerLoseLife:
0091CD  2  EE 74 07                  inc DisableScreenFlag    ;disable screen and sprite 0 check
0091D0  2  A9 00                     lda #$00
0091D2  2  8D 22 07                  sta Sprite0HitDetectFlag
0091D5  2  A9 80                     lda #Silence             ;silence music
0091D7  2  85 FC                     sta EventMusicQueue
0091D9  2  CE 5A 07                  dec NumberofLives        ;take one life from player
0091DC  2  10 0B                     bpl StillInGame          ;if player still has lives, branch
0091DE  2  A9 00                     lda #$00
0091E0  2  8D 72 07                  sta OperMode_Task        ;initialize mode task,
0091E3  2  A9 03                     lda #GameOverModeValue   ;switch to game over mode
0091E5  2  8D 70 07                  sta OperMode             ;and leave
0091E8  2  60                        rts
0091E9  2  AD 5F 07     StillInGame: lda WorldNumber          ;multiply world number by 2 and use
0091EC  2  0A                        asl                      ;as offset
0091ED  2  AA                        tax
0091EE  2  AD 5C 07                  lda LevelNumber          ;if in area -3 or -4, increment
0091F1  2  29 02                     and #$02                 ;offset by one byte, otherwise
0091F3  2  F0 01                     beq GetHalfway           ;leave offset alone
0091F5  2  E8                        inx
0091F6  2  BC BD 91     GetHalfway:  ldy HalfwayPageNybbles,x ;get halfway page number with offset
0091F9  2  AD 5C 07                  lda LevelNumber          ;check area number's LSB
0091FC  2  4A                        lsr
0091FD  2  98                        tya                      ;if in area -2 or -4, use lower nybble
0091FE  2  B0 04                     bcs MaskHPNyb
009200  2  4A                        lsr                      ;move higher nybble to lower if area
009201  2  4A                        lsr                      ;number is -1 or -3
009202  2  4A                        lsr
009203  2  4A                        lsr
009204  2  29 0F        MaskHPNyb:   and #%00001111           ;mask out all but lower nybble
009206  2  CD 1A 07                  cmp ScreenLeft_PageLoc
009209  2  F0 04                     beq SetHalfway           ;left side of screen must be at the halfway page,
00920B  2  90 02                     bcc SetHalfway           ;otherwise player must start at the
00920D  2  A9 00                     lda #$00                 ;beginning of the level
00920F  2  8D 5B 07     SetHalfway:  sta HalfwayPage          ;store as halfway page for player
009212  2  20 82 92                  jsr TransposePlayers     ;switch players around if 2-player game
009215  2  4C 64 92                  jmp ContinueGame         ;continue the game
009218  2               
009218  2               ;-------------------------------------------------------------------------------------
009218  2               
009218  2               GameOverMode:
009218  2  AD 72 07           lda OperMode_Task
00921B  2  20 04 8E           jsr JumpEngine
00921E  2               
00921E  2  24 92              .word SetupGameOver
009220  2  67 85              .word ScreenRoutines
009222  2  37 92              .word RunGameOver
009224  2               
009224  2               ;-------------------------------------------------------------------------------------
009224  2               
009224  2               SetupGameOver:
009224  2  A9 00              lda #$00                  ;reset screen routine task control for title screen, game,
009226  2  8D 3C 07           sta ScreenRoutineTask     ;and game over modes
009229  2  8D 22 07           sta Sprite0HitDetectFlag  ;disable sprite 0 check
00922C  2  A9 02              lda #GameOverMusic
00922E  2  85 FC              sta EventMusicQueue       ;put game over music in secondary queue
009230  2  EE 74 07           inc DisableScreenFlag     ;disable screen output
009233  2  EE 72 07           inc OperMode_Task         ;set secondary mode to 1
009236  2  60                 rts
009237  2               
009237  2               ;-------------------------------------------------------------------------------------
009237  2               
009237  2               RunGameOver:
009237  2  A9 00              lda #$00              ;reenable screen
009239  2  8D 74 07           sta DisableScreenFlag
00923C  2  AD FC 06           lda SavedJoypad1Bits  ;check controller for start pressed
00923F  2  29 10              and #Start_Button
009241  2  D0 05              bne TerminateGame
009243  2  AD A0 07           lda ScreenTimer       ;if not pressed, wait for
009246  2  D0 39              bne GameIsOn          ;screen timer to expire
009248  2               TerminateGame:
009248  2  A9 80              lda #Silence          ;silence music
00924A  2  85 FC              sta EventMusicQueue
00924C  2  20 82 92           jsr TransposePlayers  ;check if other player can keep
00924F  2  90 13              bcc ContinueGame      ;going, and do so if possible
009251  2  AD 5F 07           lda WorldNumber       ;otherwise put world number of current
009254  2  8D FD 07           sta ContinueWorld     ;player into secret continue function variable
009257  2  A9 00              lda #$00
009259  2  0A                 asl                   ;residual ASL instruction
00925A  2  8D 72 07           sta OperMode_Task     ;reset all modes to title screen and
00925D  2  8D A0 07           sta ScreenTimer       ;leave
009260  2  8D 70 07           sta OperMode
009263  2  60                 rts
009264  2               
009264  2               ContinueGame:
009264  2  20 03 9C                jsr LoadAreaPointer       ;update level pointer with
009267  2  A9 01                   lda #$01                  ;actual world and area numbers, then
009269  2  8D 54 07                sta PlayerSize            ;reset player's size, status, and
00926C  2  EE 57 07                inc FetchNewGameTimerFlag ;set game timer flag to reload
00926F  2  A9 00                   lda #$00                  ;game timer from header
009271  2  8D 47 07                sta TimerControl          ;also set flag for timers to count again
009274  2  8D 56 07                sta PlayerStatus
009277  2  85 0E                   sta GameEngineSubroutine  ;reset task for game core
009279  2  8D 72 07                sta OperMode_Task         ;set modes and leave
00927C  2  A9 01                   lda #$01                  ;if in game over mode, switch back to
00927E  2  8D 70 07                sta OperMode              ;game mode, because game is still on
009281  2  60           GameIsOn:  rts
009282  2               
009282  2               TransposePlayers:
009282  2  38                      sec                       ;set carry flag by default to end game
009283  2  AD 7A 07                lda NumberOfPlayers       ;if only a 1 player game, leave
009286  2  F0 21                   beq ExTrans
009288  2  AD 61 07                lda OffScr_NumberofLives  ;does offscreen player have any lives left?
00928B  2  30 1C                   bmi ExTrans               ;branch if not
00928D  2  AD 53 07                lda CurrentPlayer         ;invert bit to update
009290  2  49 01                   eor #%00000001            ;which player is on the screen
009292  2  8D 53 07                sta CurrentPlayer
009295  2  A2 06                   ldx #$06
009297  2  BD 5A 07     TransLoop: lda OnscreenPlayerInfo,x    ;transpose the information
00929A  2  48                      pha                         ;of the onscreen player
00929B  2  BD 61 07                lda OffscreenPlayerInfo,x   ;with that of the offscreen player
00929E  2  9D 5A 07                sta OnscreenPlayerInfo,x
0092A1  2  68                      pla
0092A2  2  9D 61 07                sta OffscreenPlayerInfo,x
0092A5  2  CA                      dex
0092A6  2  10 EF                   bpl TransLoop
0092A8  2  18                      clc            ;clear carry flag to get game going
0092A9  2  60           ExTrans:   rts
0092AA  2               
0092AA  2               ;-------------------------------------------------------------------------------------
0092AA  2               
0092AA  2               DoNothing1:
0092AA  2  A9 FF              lda #$ff       ;this is residual code, this value is
0092AC  2  8D C9 06           sta $06c9      ;not used anywhere in the program
0092AF  2               DoNothing2:
0092AF  2  60                 rts
0092B0  2               
0092B0  2               ;-------------------------------------------------------------------------------------
0092B0  2               
0092B0  2               AreaParserTaskHandler:
0092B0  2  AC 1F 07                   ldy AreaParserTaskNum     ;check number of tasks here
0092B3  2  D0 05                      bne DoAPTasks             ;if already set, go ahead
0092B5  2  A0 08                      ldy #$08
0092B7  2  8C 1F 07                   sty AreaParserTaskNum     ;otherwise, set eight by default
0092BA  2  88           DoAPTasks:    dey
0092BB  2  98                         tya
0092BC  2  20 C8 92                   jsr AreaParserTasks
0092BF  2  CE 1F 07                   dec AreaParserTaskNum     ;if all tasks not complete do not
0092C2  2  D0 03                      bne SkipATRender          ;render attribute table yet
0092C4  2  20 6A 89                   jsr RenderAttributeTables
0092C7  2  60           SkipATRender: rts
0092C8  2               
0092C8  2               AreaParserTasks:
0092C8  2  20 04 8E           jsr JumpEngine
0092CB  2               
0092CB  2  DB 92              .word IncrementColumnPos
0092CD  2  AE 88              .word RenderAreaGraphics
0092CF  2  AE 88              .word RenderAreaGraphics
0092D1  2  FC 93              .word AreaParserCore
0092D3  2  DB 92              .word IncrementColumnPos
0092D5  2  AE 88              .word RenderAreaGraphics
0092D7  2  AE 88              .word RenderAreaGraphics
0092D9  2  FC 93              .word AreaParserCore
0092DB  2               
0092DB  2               ;-------------------------------------------------------------------------------------
0092DB  2               
0092DB  2               IncrementColumnPos:
0092DB  2  EE 26 07                inc CurrentColumnPos     ;increment column where we're at
0092DE  2  AD 26 07                lda CurrentColumnPos
0092E1  2  29 0F                   and #%00001111           ;mask out higher nybble
0092E3  2  D0 06                   bne NoColWrap
0092E5  2  8D 26 07                sta CurrentColumnPos     ;if no bits left set, wrap back to zero (0-f)
0092E8  2  EE 25 07                inc CurrentPageLoc       ;and increment page number where we're at
0092EB  2  EE A0 06     NoColWrap: inc BlockBufferColumnPos ;increment column offset where we're at
0092EE  2  AD A0 06                lda BlockBufferColumnPos
0092F1  2  29 1F                   and #%00011111           ;mask out all but 5 LSB (0-1f)
0092F3  2  8D A0 06                sta BlockBufferColumnPos ;and save
0092F6  2  60                      rts
0092F7  2               
0092F7  2               ;-------------------------------------------------------------------------------------
0092F7  2               ;$00 - used as counter, store for low nybble for background, ceiling byte for terrain
0092F7  2               ;$01 - used to store floor byte for terrain
0092F7  2               ;$07 - used to store terrain metatile
0092F7  2               ;$06-$07 - used to store block buffer address
0092F7  2               
0092F7  2               BSceneDataOffsets:
0092F7  2  00 30 60           .byte $00, $30, $60
0092FA  2               
0092FA  2               BackSceneryData:
0092FA  2  93 00 00 11     .byte $93, $00, $00, $11, $12, $12, $13, $00 ;clouds
0092FE  2  12 12 13 00  
009302  2  00 51 52 53     .byte $00, $51, $52, $53, $00, $00, $00, $00
009306  2  00 00 00 00  
00930A  2  00 00 01 02     .byte $00, $00, $01, $02, $02, $03, $00, $00
00930E  2  02 03 00 00  
009312  2  00 00 00 00     .byte $00, $00, $00, $00, $91, $92, $93, $00
009316  2  91 92 93 00  
00931A  2  00 00 00 51     .byte $00, $00, $00, $51, $52, $53, $41, $42
00931E  2  52 53 41 42  
009322  2  43 00 00 00     .byte $43, $00, $00, $00, $00, $00, $91, $92
009326  2  00 00 91 92  
00932A  2               
00932A  2  97 87 88 89     .byte $97, $87, $88, $89, $99, $00, $00, $00 ;mountains and bushes
00932E  2  99 00 00 00  
009332  2  11 12 13 A4     .byte $11, $12, $13, $a4, $a5, $a5, $a5, $a6
009336  2  A5 A5 A5 A6  
00933A  2  97 98 99 01     .byte $97, $98, $99, $01, $02, $03, $00, $a4
00933E  2  02 03 00 A4  
009342  2  A5 A6 00 11     .byte $a5, $a6, $00, $11, $12, $12, $12, $13
009346  2  12 12 12 13  
00934A  2  00 00 00 00     .byte $00, $00, $00, $00, $01, $02, $02, $03
00934E  2  01 02 02 03  
009352  2  00 A4 A5 A5     .byte $00, $a4, $a5, $a5, $a6, $00, $00, $00
009356  2  A6 00 00 00  
00935A  2               
00935A  2  11 12 12 13     .byte $11, $12, $12, $13, $00, $00, $00, $00 ;trees and fences
00935E  2  00 00 00 00  
009362  2  00 00 00 9C     .byte $00, $00, $00, $9c, $00, $8b, $aa, $aa
009366  2  00 8B AA AA  
00936A  2  AA AA 11 12     .byte $aa, $aa, $11, $12, $13, $8b, $00, $9c
00936E  2  13 8B 00 9C  
009372  2  9C 00 00 01     .byte $9c, $00, $00, $01, $02, $03, $11, $12
009376  2  02 03 11 12  
00937A  2  12 13 00 00     .byte $12, $13, $00, $00, $00, $00, $aa, $aa
00937E  2  00 00 AA AA  
009382  2  9C AA 00 8B     .byte $9c, $aa, $00, $8b, $00, $01, $02, $03
009386  2  00 01 02 03  
00938A  2               
00938A  2               BackSceneryMetatiles:
00938A  2  80 83 00        .byte $80, $83, $00 ;cloud left
00938D  2  81 84 00        .byte $81, $84, $00 ;cloud middle
009390  2  82 85 00        .byte $82, $85, $00 ;cloud right
009393  2  02 00 00        .byte $02, $00, $00 ;bush left
009396  2  03 00 00        .byte $03, $00, $00 ;bush middle
009399  2  04 00 00        .byte $04, $00, $00 ;bush right
00939C  2  00 05 06        .byte $00, $05, $06 ;mountain left
00939F  2  07 06 0A        .byte $07, $06, $0a ;mountain middle
0093A2  2  00 08 09        .byte $00, $08, $09 ;mountain right
0093A5  2  4D 00 00        .byte $4d, $00, $00 ;fence
0093A8  2  0D 0F 4E        .byte $0d, $0f, $4e ;tall tree
0093AB  2  0E 4E 4E        .byte $0e, $4e, $4e ;short tree
0093AE  2               
0093AE  2               FSceneDataOffsets:
0093AE  2  00 0D 1A           .byte $00, $0d, $1a
0093B1  2               
0093B1  2               ForeSceneryData:
0093B1  2  86 87 87 87     .byte $86, $87, $87, $87, $87, $87, $87   ;in water
0093B5  2  87 87 87     
0093B8  2  87 87 87 87     .byte $87, $87, $87, $87, $69, $69
0093BC  2  69 69        
0093BE  2               
0093BE  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $45, $47   ;wall
0093C2  2  00 45 47     
0093C5  2  47 47 47 47     .byte $47, $47, $47, $47, $00, $00
0093C9  2  00 00        
0093CB  2               
0093CB  2  00 00 00 00     .byte $00, $00, $00, $00, $00, $00, $00   ;over water
0093CF  2  00 00 00     
0093D2  2  00 00 00 00     .byte $00, $00, $00, $00, $86, $87
0093D6  2  86 87        
0093D8  2               
0093D8  2               TerrainMetatiles:
0093D8  2  69 54 52 62        .byte $69, $54, $52, $62
0093DC  2               
0093DC  2               TerrainRenderBits:
0093DC  2  00 00              .byte %00000000, %00000000 ;no ceiling or floor
0093DE  2  00 18              .byte %00000000, %00011000 ;no ceiling, floor 2
0093E0  2  01 18              .byte %00000001, %00011000 ;ceiling 1, floor 2
0093E2  2  07 18              .byte %00000111, %00011000 ;ceiling 3, floor 2
0093E4  2  0F 18              .byte %00001111, %00011000 ;ceiling 4, floor 2
0093E6  2  FF 18              .byte %11111111, %00011000 ;ceiling 8, floor 2
0093E8  2  01 1F              .byte %00000001, %00011111 ;ceiling 1, floor 5
0093EA  2  07 1F              .byte %00000111, %00011111 ;ceiling 3, floor 5
0093EC  2  0F 1F              .byte %00001111, %00011111 ;ceiling 4, floor 5
0093EE  2  81 1F              .byte %10000001, %00011111 ;ceiling 1, floor 6
0093F0  2  01 00              .byte %00000001, %00000000 ;ceiling 1, no floor
0093F2  2  8F 1F              .byte %10001111, %00011111 ;ceiling 4, floor 6
0093F4  2  F1 1F              .byte %11110001, %00011111 ;ceiling 1, floor 9
0093F6  2  F9 18              .byte %11111001, %00011000 ;ceiling 1, middle 5, floor 2
0093F8  2  F1 18              .byte %11110001, %00011000 ;ceiling 1, middle 4, floor 2
0093FA  2  FF 1F              .byte %11111111, %00011111 ;completely solid top to bottom
0093FC  2               
0093FC  2               AreaParserCore:
0093FC  2  AD 28 07           lda BackloadingFlag       ;check to see if we are starting right of start
0093FF  2  F0 03              beq RenderSceneryTerrain  ;if not, go ahead and render background, foreground and terrain
009401  2  20 08 95           jsr ProcessAreaData       ;otherwise skip ahead and load level data
009404  2               
009404  2               RenderSceneryTerrain:
009404  2  A2 0C                  ldx #$0c
009406  2  A9 00                  lda #$00
009408  2  9D A1 06     ClrMTBuf: sta MetatileBuffer,x       ;clear out metatile buffer
00940B  2  CA                     dex
00940C  2  10 FA                  bpl ClrMTBuf
00940E  2  AC 42 07               ldy BackgroundScenery      ;do we need to render the background scenery?
009411  2  F0 42                  beq RendFore               ;if not, skip to check the foreground
009413  2  AD 25 07               lda CurrentPageLoc         ;otherwise check for every third page
009416  2  C9 03        ThirdP:   cmp #$03
009418  2  30 05                  bmi RendBack               ;if less than three we're there
00941A  2  38                     sec
00941B  2  E9 03                  sbc #$03                   ;if 3 or more, subtract 3 and
00941D  2  10 F7                  bpl ThirdP                 ;do an unconditional branch
00941F  2  0A           RendBack: asl                        ;move results to higher nybble
009420  2  0A                     asl
009421  2  0A                     asl
009422  2  0A                     asl
009423  2  79 F6 92               adc BSceneDataOffsets-1,y  ;add to it offset loaded from here
009426  2  6D 26 07               adc CurrentColumnPos       ;add to the result our current column position
009429  2  AA                     tax
00942A  2  BD FA 92               lda BackSceneryData,x      ;load data from sum of offsets
00942D  2  F0 26                  beq RendFore               ;if zero, no scenery for that part
00942F  2  48                     pha
009430  2  29 0F                  and #$0f                   ;save to stack and clear high nybble
009432  2  38                     sec
009433  2  E9 01                  sbc #$01                   ;subtract one (because low nybble is $01-$0c)
009435  2  85 00                  sta $00                    ;save low nybble
009437  2  0A                     asl                        ;multiply by three (shift to left and add result to old one)
009438  2  65 00                  adc $00                    ;note that since d7 was nulled, the carry flag is always clear
00943A  2  AA                     tax                        ;save as offset for background scenery metatile data
00943B  2  68                     pla                        ;get high nybble from stack, move low
00943C  2  4A                     lsr
00943D  2  4A                     lsr
00943E  2  4A                     lsr
00943F  2  4A                     lsr
009440  2  A8                     tay                        ;use as second offset (used to determine height)
009441  2  A9 03                  lda #$03                   ;use previously saved memory location for counter
009443  2  85 00                  sta $00
009445  2  BD 8A 93     SceLoop1: lda BackSceneryMetatiles,x ;load metatile data from offset of (lsb - 1) * 3
009448  2  99 A1 06               sta MetatileBuffer,y       ;store into buffer from offset of (msb / 16)
00944B  2  E8                     inx
00944C  2  C8                     iny
00944D  2  C0 0B                  cpy #$0b                   ;if at this location, leave loop
00944F  2  F0 04                  beq RendFore
009451  2  C6 00                  dec $00                    ;decrement until counter expires, barring exception
009453  2  D0 F0                  bne SceLoop1
009455  2  AE 41 07     RendFore: ldx ForegroundScenery      ;check for foreground data needed or not
009458  2  F0 13                  beq RendTerr               ;if not, skip this part
00945A  2  BC AD 93               ldy FSceneDataOffsets-1,x  ;load offset from location offset by header value, then
00945D  2  A2 00                  ldx #$00                   ;reinit X
00945F  2  B9 B1 93     SceLoop2: lda ForeSceneryData,y      ;load data until counter expires
009462  2  F0 03                  beq NoFore                 ;do not store if zero found
009464  2  9D A1 06               sta MetatileBuffer,x
009467  2  C8           NoFore:   iny
009468  2  E8                     inx
009469  2  E0 0D                  cpx #$0d                   ;store up to end of metatile buffer
00946B  2  D0 F2                  bne SceLoop2
00946D  2  AC 4E 07     RendTerr: ldy AreaType               ;check world type for water level
009470  2  D0 0C                  bne TerMTile               ;if not water level, skip this part
009472  2  AD 5F 07               lda WorldNumber            ;check world number, if not world number eight
009475  2  C9 07                  cmp #World8                ;then skip this part
009477  2  D0 05                  bne TerMTile
009479  2  A9 62                  lda #$62                   ;if set as water level and world number eight,
00947B  2  4C 88 94               jmp StoreMT                ;use castle wall metatile as terrain type
00947E  2  B9 D8 93     TerMTile: lda TerrainMetatiles,y     ;otherwise get appropriate metatile for area type
009481  2  AC 43 07               ldy CloudTypeOverride      ;check for cloud type override
009484  2  F0 02                  beq StoreMT                ;if not set, keep value otherwise
009486  2  A9 88                  lda #$88                   ;use cloud block terrain
009488  2  85 07        StoreMT:  sta $07                    ;store value here
00948A  2  A2 00                  ldx #$00                   ;initialize X, use as metatile buffer offset
00948C  2  AD 27 07               lda TerrainControl         ;use yet another value from the header
00948F  2  0A                     asl                        ;multiply by 2 and use as yet another offset
009490  2  A8                     tay
009491  2  B9 DC 93     TerrLoop: lda TerrainRenderBits,y    ;get one of the terrain rendering bit data
009494  2  85 00                  sta $00
009496  2  C8                     iny                        ;increment Y and use as offset next time around
009497  2  84 01                  sty $01
009499  2  AD 43 07               lda CloudTypeOverride      ;skip if value here is zero
00949C  2  F0 0A                  beq NoCloud2
00949E  2  E0 00                  cpx #$00                   ;otherwise, check if we're doing the ceiling byte
0094A0  2  F0 06                  beq NoCloud2
0094A2  2  A5 00                  lda $00                    ;if not, mask out all but d3
0094A4  2  29 08                  and #%00001000
0094A6  2  85 00                  sta $00
0094A8  2  A0 00        NoCloud2: ldy #$00                   ;start at beginning of bitmasks
0094AA  2  B9 8A C6     TerrBChk: lda Bitmasks,y             ;load bitmask, then perform AND on contents of first byte
0094AD  2  24 00                  bit $00
0094AF  2  F0 05                  beq NextTBit               ;if not set, skip this part (do not write terrain to buffer)
0094B1  2  A5 07                  lda $07
0094B3  2  9D A1 06               sta MetatileBuffer,x       ;load terrain type metatile number and store into buffer here
0094B6  2  E8           NextTBit: inx                        ;continue until end of buffer
0094B7  2  E0 0D                  cpx #$0d
0094B9  2  F0 18                  beq RendBBuf               ;if we're at the end, break out of this loop
0094BB  2  AD 4E 07               lda AreaType               ;check world type for underground area
0094BE  2  C9 02                  cmp #$02
0094C0  2  D0 08                  bne EndUChk                ;if not underground, skip this part
0094C2  2  E0 0B                  cpx #$0b
0094C4  2  D0 04                  bne EndUChk                ;if we're at the bottom of the screen, override
0094C6  2  A9 54                  lda #$54                   ;old terrain type with ground level terrain type
0094C8  2  85 07                  sta $07
0094CA  2  C8           EndUChk:  iny                        ;increment bitmasks offset in Y
0094CB  2  C0 08                  cpy #$08
0094CD  2  D0 DB                  bne TerrBChk               ;if not all bits checked, loop back
0094CF  2  A4 01                  ldy $01
0094D1  2  D0 BE                  bne TerrLoop               ;unconditional branch, use Y to load next byte
0094D3  2  20 08 95     RendBBuf: jsr ProcessAreaData        ;do the area data loading routine now
0094D6  2  AD A0 06               lda BlockBufferColumnPos
0094D9  2  20 E1 9B               jsr GetBlockBufferAddr     ;get block buffer address from where we're at
0094DC  2  A2 00                  ldx #$00
0094DE  2  A0 00                  ldy #$00                   ;init index regs and start at beginning of smaller buffer
0094E0  2  84 00        ChkMTLow: sty $00
0094E2  2  BD A1 06               lda MetatileBuffer,x       ;load stored metatile number
0094E5  2  29 C0                  and #%11000000             ;mask out all but 2 MSB
0094E7  2  0A                     asl
0094E8  2  2A                     rol                        ;make %xx000000 into %000000xx
0094E9  2  2A                     rol
0094EA  2  A8                     tay                        ;use as offset in Y
0094EB  2  BD A1 06               lda MetatileBuffer,x       ;reload original unmasked value here
0094EE  2  D9 04 95               cmp BlockBuffLowBounds,y   ;check for certain values depending on bits set
0094F1  2  B0 02                  bcs StrBlock               ;if equal or greater, branch
0094F3  2  A9 00                  lda #$00                   ;if less, init value before storing
0094F5  2  A4 00        StrBlock: ldy $00                    ;get offset for block buffer
0094F7  2  91 06                  sta ($06),y                ;store value into block buffer
0094F9  2  98                     tya
0094FA  2  18                     clc                        ;add 16 (move down one row) to offset
0094FB  2  69 10                  adc #$10
0094FD  2  A8                     tay
0094FE  2  E8                     inx                        ;increment column value
0094FF  2  E0 0D                  cpx #$0d
009501  2  90 DD                  bcc ChkMTLow               ;continue until we pass last row, then leave
009503  2  60                     rts
009504  2               
009504  2               ;numbers lower than these with the same attribute bits
009504  2               ;will not be stored in the block buffer
009504  2               BlockBuffLowBounds:
009504  2  10 51 88 C0        .byte $10, $51, $88, $c0
009508  2               
009508  2               ;-------------------------------------------------------------------------------------
009508  2               ;$00 - used to store area object identifier
009508  2               ;$07 - used as adder to find proper area object code
009508  2               
009508  2               ProcessAreaData:
009508  2  A2 02                    ldx #$02                 ;start at the end of area object buffer
00950A  2  86 08        ProcADLoop: stx ObjectOffset
00950C  2  A9 00                    lda #$00                 ;reset flag
00950E  2  8D 29 07                 sta BehindAreaParserFlag
009511  2  AC 2C 07                 ldy AreaDataOffset       ;get offset of area data pointer
009514  2  B1 E7                    lda (AreaData),y         ;get first byte of area object
009516  2  C9 FD                    cmp #$fd                 ;if end-of-area, skip all this crap
009518  2  F0 4B                    beq RdyDecode
00951A  2  BD 30 07                 lda AreaObjectLength,x   ;check area object buffer flag
00951D  2  10 46                    bpl RdyDecode            ;if buffer not negative, branch, otherwise
00951F  2  C8                       iny
009520  2  B1 E7                    lda (AreaData),y         ;get second byte of area object
009522  2  0A                       asl                      ;check for page select bit (d7), branch if not set
009523  2  90 0B                    bcc Chk1Row13
009525  2  AD 2B 07                 lda AreaObjectPageSel    ;check page select
009528  2  D0 06                    bne Chk1Row13
00952A  2  EE 2B 07                 inc AreaObjectPageSel    ;if not already set, set it now
00952D  2  EE 2A 07                 inc AreaObjectPageLoc    ;and increment page location
009530  2  88           Chk1Row13:  dey
009531  2  B1 E7                    lda (AreaData),y         ;reread first byte of level object
009533  2  29 0F                    and #$0f                 ;mask out high nybble
009535  2  C9 0D                    cmp #$0d                 ;row 13?
009537  2  D0 1B                    bne Chk1Row14
009539  2  C8                       iny                      ;if so, reread second byte of level object
00953A  2  B1 E7                    lda (AreaData),y
00953C  2  88                       dey                      ;decrement to get ready to read first byte
00953D  2  29 40                    and #%01000000           ;check for d6 set (if not, object is page control)
00953F  2  D0 1C                    bne CheckRear
009541  2  AD 2B 07                 lda AreaObjectPageSel    ;if page select is set, do not reread
009544  2  D0 17                    bne CheckRear
009546  2  C8                       iny                      ;if d6 not set, reread second byte
009547  2  B1 E7                    lda (AreaData),y
009549  2  29 1F                    and #%00011111           ;mask out all but 5 LSB and store in page control
00954B  2  8D 2A 07                 sta AreaObjectPageLoc
00954E  2  EE 2B 07                 inc AreaObjectPageSel    ;increment page select
009551  2  4C 6E 95                 jmp NextAObj
009554  2  C9 0E        Chk1Row14:  cmp #$0e                 ;row 14?
009556  2  D0 05                    bne CheckRear
009558  2  AD 28 07                 lda BackloadingFlag      ;check flag for saved page number and branch if set
00955B  2  D0 08                    bne RdyDecode            ;to render the object (otherwise bg might not look right)
00955D  2  AD 2A 07     CheckRear:  lda AreaObjectPageLoc    ;check to see if current page of level object is
009560  2  CD 25 07                 cmp CurrentPageLoc       ;behind current page of renderer
009563  2  90 06                    bcc SetBehind            ;if so branch
009565  2  20 95 95     RdyDecode:  jsr DecodeAreaData       ;do sub and do not turn on flag
009568  2  4C 71 95                 jmp ChkLength
00956B  2  EE 29 07     SetBehind:  inc BehindAreaParserFlag ;turn on flag if object is behind renderer
00956E  2  20 89 95     NextAObj:   jsr IncAreaObjOffset     ;increment buffer offset and move on
009571  2  A6 08        ChkLength:  ldx ObjectOffset         ;get buffer offset
009573  2  BD 30 07                 lda AreaObjectLength,x   ;check object length for anything stored here
009576  2  30 03                    bmi ProcLoopb            ;if not, branch to handle loopback
009578  2  DE 30 07                 dec AreaObjectLength,x   ;otherwise decrement length or get rid of it
00957B  2  CA           ProcLoopb:  dex                      ;decrement buffer offset
00957C  2  10 8C                    bpl ProcADLoop           ;and loopback unless exceeded buffer
00957E  2  AD 29 07                 lda BehindAreaParserFlag ;check for flag set if objects were behind renderer
009581  2  D0 85                    bne ProcessAreaData      ;branch if true to load more level data, otherwise
009583  2  AD 28 07                 lda BackloadingFlag      ;check for flag set if starting right of page $00
009586  2  D0 80                    bne ProcessAreaData      ;branch if true to load more level data, otherwise leave
009588  2  60           EndAParse:  rts
009589  2               
009589  2               IncAreaObjOffset:
009589  2  EE 2C 07           inc AreaDataOffset    ;increment offset of level pointer
00958C  2  EE 2C 07           inc AreaDataOffset
00958F  2  A9 00              lda #$00              ;reset page select
009591  2  8D 2B 07           sta AreaObjectPageSel
009594  2  60                 rts
009595  2               
009595  2               DecodeAreaData:
009595  2  BD 30 07               lda AreaObjectLength,x     ;check current buffer flag
009598  2  30 03                  bmi Chk1stB
00959A  2  BC 2D 07               ldy AreaObjOffsetBuffer,x  ;if not, get offset from buffer
00959D  2  A2 10        Chk1stB:  ldx #$10                   ;load offset of 16 for special row 15
00959F  2  B1 E7                  lda (AreaData),y           ;get first byte of level object again
0095A1  2  C9 FD                  cmp #$fd
0095A3  2  F0 E3                  beq EndAParse              ;if end of level, leave this routine
0095A5  2  29 0F                  and #$0f                   ;otherwise, mask out low nybble
0095A7  2  C9 0F                  cmp #$0f                   ;row 15?
0095A9  2  F0 08                  beq ChkRow14               ;if so, keep the offset of 16
0095AB  2  A2 08                  ldx #$08                   ;otherwise load offset of 8 for special row 12
0095AD  2  C9 0C                  cmp #$0c                   ;row 12?
0095AF  2  F0 02                  beq ChkRow14               ;if so, keep the offset value of 8
0095B1  2  A2 00                  ldx #$00                   ;otherwise nullify value by default
0095B3  2  86 07        ChkRow14: stx $07                    ;store whatever value we just loaded here
0095B5  2  A6 08                  ldx ObjectOffset           ;get object offset again
0095B7  2  C9 0E                  cmp #$0e                   ;row 14?
0095B9  2  D0 08                  bne ChkRow13
0095BB  2  A9 00                  lda #$00                   ;if so, load offset with $00
0095BD  2  85 07                  sta $07
0095BF  2  A9 2E                  lda #$2e                   ;and load A with another value
0095C1  2  D0 53                  bne NormObj                ;unconditional branch
0095C3  2  C9 0D        ChkRow13: cmp #$0d                   ;row 13?
0095C5  2  D0 1B                  bne ChkSRows
0095C7  2  A9 22                  lda #$22                   ;if so, load offset with 34
0095C9  2  85 07                  sta $07
0095CB  2  C8                     iny                        ;get next byte
0095CC  2  B1 E7                  lda (AreaData),y
0095CE  2  29 40                  and #%01000000             ;mask out all but d6 (page control obj bit)
0095D0  2  F0 63                  beq LeavePar               ;if d6 clear, branch to leave (we handled this earlier)
0095D2  2  B1 E7                  lda (AreaData),y           ;otherwise, get byte again
0095D4  2  29 7F                  and #%01111111             ;mask out d7
0095D6  2  C9 4B                  cmp #$4b                   ;check for loop command in low nybble
0095D8  2  D0 03                  bne Mask2MSB               ;(plus d6 set for object other than page control)
0095DA  2  EE 45 07               inc LoopCommand            ;if loop command, set loop command flag
0095DD  2  29 3F        Mask2MSB: and #%00111111             ;mask out d7 and d6
0095DF  2  4C 16 96               jmp NormObj                ;and jump
0095E2  2  C9 0C        ChkSRows: cmp #$0c                   ;row 12-15?
0095E4  2  B0 27                  bcs SpecObj
0095E6  2  C8                     iny                        ;if not, get second byte of level object
0095E7  2  B1 E7                  lda (AreaData),y
0095E9  2  29 70                  and #%01110000             ;mask out all but d6-d4
0095EB  2  D0 0B                  bne LrgObj                 ;if any bits set, branch to handle large object
0095ED  2  A9 16                  lda #$16
0095EF  2  85 07                  sta $07                    ;otherwise set offset of 24 for small object
0095F1  2  B1 E7                  lda (AreaData),y           ;reload second byte of level object
0095F3  2  29 0F                  and #%00001111             ;mask out higher nybble and jump
0095F5  2  4C 16 96               jmp NormObj
0095F8  2  85 00        LrgObj:   sta $00                    ;store value here (branch for large objects)
0095FA  2  C9 70                  cmp #$70                   ;check for vertical pipe object
0095FC  2  D0 0A                  bne NotWPipe
0095FE  2  B1 E7                  lda (AreaData),y           ;if not, reload second byte
009600  2  29 08                  and #%00001000             ;mask out all but d3 (usage control bit)
009602  2  F0 04                  beq NotWPipe               ;if d3 clear, branch to get original value
009604  2  A9 00                  lda #$00                   ;otherwise, nullify value for warp pipe
009606  2  85 00                  sta $00
009608  2  A5 00        NotWPipe: lda $00                    ;get value and jump ahead
00960A  2  4C 12 96               jmp MoveAOId
00960D  2  C8           SpecObj:  iny                        ;branch here for rows 12-15
00960E  2  B1 E7                  lda (AreaData),y
009610  2  29 70                  and #%01110000             ;get next byte and mask out all but d6-d4
009612  2  4A           MoveAOId: lsr                        ;move d6-d4 to lower nybble
009613  2  4A                     lsr
009614  2  4A                     lsr
009615  2  4A                     lsr
009616  2  85 00        NormObj:  sta $00                    ;store value here (branch for small objects and rows 13 and 14)
009618  2  BD 30 07               lda AreaObjectLength,x     ;is there something stored here already?
00961B  2  10 42                  bpl RunAObj                ;if so, branch to do its particular sub
00961D  2  AD 2A 07               lda AreaObjectPageLoc      ;otherwise check to see if the object we've loaded is on the
009620  2  CD 25 07               cmp CurrentPageLoc         ;same page as the renderer, and if so, branch
009623  2  F0 11                  beq InitRear
009625  2  AC 2C 07               ldy AreaDataOffset         ;if not, get old offset of level pointer
009628  2  B1 E7                  lda (AreaData),y           ;and reload first byte
00962A  2  29 0F                  and #%00001111
00962C  2  C9 0E                  cmp #$0e                   ;row 14?
00962E  2  D0 05                  bne LeavePar
009630  2  AD 28 07               lda BackloadingFlag        ;if so, check backloading flag
009633  2  D0 21                  bne StrAObj                ;if set, branch to render object, else leave
009635  2  60           LeavePar: rts
009636  2  AD 28 07     InitRear: lda BackloadingFlag        ;check backloading flag to see if it's been initialized
009639  2  F0 0B                  beq BackColC               ;branch to column-wise check
00963B  2  A9 00                  lda #$00                   ;if not, initialize both backloading and
00963D  2  8D 28 07               sta BackloadingFlag        ;behind-renderer flags and leave
009640  2  8D 29 07               sta BehindAreaParserFlag
009643  2  85 08                  sta ObjectOffset
009645  2  60           LoopCmdE: rts
009646  2  AC 2C 07     BackColC: ldy AreaDataOffset         ;get first byte again
009649  2  B1 E7                  lda (AreaData),y
00964B  2  29 F0                  and #%11110000             ;mask out low nybble and move high to low
00964D  2  4A                     lsr
00964E  2  4A                     lsr
00964F  2  4A                     lsr
009650  2  4A                     lsr
009651  2  CD 26 07               cmp CurrentColumnPos       ;is this where we're at?
009654  2  D0 DF                  bne LeavePar               ;if not, branch to leave
009656  2  AD 2C 07     StrAObj:  lda AreaDataOffset         ;if so, load area obj offset and store in buffer
009659  2  9D 2D 07               sta AreaObjOffsetBuffer,x
00965C  2  20 89 95               jsr IncAreaObjOffset       ;do sub to increment to next object data
00965F  2  A5 00        RunAObj:  lda $00                    ;get stored value and add offset to it
009661  2  18                     clc                        ;then use the jump engine with current contents of A
009662  2  65 07                  adc $07
009664  2  20 04 8E               jsr JumpEngine
009667  2               
009667  2               ;large objects (rows $00-$0b or 00-11, d6-d4 set)
009667  2  E5 98              .word VerticalPipe         ;used by warp pipes
009669  2  40 97              .word AreaStyleObject
00966B  2  2E 9A              .word RowOfBricks
00966D  2  3E 9A              .word RowOfSolidBlocks
00966F  2  F2 99              .word RowOfCoins
009671  2  50 9A              .word ColumnOfBricks
009673  2  59 9A              .word ColumnOfSolidBlocks
009675  2  E5 98              .word VerticalPipe         ;used by decoration pipes
009677  2               
009677  2               ;objects for special row $0c or 12
009677  2  41 9B              .word Hole_Empty
009679  2  BA 97              .word PulleyRopeObject
00967B  2  79 99              .word Bridge_High
00967D  2  7C 99              .word Bridge_Middle
00967F  2  7F 99              .word Bridge_Low
009681  2  57 99              .word Hole_Water
009683  2  68 99              .word QuestionBlockRow_High
009685  2  6B 99              .word QuestionBlockRow_Low
009687  2               
009687  2               ;objects for special row $0f or 15
009687  2  D0 99              .word EndlessRope
009689  2  D7 99              .word BalancePlatRope
00968B  2  06 98              .word CastleObject
00968D  2  B7 9A              .word StaircaseObject
00968F  2  AB 98              .word ExitPipe
009691  2  94 99              .word FlagBalls_Residual
009693  2               
009693  2               ;small objects (rows $00-$0b or 00-11, d6-d4 all clear)
009693  2  0E 9B              .word QuestionBlock     ;power-up
009695  2  0E 9B              .word QuestionBlock     ;coin
009697  2  0E 9B              .word QuestionBlock     ;hidden, coin
009699  2  01 9B              .word Hidden1UpBlock    ;hidden, 1-up
00969B  2  19 9B              .word BrickWithItem     ;brick, power-up
00969D  2  19 9B              .word BrickWithItem     ;brick, vine
00969F  2  19 9B              .word BrickWithItem     ;brick, star
0096A1  2  14 9B              .word BrickWithCoins    ;brick, coins
0096A3  2  19 9B              .word BrickWithItem     ;brick, 1-up
0096A5  2  6F 98              .word WaterPipe
0096A7  2  19 9A              .word EmptyBlock
0096A9  2  D3 9A              .word Jumpspring
0096AB  2               
0096AB  2               ;objects for special row $0d or 13 (d6 set)
0096AB  2  82 98              .word IntroPipe
0096AD  2  9E 99              .word FlagpoleObject
0096AF  2  09 9A              .word AxeObj
0096B1  2  0E 9A              .word ChainObj
0096B3  2  01 9A              .word CastleBridgeObj
0096B5  2  F2 96              .word ScrollLockObject_Warp
0096B7  2  0D 97              .word ScrollLockObject
0096B9  2  0D 97              .word ScrollLockObject
0096BB  2  2B 97              .word AreaFrenzy            ;flying cheep-cheeps
0096BD  2  2B 97              .word AreaFrenzy            ;bullet bills or swimming cheep-cheeps
0096BF  2  2B 97              .word AreaFrenzy            ;stop frenzy
0096C1  2  45 96              .word LoopCmdE
0096C3  2               
0096C3  2               ;object for special row $0e or 14
0096C3  2  C5 96              .word AlterAreaAttributes
0096C5  2               
0096C5  2               ;-------------------------------------------------------------------------------------
0096C5  2               ;(these apply to all area object subroutines in this section unless otherwise stated)
0096C5  2               ;$00 - used to store offset used to find object code
0096C5  2               ;$07 - starts with adder from area parser, used to store row offset
0096C5  2               
0096C5  2               AlterAreaAttributes:
0096C5  2  BC 2D 07              ldy AreaObjOffsetBuffer,x ;load offset for level object data saved in buffer
0096C8  2  C8                    iny                       ;load second byte
0096C9  2  B1 E7                 lda (AreaData),y
0096CB  2  48                    pha                       ;save in stack for now
0096CC  2  29 40                 and #%01000000
0096CE  2  D0 12                 bne Alter2                ;branch if d6 is set
0096D0  2  68                    pla
0096D1  2  48                    pha                       ;pull and push offset to copy to A
0096D2  2  29 0F                 and #%00001111            ;mask out high nybble and store as
0096D4  2  8D 27 07              sta TerrainControl        ;new terrain height type bits
0096D7  2  68                    pla
0096D8  2  29 30                 and #%00110000            ;pull and mask out all but d5 and d4
0096DA  2  4A                    lsr                       ;move bits to lower nybble and store
0096DB  2  4A                    lsr                       ;as new background scenery bits
0096DC  2  4A                    lsr
0096DD  2  4A                    lsr
0096DE  2  8D 42 07              sta BackgroundScenery     ;then leave
0096E1  2  60                    rts
0096E2  2  68           Alter2:  pla
0096E3  2  29 07                 and #%00000111            ;mask out all but 3 LSB
0096E5  2  C9 04                 cmp #$04                  ;if four or greater, set color control bits
0096E7  2  90 05                 bcc SetFore               ;and nullify foreground scenery bits
0096E9  2  8D 44 07              sta BackgroundColorCtrl
0096EC  2  A9 00                 lda #$00
0096EE  2  8D 41 07     SetFore: sta ForegroundScenery     ;otherwise set new foreground scenery bits
0096F1  2  60                    rts
0096F2  2               
0096F2  2               ;--------------------------------
0096F2  2               
0096F2  2               ScrollLockObject_Warp:
0096F2  2  A2 04                 ldx #$04            ;load value of 4 for game text routine as default
0096F4  2  AD 5F 07              lda WorldNumber     ;warp zone (4-3-2), then check world number
0096F7  2  F0 08                 beq WarpNum
0096F9  2  E8                    inx                 ;if world number > 1, increment for next warp zone (5)
0096FA  2  AC 4E 07              ldy AreaType        ;check area type
0096FD  2  88                    dey
0096FE  2  D0 01                 bne WarpNum         ;if ground area type, increment for last warp zone
009700  2  E8                    inx                 ;(8-7-6) and move on
009701  2  8A           WarpNum: txa
009702  2  8D D6 06              sta WarpZoneControl ;store number here to be used by warp zone routine
009705  2  20 08 88              jsr WriteGameText   ;print text and warp zone numbers
009708  2  A9 0D                 lda #PiranhaPlant
00970A  2  20 16 97              jsr KillEnemies     ;load identifier for piranha plants and do sub
00970D  2               
00970D  2               ScrollLockObject:
00970D  2  AD 23 07           lda ScrollLock      ;invert scroll lock to turn it on
009710  2  49 01              eor #%00000001
009712  2  8D 23 07           sta ScrollLock
009715  2  60                 rts
009716  2               
009716  2               ;--------------------------------
009716  2               ;$00 - used to store enemy identifier in KillEnemies
009716  2               
009716  2               KillEnemies:
009716  2  85 00                   sta $00           ;store identifier here
009718  2  A9 00                   lda #$00
00971A  2  A2 04                   ldx #$04          ;check for identifier in enemy object buffer
00971C  2  B4 16        KillELoop: ldy Enemy_ID,x
00971E  2  C4 00                   cpy $00           ;if not found, branch
009720  2  D0 02                   bne NoKillE
009722  2  95 0F                   sta Enemy_Flag,x  ;if found, deactivate enemy object flag
009724  2  CA           NoKillE:   dex               ;do this until all slots are checked
009725  2  10 F5                   bpl KillELoop
009727  2  60                      rts
009728  2               
009728  2               ;--------------------------------
009728  2               
009728  2               FrenzyIDData:
009728  2  14 17 18           .byte FlyCheepCheepFrenzy, BBill_CCheep_Frenzy, Stop_Frenzy
00972B  2               
00972B  2  A6 00        AreaFrenzy:  ldx $00               ;use area object identifier bit as offset
00972D  2  BD 20 97                  lda FrenzyIDData-8,x  ;note that it starts at 8, thus weird address here
009730  2  A0 05                     ldy #$05
009732  2  88           FreCompLoop: dey                   ;check regular slots of enemy object buffer
009733  2  30 07                     bmi ExitAFrenzy       ;if all slots checked and enemy object not found, branch to store
009735  2  D9 16 00                  cmp Enemy_ID,y    ;check for enemy object in buffer versus frenzy object
009738  2  D0 F8                     bne FreCompLoop
00973A  2  A9 00                     lda #$00              ;if enemy object already present, nullify queue and leave
00973C  2  8D CD 06     ExitAFrenzy: sta EnemyFrenzyQueue  ;store enemy into frenzy queue
00973F  2  60                        rts
009740  2               
009740  2               ;--------------------------------
009740  2               ;$06 - used by MushroomLedge to store length
009740  2               
009740  2               AreaStyleObject:
009740  2  AD 33 07           lda AreaStyle        ;load level object style and jump to the right sub
009743  2  20 04 8E           jsr JumpEngine
009746  2  4C 97              .word TreeLedge        ;also used for cloud type levels
009748  2  78 97              .word MushroomLedge
00974A  2  69 9A              .word BulletBillCannon
00974C  2               
00974C  2               TreeLedge:
00974C  2  20 BB 9B               jsr GetLrgObjAttrib     ;get row and length of green ledge
00974F  2  BD 30 07               lda AreaObjectLength,x  ;check length counter for expiration
009752  2  F0 1F                  beq EndTreeL
009754  2  10 11                  bpl MidTreeL
009756  2  98                     tya
009757  2  9D 30 07               sta AreaObjectLength,x  ;store lower nybble into buffer flag as length of ledge
00975A  2  AD 25 07               lda CurrentPageLoc
00975D  2  0D 26 07               ora CurrentColumnPos    ;are we at the start of the level?
009760  2  F0 05                  beq MidTreeL
009762  2  A9 16                  lda #$16                ;render start of tree ledge
009764  2  4C B0 97               jmp NoUnder
009767  2  A6 07        MidTreeL: ldx $07
009769  2  A9 17                  lda #$17                ;render middle of tree ledge
00976B  2  9D A1 06               sta MetatileBuffer,x    ;note that this is also used if ledge position is
00976E  2  A9 4C                  lda #$4c                ;at the start of level for continuous effect
009770  2  4C AA 97               jmp AllUnder            ;now render the part underneath
009773  2  A9 18        EndTreeL: lda #$18                ;render end of tree ledge
009775  2  4C B0 97               jmp NoUnder
009778  2               
009778  2               MushroomLedge:
009778  2  20 AC 9B               jsr ChkLrgObjLength        ;get shroom dimensions
00977B  2  84 06                  sty $06                    ;store length here for now
00977D  2  90 0C                  bcc EndMushL
00977F  2  BD 30 07               lda AreaObjectLength,x     ;divide length by 2 and store elsewhere
009782  2  4A                     lsr
009783  2  9D 36 07               sta MushroomLedgeHalfLen,x
009786  2  A9 19                  lda #$19                   ;render start of mushroom
009788  2  4C B0 97               jmp NoUnder
00978B  2  A9 1B        EndMushL: lda #$1b                   ;if at the end, render end of mushroom
00978D  2  BC 30 07               ldy AreaObjectLength,x
009790  2  F0 1E                  beq NoUnder
009792  2  BD 36 07               lda MushroomLedgeHalfLen,x ;get divided length and store where length
009795  2  85 06                  sta $06                    ;was stored originally
009797  2  A6 07                  ldx $07
009799  2  A9 1A                  lda #$1a
00979B  2  9D A1 06               sta MetatileBuffer,x       ;render middle of mushroom
00979E  2  C4 06                  cpy $06                    ;are we smack dab in the center?
0097A0  2  D0 2C                  bne MushLExit              ;if not, branch to leave
0097A2  2  E8                     inx
0097A3  2  A9 4F                  lda #$4f
0097A5  2  9D A1 06               sta MetatileBuffer,x       ;render stem top of mushroom underneath the middle
0097A8  2  A9 50                  lda #$50
0097AA  2  E8           AllUnder: inx
0097AB  2  A0 0F                  ldy #$0f                   ;set $0f to render all way down
0097AD  2  4C 7D 9B               jmp RenderUnderPart       ;now render the stem of mushroom
0097B0  2  A6 07        NoUnder:  ldx $07                    ;load row of ledge
0097B2  2  A0 00                  ldy #$00                   ;set 0 for no bottom on this part
0097B4  2  4C 7D 9B               jmp RenderUnderPart
0097B7  2               
0097B7  2               ;--------------------------------
0097B7  2               
0097B7  2               ;tiles used by pulleys and rope object
0097B7  2               PulleyRopeMetatiles:
0097B7  2  42 41 43           .byte $42, $41, $43
0097BA  2               
0097BA  2               PulleyRopeObject:
0097BA  2  20 AC 9B                jsr ChkLrgObjLength       ;get length of pulley/rope object
0097BD  2  A0 00                   ldy #$00                  ;initialize metatile offset
0097BF  2  B0 07                   bcs RenderPul             ;if starting, render left pulley
0097C1  2  C8                      iny
0097C2  2  BD 30 07                lda AreaObjectLength,x    ;if not at the end, render rope
0097C5  2  D0 01                   bne RenderPul
0097C7  2  C8                      iny                       ;otherwise render right pulley
0097C8  2  B9 B7 97     RenderPul: lda PulleyRopeMetatiles,y
0097CB  2  8D A1 06                sta MetatileBuffer        ;render at the top of the screen
0097CE  2  60           MushLExit: rts                       ;and leave
0097CF  2               
0097CF  2               ;--------------------------------
0097CF  2               ;$06 - used to store upper limit of rows for CastleObject
0097CF  2               
0097CF  2               CastleMetatiles:
0097CF  2  00 45 45 45        .byte $00, $45, $45, $45, $00
0097D3  2  00           
0097D4  2  00 48 47 46        .byte $00, $48, $47, $46, $00
0097D8  2  00           
0097D9  2  45 49 49 49        .byte $45, $49, $49, $49, $45
0097DD  2  45           
0097DE  2  47 47 4A 47        .byte $47, $47, $4a, $47, $47
0097E2  2  47           
0097E3  2  47 47 4B 47        .byte $47, $47, $4b, $47, $47
0097E7  2  47           
0097E8  2  49 49 49 49        .byte $49, $49, $49, $49, $49
0097EC  2  49           
0097ED  2  47 4A 47 4A        .byte $47, $4a, $47, $4a, $47
0097F1  2  47           
0097F2  2  47 4B 47 4B        .byte $47, $4b, $47, $4b, $47
0097F6  2  47           
0097F7  2  47 47 47 47        .byte $47, $47, $47, $47, $47
0097FB  2  47           
0097FC  2  4A 47 4A 47        .byte $4a, $47, $4a, $47, $4a
009800  2  4A           
009801  2  4B 47 4B 47        .byte $4b, $47, $4b, $47, $4b
009805  2  4B           
009806  2               
009806  2               CastleObject:
009806  2  20 BB 9B                 jsr GetLrgObjAttrib      ;save lower nybble as starting row
009809  2  84 07                    sty $07                  ;if starting row is above $0a, game will crash!!!
00980B  2  A0 04                    ldy #$04
00980D  2  20 AF 9B                 jsr ChkLrgObjFixedLength ;load length of castle if not already loaded
009810  2  8A                       txa
009811  2  48                       pha                      ;save obj buffer offset to stack
009812  2  BC 30 07                 ldy AreaObjectLength,x   ;use current length as offset for castle data
009815  2  A6 07                    ldx $07                  ;begin at starting row
009817  2  A9 0B                    lda #$0b
009819  2  85 06                    sta $06                  ;load upper limit of number of rows to print
00981B  2  B9 CF 97     CRendLoop:  lda CastleMetatiles,y    ;load current byte using offset
00981E  2  9D A1 06                 sta MetatileBuffer,x
009821  2  E8                       inx                      ;store in buffer and increment buffer offset
009822  2  A5 06                    lda $06
009824  2  F0 07                    beq ChkCFloor            ;have we reached upper limit yet?
009826  2  C8                       iny                      ;if not, increment column-wise
009827  2  C8                       iny                      ;to byte in next row
009828  2  C8                       iny
009829  2  C8                       iny
00982A  2  C8                       iny
00982B  2  C6 06                    dec $06                  ;move closer to upper limit
00982D  2  E0 0B        ChkCFloor:  cpx #$0b                 ;have we reached the row just before floor?
00982F  2  D0 EA                    bne CRendLoop            ;if not, go back and do another row
009831  2  68                       pla
009832  2  AA                       tax                      ;get obj buffer offset from before
009833  2  AD 25 07                 lda CurrentPageLoc
009836  2  F0 36                    beq ExitCastle           ;if we're at page 0, we do not need to do anything else
009838  2  BD 30 07                 lda AreaObjectLength,x   ;check length
00983B  2  C9 01                    cmp #$01                 ;if length almost about to expire, put brick at floor
00983D  2  F0 2A                    beq PlayerStop
00983F  2  A4 07                    ldy $07                  ;check starting row for tall castle ($00)
009841  2  D0 04                    bne NotTall
009843  2  C9 03                    cmp #$03                 ;if found, then check to see if we're at the second column
009845  2  F0 22                    beq PlayerStop
009847  2  C9 02        NotTall:    cmp #$02                 ;if not tall castle, check to see if we're at the third column
009849  2  D0 23                    bne ExitCastle           ;if we aren't and the castle is tall, don't create flag yet
00984B  2  20 CB 9B                 jsr GetAreaObjXPosition  ;otherwise, obtain and save horizontal pixel coordinate
00984E  2  48                       pha
00984F  2  20 4A 99                 jsr FindEmptyEnemySlot   ;find an empty place on the enemy object buffer
009852  2  68                       pla
009853  2  95 87                    sta Enemy_X_Position,x   ;then write horizontal coordinate for star flag
009855  2  AD 25 07                 lda CurrentPageLoc
009858  2  95 6E                    sta Enemy_PageLoc,x      ;set page location for star flag
00985A  2  A9 01                    lda #$01
00985C  2  95 B6                    sta Enemy_Y_HighPos,x    ;set vertical high byte
00985E  2  95 0F                    sta Enemy_Flag,x         ;set flag for buffer
009860  2  A9 90                    lda #$90
009862  2  95 CF                    sta Enemy_Y_Position,x   ;set vertical coordinate
009864  2  A9 31                    lda #StarFlagObject      ;set star flag value in buffer itself
009866  2  95 16                    sta Enemy_ID,x
009868  2  60                       rts
009869  2  A0 52        PlayerStop: ldy #$52                 ;put brick at floor to stop player at end of level
00986B  2  8C AB 06                 sty MetatileBuffer+10    ;this is only done if we're on the second column
00986E  2  60           ExitCastle: rts
00986F  2               
00986F  2               ;--------------------------------
00986F  2               
00986F  2               WaterPipe:
00986F  2  20 BB 9B           jsr GetLrgObjAttrib     ;get row and lower nybble
009872  2  BC 30 07           ldy AreaObjectLength,x  ;get length (residual code, water pipe is 1 col thick)
009875  2  A6 07              ldx $07                 ;get row
009877  2  A9 6B              lda #$6b
009879  2  9D A1 06           sta MetatileBuffer,x    ;draw something here and below it
00987C  2  A9 6C              lda #$6c
00987E  2  9D A2 06           sta MetatileBuffer+1,x
009881  2  60                 rts
009882  2               
009882  2               ;--------------------------------
009882  2               ;$05 - used to store length of vertical shaft in RenderSidewaysPipe
009882  2               ;$06 - used to store leftover horizontal length in RenderSidewaysPipe
009882  2               ; and vertical length in VerticalPipe and GetPipeHeight
009882  2               
009882  2               IntroPipe:
009882  2  A0 03                       ldy #$03                 ;check if length set, if not set, set it
009884  2  20 AF 9B                    jsr ChkLrgObjFixedLength
009887  2  A0 0A                       ldy #$0a                 ;set fixed value and render the sideways part
009889  2  20 B3 98                    jsr RenderSidewaysPipe
00988C  2  B0 10                       bcs NoBlankP             ;if carry flag set, not time to draw vertical pipe part
00988E  2  A2 06                       ldx #$06                 ;blank everything above the vertical pipe part
009890  2  A9 00        VPipeSectLoop: lda #$00                 ;all the way to the top of the screen
009892  2  9D A1 06                    sta MetatileBuffer,x     ;because otherwise it will look like exit pipe
009895  2  CA                          dex
009896  2  10 F8                       bpl VPipeSectLoop
009898  2  B9 DD 98                    lda VerticalPipeData,y   ;draw the end of the vertical pipe part
00989B  2  8D A8 06                    sta MetatileBuffer+7
00989E  2  60           NoBlankP:      rts
00989F  2               
00989F  2               SidePipeShaftData:
00989F  2  15 14              .byte $15, $14  ;used to control whether or not vertical pipe shaft
0098A1  2  00 00              .byte $00, $00  ;is drawn, and if so, controls the metatile number
0098A3  2               SidePipeTopPart:
0098A3  2  15 1E              .byte $15, $1e  ;top part of sideways part of pipe
0098A5  2  1D 1C              .byte $1d, $1c
0098A7  2               SidePipeBottomPart:
0098A7  2  15 21              .byte $15, $21  ;bottom part of sideways part of pipe
0098A9  2  20 1F              .byte $20, $1f
0098AB  2               
0098AB  2               ExitPipe:
0098AB  2  A0 03              ldy #$03                 ;check if length set, if not set, set it
0098AD  2  20 AF 9B           jsr ChkLrgObjFixedLength
0098B0  2  20 BB 9B           jsr GetLrgObjAttrib      ;get vertical length, then plow on through RenderSidewaysPipe
0098B3  2               
0098B3  2               RenderSidewaysPipe:
0098B3  2  88                         dey                       ;decrement twice to make room for shaft at bottom
0098B4  2  88                         dey                       ;and store here for now as vertical length
0098B5  2  84 05                      sty $05
0098B7  2  BC 30 07                   ldy AreaObjectLength,x    ;get length left over and store here
0098BA  2  84 06                      sty $06
0098BC  2  A6 05                      ldx $05                   ;get vertical length plus one, use as buffer offset
0098BE  2  E8                         inx
0098BF  2  B9 9F 98                   lda SidePipeShaftData,y   ;check for value $00 based on horizontal offset
0098C2  2  C9 00                      cmp #$00
0098C4  2  F0 08                      beq DrawSidePart          ;if found, do not draw the vertical pipe shaft
0098C6  2  A2 00                      ldx #$00
0098C8  2  A4 05                      ldy $05                   ;init buffer offset and get vertical length
0098CA  2  20 7D 9B                   jsr RenderUnderPart       ;and render vertical shaft using tile number in A
0098CD  2  18                         clc                       ;clear carry flag to be used by IntroPipe
0098CE  2  A4 06        DrawSidePart: ldy $06                   ;render side pipe part at the bottom
0098D0  2  B9 A3 98                   lda SidePipeTopPart,y
0098D3  2  9D A1 06                   sta MetatileBuffer,x      ;note that the pipe parts are stored
0098D6  2  B9 A7 98                   lda SidePipeBottomPart,y  ;backwards horizontally
0098D9  2  9D A2 06                   sta MetatileBuffer+1,x
0098DC  2  60                         rts
0098DD  2               
0098DD  2               VerticalPipeData:
0098DD  2  11 10              .byte $11, $10 ;used by pipes that lead somewhere
0098DF  2  15 14              .byte $15, $14
0098E1  2  13 12              .byte $13, $12 ;used by decoration pipes
0098E3  2  15 14              .byte $15, $14
0098E5  2               
0098E5  2               VerticalPipe:
0098E5  2  20 39 99               jsr GetPipeHeight
0098E8  2  A5 00                  lda $00                  ;check to see if value was nullified earlier
0098EA  2  F0 04                  beq WarpPipe             ;(if d3, the usage control bit of second byte, was set)
0098EC  2  C8                     iny
0098ED  2  C8                     iny
0098EE  2  C8                     iny
0098EF  2  C8                     iny                      ;add four if usage control bit was not set
0098F0  2  98           WarpPipe: tya                      ;save value in stack
0098F1  2  48                     pha
0098F2  2  AD 60 07               lda AreaNumber
0098F5  2  0D 5F 07               ora WorldNumber          ;if at world 1-1, do not add piranha plant ever
0098F8  2  F0 2B                  beq DrawPipe
0098FA  2  BC 30 07               ldy AreaObjectLength,x   ;if on second column of pipe, branch
0098FD  2  F0 26                  beq DrawPipe             ;(because we only need to do this once)
0098FF  2  20 4A 99               jsr FindEmptyEnemySlot   ;check for an empty moving data buffer space
009902  2  B0 21                  bcs DrawPipe             ;if not found, too many enemies, thus skip
009904  2  20 CB 9B               jsr GetAreaObjXPosition  ;get horizontal pixel coordinate
009907  2  18                     clc
009908  2  69 08                  adc #$08                 ;add eight to put the piranha plant in the center
00990A  2  95 87                  sta Enemy_X_Position,x   ;store as enemy's horizontal coordinate
00990C  2  AD 25 07               lda CurrentPageLoc       ;add carry to current page number
00990F  2  69 00                  adc #$00
009911  2  95 6E                  sta Enemy_PageLoc,x      ;store as enemy's page coordinate
009913  2  A9 01                  lda #$01
009915  2  95 B6                  sta Enemy_Y_HighPos,x
009917  2  95 0F                  sta Enemy_Flag,x         ;activate enemy flag
009919  2  20 D3 9B               jsr GetAreaObjYPosition  ;get piranha plant's vertical coordinate and store here
00991C  2  95 CF                  sta Enemy_Y_Position,x
00991E  2  A9 0D                  lda #PiranhaPlant        ;write piranha plant's value into buffer
009920  2  95 16                  sta Enemy_ID,x
009922  2  20 87 C7               jsr InitPiranhaPlant
009925  2  68           DrawPipe: pla                      ;get value saved earlier and use as Y
009926  2  A8                     tay
009927  2  A6 07                  ldx $07                  ;get buffer offset
009929  2  B9 DD 98               lda VerticalPipeData,y   ;draw the appropriate pipe with the Y we loaded earlier
00992C  2  9D A1 06               sta MetatileBuffer,x     ;render the top of the pipe
00992F  2  E8                     inx
009930  2  B9 DF 98               lda VerticalPipeData+2,y ;render the rest of the pipe
009933  2  A4 06                  ldy $06                  ;subtract one from length and render the part underneath
009935  2  88                     dey
009936  2  4C 7D 9B               jmp RenderUnderPart
009939  2               
009939  2               GetPipeHeight:
009939  2  A0 01              ldy #$01       ;check for length loaded, if not, load
00993B  2  20 AF 9B           jsr ChkLrgObjFixedLength ;pipe length of 2 (horizontal)
00993E  2  20 BB 9B           jsr GetLrgObjAttrib
009941  2  98                 tya            ;get saved lower nybble as height
009942  2  29 07              and #$07       ;save only the three lower bits as
009944  2  85 06              sta $06        ;vertical length, then load Y with
009946  2  BC 30 07           ldy AreaObjectLength,x    ;length left over
009949  2  60                 rts
00994A  2               
00994A  2               FindEmptyEnemySlot:
00994A  2  A2 00                      ldx #$00          ;start at first enemy slot
00994C  2  18           EmptyChkLoop: clc               ;clear carry flag by default
00994D  2  B5 0F                      lda Enemy_Flag,x  ;check enemy buffer for nonzero
00994F  2  F0 05                      beq ExitEmptyChk  ;if zero, leave
009951  2  E8                         inx
009952  2  E0 05                      cpx #$05          ;if nonzero, check next value
009954  2  D0 F6                      bne EmptyChkLoop
009956  2  60           ExitEmptyChk: rts               ;if all values nonzero, carry flag is set
009957  2               
009957  2               ;--------------------------------
009957  2               
009957  2               Hole_Water:
009957  2  20 AC 9B           jsr ChkLrgObjLength   ;get low nybble and save as length
00995A  2  A9 86              lda #$86              ;render waves
00995C  2  8D AB 06           sta MetatileBuffer+10
00995F  2  A2 0B              ldx #$0b
009961  2  A0 01              ldy #$01              ;now render the water underneath
009963  2  A9 87              lda #$87
009965  2  4C 7D 9B           jmp RenderUnderPart
009968  2               
009968  2               ;--------------------------------
009968  2               
009968  2               QuestionBlockRow_High:
009968  2  A9 03              lda #$03    ;start on the fourth row
00996A  2  2C                 .byte $2c     ;BIT instruction opcode
00996B  2               
00996B  2               QuestionBlockRow_Low:
00996B  2  A9 07              lda #$07             ;start on the eighth row
00996D  2  48                 pha                  ;save whatever row to the stack for now
00996E  2  20 AC 9B           jsr ChkLrgObjLength  ;get low nybble and save as length
009971  2  68                 pla
009972  2  AA                 tax                  ;render question boxes with coins
009973  2  A9 C0              lda #$c0
009975  2  9D A1 06           sta MetatileBuffer,x
009978  2  60                 rts
009979  2               
009979  2               ;--------------------------------
009979  2               
009979  2               Bridge_High:
009979  2  A9 06              lda #$06  ;start on the seventh row from top of screen
00997B  2  2C                 .byte $2c   ;BIT instruction opcode
00997C  2               
00997C  2               Bridge_Middle:
00997C  2  A9 07              lda #$07  ;start on the eighth row
00997E  2  2C                 .byte $2c   ;BIT instruction opcode
00997F  2               
00997F  2               Bridge_Low:
00997F  2  A9 09              lda #$09             ;start on the tenth row
009981  2  48                 pha                  ;save whatever row to the stack for now
009982  2  20 AC 9B           jsr ChkLrgObjLength  ;get low nybble and save as length
009985  2  68                 pla
009986  2  AA                 tax                  ;render bridge railing
009987  2  A9 0B              lda #$0b
009989  2  9D A1 06           sta MetatileBuffer,x
00998C  2  E8                 inx
00998D  2  A0 00              ldy #$00             ;now render the bridge itself
00998F  2  A9 63              lda #$63
009991  2  4C 7D 9B           jmp RenderUnderPart
009994  2               
009994  2               ;--------------------------------
009994  2               
009994  2               FlagBalls_Residual:
009994  2  20 BB 9B           jsr GetLrgObjAttrib  ;get low nybble from object byte
009997  2  A2 02              ldx #$02             ;render flag balls on third row from top
009999  2  A9 6D              lda #$6d             ;of screen downwards based on low nybble
00999B  2  4C 7D 9B           jmp RenderUnderPart
00999E  2               
00999E  2               ;--------------------------------
00999E  2               
00999E  2               FlagpoleObject:
00999E  2  A9 24              lda #$24                 ;render flagpole ball on top
0099A0  2  8D A1 06           sta MetatileBuffer
0099A3  2  A2 01              ldx #$01                 ;now render the flagpole shaft
0099A5  2  A0 08              ldy #$08
0099A7  2  A9 25              lda #$25
0099A9  2  20 7D 9B           jsr RenderUnderPart
0099AC  2  A9 61              lda #$61                 ;render solid block at the bottom
0099AE  2  8D AB 06           sta MetatileBuffer+10
0099B1  2  20 CB 9B           jsr GetAreaObjXPosition
0099B4  2  38                 sec                      ;get pixel coordinate of where the flagpole is,
0099B5  2  E9 08              sbc #$08                 ;subtract eight pixels and use as horizontal
0099B7  2  85 8C              sta Enemy_X_Position+5   ;coordinate for the flag
0099B9  2  AD 25 07           lda CurrentPageLoc
0099BC  2  E9 00              sbc #$00                 ;subtract borrow from page location and use as
0099BE  2  85 73              sta Enemy_PageLoc+5      ;page location for the flag
0099C0  2  A9 30              lda #$30
0099C2  2  85 D4              sta Enemy_Y_Position+5   ;set vertical coordinate for flag
0099C4  2  A9 B0              lda #$b0
0099C6  2  8D 0D 01           sta FlagpoleFNum_Y_Pos   ;set initial vertical coordinate for flagpole's floatey number
0099C9  2  A9 30              lda #FlagpoleFlagObject
0099CB  2  85 1B              sta Enemy_ID+5           ;set flag identifier, note that identifier and coordinates
0099CD  2  E6 14              inc Enemy_Flag+5         ;use last space in enemy object buffer
0099CF  2  60                 rts
0099D0  2               
0099D0  2               ;--------------------------------
0099D0  2               
0099D0  2               EndlessRope:
0099D0  2  A2 00              ldx #$00       ;render rope from the top to the bottom of screen
0099D2  2  A0 0F              ldy #$0f
0099D4  2  4C E9 99           jmp DrawRope
0099D7  2               
0099D7  2               BalancePlatRope:
0099D7  2  8A                     txa                 ;save object buffer offset for now
0099D8  2  48                     pha
0099D9  2  A2 01                  ldx #$01            ;blank out all from second row to the bottom
0099DB  2  A0 0F                  ldy #$0f            ;with blank used for balance platform rope
0099DD  2  A9 44                  lda #$44
0099DF  2  20 7D 9B               jsr RenderUnderPart
0099E2  2  68                     pla                 ;get back object buffer offset
0099E3  2  AA                     tax
0099E4  2  20 BB 9B               jsr GetLrgObjAttrib ;get vertical length from lower nybble
0099E7  2  A2 01                  ldx #$01
0099E9  2  A9 40        DrawRope: lda #$40            ;render the actual rope
0099EB  2  4C 7D 9B               jmp RenderUnderPart
0099EE  2               
0099EE  2               ;--------------------------------
0099EE  2               
0099EE  2               CoinMetatileData:
0099EE  2  C3 C2 C2 C2        .byte $c3, $c2, $c2, $c2
0099F2  2               
0099F2  2               RowOfCoins:
0099F2  2  AC 4E 07           ldy AreaType            ;get area type
0099F5  2  B9 EE 99           lda CoinMetatileData,y  ;load appropriate coin metatile
0099F8  2  4C 44 9A           jmp GetRow
0099FB  2               
0099FB  2               ;--------------------------------
0099FB  2               
0099FB  2               C_ObjectRow:
0099FB  2  06 07 08           .byte $06, $07, $08
0099FE  2               
0099FE  2               C_ObjectMetatile:
0099FE  2  C5 0C 89           .byte $c5, $0c, $89
009A01  2               
009A01  2               CastleBridgeObj:
009A01  2  A0 0C              ldy #$0c                  ;load length of 13 columns
009A03  2  20 AF 9B           jsr ChkLrgObjFixedLength
009A06  2  4C 0E 9A           jmp ChainObj
009A09  2               
009A09  2               AxeObj:
009A09  2  A9 08              lda #$08                  ;load bowser's palette into sprite portion of palette
009A0B  2  8D 73 07           sta VRAM_Buffer_AddrCtrl
009A0E  2               
009A0E  2               ChainObj:
009A0E  2  A4 00              ldy $00                   ;get value loaded earlier from decoder
009A10  2  BE F9 99           ldx C_ObjectRow-2,y       ;get appropriate row and metatile for object
009A13  2  B9 FC 99           lda C_ObjectMetatile-2,y
009A16  2  4C 20 9A           jmp ColObj
009A19  2               
009A19  2               EmptyBlock:
009A19  2  20 BB 9B             jsr GetLrgObjAttrib  ;get row location
009A1C  2  A6 07                ldx $07
009A1E  2  A9 C4                lda #$c4
009A20  2  A0 00        ColObj: ldy #$00             ;column length of 1
009A22  2  4C 7D 9B             jmp RenderUnderPart
009A25  2               
009A25  2               ;--------------------------------
009A25  2               
009A25  2               SolidBlockMetatiles:
009A25  2  69 61 61 62        .byte $69, $61, $61, $62
009A29  2               
009A29  2               BrickMetatiles:
009A29  2  22 51 52 52        .byte $22, $51, $52, $52
009A2D  2  88                 .byte $88 ;used only by row of bricks object
009A2E  2               
009A2E  2               RowOfBricks:
009A2E  2  AC 4E 07                 ldy AreaType           ;load area type obtained from area offset pointer
009A31  2  AD 43 07                 lda CloudTypeOverride  ;check for cloud type override
009A34  2  F0 02                    beq DrawBricks
009A36  2  A0 04                    ldy #$04               ;if cloud type, override area type
009A38  2  B9 29 9A     DrawBricks: lda BrickMetatiles,y   ;get appropriate metatile
009A3B  2  4C 44 9A                 jmp GetRow             ;and go render it
009A3E  2               
009A3E  2               RowOfSolidBlocks:
009A3E  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset pointer
009A41  2  B9 25 9A              lda SolidBlockMetatiles,y  ;get metatile
009A44  2  48           GetRow:  pha                        ;store metatile here
009A45  2  20 AC 9B              jsr ChkLrgObjLength        ;get row number, load length
009A48  2  A6 07        DrawRow: ldx $07
009A4A  2  A0 00                 ldy #$00                   ;set vertical height of 1
009A4C  2  68                    pla
009A4D  2  4C 7D 9B              jmp RenderUnderPart        ;render object
009A50  2               
009A50  2               ColumnOfBricks:
009A50  2  AC 4E 07           ldy AreaType          ;load area type obtained from area offset
009A53  2  B9 29 9A           lda BrickMetatiles,y  ;get metatile (no cloud override as for row)
009A56  2  4C 5F 9A           jmp GetRow2
009A59  2               
009A59  2               ColumnOfSolidBlocks:
009A59  2  AC 4E 07              ldy AreaType               ;load area type obtained from area offset
009A5C  2  B9 25 9A              lda SolidBlockMetatiles,y  ;get metatile
009A5F  2  48           GetRow2: pha                        ;save metatile to stack for now
009A60  2  20 BB 9B              jsr GetLrgObjAttrib        ;get length and row
009A63  2  68                    pla                        ;restore metatile
009A64  2  A6 07                 ldx $07                    ;get starting row
009A66  2  4C 7D 9B              jmp RenderUnderPart        ;now render the column
009A69  2               
009A69  2               ;--------------------------------
009A69  2               
009A69  2               BulletBillCannon:
009A69  2  20 BB 9B                  jsr GetLrgObjAttrib      ;get row and length of bullet bill cannon
009A6C  2  A6 07                     ldx $07                  ;start at first row
009A6E  2  A9 64                     lda #$64                 ;render bullet bill cannon
009A70  2  9D A1 06                  sta MetatileBuffer,x
009A73  2  E8                        inx
009A74  2  88                        dey                      ;done yet?
009A75  2  30 0E                     bmi SetupCannon
009A77  2  A9 65                     lda #$65                 ;if not, render middle part
009A79  2  9D A1 06                  sta MetatileBuffer,x
009A7C  2  E8                        inx
009A7D  2  88                        dey                      ;done yet?
009A7E  2  30 05                     bmi SetupCannon
009A80  2  A9 66                     lda #$66                 ;if not, render bottom until length expires
009A82  2  20 7D 9B                  jsr RenderUnderPart
009A85  2  AE 6A 04     SetupCannon: ldx Cannon_Offset        ;get offset for data used by cannons and whirlpools
009A88  2  20 D3 9B                  jsr GetAreaObjYPosition  ;get proper vertical coordinate for cannon
009A8B  2  9D 77 04                  sta Cannon_Y_Position,x  ;and store it here
009A8E  2  AD 25 07                  lda CurrentPageLoc
009A91  2  9D 6B 04                  sta Cannon_PageLoc,x     ;store page number for cannon here
009A94  2  20 CB 9B                  jsr GetAreaObjXPosition  ;get proper horizontal coordinate for cannon
009A97  2  9D 71 04                  sta Cannon_X_Position,x  ;and store it here
009A9A  2  E8                        inx
009A9B  2  E0 06                     cpx #$06                 ;increment and check offset
009A9D  2  90 02                     bcc StrCOffset           ;if not yet reached sixth cannon, branch to save offset
009A9F  2  A2 00                     ldx #$00                 ;otherwise initialize it
009AA1  2  8E 6A 04     StrCOffset:  stx Cannon_Offset        ;save new offset and leave
009AA4  2  60                        rts
009AA5  2               
009AA5  2               ;--------------------------------
009AA5  2               
009AA5  2               StaircaseHeightData:
009AA5  2  07 07 06 05        .byte $07, $07, $06, $05, $04, $03, $02, $01, $00
009AA9  2  04 03 02 01  
009AAD  2  00           
009AAE  2               
009AAE  2               StaircaseRowData:
009AAE  2  03 03 04 05        .byte $03, $03, $04, $05, $06, $07, $08, $09, $0a
009AB2  2  06 07 08 09  
009AB6  2  0A           
009AB7  2               
009AB7  2               StaircaseObject:
009AB7  2  20 AC 9B                jsr ChkLrgObjLength       ;check and load length
009ABA  2  90 05                   bcc NextStair             ;if length already loaded, skip init part
009ABC  2  A9 09                   lda #$09                  ;start past the end for the bottom
009ABE  2  8D 34 07                sta StaircaseControl      ;of the staircase
009AC1  2  CE 34 07     NextStair: dec StaircaseControl      ;move onto next step (or first if starting)
009AC4  2  AC 34 07                ldy StaircaseControl
009AC7  2  BE AE 9A                ldx StaircaseRowData,y    ;get starting row and height to render
009ACA  2  B9 A5 9A                lda StaircaseHeightData,y
009ACD  2  A8                      tay
009ACE  2  A9 61                   lda #$61                  ;now render solid block staircase
009AD0  2  4C 7D 9B                jmp RenderUnderPart
009AD3  2               
009AD3  2               ;--------------------------------
009AD3  2               
009AD3  2               Jumpspring:
009AD3  2  20 BB 9B           jsr GetLrgObjAttrib
009AD6  2  20 4A 99           jsr FindEmptyEnemySlot      ;find empty space in enemy object buffer
009AD9  2  20 CB 9B           jsr GetAreaObjXPosition     ;get horizontal coordinate for jumpspring
009ADC  2  95 87              sta Enemy_X_Position,x      ;and store
009ADE  2  AD 25 07           lda CurrentPageLoc          ;store page location of jumpspring
009AE1  2  95 6E              sta Enemy_PageLoc,x
009AE3  2  20 D3 9B           jsr GetAreaObjYPosition     ;get vertical coordinate for jumpspring
009AE6  2  95 CF              sta Enemy_Y_Position,x      ;and store
009AE8  2  95 58              sta Jumpspring_FixedYPos,x  ;store as permanent coordinate here
009AEA  2  A9 32              lda #JumpspringObject
009AEC  2  95 16              sta Enemy_ID,x              ;write jumpspring object to enemy object buffer
009AEE  2  A0 01              ldy #$01
009AF0  2  94 B6              sty Enemy_Y_HighPos,x       ;store vertical high byte
009AF2  2  F6 0F              inc Enemy_Flag,x            ;set flag for enemy object buffer
009AF4  2  A6 07              ldx $07
009AF6  2  A9 67              lda #$67                    ;draw metatiles in two rows where jumpspring is
009AF8  2  9D A1 06           sta MetatileBuffer,x
009AFB  2  A9 68              lda #$68
009AFD  2  9D A2 06           sta MetatileBuffer+1,x
009B00  2  60                 rts
009B01  2               
009B01  2               ;--------------------------------
009B01  2               ;$07 - used to save ID of brick object
009B01  2               
009B01  2               Hidden1UpBlock:
009B01  2  AD 5D 07           lda Hidden1UpFlag  ;if flag not set, do not render object
009B04  2  F0 36              beq ExitDecBlock
009B06  2  A9 00              lda #$00           ;if set, init for the next one
009B08  2  8D 5D 07           sta Hidden1UpFlag
009B0B  2  4C 19 9B           jmp BrickWithItem  ;jump to code shared with unbreakable bricks
009B0E  2               
009B0E  2               QuestionBlock:
009B0E  2  20 36 9B           jsr GetAreaObjectID ;get value from level decoder routine
009B11  2  4C 2C 9B           jmp DrawQBlk        ;go to render it
009B14  2               
009B14  2               BrickWithCoins:
009B14  2  A9 00              lda #$00                 ;initialize multi-coin timer flag
009B16  2  8D BC 06           sta BrickCoinTimerFlag
009B19  2               
009B19  2               BrickWithItem:
009B19  2  20 36 9B               jsr GetAreaObjectID         ;save area object ID
009B1C  2  84 07                  sty $07
009B1E  2  A9 00                  lda #$00                    ;load default adder for bricks with lines
009B20  2  AC 4E 07               ldy AreaType                ;check level type for ground level
009B23  2  88                     dey
009B24  2  F0 02                  beq BWithL                  ;if ground type, do not start with 5
009B26  2  A9 05                  lda #$05                    ;otherwise use adder for bricks without lines
009B28  2  18           BWithL:   clc                         ;add object ID to adder
009B29  2  65 07                  adc $07
009B2B  2  A8                     tay                         ;use as offset for metatile
009B2C  2  B9 E8 BD     DrawQBlk: lda BrickQBlockMetatiles,y  ;get appropriate metatile for brick (question block
009B2F  2  48                     pha                         ;if branched to here from question block routine)
009B30  2  20 BB 9B               jsr GetLrgObjAttrib         ;get row from location byte
009B33  2  4C 48 9A               jmp DrawRow                 ;now render the object
009B36  2               
009B36  2               GetAreaObjectID:
009B36  2  A5 00                      lda $00    ;get value saved from area parser routine
009B38  2  38                         sec
009B39  2  E9 00                      sbc #$00   ;possibly residual code
009B3B  2  A8                         tay        ;save to Y
009B3C  2  60           ExitDecBlock: rts
009B3D  2               
009B3D  2               ;--------------------------------
009B3D  2               
009B3D  2               HoleMetatiles:
009B3D  2  87 00 00 00        .byte $87, $00, $00, $00
009B41  2               
009B41  2               Hole_Empty:
009B41  2  20 AC 9B                 jsr ChkLrgObjLength          ;get lower nybble and save as length
009B44  2  90 2D                    bcc NoWhirlP                 ;skip this part if length already loaded
009B46  2  AD 4E 07                 lda AreaType                 ;check for water type level
009B49  2  D0 28                    bne NoWhirlP                 ;if not water type, skip this part
009B4B  2  AE 6A 04                 ldx Whirlpool_Offset         ;get offset for data used by cannons and whirlpools
009B4E  2  20 CB 9B                 jsr GetAreaObjXPosition      ;get proper vertical coordinate of where we're at
009B51  2  38                       sec
009B52  2  E9 10                    sbc #$10                     ;subtract 16 pixels
009B54  2  9D 71 04                 sta Whirlpool_LeftExtent,x   ;store as left extent of whirlpool
009B57  2  AD 25 07                 lda CurrentPageLoc           ;get page location of where we're at
009B5A  2  E9 00                    sbc #$00                     ;subtract borrow
009B5C  2  9D 6B 04                 sta Whirlpool_PageLoc,x      ;save as page location of whirlpool
009B5F  2  C8                       iny
009B60  2  C8                       iny                          ;increment length by 2
009B61  2  98                       tya
009B62  2  0A                       asl                          ;multiply by 16 to get size of whirlpool
009B63  2  0A                       asl                          ;note that whirlpool will always be
009B64  2  0A                       asl                          ;two blocks bigger than actual size of hole
009B65  2  0A                       asl                          ;and extend one block beyond each edge
009B66  2  9D 77 04                 sta Whirlpool_Length,x       ;save size of whirlpool here
009B69  2  E8                       inx
009B6A  2  E0 05                    cpx #$05                     ;increment and check offset
009B6C  2  90 02                    bcc StrWOffset               ;if not yet reached fifth whirlpool, branch to save offset
009B6E  2  A2 00                    ldx #$00                     ;otherwise initialize it
009B70  2  8E 6A 04     StrWOffset: stx Whirlpool_Offset         ;save new offset here
009B73  2  AE 4E 07     NoWhirlP:   ldx AreaType                 ;get appropriate metatile, then
009B76  2  BD 3D 9B                 lda HoleMetatiles,x          ;render the hole proper
009B79  2  A2 08                    ldx #$08
009B7B  2  A0 0F                    ldy #$0f                     ;start at ninth row and go to bottom, run RenderUnderPart
009B7D  2               
009B7D  2               ;--------------------------------
009B7D  2               
009B7D  2               RenderUnderPart:
009B7D  2  8C 35 07                  sty AreaObjectHeight  ;store vertical length to render
009B80  2  BC A1 06                  ldy MetatileBuffer,x  ;check current spot to see if there's something
009B83  2  F0 18                     beq DrawThisRow       ;we need to keep, if nothing, go ahead
009B85  2  C0 17                     cpy #$17
009B87  2  F0 17                     beq WaitOneRow        ;if middle part (tree ledge), wait until next row
009B89  2  C0 1A                     cpy #$1a
009B8B  2  F0 13                     beq WaitOneRow        ;if middle part (mushroom ledge), wait until next row
009B8D  2  C0 C0                     cpy #$c0
009B8F  2  F0 0C                     beq DrawThisRow       ;if question block w/ coin, overwrite
009B91  2  C0 C0                     cpy #$c0
009B93  2  B0 0B                     bcs WaitOneRow        ;if any other metatile with palette 3, wait until next row
009B95  2  C0 54                     cpy #$54
009B97  2  D0 04                     bne DrawThisRow       ;if cracked rock terrain, overwrite
009B99  2  C9 50                     cmp #$50
009B9B  2  F0 03                     beq WaitOneRow        ;if stem top of mushroom, wait until next row
009B9D  2  9D A1 06     DrawThisRow: sta MetatileBuffer,x  ;render contents of A from routine that called this
009BA0  2  E8           WaitOneRow:  inx
009BA1  2  E0 0D                     cpx #$0d              ;stop rendering if we're at the bottom of the screen
009BA3  2  B0 06                     bcs ExitUPartR
009BA5  2  AC 35 07                  ldy AreaObjectHeight  ;decrement, and stop rendering if there is no more length
009BA8  2  88                        dey
009BA9  2  10 D2                     bpl RenderUnderPart
009BAB  2  60           ExitUPartR:  rts
009BAC  2               
009BAC  2               ;--------------------------------
009BAC  2               
009BAC  2               ChkLrgObjLength:
009BAC  2  20 BB 9B             jsr GetLrgObjAttrib     ;get row location and size (length if branched to from here)
009BAF  2               
009BAF  2               ChkLrgObjFixedLength:
009BAF  2  BD 30 07             lda AreaObjectLength,x  ;check for set length counter
009BB2  2  18                   clc                     ;clear carry flag for not just starting
009BB3  2  10 05                bpl LenSet              ;if counter not set, load it, otherwise leave alone
009BB5  2  98                   tya                     ;save length into length counter
009BB6  2  9D 30 07             sta AreaObjectLength,x
009BB9  2  38                   sec                     ;set carry flag if just starting
009BBA  2  60           LenSet: rts
009BBB  2               
009BBB  2               
009BBB  2               GetLrgObjAttrib:
009BBB  2  BC 2D 07           ldy AreaObjOffsetBuffer,x ;get offset saved from area obj decoding routine
009BBE  2  B1 E7              lda (AreaData),y          ;get first byte of level object
009BC0  2  29 0F              and #%00001111
009BC2  2  85 07              sta $07                   ;save row location
009BC4  2  C8                 iny
009BC5  2  B1 E7              lda (AreaData),y          ;get next byte, save lower nybble (length or height)
009BC7  2  29 0F              and #%00001111            ;as Y, then leave
009BC9  2  A8                 tay
009BCA  2  60                 rts
009BCB  2               
009BCB  2               ;--------------------------------
009BCB  2               
009BCB  2               GetAreaObjXPosition:
009BCB  2  AD 26 07           lda CurrentColumnPos    ;multiply current offset where we're at by 16
009BCE  2  0A                 asl                     ;to obtain horizontal pixel coordinate
009BCF  2  0A                 asl
009BD0  2  0A                 asl
009BD1  2  0A                 asl
009BD2  2  60                 rts
009BD3  2               
009BD3  2               ;--------------------------------
009BD3  2               
009BD3  2               GetAreaObjYPosition:
009BD3  2  A5 07              lda $07  ;multiply value by 16
009BD5  2  0A                 asl
009BD6  2  0A                 asl      ;this will give us the proper vertical pixel coordinate
009BD7  2  0A                 asl
009BD8  2  0A                 asl
009BD9  2  18                 clc
009BDA  2  69 20              adc #32  ;add 32 pixels for the status bar
009BDC  2  60                 rts
009BDD  2               
009BDD  2               ;-------------------------------------------------------------------------------------
009BDD  2               ;$06-$07 - used to store block buffer address used as indirect
009BDD  2               
009BDD  2               BlockBufferAddr:
009BDD  2  00 D0              .byte <Block_Buffer_1, <Block_Buffer_2
009BDF  2  05 05              .byte >Block_Buffer_1, >Block_Buffer_2
009BE1  2               
009BE1  2               GetBlockBufferAddr:
009BE1  2  48                 pha                      ;take value of A, save
009BE2  2  4A                 lsr                      ;move high nybble to low
009BE3  2  4A                 lsr
009BE4  2  4A                 lsr
009BE5  2  4A                 lsr
009BE6  2  A8                 tay                      ;use nybble as pointer to high byte
009BE7  2  B9 DF 9B           lda BlockBufferAddr+2,y  ;of indirect here
009BEA  2  85 07              sta $07
009BEC  2  68                 pla
009BED  2  29 0F              and #%00001111           ;pull from stack, mask out high nybble
009BEF  2  18                 clc
009BF0  2  79 DD 9B           adc BlockBufferAddr,y    ;add to low byte
009BF3  2  85 06              sta $06                  ;store here and leave
009BF5  2  60                 rts
009BF6  2               
009BF6  2               ;-------------------------------------------------------------------------------------
009BF6  2               
009BF6  2               ;unused space
009BF6  2  FF FF              .byte $ff, $ff
009BF8  2               
009BF8  2               ;-------------------------------------------------------------------------------------
009BF8  2               
009BF8  2               AreaDataOfsLoopback:
009BF8  2  12 36 0E 0E        .byte $12, $36, $0e, $0e, $0e, $32, $32, $32, $0a, $26, $40
009BFC  2  0E 32 32 32  
009C00  2  0A 26 40     
009C03  2               
009C03  2               ;-------------------------------------------------------------------------------------
009C03  2               
009C03  2               LoadAreaPointer:
009C03  2  20 13 9C                  jsr FindAreaPointer  ;find it and store it here
009C06  2  8D 50 07                  sta AreaPointer
009C09  2  29 60        GetAreaType: and #%01100000       ;mask out all but d6 and d5
009C0B  2  0A                        asl
009C0C  2  2A                        rol
009C0D  2  2A                        rol
009C0E  2  2A                        rol                  ;make %0xx00000 into %000000xx
009C0F  2  8D 4E 07                  sta AreaType         ;save 2 MSB as area type
009C12  2  60                        rts
009C13  2               
009C13  2               FindAreaPointer:
009C13  2  AC 5F 07           ldy WorldNumber        ;load offset from world variable
009C16  2  B9 B4 9C           lda WorldAddrOffsets,y
009C19  2  18                 clc                    ;add area number used to find data
009C1A  2  6D 60 07           adc AreaNumber
009C1D  2  A8                 tay
009C1E  2  B9 BC 9C           lda AreaAddrOffsets,y  ;from there we have our area pointer
009C21  2  60                 rts
009C22  2               
009C22  2               
009C22  2               GetAreaDataAddrs:
009C22  2  AD 50 07                 lda AreaPointer          ;use 2 MSB for Y
009C25  2  20 09 9C                 jsr GetAreaType
009C28  2  A8                       tay
009C29  2  AD 50 07                 lda AreaPointer          ;mask out all but 5 LSB
009C2C  2  29 1F                    and #%00011111
009C2E  2  8D 4F 07                 sta AreaAddrsLOffset     ;save as low offset
009C31  2  B9 E0 9C                 lda EnemyAddrHOffsets,y  ;load base value with 2 altered MSB,
009C34  2  18                       clc                      ;then add base value to 5 LSB, result
009C35  2  6D 4F 07                 adc AreaAddrsLOffset     ;becomes offset for level data
009C38  2  A8                       tay
009C39  2  B9 E4 9C                 lda EnemyDataAddrLow,y   ;use offset to load pointer
009C3C  2  85 E9                    sta EnemyDataLow
009C3E  2  B9 06 9D                 lda EnemyDataAddrHigh,y
009C41  2  85 EA                    sta EnemyDataHigh
009C43  2  AC 4E 07                 ldy AreaType             ;use area type as offset
009C46  2  B9 28 9D                 lda AreaDataHOffsets,y   ;do the same thing but with different base value
009C49  2  18                       clc
009C4A  2  6D 4F 07                 adc AreaAddrsLOffset
009C4D  2  A8                       tay
009C4E  2  B9 2C 9D                 lda AreaDataAddrLow,y    ;use this offset to load another pointer
009C51  2  85 E7                    sta AreaDataLow
009C53  2  B9 4E 9D                 lda AreaDataAddrHigh,y
009C56  2  85 E8                    sta AreaDataHigh
009C58  2  A0 00                    ldy #$00                 ;load first byte of header
009C5A  2  B1 E7                    lda (AreaData),y
009C5C  2  48                       pha                      ;save it to the stack for now
009C5D  2  29 07                    and #%00000111           ;save 3 LSB for foreground scenery or bg color control
009C5F  2  C9 04                    cmp #$04
009C61  2  90 05                    bcc StoreFore
009C63  2  8D 44 07                 sta BackgroundColorCtrl  ;if 4 or greater, save value here as bg color control
009C66  2  A9 00                    lda #$00
009C68  2  8D 41 07     StoreFore:  sta ForegroundScenery    ;if less, save value here as foreground scenery
009C6B  2  68                       pla                      ;pull byte from stack and push it back
009C6C  2  48                       pha
009C6D  2  29 38                    and #%00111000           ;save player entrance control bits
009C6F  2  4A                       lsr                      ;shift bits over to LSBs
009C70  2  4A                       lsr
009C71  2  4A                       lsr
009C72  2  8D 10 07                 sta PlayerEntranceCtrl       ;save value here as player entrance control
009C75  2  68                       pla                      ;pull byte again but do not push it back
009C76  2  29 C0                    and #%11000000           ;save 2 MSB for game timer setting
009C78  2  18                       clc
009C79  2  2A                       rol                      ;rotate bits over to LSBs
009C7A  2  2A                       rol
009C7B  2  2A                       rol
009C7C  2  8D 15 07                 sta GameTimerSetting     ;save value here as game timer setting
009C7F  2  C8                       iny
009C80  2  B1 E7                    lda (AreaData),y         ;load second byte of header
009C82  2  48                       pha                      ;save to stack
009C83  2  29 0F                    and #%00001111           ;mask out all but lower nybble
009C85  2  8D 27 07                 sta TerrainControl
009C88  2  68                       pla                      ;pull and push byte to copy it to A
009C89  2  48                       pha
009C8A  2  29 30                    and #%00110000           ;save 2 MSB for background scenery type
009C8C  2  4A                       lsr
009C8D  2  4A                       lsr                      ;shift bits to LSBs
009C8E  2  4A                       lsr
009C8F  2  4A                       lsr
009C90  2  8D 42 07                 sta BackgroundScenery    ;save as background scenery
009C93  2  68                       pla
009C94  2  29 C0                    and #%11000000
009C96  2  18                       clc
009C97  2  2A                       rol                      ;rotate bits over to LSBs
009C98  2  2A                       rol
009C99  2  2A                       rol
009C9A  2  C9 03                    cmp #%00000011           ;if set to 3, store here
009C9C  2  D0 05                    bne StoreStyle           ;and nullify other value
009C9E  2  8D 43 07                 sta CloudTypeOverride    ;otherwise store value in other place
009CA1  2  A9 00                    lda #$00
009CA3  2  8D 33 07     StoreStyle: sta AreaStyle
009CA6  2  A5 E7                    lda AreaDataLow          ;increment area data address by 2 bytes
009CA8  2  18                       clc
009CA9  2  69 02                    adc #$02
009CAB  2  85 E7                    sta AreaDataLow
009CAD  2  A5 E8                    lda AreaDataHigh
009CAF  2  69 00                    adc #$00
009CB1  2  85 E8                    sta AreaDataHigh
009CB3  2  60                       rts
009CB4  2               
009CB4  2               ;-------------------------------------------------------------------------------------
009CB4  2               ;GAME LEVELS DATA
009CB4  2               
009CB4  2               WorldAddrOffsets:
009CB4  2  00 05              .byte World1Areas-AreaAddrOffsets, World2Areas-AreaAddrOffsets
009CB6  2  0A 0E              .byte World3Areas-AreaAddrOffsets, World4Areas-AreaAddrOffsets
009CB8  2  13 17              .byte World5Areas-AreaAddrOffsets, World6Areas-AreaAddrOffsets
009CBA  2  1B 20              .byte World7Areas-AreaAddrOffsets, World8Areas-AreaAddrOffsets
009CBC  2               
009CBC  2               AreaAddrOffsets:
009CBC  2  25 29 C0 26  World1Areas: .byte $25, $29, $c0, $26, $60
009CC0  2  60           
009CC1  2  28 29 01 27  World2Areas: .byte $28, $29, $01, $27, $62
009CC5  2  62           
009CC6  2  24 35 20 63  World3Areas: .byte $24, $35, $20, $63
009CCA  2  22 29 41 2C  World4Areas: .byte $22, $29, $41, $2c, $61
009CCE  2  61           
009CCF  2  2A 31 26 62  World5Areas: .byte $2a, $31, $26, $62
009CD3  2  2E 23 2D 60  World6Areas: .byte $2e, $23, $2d, $60
009CD7  2  33 29 01 27  World7Areas: .byte $33, $29, $01, $27, $64
009CDB  2  64           
009CDC  2  30 32 21 65  World8Areas: .byte $30, $32, $21, $65
009CE0  2               
009CE0  2               ;bonus area data offsets, included here for comparison purposes
009CE0  2               ;underground bonus area  - c2
009CE0  2               ;cloud area 1 (day)      - 2b
009CE0  2               ;cloud area 2 (night)    - 34
009CE0  2               ;water area (5-2/6-2)    - 00
009CE0  2               ;water area (8-4)        - 02
009CE0  2               ;warp zone area (4-2)    - 2f
009CE0  2               
009CE0  2               EnemyAddrHOffsets:
009CE0  2  1F 06 1C 00        .byte $1f, $06, $1c, $00
009CE4  2               
009CE4  2               EnemyDataAddrLow:
009CE4  2  70 97 B0 DF        .byte <E_CastleArea1, <E_CastleArea2, <E_CastleArea3, <E_CastleArea4, <E_CastleArea5, <E_CastleArea6
009CE8  2  0A 1F        
009CEA  2  59 7E 9B A9        .byte <E_GroundArea1, <E_GroundArea2, <E_GroundArea3, <E_GroundArea4, <E_GroundArea5, <E_GroundArea6
009CEE  2  D0 01        
009CF0  2  1F 3C 51 7B        .byte <E_GroundArea7, <E_GroundArea8, <E_GroundArea9, <E_GroundArea10, <E_GroundArea11, <E_GroundArea12
009CF4  2  7C A0        
009CF6  2  A9 CE F1 FA        .byte <E_GroundArea13, <E_GroundArea14, <E_GroundArea15, <E_GroundArea16, <E_GroundArea17, <E_GroundArea18
009CFA  2  FB 35        
009CFC  2  60 8E AA B3        .byte <E_GroundArea19, <E_GroundArea20, <E_GroundArea21, <E_GroundArea22, <E_UndergroundArea1
009D00  2  D8           
009D01  2  05 33 60 71        .byte <E_UndergroundArea2, <E_UndergroundArea3, <E_WaterArea1, <E_WaterArea2, <E_WaterArea3
009D05  2  9B           
009D06  2               
009D06  2               EnemyDataAddrHigh:
009D06  2  9D 9D 9D 9D        .byte >E_CastleArea1, >E_CastleArea2, >E_CastleArea3, >E_CastleArea4, >E_CastleArea5, >E_CastleArea6
009D0A  2  9E 9E        
009D0C  2  9E 9E 9E 9E        .byte >E_GroundArea1, >E_GroundArea2, >E_GroundArea3, >E_GroundArea4, >E_GroundArea5, >E_GroundArea6
009D10  2  9E 9F        
009D12  2  9F 9F 9F 9F        .byte >E_GroundArea7, >E_GroundArea8, >E_GroundArea9, >E_GroundArea10, >E_GroundArea11, >E_GroundArea12
009D16  2  9F 9F        
009D18  2  9F 9F 9F 9F        .byte >E_GroundArea13, >E_GroundArea14, >E_GroundArea15, >E_GroundArea16, >E_GroundArea17, >E_GroundArea18
009D1C  2  9F A0        
009D1E  2  A0 A0 A0 A0        .byte >E_GroundArea19, >E_GroundArea20, >E_GroundArea21, >E_GroundArea22, >E_UndergroundArea1
009D22  2  A0           
009D23  2  A1 A1 A1 A1        .byte >E_UndergroundArea2, >E_UndergroundArea3, >E_WaterArea1, >E_WaterArea2, >E_WaterArea3
009D27  2  A1           
009D28  2               
009D28  2               AreaDataHOffsets:
009D28  2  00 03 19 1C        .byte $00, $03, $19, $1c
009D2C  2               
009D2C  2               AreaDataAddrLow:
009D2C  2  06 45 C0 6B        .byte <L_WaterArea1, <L_WaterArea2, <L_WaterArea3, <L_GroundArea1, <L_GroundArea2, <L_GroundArea3
009D30  2  CE 37        
009D32  2  8A 19 8E F3        .byte <L_GroundArea4, <L_GroundArea5, <L_GroundArea6, <L_GroundArea7, <L_GroundArea8, <L_GroundArea9
009D36  2  48 CD        
009D38  2  32 3B 7A 8F        .byte <L_GroundArea10, <L_GroundArea11, <L_GroundArea12, <L_GroundArea13, <L_GroundArea14, <L_GroundArea15
009D3C  2  F6 5B        
009D3E  2  CE FF 92 05        .byte <L_GroundArea16, <L_GroundArea17, <L_GroundArea18, <L_GroundArea19, <L_GroundArea20, <L_GroundArea21
009D42  2  7E D7        
009D44  2  02 35 D8 79        .byte <L_GroundArea22, <L_UndergroundArea1, <L_UndergroundArea2, <L_UndergroundArea3, <L_CastleArea1
009D48  2  AF           
009D49  2  10 8F 02 6F        .byte <L_CastleArea2, <L_CastleArea3, <L_CastleArea4, <L_CastleArea5, <L_CastleArea6
009D4D  2  FA           
009D4E  2               
009D4E  2               AreaDataAddrHigh:
009D4E  2  AE AE AE A4        .byte >L_WaterArea1, >L_WaterArea2, >L_WaterArea3, >L_GroundArea1, >L_GroundArea2, >L_GroundArea3
009D52  2  A4 A5        
009D54  2  A5 A6 A6 A6        .byte >L_GroundArea4, >L_GroundArea5, >L_GroundArea6, >L_GroundArea7, >L_GroundArea8, >L_GroundArea9
009D58  2  A7 A7        
009D5A  2  A8 A8 A8 A8        .byte >L_GroundArea10, >L_GroundArea11, >L_GroundArea12, >L_GroundArea13, >L_GroundArea14, >L_GroundArea15
009D5E  2  A8 A9        
009D60  2  A9 A9 AA AB        .byte >L_GroundArea16, >L_GroundArea17, >L_GroundArea18, >L_GroundArea19, >L_GroundArea20, >L_GroundArea21
009D64  2  AB AB        
009D66  2  AC AC AC AD        .byte >L_GroundArea22, >L_UndergroundArea1, >L_UndergroundArea2, >L_UndergroundArea3, >L_CastleArea1
009D6A  2  A1           
009D6B  2  A2 A2 A3 A3        .byte >L_CastleArea2, >L_CastleArea3, >L_CastleArea4, >L_CastleArea5, >L_CastleArea6
009D6F  2  A3           
009D70  2               
009D70  2               ;ENEMY OBJECT DATA
009D70  2               
009D70  2               ;level 1-4/6-4
009D70  2               E_CastleArea1:
009D70  2  76 DD BB 4C        .byte $76, $dd, $bb, $4c, $ea, $1d, $1b, $cc, $56, $5d
009D74  2  EA 1D 1B CC  
009D78  2  56 5D        
009D7A  2  16 9D C6 1D        .byte $16, $9d, $c6, $1d, $36, $9d, $c9, $1d, $04, $db
009D7E  2  36 9D C9 1D  
009D82  2  04 DB        
009D84  2  49 1D 84 1B        .byte $49, $1d, $84, $1b, $c9, $5d, $88, $95, $0f, $08
009D88  2  C9 5D 88 95  
009D8C  2  0F 08        
009D8E  2  30 4C 78 2D        .byte $30, $4c, $78, $2d, $a6, $28, $90, $b5
009D92  2  A6 28 90 B5  
009D96  2  FF                 .byte $ff
009D97  2               
009D97  2               ;level 4-4
009D97  2               E_CastleArea2:
009D97  2  0F 03 56 1B        .byte $0f, $03, $56, $1b, $c9, $1b, $0f, $07, $36, $1b
009D9B  2  C9 1B 0F 07  
009D9F  2  36 1B        
009DA1  2  AA 1B 48 95        .byte $aa, $1b, $48, $95, $0f, $0a, $2a, $1b, $5b, $0c
009DA5  2  0F 0A 2A 1B  
009DA9  2  5B 0C        
009DAB  2  78 2D 90 B5        .byte $78, $2d, $90, $b5
009DAF  2  FF                 .byte $ff
009DB0  2               
009DB0  2               ;level 2-4/5-4
009DB0  2               E_CastleArea3:
009DB0  2  0B 8C 4B 4C        .byte $0b, $8c, $4b, $4c, $77, $5f, $eb, $0c, $bd, $db
009DB4  2  77 5F EB 0C  
009DB8  2  BD DB        
009DBA  2  19 9D 75 1D        .byte $19, $9d, $75, $1d, $7d, $5b, $d9, $1d, $3d, $dd
009DBE  2  7D 5B D9 1D  
009DC2  2  3D DD        
009DC4  2  99 1D 26 9D        .byte $99, $1d, $26, $9d, $5a, $2b, $8a, $2c, $ca, $1b
009DC8  2  5A 2B 8A 2C  
009DCC  2  CA 1B        
009DCE  2  20 95 7B 5C        .byte $20, $95, $7b, $5c, $db, $4c, $1b, $cc, $3b, $cc
009DD2  2  DB 4C 1B CC  
009DD6  2  3B CC        
009DD8  2  78 2D A6 28        .byte $78, $2d, $a6, $28, $90, $b5
009DDC  2  90 B5        
009DDE  2  FF                 .byte $ff
009DDF  2               
009DDF  2               ;level 3-4
009DDF  2               E_CastleArea4:
009DDF  2  0B 8C 3B 1D        .byte $0b, $8c, $3b, $1d, $8b, $1d, $ab, $0c, $db, $1d
009DE3  2  8B 1D AB 0C  
009DE7  2  DB 1D        
009DE9  2  0F 03 65 1D        .byte $0f, $03, $65, $1d, $6b, $1b, $05, $9d, $0b, $1b
009DED  2  6B 1B 05 9D  
009DF1  2  0B 1B        
009DF3  2  05 9B 0B 1D        .byte $05, $9b, $0b, $1d, $8b, $0c, $1b, $8c, $70, $15
009DF7  2  8B 0C 1B 8C  
009DFB  2  70 15        
009DFD  2  7B 0C DB 0C        .byte $7b, $0c, $db, $0c, $0f, $08, $78, $2d, $a6, $28
009E01  2  0F 08 78 2D  
009E05  2  A6 28        
009E07  2  90 B5              .byte $90, $b5
009E09  2  FF                 .byte $ff
009E0A  2               
009E0A  2               ;level 7-4
009E0A  2               E_CastleArea5:
009E0A  2  27 A9 4B 0C        .byte $27, $a9, $4b, $0c, $68, $29, $0f, $06, $77, $1b
009E0E  2  68 29 0F 06  
009E12  2  77 1B        
009E14  2  0F 0B 60 15        .byte $0f, $0b, $60, $15, $4b, $8c, $78, $2d, $90, $b5
009E18  2  4B 8C 78 2D  
009E1C  2  90 B5        
009E1E  2  FF                 .byte $ff
009E1F  2               
009E1F  2               ;level 8-4
009E1F  2               E_CastleArea6:
009E1F  2  0F 03 8E 65        .byte $0f, $03, $8e, $65, $e1, $bb, $38, $6d, $a8, $3e, $e5, $e7
009E23  2  E1 BB 38 6D  
009E27  2  A8 3E E5 E7  
009E2B  2  0F 08 0B 02        .byte $0f, $08, $0b, $02, $2b, $02, $5e, $65, $e1, $bb, $0e
009E2F  2  2B 02 5E 65  
009E33  2  E1 BB 0E     
009E36  2  DB 0E BB 8E        .byte $db, $0e, $bb, $8e, $db, $0e, $fe, $65, $ec, $0f, $0d
009E3A  2  DB 0E FE 65  
009E3E  2  EC 0F 0D     
009E41  2  4E 65 E1 0F        .byte $4e, $65, $e1, $0f, $0e, $4e, $02, $e0, $0f, $10, $fe, $e5, $e1
009E45  2  0E 4E 02 E0  
009E49  2  0F 10 FE E5  
009E4E  2  1B 85 7B 0C        .byte $1b, $85, $7b, $0c, $5b, $95, $78, $2d, $90, $b5
009E52  2  5B 95 78 2D  
009E56  2  90 B5        
009E58  2  FF                 .byte $ff
009E59  2               
009E59  2               ;level 3-3
009E59  2               E_GroundArea1:
009E59  2  A5 86 E4 28        .byte $a5, $86, $e4, $28, $18, $a8, $45, $83, $69, $03
009E5D  2  18 A8 45 83  
009E61  2  69 03        
009E63  2  C6 29 9B 83        .byte $c6, $29, $9b, $83, $16, $a4, $88, $24, $e9, $28
009E67  2  16 A4 88 24  
009E6B  2  E9 28        
009E6D  2  05 A8 7B 28        .byte $05, $a8, $7b, $28, $24, $8f, $c8, $03, $e8, $03
009E71  2  24 8F C8 03  
009E75  2  E8 03        
009E77  2  46 A8 85 24        .byte $46, $a8, $85, $24, $c8, $24
009E7B  2  C8 24        
009E7D  2  FF                 .byte $ff
009E7E  2               
009E7E  2               ;level 8-3
009E7E  2               E_GroundArea2:
009E7E  2  EB 8E 0F 03        .byte $eb, $8e, $0f, $03, $fb, $05, $17, $85, $db, $8e
009E82  2  FB 05 17 85  
009E86  2  DB 8E        
009E88  2  0F 07 57 05        .byte $0f, $07, $57, $05, $7b, $05, $9b, $80, $2b, $85
009E8C  2  7B 05 9B 80  
009E90  2  2B 85        
009E92  2  FB 05 0F 0B        .byte $fb, $05, $0f, $0b, $1b, $05, $9b, $05
009E96  2  1B 05 9B 05  
009E9A  2  FF                 .byte $ff
009E9B  2               
009E9B  2               ;level 4-1
009E9B  2               E_GroundArea3:
009E9B  2  2E C2 66 E2        .byte $2e, $c2, $66, $e2, $11, $0f, $07, $02, $11, $0f, $0c
009E9F  2  11 0F 07 02  
009EA3  2  11 0F 0C     
009EA6  2  12 11              .byte $12, $11
009EA8  2  FF                 .byte $ff
009EA9  2               
009EA9  2               ;level 6-2
009EA9  2               E_GroundArea4:
009EA9  2  0E C2 A8 AB        .byte $0e, $c2, $a8, $ab, $00, $bb, $8e, $6b, $82, $de, $00, $a0
009EAD  2  00 BB 8E 6B  
009EB1  2  82 DE 00 A0  
009EB5  2  33 86 43 06        .byte $33, $86, $43, $06, $3e, $b4, $a0, $cb, $02, $0f, $07
009EB9  2  3E B4 A0 CB  
009EBD  2  02 0F 07     
009EC0  2  7E 42 A6 83        .byte $7e, $42, $a6, $83, $02, $0f, $0a, $3b, $02, $cb, $37
009EC4  2  02 0F 0A 3B  
009EC8  2  02 CB 37     
009ECB  2  0F 0C E3 0E        .byte $0f, $0c, $e3, $0e
009ECF  2  FF                 .byte $ff
009ED0  2               
009ED0  2               ;level 3-1
009ED0  2               E_GroundArea5:
009ED0  2  9B 8E CA 0E        .byte $9b, $8e, $ca, $0e, $ee, $42, $44, $5b, $86, $80, $b8
009ED4  2  EE 42 44 5B  
009ED8  2  86 80 B8     
009EDB  2  1B 80 50 BA        .byte $1b, $80, $50, $ba, $10, $b7, $5b, $00, $17, $85
009EDF  2  10 B7 5B 00  
009EE3  2  17 85        
009EE5  2  4B 05 FE 34        .byte $4b, $05, $fe, $34, $40, $b7, $86, $c6, $06, $5b, $80
009EE9  2  40 B7 86 C6  
009EED  2  06 5B 80     
009EF0  2  83 00 D0 38        .byte $83, $00, $d0, $38, $5b, $8e, $8a, $0e, $a6, $00
009EF4  2  5B 8E 8A 0E  
009EF8  2  A6 00        
009EFA  2  BB 0E C5 80        .byte $bb, $0e, $c5, $80, $f3, $00
009EFE  2  F3 00        
009F00  2  FF                 .byte $ff
009F01  2               
009F01  2               ;level 1-1
009F01  2               E_GroundArea6:
009F01  2  1E C2 00 6B        .byte $1e, $c2, $00, $6b, $06, $8b, $86, $63, $b7, $0f, $05
009F05  2  06 8B 86 63  
009F09  2  B7 0F 05     
009F0C  2  03 06 23 06        .byte $03, $06, $23, $06, $4b, $b7, $bb, $00, $5b, $b7
009F10  2  4B B7 BB 00  
009F14  2  5B B7        
009F16  2  FB 37 3B B7        .byte $fb, $37, $3b, $b7, $0f, $0b, $1b, $37
009F1A  2  0F 0B 1B 37  
009F1E  2  FF                 .byte $ff
009F1F  2               
009F1F  2               ;level 1-3/5-3
009F1F  2               E_GroundArea7:
009F1F  2  2B D7 E3 03        .byte $2b, $d7, $e3, $03, $c2, $86, $e2, $06, $76, $a5
009F23  2  C2 86 E2 06  
009F27  2  76 A5        
009F29  2  A3 8F 03 86        .byte $a3, $8f, $03, $86, $2b, $57, $68, $28, $e9, $28
009F2D  2  2B 57 68 28  
009F31  2  E9 28        
009F33  2  E5 83 24 8F        .byte $e5, $83, $24, $8f, $36, $a8, $5b, $03
009F37  2  36 A8 5B 03  
009F3B  2  FF                 .byte $ff
009F3C  2               
009F3C  2               ;level 2-3/7-3
009F3C  2               E_GroundArea8:
009F3C  2  0F 02 78 40        .byte $0f, $02, $78, $40, $48, $ce, $f8, $c3, $f8, $c3
009F40  2  48 CE F8 C3  
009F44  2  F8 C3        
009F46  2  0F 07 7B 43        .byte $0f, $07, $7b, $43, $c6, $d0, $0f, $8a, $c8, $50
009F4A  2  C6 D0 0F 8A  
009F4E  2  C8 50        
009F50  2  FF                 .byte $ff
009F51  2               
009F51  2               ;level 2-1
009F51  2               E_GroundArea9:
009F51  2  85 86 0B 80        .byte $85, $86, $0b, $80, $1b, $00, $db, $37, $77, $80
009F55  2  1B 00 DB 37  
009F59  2  77 80        
009F5B  2  EB 37 FE 2B        .byte $eb, $37, $fe, $2b, $20, $2b, $80, $7b, $38, $ab, $b8
009F5F  2  20 2B 80 7B  
009F63  2  38 AB B8     
009F66  2  77 86 FE 42        .byte $77, $86, $fe, $42, $20, $49, $86, $8b, $06, $9b, $80
009F6A  2  20 49 86 8B  
009F6E  2  06 9B 80     
009F71  2  7B 8E 5B B7        .byte $7b, $8e, $5b, $b7, $9b, $0e, $bb, $0e, $9b, $80
009F75  2  9B 0E BB 0E  
009F79  2  9B 80        
009F7B  2               ;end of data terminator here is also used by pipe intro area
009F7B  2               E_GroundArea10:
009F7B  2  FF                 .byte $ff
009F7C  2               
009F7C  2               ;level 5-1
009F7C  2               E_GroundArea11:
009F7C  2  0B 80 60 38        .byte $0b, $80, $60, $38, $10, $b8, $c0, $3b, $db, $8e
009F80  2  10 B8 C0 3B  
009F84  2  DB 8E        
009F86  2  40 B8 F0 38        .byte $40, $b8, $f0, $38, $7b, $8e, $a0, $b8, $c0, $b8
009F8A  2  7B 8E A0 B8  
009F8E  2  C0 B8        
009F90  2  FB 00 A0 B8        .byte $fb, $00, $a0, $b8, $30, $bb, $ee, $42, $88, $0f, $0b
009F94  2  30 BB EE 42  
009F98  2  88 0F 0B     
009F9B  2  2B 0E 67 0E        .byte $2b, $0e, $67, $0e
009F9F  2  FF                 .byte $ff
009FA0  2               
009FA0  2               ;cloud level used in levels 2-1 and 5-2
009FA0  2               E_GroundArea12:
009FA0  2  0A AA 0E 28        .byte $0a, $aa, $0e, $28, $2a, $0e, $31, $88
009FA4  2  2A 0E 31 88  
009FA8  2  FF                 .byte $ff
009FA9  2               
009FA9  2               ;level 4-3
009FA9  2               E_GroundArea13:
009FA9  2  C7 83 D7 03        .byte $c7, $83, $d7, $03, $42, $8f, $7a, $03, $05, $a4
009FAD  2  42 8F 7A 03  
009FB1  2  05 A4        
009FB3  2  78 24 A6 25        .byte $78, $24, $a6, $25, $e4, $25, $4b, $83, $e3, $03
009FB7  2  E4 25 4B 83  
009FBB  2  E3 03        
009FBD  2  05 A4 89 24        .byte $05, $a4, $89, $24, $b5, $24, $09, $a4, $65, $24
009FC1  2  B5 24 09 A4  
009FC5  2  65 24        
009FC7  2  C9 24 0F 08        .byte $c9, $24, $0f, $08, $85, $25
009FCB  2  85 25        
009FCD  2  FF                 .byte $ff
009FCE  2               
009FCE  2               ;level 6-3
009FCE  2               E_GroundArea14:
009FCE  2  CD A5 B5 A8        .byte $cd, $a5, $b5, $a8, $07, $a8, $76, $28, $cc, $25
009FD2  2  07 A8 76 28  
009FD6  2  CC 25        
009FD8  2  65 A4 A9 24        .byte $65, $a4, $a9, $24, $e5, $24, $19, $a4, $0f, $07
009FDC  2  E5 24 19 A4  
009FE0  2  0F 07        
009FE2  2  95 28 E6 24        .byte $95, $28, $e6, $24, $19, $a4, $d7, $29, $16, $a9
009FE6  2  19 A4 D7 29  
009FEA  2  16 A9        
009FEC  2  58 29 97 29        .byte $58, $29, $97, $29
009FF0  2  FF                 .byte $ff
009FF1  2               
009FF1  2               ;level 6-1
009FF1  2               E_GroundArea15:
009FF1  2  0F 02 02 11        .byte $0f, $02, $02, $11, $0f, $07, $02, $11
009FF5  2  0F 07 02 11  
009FF9  2  FF                 .byte $ff
009FFA  2               
009FFA  2               ;warp zone area used in level 4-2
009FFA  2               E_GroundArea16:
009FFA  2  FF                 .byte $ff
009FFB  2               
009FFB  2               ;level 8-1
009FFB  2               E_GroundArea17:
009FFB  2  2B 82 AB 38        .byte $2b, $82, $ab, $38, $de, $42, $e2, $1b, $b8, $eb
009FFF  2  DE 42 E2 1B  
00A003  2  B8 EB        
00A005  2  3B DB 80 8B        .byte $3b, $db, $80, $8b, $b8, $1b, $82, $fb, $b8, $7b
00A009  2  B8 1B 82 FB  
00A00D  2  B8 7B        
00A00F  2  80 FB 3C 5B        .byte $80, $fb, $3c, $5b, $bc, $7b, $b8, $1b, $8e, $cb
00A013  2  BC 7B B8 1B  
00A017  2  8E CB        
00A019  2  0E 1B 8E 0F        .byte $0e, $1b, $8e, $0f, $0d, $2b, $3b, $bb, $b8, $eb, $82
00A01D  2  0D 2B 3B BB  
00A021  2  B8 EB 82     
00A024  2  4B B8 BB 38        .byte $4b, $b8, $bb, $38, $3b, $b7, $bb, $02, $0f, $13
00A028  2  3B B7 BB 02  
00A02C  2  0F 13        
00A02E  2  1B 00 CB 80        .byte $1b, $00, $cb, $80, $6b, $bc
00A032  2  6B BC        
00A034  2  FF                 .byte $ff
00A035  2               
00A035  2               ;level 5-2
00A035  2               E_GroundArea18:
00A035  2  7B 80 AE 00        .byte $7b, $80, $ae, $00, $80, $8b, $8e, $e8, $05, $f9, $86
00A039  2  80 8B 8E E8  
00A03D  2  05 F9 86     
00A040  2  17 86 16 85        .byte $17, $86, $16, $85, $4e, $2b, $80, $ab, $8e, $87, $85
00A044  2  4E 2B 80 AB  
00A048  2  8E 87 85     
00A04B  2  C3 05 8B 82        .byte $c3, $05, $8b, $82, $9b, $02, $ab, $02, $bb, $86
00A04F  2  9B 02 AB 02  
00A053  2  BB 86        
00A055  2  CB 06 D3 03        .byte $cb, $06, $d3, $03, $3b, $8e, $6b, $0e, $a7, $8e
00A059  2  3B 8E 6B 0E  
00A05D  2  A7 8E        
00A05F  2  FF                 .byte $ff
00A060  2               
00A060  2               ;level 8-2
00A060  2               E_GroundArea19:
00A060  2  29 8E 52 11        .byte $29, $8e, $52, $11, $83, $0e, $0f, $03, $9b, $0e
00A064  2  83 0E 0F 03  
00A068  2  9B 0E        
00A06A  2  2B 8E 5B 0E        .byte $2b, $8e, $5b, $0e, $cb, $8e, $fb, $0e, $fb, $82
00A06E  2  CB 8E FB 0E  
00A072  2  FB 82        
00A074  2  9B 82 BB 02        .byte $9b, $82, $bb, $02, $fe, $42, $e8, $bb, $8e, $0f, $0a
00A078  2  FE 42 E8 BB  
00A07C  2  8E 0F 0A     
00A07F  2  AB 0E CB 0E        .byte $ab, $0e, $cb, $0e, $f9, $0e, $88, $86, $a6, $06
00A083  2  F9 0E 88 86  
00A087  2  A6 06        
00A089  2  DB 02 B6 8E        .byte $db, $02, $b6, $8e
00A08D  2  FF                 .byte $ff
00A08E  2               
00A08E  2               ;level 7-1
00A08E  2               E_GroundArea20:
00A08E  2  AB CE DE 42        .byte $ab, $ce, $de, $42, $c0, $cb, $ce, $5b, $8e, $1b, $ce
00A092  2  C0 CB CE 5B  
00A096  2  8E 1B CE     
00A099  2  4B 85 67 45        .byte $4b, $85, $67, $45, $0f, $07, $2b, $00, $7b, $85
00A09D  2  0F 07 2B 00  
00A0A1  2  7B 85        
00A0A3  2  97 05 0F 0A        .byte $97, $05, $0f, $0a, $92, $02
00A0A7  2  92 02        
00A0A9  2  FF                 .byte $ff
00A0AA  2               
00A0AA  2               ;cloud level used in levels 3-1 and 6-2
00A0AA  2               E_GroundArea21:
00A0AA  2  0A AA 0E 24        .byte $0a, $aa, $0e, $24, $4a, $1e, $23, $aa
00A0AE  2  4A 1E 23 AA  
00A0B2  2  FF                 .byte $ff
00A0B3  2               
00A0B3  2               ;level 3-2
00A0B3  2               E_GroundArea22:
00A0B3  2  1B 80 BB 38        .byte $1b, $80, $bb, $38, $4b, $bc, $eb, $3b, $0f, $04
00A0B7  2  4B BC EB 3B  
00A0BB  2  0F 04        
00A0BD  2  2B 00 AB 38        .byte $2b, $00, $ab, $38, $eb, $00, $cb, $8e, $fb, $80
00A0C1  2  EB 00 CB 8E  
00A0C5  2  FB 80        
00A0C7  2  AB B8 6B 80        .byte $ab, $b8, $6b, $80, $fb, $3c, $9b, $bb, $5b, $bc
00A0CB  2  FB 3C 9B BB  
00A0CF  2  5B BC        
00A0D1  2  FB 00 6B B8        .byte $fb, $00, $6b, $b8, $fb, $38
00A0D5  2  FB 38        
00A0D7  2  FF                 .byte $ff
00A0D8  2               
00A0D8  2               ;level 1-2
00A0D8  2               E_UndergroundArea1:
00A0D8  2  0B 86 1A 06        .byte $0b, $86, $1a, $06, $db, $06, $de, $c2, $02, $f0, $3b
00A0DC  2  DB 06 DE C2  
00A0E0  2  02 F0 3B     
00A0E3  2  BB 80 EB 06        .byte $bb, $80, $eb, $06, $0b, $86, $93, $06, $f0, $39
00A0E7  2  0B 86 93 06  
00A0EB  2  F0 39        
00A0ED  2  0F 06 60 B8        .byte $0f, $06, $60, $b8, $1b, $86, $a0, $b9, $b7, $27
00A0F1  2  1B 86 A0 B9  
00A0F5  2  B7 27        
00A0F7  2  BD 27 2B 83        .byte $bd, $27, $2b, $83, $a1, $26, $a9, $26, $ee, $25, $0b
00A0FB  2  A1 26 A9 26  
00A0FF  2  EE 25 0B     
00A102  2  27 B4              .byte $27, $b4
00A104  2  FF                 .byte $ff
00A105  2               
00A105  2               ;level 4-2
00A105  2               E_UndergroundArea2:
00A105  2  0F 02 1E 2F        .byte $0f, $02, $1e, $2f, $60, $e0, $3a, $a5, $a7, $db, $80
00A109  2  60 E0 3A A5  
00A10D  2  A7 DB 80     
00A110  2  3B 82 8B 02        .byte $3b, $82, $8b, $02, $fe, $42, $68, $70, $bb, $25, $a7
00A114  2  FE 42 68 70  
00A118  2  BB 25 A7     
00A11B  2  2C 27 B2 26        .byte $2c, $27, $b2, $26, $b9, $26, $9b, $80, $a8, $82
00A11F  2  B9 26 9B 80  
00A123  2  A8 82        
00A125  2  B5 27 BC 27        .byte $b5, $27, $bc, $27, $b0, $bb, $3b, $82, $87, $34
00A129  2  B0 BB 3B 82  
00A12D  2  87 34        
00A12F  2  EE 25 6B           .byte $ee, $25, $6b
00A132  2  FF                 .byte $ff
00A133  2               
00A133  2               ;underground bonus rooms area used in many levels
00A133  2               E_UndergroundArea3:
00A133  2  1E A5 0A 2E        .byte $1e, $a5, $0a, $2e, $28, $27, $2e, $33, $c7, $0f, $03, $1e, $40, $07
00A137  2  28 27 2E 33  
00A13B  2  C7 0F 03 1E  
00A141  2  2E 30 E7 0F        .byte $2e, $30, $e7, $0f, $05, $1e, $24, $44, $0f, $07, $1e, $22, $6a
00A145  2  05 1E 24 44  
00A149  2  0F 07 1E 22  
00A14E  2  2E 23 AB 0F        .byte $2e, $23, $ab, $0f, $09, $1e, $41, $68, $1e, $2a, $8a, $2e, $23, $a2
00A152  2  09 1E 41 68  
00A156  2  1E 2A 8A 2E  
00A15C  2  2E 32 EA           .byte $2e, $32, $ea
00A15F  2  FF                 .byte $ff
00A160  2               
00A160  2               ;water area used in levels 5-2 and 6-2
00A160  2               E_WaterArea1:
00A160  2  3B 87 66 27        .byte $3b, $87, $66, $27, $cc, $27, $ee, $31, $87, $ee, $23, $a7
00A164  2  CC 27 EE 31  
00A168  2  87 EE 23 A7  
00A16C  2  3B 87 DB 07        .byte $3b, $87, $db, $07
00A170  2  FF                 .byte $ff
00A171  2               
00A171  2               ;level 2-2/7-2
00A171  2               E_WaterArea2:
00A171  2  0F 01 2E 25        .byte $0f, $01, $2e, $25, $2b, $2e, $25, $4b, $4e, $25, $cb, $6b, $07
00A175  2  2B 2E 25 4B  
00A179  2  4E 25 CB 6B  
00A17E  2  97 47 E9 87        .byte $97, $47, $e9, $87, $47, $c7, $7a, $07, $d6, $c7
00A182  2  47 C7 7A 07  
00A186  2  D6 C7        
00A188  2  78 07 38 87        .byte $78, $07, $38, $87, $ab, $47, $e3, $07, $9b, $87
00A18C  2  AB 47 E3 07  
00A190  2  9B 87        
00A192  2  0F 09 68 47        .byte $0f, $09, $68, $47, $db, $c7, $3b, $c7
00A196  2  DB C7 3B C7  
00A19A  2  FF                 .byte $ff
00A19B  2               
00A19B  2               ;water area used in level 8-4
00A19B  2               E_WaterArea3:
00A19B  2  47 9B CB 07        .byte $47, $9b, $cb, $07, $fa, $1d, $86, $9b, $3a, $87
00A19F  2  FA 1D 86 9B  
00A1A3  2  3A 87        
00A1A5  2  56 07 88 1B        .byte $56, $07, $88, $1b, $07, $9d, $2e, $65, $f0
00A1A9  2  07 9D 2E 65  
00A1AD  2  F0           
00A1AE  2  FF                 .byte $ff
00A1AF  2               
00A1AF  2               ;AREA OBJECT DATA
00A1AF  2               
00A1AF  2               ;level 1-4/6-4
00A1AF  2               L_CastleArea1:
00A1AF  2  9B 07              .byte $9b, $07
00A1B1  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $ce, $03, $dc, $51
00A1B5  2  07 34 CE 03  
00A1B9  2  DC 51        
00A1BB  2  EE 07 73 E0        .byte $ee, $07, $73, $e0, $74, $0a, $7e, $06, $9e, $0a
00A1BF  2  74 0A 7E 06  
00A1C3  2  9E 0A        
00A1C5  2  CE 06 E4 00        .byte $ce, $06, $e4, $00, $e8, $0a, $fe, $0a, $2e, $89
00A1C9  2  E8 0A FE 0A  
00A1CD  2  2E 89        
00A1CF  2  4E 0B 54 0A        .byte $4e, $0b, $54, $0a, $14, $8a, $c4, $0a, $34, $8a
00A1D3  2  14 8A C4 0A  
00A1D7  2  34 8A        
00A1D9  2  7E 06 C7 0A        .byte $7e, $06, $c7, $0a, $01, $e0, $02, $0a, $47, $0a
00A1DD  2  01 E0 02 0A  
00A1E1  2  47 0A        
00A1E3  2  81 60 82 0A        .byte $81, $60, $82, $0a, $c7, $0a, $0e, $87, $7e, $02
00A1E7  2  C7 0A 0E 87  
00A1EB  2  7E 02        
00A1ED  2  A7 02 B3 02        .byte $a7, $02, $b3, $02, $d7, $02, $e3, $02, $07, $82
00A1F1  2  D7 02 E3 02  
00A1F5  2  07 82        
00A1F7  2  13 02 3E 06        .byte $13, $02, $3e, $06, $7e, $02, $ae, $07, $fe, $0a
00A1FB  2  7E 02 AE 07  
00A1FF  2  FE 0A        
00A201  2  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
00A205  2  CE 09 DE 0B  
00A209  2  DD 42        
00A20B  2  FE 02 5D C7        .byte $fe, $02, $5d, $c7
00A20F  2  FD                 .byte $fd
00A210  2               
00A210  2               ;level 4-4
00A210  2               L_CastleArea2:
00A210  2  5B 07              .byte $5b, $07
00A212  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $68, $64
00A216  2  07 34 5E 0A  
00A21A  2  68 64        
00A21C  2  98 64 A8 64        .byte $98, $64, $a8, $64, $ce, $06, $fe, $02, $0d, $01
00A220  2  CE 06 FE 02  
00A224  2  0D 01        
00A226  2  1E 0E 7E 02        .byte $1e, $0e, $7e, $02, $94, $63, $b4, $63, $d4, $63
00A22A  2  94 63 B4 63  
00A22E  2  D4 63        
00A230  2  F4 63 14 E3        .byte $f4, $63, $14, $e3, $2e, $0e, $5e, $02, $64, $35
00A234  2  2E 0E 5E 02  
00A238  2  64 35        
00A23A  2  88 72 BE 0E        .byte $88, $72, $be, $0e, $0d, $04, $ae, $02, $ce, $08
00A23E  2  0D 04 AE 02  
00A242  2  CE 08        
00A244  2  CD 4B FE 02        .byte $cd, $4b, $fe, $02, $0d, $05, $68, $31, $7e, $0a
00A248  2  0D 05 68 31  
00A24C  2  7E 0A        
00A24E  2  96 31 A9 63        .byte $96, $31, $a9, $63, $a8, $33, $d5, $30, $ee, $02
00A252  2  A8 33 D5 30  
00A256  2  EE 02        
00A258  2  E6 62 F4 61        .byte $e6, $62, $f4, $61, $04, $b1, $08, $3f, $44, $33
00A25C  2  04 B1 08 3F  
00A260  2  44 33        
00A262  2  94 63 A4 31        .byte $94, $63, $a4, $31, $e4, $31, $04, $bf, $08, $3f
00A266  2  E4 31 04 BF  
00A26A  2  08 3F        
00A26C  2  04 BF 08 3F        .byte $04, $bf, $08, $3f, $cd, $4b, $03, $e4, $0e, $03
00A270  2  CD 4B 03 E4  
00A274  2  0E 03        
00A276  2  2E 01 7E 06        .byte $2e, $01, $7e, $06, $be, $02, $de, $06, $fe, $0a
00A27A  2  BE 02 DE 06  
00A27E  2  FE 0A        
00A280  2  0D C4 CD 43        .byte $0d, $c4, $cd, $43, $ce, $09, $de, $0b, $dd, $42
00A284  2  CE 09 DE 0B  
00A288  2  DD 42        
00A28A  2  FE 02 5D C7        .byte $fe, $02, $5d, $c7
00A28E  2  FD                 .byte $fd
00A28F  2               
00A28F  2               ;level 2-4/5-4
00A28F  2               L_CastleArea3:
00A28F  2  9B 07              .byte $9b, $07
00A291  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $00, $27, $b1
00A295  2  07 34 FE 00  
00A299  2  27 B1        
00A29B  2  65 32 75 0A        .byte $65, $32, $75, $0a, $71, $00, $b7, $31, $08, $e4
00A29F  2  71 00 B7 31  
00A2A3  2  08 E4        
00A2A5  2  18 64 1E 04        .byte $18, $64, $1e, $04, $57, $3b, $bb, $0a, $17, $8a
00A2A9  2  57 3B BB 0A  
00A2AD  2  17 8A        
00A2AF  2  27 3A 73 0A        .byte $27, $3a, $73, $0a, $7b, $0a, $d7, $0a, $e7, $3a
00A2B3  2  7B 0A D7 0A  
00A2B7  2  E7 3A        
00A2B9  2  3B 8A 97 0A        .byte $3b, $8a, $97, $0a, $fe, $08, $24, $8a, $2e, $00
00A2BD  2  FE 08 24 8A  
00A2C1  2  2E 00        
00A2C3  2  3E 40 38 64        .byte $3e, $40, $38, $64, $6f, $00, $9f, $00, $be, $43
00A2C7  2  6F 00 9F 00  
00A2CB  2  BE 43        
00A2CD  2  C8 0A C9 63        .byte $c8, $0a, $c9, $63, $ce, $07, $fe, $07, $2e, $81
00A2D1  2  CE 07 FE 07  
00A2D5  2  2E 81        
00A2D7  2  66 42 6A 42        .byte $66, $42, $6a, $42, $79, $0a, $be, $00, $c8, $64
00A2DB  2  79 0A BE 00  
00A2DF  2  C8 64        
00A2E1  2  F8 64 08 E4        .byte $f8, $64, $08, $e4, $2e, $07, $7e, $03, $9e, $07
00A2E5  2  2E 07 7E 03  
00A2E9  2  9E 07        
00A2EB  2  BE 03 DE 07        .byte $be, $03, $de, $07, $fe, $0a, $03, $a5, $0d, $44
00A2EF  2  FE 0A 03 A5  
00A2F3  2  0D 44        
00A2F5  2  CD 43 CE 09        .byte $cd, $43, $ce, $09, $dd, $42, $de, $0b, $fe, $02
00A2F9  2  DD 42 DE 0B  
00A2FD  2  FE 02        
00A2FF  2  5D C7              .byte $5d, $c7
00A301  2  FD                 .byte $fd
00A302  2               
00A302  2               ;level 3-4
00A302  2               L_CastleArea4:
00A302  2  9B 07              .byte $9b, $07
00A304  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $06, $0c, $81
00A308  2  07 34 FE 06  
00A30C  2  0C 81        
00A30E  2  39 0A 5C 01        .byte $39, $0a, $5c, $01, $89, $0a, $ac, $01, $d9, $0a
00A312  2  89 0A AC 01  
00A316  2  D9 0A        
00A318  2  FC 01 2E 83        .byte $fc, $01, $2e, $83, $a7, $01, $b7, $00, $c7, $01
00A31C  2  A7 01 B7 00  
00A320  2  C7 01        
00A322  2  DE 0A FE 02        .byte $de, $0a, $fe, $02, $4e, $83, $5a, $32, $63, $0a
00A326  2  4E 83 5A 32  
00A32A  2  63 0A        
00A32C  2  69 0A 7E 02        .byte $69, $0a, $7e, $02, $ee, $03, $fa, $32, $03, $8a
00A330  2  EE 03 FA 32  
00A334  2  03 8A        
00A336  2  09 0A 1E 02        .byte $09, $0a, $1e, $02, $ee, $03, $fa, $32, $03, $8a
00A33A  2  EE 03 FA 32  
00A33E  2  03 8A        
00A340  2  09 0A 14 42        .byte $09, $0a, $14, $42, $1e, $02, $7e, $0a, $9e, $07
00A344  2  1E 02 7E 0A  
00A348  2  9E 07        
00A34A  2  FE 0A 2E 86        .byte $fe, $0a, $2e, $86, $5e, $0a, $8e, $06, $be, $0a
00A34E  2  5E 0A 8E 06  
00A352  2  BE 0A        
00A354  2  EE 07 3E 83        .byte $ee, $07, $3e, $83, $5e, $07, $fe, $0a, $0d, $c4
00A358  2  5E 07 FE 0A  
00A35C  2  0D C4        
00A35E  2  41 52 51 52        .byte $41, $52, $51, $52, $cd, $43, $ce, $09, $de, $0b
00A362  2  CD 43 CE 09  
00A366  2  DE 0B        
00A368  2  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
00A36C  2  5D C7        
00A36E  2  FD                 .byte $fd
00A36F  2               
00A36F  2               ;level 7-4
00A36F  2               L_CastleArea5:
00A36F  2  5B 07              .byte $5b, $07
00A371  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $fe, $0a, $ae, $86
00A375  2  07 34 FE 0A  
00A379  2  AE 86        
00A37B  2  BE 07 FE 02        .byte $be, $07, $fe, $02, $0d, $02, $27, $32, $46, $61
00A37F  2  0D 02 27 32  
00A383  2  46 61        
00A385  2  55 62 5E 0E        .byte $55, $62, $5e, $0e, $1e, $82, $68, $3c, $74, $3a
00A389  2  1E 82 68 3C  
00A38D  2  74 3A        
00A38F  2  7D 4B 5E 8E        .byte $7d, $4b, $5e, $8e, $7d, $4b, $7e, $82, $84, $62
00A393  2  7D 4B 7E 82  
00A397  2  84 62        
00A399  2  94 61 A4 31        .byte $94, $61, $a4, $31, $bd, $4b, $ce, $06, $fe, $02
00A39D  2  BD 4B CE 06  
00A3A1  2  FE 02        
00A3A3  2  0D 06 34 31        .byte $0d, $06, $34, $31, $3e, $0a, $64, $32, $75, $0a
00A3A7  2  3E 0A 64 32  
00A3AB  2  75 0A        
00A3AD  2  7B 61 A4 33        .byte $7b, $61, $a4, $33, $ae, $02, $de, $0e, $3e, $82
00A3B1  2  AE 02 DE 0E  
00A3B5  2  3E 82        
00A3B7  2  64 32 78 32        .byte $64, $32, $78, $32, $b4, $36, $c8, $36, $dd, $4b
00A3BB  2  B4 36 C8 36  
00A3BF  2  DD 4B        
00A3C1  2  44 B2 58 32        .byte $44, $b2, $58, $32, $94, $63, $a4, $3e, $ba, $30
00A3C5  2  94 63 A4 3E  
00A3C9  2  BA 30        
00A3CB  2  C9 61 CE 06        .byte $c9, $61, $ce, $06, $dd, $4b, $ce, $86, $dd, $4b
00A3CF  2  DD 4B CE 86  
00A3D3  2  DD 4B        
00A3D5  2  FE 02 2E 86        .byte $fe, $02, $2e, $86, $5e, $02, $7e, $06, $fe, $02
00A3D9  2  5E 02 7E 06  
00A3DD  2  FE 02        
00A3DF  2  1E 86 3E 02        .byte $1e, $86, $3e, $02, $5e, $06, $7e, $02, $9e, $06
00A3E3  2  5E 06 7E 02  
00A3E7  2  9E 06        
00A3E9  2  FE 0A 0D C4        .byte $fe, $0a, $0d, $c4, $cd, $43, $ce, $09, $de, $0b
00A3ED  2  CD 43 CE 09  
00A3F1  2  DE 0B        
00A3F3  2  DD 42 FE 02        .byte $dd, $42, $fe, $02, $5d, $c7
00A3F7  2  5D C7        
00A3F9  2  FD                 .byte $fd
00A3FA  2               
00A3FA  2               ;level 8-4
00A3FA  2               L_CastleArea6:
00A3FA  2  5B 06              .byte $5b, $06
00A3FC  2  05 32 06 33        .byte $05, $32, $06, $33, $07, $34, $5e, $0a, $ae, $02
00A400  2  07 34 5E 0A  
00A404  2  AE 02        
00A406  2  0D 01 39 73        .byte $0d, $01, $39, $73, $0d, $03, $39, $7b, $4d, $4b
00A40A  2  0D 03 39 7B  
00A40E  2  4D 4B        
00A410  2  DE 06 1E 8A        .byte $de, $06, $1e, $8a, $ae, $06, $c4, $33, $16, $fe
00A414  2  AE 06 C4 33  
00A418  2  16 FE        
00A41A  2  A5 77 FE 02        .byte $a5, $77, $fe, $02, $fe, $82, $0d, $07, $39, $73
00A41E  2  FE 82 0D 07  
00A422  2  39 73        
00A424  2  A8 74 ED 4B        .byte $a8, $74, $ed, $4b, $49, $fb, $e8, $74, $fe, $0a
00A428  2  49 FB E8 74  
00A42C  2  FE 0A        
00A42E  2  2E 82 67 02        .byte $2e, $82, $67, $02, $84, $7a, $87, $31, $0d, $0b
00A432  2  84 7A 87 31  
00A436  2  0D 0B        
00A438  2  FE 02 0D 0C        .byte $fe, $02, $0d, $0c, $39, $73, $5e, $06, $c6, $76
00A43C  2  39 73 5E 06  
00A440  2  C6 76        
00A442  2  45 FF BE 0A        .byte $45, $ff, $be, $0a, $dd, $48, $fe, $06, $3d, $cb
00A446  2  DD 48 FE 06  
00A44A  2  3D CB        
00A44C  2  46 7E AD 4A        .byte $46, $7e, $ad, $4a, $fe, $82, $39, $f3, $a9, $7b
00A450  2  FE 82 39 F3  
00A454  2  A9 7B        
00A456  2  4E 8A 9E 07        .byte $4e, $8a, $9e, $07, $fe, $0a, $0d, $c4, $cd, $43
00A45A  2  FE 0A 0D C4  
00A45E  2  CD 43        
00A460  2  CE 09 DE 0B        .byte $ce, $09, $de, $0b, $dd, $42, $fe, $02, $5d, $c7
00A464  2  DD 42 FE 02  
00A468  2  5D C7        
00A46A  2  FD                 .byte $fd
00A46B  2               
00A46B  2               ;level 3-3
00A46B  2               L_GroundArea1:
00A46B  2  94 11              .byte $94, $11
00A46D  2  0F 26 FE 10        .byte $0f, $26, $fe, $10, $28, $94, $65, $15, $eb, $12
00A471  2  28 94 65 15  
00A475  2  EB 12        
00A477  2  FA 41 4A 96        .byte $fa, $41, $4a, $96, $54, $40, $a4, $42, $b7, $13
00A47B  2  54 40 A4 42  
00A47F  2  B7 13        
00A481  2  E9 19 F5 15        .byte $e9, $19, $f5, $15, $11, $80, $47, $42, $71, $13
00A485  2  11 80 47 42  
00A489  2  71 13        
00A48B  2  80 41 15 92        .byte $80, $41, $15, $92, $1b, $1f, $24, $40, $55, $12
00A48F  2  1B 1F 24 40  
00A493  2  55 12        
00A495  2  64 40 95 12        .byte $64, $40, $95, $12, $a4, $40, $d2, $12, $e1, $40
00A499  2  A4 40 D2 12  
00A49D  2  E1 40        
00A49F  2  13 C0 2C 17        .byte $13, $c0, $2c, $17, $2f, $12, $49, $13, $83, $40
00A4A3  2  2F 12 49 13  
00A4A7  2  83 40        
00A4A9  2  9F 14 A3 40        .byte $9f, $14, $a3, $40, $17, $92, $83, $13, $92, $41
00A4AD  2  17 92 83 13  
00A4B1  2  92 41        
00A4B3  2  B9 14 C5 12        .byte $b9, $14, $c5, $12, $c8, $40, $d4, $40, $4b, $92
00A4B7  2  C8 40 D4 40  
00A4BB  2  4B 92        
00A4BD  2  78 1B 9C 94        .byte $78, $1b, $9c, $94, $9f, $11, $df, $14, $fe, $11
00A4C1  2  9F 11 DF 14  
00A4C5  2  FE 11        
00A4C7  2  7D C1 9E 42        .byte $7d, $c1, $9e, $42, $cf, $20
00A4CB  2  CF 20        
00A4CD  2  FD                 .byte $fd
00A4CE  2               
00A4CE  2               ;level 8-3
00A4CE  2               L_GroundArea2:
00A4CE  2  90 B1              .byte $90, $b1
00A4D0  2  0F 26 29 91        .byte $0f, $26, $29, $91, $7e, $42, $fe, $40, $28, $92
00A4D4  2  7E 42 FE 40  
00A4D8  2  28 92        
00A4DA  2  4E 42 2E C0        .byte $4e, $42, $2e, $c0, $57, $73, $c3, $25, $c7, $27
00A4DE  2  57 73 C3 25  
00A4E2  2  C7 27        
00A4E4  2  23 84 33 20        .byte $23, $84, $33, $20, $5c, $01, $77, $63, $88, $62
00A4E8  2  5C 01 77 63  
00A4EC  2  88 62        
00A4EE  2  99 61 AA 60        .byte $99, $61, $aa, $60, $bc, $01, $ee, $42, $4e, $c0
00A4F2  2  BC 01 EE 42  
00A4F6  2  4E C0        
00A4F8  2  69 11 7E 42        .byte $69, $11, $7e, $42, $de, $40, $f8, $62, $0e, $c2
00A4FC  2  DE 40 F8 62  
00A500  2  0E C2        
00A502  2  AE 40 D7 63        .byte $ae, $40, $d7, $63, $e7, $63, $33, $a7, $37, $27
00A506  2  E7 63 33 A7  
00A50A  2  37 27        
00A50C  2  43 04 CC 01        .byte $43, $04, $cc, $01, $e7, $73, $0c, $81, $3e, $42
00A510  2  E7 73 0C 81  
00A514  2  3E 42        
00A516  2  0D 0A 5E 40        .byte $0d, $0a, $5e, $40, $88, $72, $be, $42, $e7, $87
00A51A  2  88 72 BE 42  
00A51E  2  E7 87        
00A520  2  FE 40 39 E1        .byte $fe, $40, $39, $e1, $4e, $00, $69, $60, $87, $60
00A524  2  4E 00 69 60  
00A528  2  87 60        
00A52A  2  A5 60 C3 31        .byte $a5, $60, $c3, $31, $fe, $31, $6d, $c1, $be, $42
00A52E  2  FE 31 6D C1  
00A532  2  BE 42        
00A534  2  EF 20              .byte $ef, $20
00A536  2  FD                 .byte $fd
00A537  2               
00A537  2               ;level 4-1
00A537  2               L_GroundArea3:
00A537  2  52 21              .byte $52, $21
00A539  2  0F 20 6E 40        .byte $0f, $20, $6e, $40, $58, $f2, $93, $01, $97, $00
00A53D  2  58 F2 93 01  
00A541  2  97 00        
00A543  2  0C 81 97 40        .byte $0c, $81, $97, $40, $a6, $41, $c7, $40, $0d, $04
00A547  2  A6 41 C7 40  
00A54B  2  0D 04        
00A54D  2  03 01 07 01        .byte $03, $01, $07, $01, $23, $01, $27, $01, $ec, $03
00A551  2  23 01 27 01  
00A555  2  EC 03        
00A557  2  AC F3 C3 03        .byte $ac, $f3, $c3, $03, $78, $e2, $94, $43, $47, $f3
00A55B  2  78 E2 94 43  
00A55F  2  47 F3        
00A561  2  74 43 47 FB        .byte $74, $43, $47, $fb, $74, $43, $2c, $f1, $4c, $63
00A565  2  74 43 2C F1  
00A569  2  4C 63        
00A56B  2  47 00 57 21        .byte $47, $00, $57, $21, $5c, $01, $7c, $72, $39, $f1
00A56F  2  5C 01 7C 72  
00A573  2  39 F1        
00A575  2  EC 02 4C 81        .byte $ec, $02, $4c, $81, $d8, $62, $ec, $01, $0d, $0d
00A579  2  D8 62 EC 01  
00A57D  2  0D 0D        
00A57F  2  0F 38 C7 07        .byte $0f, $38, $c7, $07, $ed, $4a, $1d, $c1, $5f, $26
00A583  2  ED 4A 1D C1  
00A587  2  5F 26        
00A589  2  FD                 .byte $fd
00A58A  2               
00A58A  2               ;level 6-2
00A58A  2               L_GroundArea4:
00A58A  2  54 21              .byte $54, $21
00A58C  2  0F 26 A7 22        .byte $0f, $26, $a7, $22, $37, $fb, $73, $20, $83, $07
00A590  2  37 FB 73 20  
00A594  2  83 07        
00A596  2  87 02 93 20        .byte $87, $02, $93, $20, $c7, $73, $04, $f1, $06, $31
00A59A  2  C7 73 04 F1  
00A59E  2  06 31        
00A5A0  2  39 71 59 71        .byte $39, $71, $59, $71, $e7, $73, $37, $a0, $47, $04
00A5A4  2  E7 73 37 A0  
00A5A8  2  47 04        
00A5AA  2  86 7C E5 71        .byte $86, $7c, $e5, $71, $e7, $31, $33, $a4, $39, $71
00A5AE  2  E7 31 33 A4  
00A5B2  2  39 71        
00A5B4  2  A9 71 D3 23        .byte $a9, $71, $d3, $23, $08, $f2, $13, $05, $27, $02
00A5B8  2  08 F2 13 05  
00A5BC  2  27 02        
00A5BE  2  49 71 75 75        .byte $49, $71, $75, $75, $e8, $72, $67, $f3, $99, $71
00A5C2  2  E8 72 67 F3  
00A5C6  2  99 71        
00A5C8  2  E7 20 F4 72        .byte $e7, $20, $f4, $72, $f7, $31, $17, $a0, $33, $20
00A5CC  2  F7 31 17 A0  
00A5D0  2  33 20        
00A5D2  2  39 71 73 28        .byte $39, $71, $73, $28, $bc, $05, $39, $f1, $79, $71
00A5D6  2  BC 05 39 F1  
00A5DA  2  79 71        
00A5DC  2  A6 21 C3 06        .byte $a6, $21, $c3, $06, $d3, $20, $dc, $00, $fc, $00
00A5E0  2  D3 20 DC 00  
00A5E4  2  FC 00        
00A5E6  2  07 A2 13 21        .byte $07, $a2, $13, $21, $5f, $32, $8c, $00, $98, $7a
00A5EA  2  5F 32 8C 00  
00A5EE  2  98 7A        
00A5F0  2  C7 63 D9 61        .byte $c7, $63, $d9, $61, $03, $a2, $07, $22, $74, $72
00A5F4  2  03 A2 07 22  
00A5F8  2  74 72        
00A5FA  2  77 31 E7 73        .byte $77, $31, $e7, $73, $39, $f1, $58, $72, $77, $73
00A5FE  2  39 F1 58 72  
00A602  2  77 73        
00A604  2  D8 72 7F B1        .byte $d8, $72, $7f, $b1, $97, $73, $b6, $64, $c5, $65
00A608  2  97 73 B6 64  
00A60C  2  C5 65        
00A60E  2  D4 66 E3 67        .byte $d4, $66, $e3, $67, $f3, $67, $8d, $c1, $cf, $26
00A612  2  F3 67 8D C1  
00A616  2  CF 26        
00A618  2  FD                 .byte $fd
00A619  2               
00A619  2               ;level 3-1
00A619  2               L_GroundArea5:
00A619  2  52 31              .byte $52, $31
00A61B  2  0F 20 6E 66        .byte $0f, $20, $6e, $66, $07, $81, $36, $01, $66, $00
00A61F  2  07 81 36 01  
00A623  2  66 00        
00A625  2  A7 22 08 F2        .byte $a7, $22, $08, $f2, $67, $7b, $dc, $02, $98, $f2
00A629  2  67 7B DC 02  
00A62D  2  98 F2        
00A62F  2  D7 20 39 F1        .byte $d7, $20, $39, $f1, $9f, $33, $dc, $27, $dc, $57
00A633  2  9F 33 DC 27  
00A637  2  DC 57        
00A639  2  23 83 57 63        .byte $23, $83, $57, $63, $6c, $51, $87, $63, $99, $61
00A63D  2  6C 51 87 63  
00A641  2  99 61        
00A643  2  A3 06 B3 21        .byte $a3, $06, $b3, $21, $77, $f3, $f3, $21, $f7, $2a
00A647  2  77 F3 F3 21  
00A64B  2  F7 2A        
00A64D  2  13 81 23 22        .byte $13, $81, $23, $22, $53, $00, $63, $22, $e9, $0b
00A651  2  53 00 63 22  
00A655  2  E9 0B        
00A657  2  0C 83 13 21        .byte $0c, $83, $13, $21, $16, $22, $33, $05, $8f, $35
00A65B  2  16 22 33 05  
00A65F  2  8F 35        
00A661  2  EC 01 63 A0        .byte $ec, $01, $63, $a0, $67, $20, $73, $01, $77, $01
00A665  2  67 20 73 01  
00A669  2  77 01        
00A66B  2  83 20 87 20        .byte $83, $20, $87, $20, $b3, $20, $b7, $20, $c3, $01
00A66F  2  B3 20 B7 20  
00A673  2  C3 01        
00A675  2  C7 00 D3 20        .byte $c7, $00, $d3, $20, $d7, $20, $67, $a0, $77, $07
00A679  2  D7 20 67 A0  
00A67D  2  77 07        
00A67F  2  87 22 E8 62        .byte $87, $22, $e8, $62, $f5, $65, $1c, $82, $7f, $38
00A683  2  F5 65 1C 82  
00A687  2  7F 38        
00A689  2  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00A68D  2  FD                 .byte $fd
00A68E  2               
00A68E  2               ;level 1-1
00A68E  2               L_GroundArea6:
00A68E  2  50 21              .byte $50, $21
00A690  2  07 81 47 24        .byte $07, $81, $47, $24, $57, $00, $63, $01, $77, $01
00A694  2  57 00 63 01  
00A698  2  77 01        
00A69A  2  C9 71 68 F2        .byte $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83
00A69E  2  E7 73 97 FB  
00A6A2  2  06 83        
00A6A4  2  5C 01 D7 22        .byte $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02
00A6A8  2  E7 00 03 A7  
00A6AC  2  6C 02        
00A6AE  2  B3 22 E3 01        .byte $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06
00A6B2  2  E7 07 47 A0  
00A6B6  2  57 06        
00A6B8  2  A7 01 D3 00        .byte $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20
00A6BC  2  D7 01 07 81  
00A6C0  2  67 20        
00A6C2  2  93 22 03 A3        .byte $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33
00A6C6  2  1C 61 17 21  
00A6CA  2  6F 33        
00A6CC  2  C7 63 D8 62        .byte $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3
00A6D0  2  E9 61 FA 60  
00A6D4  2  4F B3        
00A6D6  2  87 63 9C 01        .byte $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61
00A6DA  2  B7 63 C8 62  
00A6DE  2  D9 61        
00A6E0  2  EA 60 39 F1        .byte $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20
00A6E4  2  87 21 A7 01  
00A6E8  2  B7 20        
00A6EA  2  39 F1 5F 38        .byte $39, $f1, $5f, $38, $6d, $c1, $af, $26
00A6EE  2  6D C1 AF 26  
00A6F2  2  FD                 .byte $fd
00A6F3  2               
00A6F3  2               ;level 1-3/5-3
00A6F3  2               L_GroundArea7:
00A6F3  2  90 11              .byte $90, $11
00A6F5  2  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2a, $93, $87, $17, $a3, $14
00A6F9  2  2A 93 87 17  
00A6FD  2  A3 14        
00A6FF  2  B2 42 0A 92        .byte $b2, $42, $0a, $92, $19, $40, $36, $14, $50, $41
00A703  2  19 40 36 14  
00A707  2  50 41        
00A709  2  82 16 2B 93        .byte $82, $16, $2b, $93, $24, $41, $bb, $14, $b8, $00
00A70D  2  24 41 BB 14  
00A711  2  B8 00        
00A713  2  C2 43 C3 13        .byte $c2, $43, $c3, $13, $1b, $94, $67, $12, $c4, $15
00A717  2  1B 94 67 12  
00A71B  2  C4 15        
00A71D  2  53 C1 D2 41        .byte $53, $c1, $d2, $41, $12, $c1, $29, $13, $85, $17
00A721  2  12 C1 29 13  
00A725  2  85 17        
00A727  2  1B 92 1A 42        .byte $1b, $92, $1a, $42, $47, $13, $83, $41, $a7, $13
00A72B  2  47 13 83 41  
00A72F  2  A7 13        
00A731  2  0E 91 A7 63        .byte $0e, $91, $a7, $63, $b7, $63, $c5, $65, $d5, $65
00A735  2  B7 63 C5 65  
00A739  2  D5 65        
00A73B  2  DD 4A E3 67        .byte $dd, $4a, $e3, $67, $f3, $67, $8d, $c1, $ae, $42
00A73F  2  F3 67 8D C1  
00A743  2  AE 42        
00A745  2  DF 20              .byte $df, $20
00A747  2  FD                 .byte $fd
00A748  2               
00A748  2               ;level 2-3/7-3
00A748  2               L_GroundArea8:
00A748  2  90 11              .byte $90, $11
00A74A  2  0F 26 6E 10        .byte $0f, $26, $6e, $10, $8b, $17, $af, $32, $d8, $62
00A74E  2  8B 17 AF 32  
00A752  2  D8 62        
00A754  2  E8 62 FC 3F        .byte $e8, $62, $fc, $3f, $ad, $c8, $f8, $64, $0c, $be
00A758  2  AD C8 F8 64  
00A75C  2  0C BE        
00A75E  2  43 43 F8 64        .byte $43, $43, $f8, $64, $0c, $bf, $73, $40, $84, $40
00A762  2  0C BF 73 40  
00A766  2  84 40        
00A768  2  93 40 A4 40        .byte $93, $40, $a4, $40, $b3, $40, $f8, $64, $48, $e4
00A76C  2  B3 40 F8 64  
00A770  2  48 E4        
00A772  2  5C 39 83 40        .byte $5c, $39, $83, $40, $92, $41, $b3, $40, $f8, $64
00A776  2  92 41 B3 40  
00A77A  2  F8 64        
00A77C  2  48 E4 5C 39        .byte $48, $e4, $5c, $39, $f8, $64, $13, $c2, $37, $65
00A780  2  F8 64 13 C2  
00A784  2  37 65        
00A786  2  4C 24 63 00        .byte $4c, $24, $63, $00, $97, $65, $c3, $42, $0b, $97
00A78A  2  97 65 C3 42  
00A78E  2  0B 97        
00A790  2  AC 32 F8 64        .byte $ac, $32, $f8, $64, $0c, $be, $53, $45, $9d, $48
00A794  2  0C BE 53 45  
00A798  2  9D 48        
00A79A  2  F8 64 2A E2        .byte $f8, $64, $2a, $e2, $3c, $47, $56, $43, $ba, $62
00A79E  2  3C 47 56 43  
00A7A2  2  BA 62        
00A7A4  2  F8 64 0C B7        .byte $f8, $64, $0c, $b7, $88, $64, $bc, $31, $d4, $45
00A7A8  2  88 64 BC 31  
00A7AC  2  D4 45        
00A7AE  2  FC 31 3C B1        .byte $fc, $31, $3c, $b1, $78, $64, $8c, $38, $0b, $9c
00A7B2  2  78 64 8C 38  
00A7B6  2  0B 9C        
00A7B8  2  1A 33 18 61        .byte $1a, $33, $18, $61, $28, $61, $39, $60, $5d, $4a
00A7BC  2  28 61 39 60  
00A7C0  2  5D 4A        
00A7C2  2  EE 11 0F B8        .byte $ee, $11, $0f, $b8, $1d, $c1, $3e, $42, $6f, $20
00A7C6  2  1D C1 3E 42  
00A7CA  2  6F 20        
00A7CC  2  FD                 .byte $fd
00A7CD  2               
00A7CD  2               ;level 2-1
00A7CD  2               L_GroundArea9:
00A7CD  2  52 31              .byte $52, $31
00A7CF  2  0F 20 6E 40        .byte $0f, $20, $6e, $40, $f7, $20, $07, $84, $17, $20
00A7D3  2  F7 20 07 84  
00A7D7  2  17 20        
00A7D9  2  4F 34 C3 03        .byte $4f, $34, $c3, $03, $c7, $02, $d3, $22, $27, $e3
00A7DD  2  C7 02 D3 22  
00A7E1  2  27 E3        
00A7E3  2  39 61 E7 73        .byte $39, $61, $e7, $73, $5c, $e4, $57, $00, $6c, $73
00A7E7  2  5C E4 57 00  
00A7EB  2  6C 73        
00A7ED  2  47 A0 53 06        .byte $47, $a0, $53, $06, $63, $22, $a7, $73, $fc, $73
00A7F1  2  63 22 A7 73  
00A7F5  2  FC 73        
00A7F7  2  13 A1 33 05        .byte $13, $a1, $33, $05, $43, $21, $5c, $72, $c3, $23
00A7FB  2  43 21 5C 72  
00A7FF  2  C3 23        
00A801  2  CC 03 77 FB        .byte $cc, $03, $77, $fb, $ac, $02, $39, $f1, $a7, $73
00A805  2  AC 02 39 F1  
00A809  2  A7 73        
00A80B  2  D3 04 E8 72        .byte $d3, $04, $e8, $72, $e3, $22, $26, $f4, $bc, $02
00A80F  2  E3 22 26 F4  
00A813  2  BC 02        
00A815  2  8C 81 A8 62        .byte $8c, $81, $a8, $62, $17, $87, $43, $24, $a7, $01
00A819  2  17 87 43 24  
00A81D  2  A7 01        
00A81F  2  C3 04 08 F2        .byte $c3, $04, $08, $f2, $97, $21, $a3, $02, $c9, $0b
00A823  2  97 21 A3 02  
00A827  2  C9 0B        
00A829  2  E1 69 F1 69        .byte $e1, $69, $f1, $69, $8d, $c1, $cf, $26
00A82D  2  8D C1 CF 26  
00A831  2  FD                 .byte $fd
00A832  2               
00A832  2               ;pipe intro area
00A832  2               L_GroundArea10:
00A832  2  38 11              .byte $38, $11
00A834  2  0F 26 AD 40        .byte $0f, $26, $ad, $40, $3d, $c7
00A838  2  3D C7        
00A83A  2  FD                 .byte $fd
00A83B  2               
00A83B  2               ;level 5-1
00A83B  2               L_GroundArea11:
00A83B  2  95 B1              .byte $95, $b1
00A83D  2  0F 26 0D 02        .byte $0f, $26, $0d, $02, $c8, $72, $1c, $81, $38, $72
00A841  2  C8 72 1C 81  
00A845  2  38 72        
00A847  2  0D 05 97 34        .byte $0d, $05, $97, $34, $98, $62, $a3, $20, $b3, $06
00A84B  2  98 62 A3 20  
00A84F  2  B3 06        
00A851  2  C3 20 CC 03        .byte $c3, $20, $cc, $03, $f9, $91, $2c, $81, $48, $62
00A855  2  F9 91 2C 81  
00A859  2  48 62        
00A85B  2  0D 09 37 63        .byte $0d, $09, $37, $63, $47, $03, $57, $21, $8c, $02
00A85F  2  47 03 57 21  
00A863  2  8C 02        
00A865  2  C5 79 C7 31        .byte $c5, $79, $c7, $31, $f9, $11, $39, $f1, $a9, $11
00A869  2  F9 11 39 F1  
00A86D  2  A9 11        
00A86F  2  6F B4 D3 65        .byte $6f, $b4, $d3, $65, $e3, $65, $7d, $c1, $bf, $26
00A873  2  E3 65 7D C1  
00A877  2  BF 26        
00A879  2  FD                 .byte $fd
00A87A  2               
00A87A  2               ;cloud level used in levels 2-1 and 5-2
00A87A  2               L_GroundArea12:
00A87A  2  00 C1              .byte $00, $c1
00A87C  2  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $02, $42, $43, $4f
00A880  2  0D 02 02 42  
00A884  2  43 4F        
00A886  2  52 C2 DE 00        .byte $52, $c2, $de, $00, $5a, $c2, $4d, $c7
00A88A  2  5A C2 4D C7  
00A88E  2  FD                 .byte $fd
00A88F  2               
00A88F  2               ;level 4-3
00A88F  2               L_GroundArea13:
00A88F  2  90 51              .byte $90, $51
00A891  2  0F 26 EE 10        .byte $0f, $26, $ee, $10, $0b, $94, $33, $14, $42, $42
00A895  2  0B 94 33 14  
00A899  2  42 42        
00A89B  2  77 16 86 44        .byte $77, $16, $86, $44, $02, $92, $4a, $16, $69, $42
00A89F  2  02 92 4A 16  
00A8A3  2  69 42        
00A8A5  2  73 14 B0 00        .byte $73, $14, $b0, $00, $c7, $12, $05, $c0, $1c, $17
00A8A9  2  C7 12 05 C0  
00A8AD  2  1C 17        
00A8AF  2  1F 11 36 12        .byte $1f, $11, $36, $12, $8f, $14, $91, $40, $1b, $94
00A8B3  2  8F 14 91 40  
00A8B7  2  1B 94        
00A8B9  2  35 12 34 42        .byte $35, $12, $34, $42, $60, $42, $61, $12, $87, $12
00A8BD  2  60 42 61 12  
00A8C1  2  87 12        
00A8C3  2  96 40 A3 14        .byte $96, $40, $a3, $14, $1c, $98, $1f, $11, $47, $12
00A8C7  2  1C 98 1F 11  
00A8CB  2  47 12        
00A8CD  2  9F 15 CC 15        .byte $9f, $15, $cc, $15, $cf, $11, $05, $c0, $1f, $15
00A8D1  2  CF 11 05 C0  
00A8D5  2  1F 15        
00A8D7  2  39 12 7C 16        .byte $39, $12, $7c, $16, $7f, $11, $82, $40, $98, $12
00A8DB  2  7F 11 82 40  
00A8DF  2  98 12        
00A8E1  2  DF 15 16 C4        .byte $df, $15, $16, $c4, $17, $14, $54, $12, $9b, $16
00A8E5  2  17 14 54 12  
00A8E9  2  9B 16        
00A8EB  2  28 94 CE 01        .byte $28, $94, $ce, $01, $3d, $c1, $5e, $42, $8f, $20
00A8EF  2  3D C1 5E 42  
00A8F3  2  8F 20        
00A8F5  2  FD                 .byte $fd
00A8F6  2               
00A8F6  2               ;level 6-3
00A8F6  2               L_GroundArea14:
00A8F6  2  97 11              .byte $97, $11
00A8F8  2  0F 26 FE 10        .byte $0f, $26, $fe, $10, $2b, $92, $57, $12, $8b, $12
00A8FC  2  2B 92 57 12  
00A900  2  8B 12        
00A902  2  C0 41 F7 13        .byte $c0, $41, $f7, $13, $5b, $92, $69, $0b, $bb, $12
00A906  2  5B 92 69 0B  
00A90A  2  BB 12        
00A90C  2  B2 46 19 93        .byte $b2, $46, $19, $93, $71, $00, $17, $94, $7c, $14
00A910  2  71 00 17 94  
00A914  2  7C 14        
00A916  2  7F 11 93 41        .byte $7f, $11, $93, $41, $bf, $15, $fc, $13, $ff, $11
00A91A  2  BF 15 FC 13  
00A91E  2  FF 11        
00A920  2  2F 95 50 42        .byte $2f, $95, $50, $42, $51, $12, $58, $14, $a6, $12
00A924  2  51 12 58 14  
00A928  2  A6 12        
00A92A  2  DB 12 1B 93        .byte $db, $12, $1b, $93, $46, $43, $7b, $12, $8d, $49
00A92E  2  46 43 7B 12  
00A932  2  8D 49        
00A934  2  B7 14 1B 94        .byte $b7, $14, $1b, $94, $49, $0b, $bb, $12, $fc, $13
00A938  2  49 0B BB 12  
00A93C  2  FC 13        
00A93E  2  FF 12 03 C1        .byte $ff, $12, $03, $c1, $2f, $15, $43, $12, $4b, $13
00A942  2  2F 15 43 12  
00A946  2  4B 13        
00A948  2  77 13 9D 4A        .byte $77, $13, $9d, $4a, $15, $c1, $a1, $41, $c3, $12
00A94C  2  15 C1 A1 41  
00A950  2  C3 12        
00A952  2  FE 01 7D C1        .byte $fe, $01, $7d, $c1, $9e, $42, $cf, $20
00A956  2  9E 42 CF 20  
00A95A  2  FD                 .byte $fd
00A95B  2               
00A95B  2               ;level 6-1
00A95B  2               L_GroundArea15:
00A95B  2  52 21              .byte $52, $21
00A95D  2  0F 20 6E 44        .byte $0f, $20, $6e, $44, $0c, $f1, $4c, $01, $aa, $35
00A961  2  0C F1 4C 01  
00A965  2  AA 35        
00A967  2  D9 34 EE 20        .byte $d9, $34, $ee, $20, $08, $b3, $37, $32, $43, $04
00A96B  2  08 B3 37 32  
00A96F  2  43 04        
00A971  2  4E 21 53 20        .byte $4e, $21, $53, $20, $7c, $01, $97, $21, $b7, $07
00A975  2  7C 01 97 21  
00A979  2  B7 07        
00A97B  2  9C 81 E7 42        .byte $9c, $81, $e7, $42, $5f, $b3, $97, $63, $ac, $02
00A97F  2  5F B3 97 63  
00A983  2  AC 02        
00A985  2  C5 41 49 E0        .byte $c5, $41, $49, $e0, $58, $61, $76, $64, $85, $65
00A989  2  58 61 76 64  
00A98D  2  85 65        
00A98F  2  94 66 A4 22        .byte $94, $66, $a4, $22, $a6, $03, $c8, $22, $dc, $02
00A993  2  A6 03 C8 22  
00A997  2  DC 02        
00A999  2  68 F2 96 42        .byte $68, $f2, $96, $42, $13, $82, $17, $02, $af, $34
00A99D  2  13 82 17 02  
00A9A1  2  AF 34        
00A9A3  2  F6 21 FC 06        .byte $f6, $21, $fc, $06, $26, $80, $2a, $24, $36, $01
00A9A7  2  26 80 2A 24  
00A9AB  2  36 01        
00A9AD  2  8C 00 FF 35        .byte $8c, $00, $ff, $35, $4e, $a0, $55, $21, $77, $20
00A9B1  2  4E A0 55 21  
00A9B5  2  77 20        
00A9B7  2  87 07 89 22        .byte $87, $07, $89, $22, $ae, $21, $4c, $82, $9f, $34
00A9BB  2  AE 21 4C 82  
00A9BF  2  9F 34        
00A9C1  2  EC 01 03 E7        .byte $ec, $01, $03, $e7, $13, $67, $8d, $4a, $ad, $41
00A9C5  2  13 67 8D 4A  
00A9C9  2  AD 41        
00A9CB  2  0F A6              .byte $0f, $a6
00A9CD  2  FD                 .byte $fd
00A9CE  2               
00A9CE  2               ;warp zone area used in level 4-2
00A9CE  2               L_GroundArea16:
00A9CE  2  10 51              .byte $10, $51
00A9D0  2  4C 00 C7 12        .byte $4c, $00, $c7, $12, $c6, $42, $03, $92, $02, $42
00A9D4  2  C6 42 03 92  
00A9D8  2  02 42        
00A9DA  2  29 12 63 12        .byte $29, $12, $63, $12, $62, $42, $69, $14, $a5, $12
00A9DE  2  62 42 69 14  
00A9E2  2  A5 12        
00A9E4  2  A4 42 E2 14        .byte $a4, $42, $e2, $14, $e1, $44, $f8, $16, $37, $c1
00A9E8  2  E1 44 F8 16  
00A9EC  2  37 C1        
00A9EE  2  8F 38 02 BB        .byte $8f, $38, $02, $bb, $28, $7a, $68, $7a, $a8, $7a
00A9F2  2  28 7A 68 7A  
00A9F6  2  A8 7A        
00A9F8  2  E0 6A F0 6A        .byte $e0, $6a, $f0, $6a, $6d, $c5
00A9FC  2  6D C5        
00A9FE  2  FD                 .byte $fd
00A9FF  2               
00A9FF  2               ;level 8-1
00A9FF  2               L_GroundArea17:
00A9FF  2  92 31              .byte $92, $31
00AA01  2  0F 20 6E 40        .byte $0f, $20, $6e, $40, $0d, $02, $37, $73, $ec, $00
00AA05  2  0D 02 37 73  
00AA09  2  EC 00        
00AA0B  2  0C 80 3C 00        .byte $0c, $80, $3c, $00, $6c, $00, $9c, $00, $06, $c0
00AA0F  2  6C 00 9C 00  
00AA13  2  06 C0        
00AA15  2  C7 73 06 83        .byte $c7, $73, $06, $83, $28, $72, $96, $40, $e7, $73
00AA19  2  28 72 96 40  
00AA1D  2  E7 73        
00AA1F  2  26 C0 87 7B        .byte $26, $c0, $87, $7b, $d2, $41, $39, $f1, $c8, $f2
00AA23  2  D2 41 39 F1  
00AA27  2  C8 F2        
00AA29  2  97 E3 A3 23        .byte $97, $e3, $a3, $23, $e7, $02, $e3, $07, $f3, $22
00AA2D  2  E7 02 E3 07  
00AA31  2  F3 22        
00AA33  2  37 E3 9C 00        .byte $37, $e3, $9c, $00, $bc, $00, $ec, $00, $0c, $80
00AA37  2  BC 00 EC 00  
00AA3B  2  0C 80        
00AA3D  2  3C 00 86 21        .byte $3c, $00, $86, $21, $a6, $06, $b6, $24, $5c, $80
00AA41  2  A6 06 B6 24  
00AA45  2  5C 80        
00AA47  2  7C 00 9C 00        .byte $7c, $00, $9c, $00, $29, $e1, $dc, $05, $f6, $41
00AA4B  2  29 E1 DC 05  
00AA4F  2  F6 41        
00AA51  2  DC 80 E8 72        .byte $dc, $80, $e8, $72, $0c, $81, $27, $73, $4c, $01
00AA55  2  0C 81 27 73  
00AA59  2  4C 01        
00AA5B  2  66 74 0D 11        .byte $66, $74, $0d, $11, $3f, $35, $b6, $41, $2c, $82
00AA5F  2  3F 35 B6 41  
00AA63  2  2C 82        
00AA65  2  36 40 7C 02        .byte $36, $40, $7c, $02, $86, $40, $f9, $61, $39, $e1
00AA69  2  86 40 F9 61  
00AA6D  2  39 E1        
00AA6F  2  AC 04 C6 41        .byte $ac, $04, $c6, $41, $0c, $83, $16, $41, $88, $f2
00AA73  2  0C 83 16 41  
00AA77  2  88 F2        
00AA79  2  39 F1 7C 00        .byte $39, $f1, $7c, $00, $89, $61, $9c, $00, $a7, $63
00AA7D  2  89 61 9C 00  
00AA81  2  A7 63        
00AA83  2  BC 00 C5 65        .byte $bc, $00, $c5, $65, $dc, $00, $e3, $67, $f3, $67
00AA87  2  DC 00 E3 67  
00AA8B  2  F3 67        
00AA8D  2  8D C1 CF 26        .byte $8d, $c1, $cf, $26
00AA91  2  FD                 .byte $fd
00AA92  2               
00AA92  2               ;level 5-2
00AA92  2               L_GroundArea18:
00AA92  2  55 B1              .byte $55, $b1
00AA94  2  0F 26 CF 33        .byte $0f, $26, $cf, $33, $07, $b2, $15, $11, $52, $42
00AA98  2  07 B2 15 11  
00AA9C  2  52 42        
00AA9E  2  99 0B AC 02        .byte $99, $0b, $ac, $02, $d3, $24, $d6, $42, $d7, $25
00AAA2  2  D3 24 D6 42  
00AAA6  2  D7 25        
00AAA8  2  23 84 CF 33        .byte $23, $84, $cf, $33, $07, $e3, $19, $61, $78, $7a
00AAAC  2  07 E3 19 61  
00AAB0  2  78 7A        
00AAB2  2  EF 33 2C 81        .byte $ef, $33, $2c, $81, $46, $64, $55, $65, $65, $65
00AAB6  2  46 64 55 65  
00AABA  2  65 65        
00AABC  2  EC 74 47 82        .byte $ec, $74, $47, $82, $53, $05, $63, $21, $62, $41
00AAC0  2  53 05 63 21  
00AAC4  2  62 41        
00AAC6  2  96 22 9A 41        .byte $96, $22, $9a, $41, $cc, $03, $b9, $91, $39, $f1
00AACA  2  CC 03 B9 91  
00AACE  2  39 F1        
00AAD0  2  63 26 67 27        .byte $63, $26, $67, $27, $d3, $06, $fc, $01, $18, $e2
00AAD4  2  D3 06 FC 01  
00AAD8  2  18 E2        
00AADA  2  D9 07 E9 04        .byte $d9, $07, $e9, $04, $0c, $86, $37, $22, $93, $24
00AADE  2  0C 86 37 22  
00AAE2  2  93 24        
00AAE4  2  87 84 AC 02        .byte $87, $84, $ac, $02, $c2, $41, $c3, $23, $d9, $71
00AAE8  2  C2 41 C3 23  
00AAEC  2  D9 71        
00AAEE  2  FC 01 7F B1        .byte $fc, $01, $7f, $b1, $9c, $00, $a7, $63, $b6, $64
00AAF2  2  9C 00 A7 63  
00AAF6  2  B6 64        
00AAF8  2  CC 00 D4 66        .byte $cc, $00, $d4, $66, $e3, $67, $f3, $67, $8d, $c1
00AAFC  2  E3 67 F3 67  
00AB00  2  8D C1        
00AB02  2  CF 26              .byte $cf, $26
00AB04  2  FD                 .byte $fd
00AB05  2               
00AB05  2               ;level 8-2
00AB05  2               L_GroundArea19:
00AB05  2  50 B1              .byte $50, $b1
00AB07  2  0F 26 FC 00        .byte $0f, $26, $fc, $00, $1f, $b3, $5c, $00, $65, $65
00AB0B  2  1F B3 5C 00  
00AB0F  2  65 65        
00AB11  2  74 66 83 67        .byte $74, $66, $83, $67, $93, $67, $dc, $73, $4c, $80
00AB15  2  93 67 DC 73  
00AB19  2  4C 80        
00AB1B  2  B3 20 C9 0B        .byte $b3, $20, $c9, $0b, $c3, $08, $d3, $2f, $dc, $00
00AB1F  2  C3 08 D3 2F  
00AB23  2  DC 00        
00AB25  2  2C 80 4C 00        .byte $2c, $80, $4c, $00, $8c, $00, $d3, $2e, $ed, $4a
00AB29  2  8C 00 D3 2E  
00AB2D  2  ED 4A        
00AB2F  2  FC 00 D7 A1        .byte $fc, $00, $d7, $a1, $ec, $01, $4c, $80, $59, $11
00AB33  2  EC 01 4C 80  
00AB37  2  59 11        
00AB39  2  D8 11 DA 10        .byte $d8, $11, $da, $10, $37, $a0, $47, $04, $99, $11
00AB3D  2  37 A0 47 04  
00AB41  2  99 11        
00AB43  2  E7 21 3A 90        .byte $e7, $21, $3a, $90, $67, $20, $76, $10, $77, $60
00AB47  2  67 20 76 10  
00AB4B  2  77 60        
00AB4D  2  87 07 D8 12        .byte $87, $07, $d8, $12, $39, $f1, $ac, $00, $e9, $71
00AB51  2  39 F1 AC 00  
00AB55  2  E9 71        
00AB57  2  0C 80 2C 00        .byte $0c, $80, $2c, $00, $4c, $05, $c7, $7b, $39, $f1
00AB5B  2  4C 05 C7 7B  
00AB5F  2  39 F1        
00AB61  2  EC 00 F9 11        .byte $ec, $00, $f9, $11, $0c, $82, $6f, $34, $f8, $11
00AB65  2  0C 82 6F 34  
00AB69  2  F8 11        
00AB6B  2  FA 10 7F B2        .byte $fa, $10, $7f, $b2, $ac, $00, $b6, $64, $cc, $01
00AB6F  2  AC 00 B6 64  
00AB73  2  CC 01        
00AB75  2  E3 67 F3 67        .byte $e3, $67, $f3, $67, $8d, $c1, $cf, $26
00AB79  2  8D C1 CF 26  
00AB7D  2  FD                 .byte $fd
00AB7E  2               
00AB7E  2               ;level 7-1
00AB7E  2               L_GroundArea20:
00AB7E  2  52 B1              .byte $52, $b1
00AB80  2  0F 20 6E 45        .byte $0f, $20, $6e, $45, $39, $91, $b3, $04, $c3, $21
00AB84  2  39 91 B3 04  
00AB88  2  C3 21        
00AB8A  2  C8 11 CA 10        .byte $c8, $11, $ca, $10, $49, $91, $7c, $73, $e8, $12
00AB8E  2  49 91 7C 73  
00AB92  2  E8 12        
00AB94  2  88 91 8A 10        .byte $88, $91, $8a, $10, $e7, $21, $05, $91, $07, $30
00AB98  2  E7 21 05 91  
00AB9C  2  07 30        
00AB9E  2  17 07 27 20        .byte $17, $07, $27, $20, $49, $11, $9c, $01, $c8, $72
00ABA2  2  49 11 9C 01  
00ABA6  2  C8 72        
00ABA8  2  23 A6 27 26        .byte $23, $a6, $27, $26, $d3, $03, $d8, $7a, $89, $91
00ABAC  2  D3 03 D8 7A  
00ABB0  2  89 91        
00ABB2  2  D8 72 39 F1        .byte $d8, $72, $39, $f1, $a9, $11, $09, $f1, $63, $24
00ABB6  2  A9 11 09 F1  
00ABBA  2  63 24        
00ABBC  2  67 24 D8 62        .byte $67, $24, $d8, $62, $28, $91, $2a, $10, $56, $21
00ABC0  2  28 91 2A 10  
00ABC4  2  56 21        
00ABC6  2  70 04 79 0B        .byte $70, $04, $79, $0b, $8c, $00, $94, $21, $9f, $35
00ABCA  2  8C 00 94 21  
00ABCE  2  9F 35        
00ABD0  2  2F B8 3D C1        .byte $2f, $b8, $3d, $c1, $7f, $26
00ABD4  2  7F 26        
00ABD6  2  FD                 .byte $fd
00ABD7  2               
00ABD7  2               ;cloud level used in levels 3-1 and 6-2
00ABD7  2               L_GroundArea21:
00ABD7  2  06 C1              .byte $06, $c1
00ABD9  2  4C 00 F4 4F        .byte $4c, $00, $f4, $4f, $0d, $02, $06, $20, $24, $4f
00ABDD  2  0D 02 06 20  
00ABE1  2  24 4F        
00ABE3  2  35 A0 36 20        .byte $35, $a0, $36, $20, $53, $46, $d5, $20, $d6, $20
00ABE7  2  53 46 D5 20  
00ABEB  2  D6 20        
00ABED  2  34 A1 73 49        .byte $34, $a1, $73, $49, $74, $20, $94, $20, $b4, $20
00ABF1  2  74 20 94 20  
00ABF5  2  B4 20        
00ABF7  2  D4 20 F4 20        .byte $d4, $20, $f4, $20, $2e, $80, $59, $42, $4d, $c7
00ABFB  2  2E 80 59 42  
00ABFF  2  4D C7        
00AC01  2  FD                 .byte $fd
00AC02  2               
00AC02  2               ;level 3-2
00AC02  2               L_GroundArea22:
00AC02  2  96 31              .byte $96, $31
00AC04  2  0F 26 0D 03        .byte $0f, $26, $0d, $03, $1a, $60, $77, $42, $c4, $00
00AC08  2  1A 60 77 42  
00AC0C  2  C4 00        
00AC0E  2  C8 62 B9 E1        .byte $c8, $62, $b9, $e1, $d3, $06, $d7, $07, $f9, $61
00AC12  2  D3 06 D7 07  
00AC16  2  F9 61        
00AC18  2  0C 81 4E B1        .byte $0c, $81, $4e, $b1, $8e, $b1, $bc, $01, $e4, $50
00AC1C  2  8E B1 BC 01  
00AC20  2  E4 50        
00AC22  2  E9 61 0C 81        .byte $e9, $61, $0c, $81, $0d, $0a, $84, $43, $98, $72
00AC26  2  0D 0A 84 43  
00AC2A  2  98 72        
00AC2C  2  0D 0C 0F 38        .byte $0d, $0c, $0f, $38, $1d, $c1, $5f, $26
00AC30  2  1D C1 5F 26  
00AC34  2  FD                 .byte $fd
00AC35  2               
00AC35  2               ;level 1-2
00AC35  2               L_UndergroundArea1:
00AC35  2  48 0F              .byte $48, $0f
00AC37  2  0E 01 5E 02        .byte $0e, $01, $5e, $02, $a7, $00, $bc, $73, $1a, $e0
00AC3B  2  A7 00 BC 73  
00AC3F  2  1A E0        
00AC41  2  39 61 58 62        .byte $39, $61, $58, $62, $77, $63, $97, $63, $b8, $62
00AC45  2  77 63 97 63  
00AC49  2  B8 62        
00AC4B  2  D6 07 F8 62        .byte $d6, $07, $f8, $62, $19, $e1, $75, $52, $86, $40
00AC4F  2  19 E1 75 52  
00AC53  2  86 40        
00AC55  2  87 50 95 52        .byte $87, $50, $95, $52, $93, $43, $a5, $21, $c5, $52
00AC59  2  93 43 A5 21  
00AC5D  2  C5 52        
00AC5F  2  D6 40 D7 20        .byte $d6, $40, $d7, $20, $e5, $06, $e6, $51, $3e, $8d
00AC63  2  E5 06 E6 51  
00AC67  2  3E 8D        
00AC69  2  5E 03 67 52        .byte $5e, $03, $67, $52, $77, $52, $7e, $02, $9e, $03
00AC6D  2  77 52 7E 02  
00AC71  2  9E 03        
00AC73  2  A6 43 A7 23        .byte $a6, $43, $a7, $23, $de, $05, $fe, $02, $1e, $83
00AC77  2  DE 05 FE 02  
00AC7B  2  1E 83        
00AC7D  2  33 54 46 40        .byte $33, $54, $46, $40, $47, $21, $56, $04, $5e, $02
00AC81  2  47 21 56 04  
00AC85  2  5E 02        
00AC87  2  83 54 93 52        .byte $83, $54, $93, $52, $96, $07, $97, $50, $be, $03
00AC8B  2  96 07 97 50  
00AC8F  2  BE 03        
00AC91  2  C7 23 FE 02        .byte $c7, $23, $fe, $02, $0c, $82, $43, $45, $45, $24
00AC95  2  0C 82 43 45  
00AC99  2  45 24        
00AC9B  2  46 24 90 08        .byte $46, $24, $90, $08, $95, $51, $78, $fa, $d7, $73
00AC9F  2  95 51 78 FA  
00ACA3  2  D7 73        
00ACA5  2  39 F1 8C 01        .byte $39, $f1, $8c, $01, $a8, $52, $b8, $52, $cc, $01
00ACA9  2  A8 52 B8 52  
00ACAD  2  CC 01        
00ACAF  2  5F B3 97 63        .byte $5f, $b3, $97, $63, $9e, $00, $0e, $81, $16, $24
00ACB3  2  9E 00 0E 81  
00ACB7  2  16 24        
00ACB9  2  66 04 8E 00        .byte $66, $04, $8e, $00, $fe, $01, $08, $d2, $0e, $06
00ACBD  2  FE 01 08 D2  
00ACC1  2  0E 06        
00ACC3  2  6F 47 9E 0F        .byte $6f, $47, $9e, $0f, $0e, $82, $2d, $47, $28, $7a
00ACC7  2  0E 82 2D 47  
00ACCB  2  28 7A        
00ACCD  2  68 7A A8 7A        .byte $68, $7a, $a8, $7a, $ae, $01, $de, $0f, $6d, $c5
00ACD1  2  AE 01 DE 0F  
00ACD5  2  6D C5        
00ACD7  2  FD                 .byte $fd
00ACD8  2               
00ACD8  2               ;level 4-2
00ACD8  2               L_UndergroundArea2:
00ACD8  2  48 0F              .byte $48, $0f
00ACDA  2  0E 01 5E 02        .byte $0e, $01, $5e, $02, $bc, $01, $fc, $01, $2c, $82
00ACDE  2  BC 01 FC 01  
00ACE2  2  2C 82        
00ACE4  2  41 52 4E 04        .byte $41, $52, $4e, $04, $67, $25, $68, $24, $69, $24
00ACE8  2  67 25 68 24  
00ACEC  2  69 24        
00ACEE  2  BA 42 C7 04        .byte $ba, $42, $c7, $04, $de, $0b, $b2, $87, $fe, $02
00ACF2  2  DE 0B B2 87  
00ACF6  2  FE 02        
00ACF8  2  2C E1 2C 71        .byte $2c, $e1, $2c, $71, $67, $01, $77, $00, $87, $01
00ACFC  2  67 01 77 00  
00AD00  2  87 01        
00AD02  2  8E 00 EE 01        .byte $8e, $00, $ee, $01, $f6, $02, $03, $85, $05, $02
00AD06  2  F6 02 03 85  
00AD0A  2  05 02        
00AD0C  2  13 21 16 02        .byte $13, $21, $16, $02, $27, $02, $2e, $02, $88, $72
00AD10  2  27 02 2E 02  
00AD14  2  88 72        
00AD16  2  C7 20 D7 07        .byte $c7, $20, $d7, $07, $e4, $76, $07, $a0, $17, $06
00AD1A  2  E4 76 07 A0  
00AD1E  2  17 06        
00AD20  2  48 7A 76 20        .byte $48, $7a, $76, $20, $98, $72, $79, $e1, $88, $62
00AD24  2  98 72 79 E1  
00AD28  2  88 62        
00AD2A  2  9C 01 B7 73        .byte $9c, $01, $b7, $73, $dc, $01, $f8, $62, $fe, $01
00AD2E  2  DC 01 F8 62  
00AD32  2  FE 01        
00AD34  2  08 E2 0E 00        .byte $08, $e2, $0e, $00, $6e, $02, $73, $20, $77, $23
00AD38  2  6E 02 73 20  
00AD3C  2  77 23        
00AD3E  2  83 04 93 20        .byte $83, $04, $93, $20, $ae, $00, $fe, $0a, $0e, $82
00AD42  2  AE 00 FE 0A  
00AD46  2  0E 82        
00AD48  2  39 71 A8 72        .byte $39, $71, $a8, $72, $e7, $73, $0c, $81, $8f, $32
00AD4C  2  E7 73 0C 81  
00AD50  2  8F 32        
00AD52  2  AE 00 FE 04        .byte $ae, $00, $fe, $04, $04, $d1, $17, $04, $26, $49
00AD56  2  04 D1 17 04  
00AD5A  2  26 49        
00AD5C  2  27 29 DF 33        .byte $27, $29, $df, $33, $fe, $02, $44, $f6, $7c, $01
00AD60  2  FE 02 44 F6  
00AD64  2  7C 01        
00AD66  2  8E 06 BF 47        .byte $8e, $06, $bf, $47, $ee, $0f, $4d, $c7, $0e, $82
00AD6A  2  EE 0F 4D C7  
00AD6E  2  0E 82        
00AD70  2  68 7A AE 01        .byte $68, $7a, $ae, $01, $de, $0f, $6d, $c5
00AD74  2  DE 0F 6D C5  
00AD78  2  FD                 .byte $fd
00AD79  2               
00AD79  2               ;underground bonus rooms area used in many levels
00AD79  2               L_UndergroundArea3:
00AD79  2  48 01              .byte $48, $01
00AD7B  2  0E 01 00 5A        .byte $0e, $01, $00, $5a, $3e, $06, $45, $46, $47, $46
00AD7F  2  3E 06 45 46  
00AD83  2  47 46        
00AD85  2  53 44 AE 01        .byte $53, $44, $ae, $01, $df, $4a, $4d, $c7, $0e, $81
00AD89  2  DF 4A 4D C7  
00AD8D  2  0E 81        
00AD8F  2  00 5A 2E 04        .byte $00, $5a, $2e, $04, $37, $28, $3a, $48, $46, $47
00AD93  2  37 28 3A 48  
00AD97  2  46 47        
00AD99  2  C7 07 CE 0F        .byte $c7, $07, $ce, $0f, $df, $4a, $4d, $c7, $0e, $81
00AD9D  2  DF 4A 4D C7  
00ADA1  2  0E 81        
00ADA3  2  00 5A 33 53        .byte $00, $5a, $33, $53, $43, $51, $46, $40, $47, $50
00ADA7  2  43 51 46 40  
00ADAB  2  47 50        
00ADAD  2  53 04 55 40        .byte $53, $04, $55, $40, $56, $50, $62, $43, $64, $40
00ADB1  2  56 50 62 43  
00ADB5  2  64 40        
00ADB7  2  65 50 71 41        .byte $65, $50, $71, $41, $73, $51, $83, $51, $94, $40
00ADBB  2  73 51 83 51  
00ADBF  2  94 40        
00ADC1  2  95 50 A3 50        .byte $95, $50, $a3, $50, $a5, $40, $a6, $50, $b3, $51
00ADC5  2  A5 40 A6 50  
00ADC9  2  B3 51        
00ADCB  2  B6 40 B7 50        .byte $b6, $40, $b7, $50, $c3, $53, $df, $4a, $4d, $c7
00ADCF  2  C3 53 DF 4A  
00ADD3  2  4D C7        
00ADD5  2  0E 81 00 5A        .byte $0e, $81, $00, $5a, $2e, $02, $36, $47, $37, $52
00ADD9  2  2E 02 36 47  
00ADDD  2  37 52        
00ADDF  2  3A 49 47 25        .byte $3a, $49, $47, $25, $a7, $52, $d7, $04, $df, $4a
00ADE3  2  A7 52 D7 04  
00ADE7  2  DF 4A        
00ADE9  2  4D C7 0E 81        .byte $4d, $c7, $0e, $81, $00, $5a, $3e, $02, $44, $51
00ADED  2  00 5A 3E 02  
00ADF1  2  44 51        
00ADF3  2  53 44 54 44        .byte $53, $44, $54, $44, $55, $24, $a1, $54, $ae, $01
00ADF7  2  55 24 A1 54  
00ADFB  2  AE 01        
00ADFD  2  B4 21 DF 4A        .byte $b4, $21, $df, $4a, $e5, $07, $4d, $c7
00AE01  2  E5 07 4D C7  
00AE05  2  FD                 .byte $fd
00AE06  2               
00AE06  2               ;water area used in levels 5-2 and 6-2
00AE06  2               L_WaterArea1:
00AE06  2  41 01              .byte $41, $01
00AE08  2  B4 34 C8 52        .byte $b4, $34, $c8, $52, $f2, $51, $47, $d3, $6c, $03
00AE0C  2  F2 51 47 D3  
00AE10  2  6C 03        
00AE12  2  65 49 9E 07        .byte $65, $49, $9e, $07, $be, $01, $cc, $03, $fe, $07
00AE16  2  BE 01 CC 03  
00AE1A  2  FE 07        
00AE1C  2  0D C9 1E 01        .byte $0d, $c9, $1e, $01, $6c, $01, $62, $35, $63, $53
00AE20  2  6C 01 62 35  
00AE24  2  63 53        
00AE26  2  8A 41 AC 01        .byte $8a, $41, $ac, $01, $b3, $53, $e9, $51, $26, $c3
00AE2A  2  B3 53 E9 51  
00AE2E  2  26 C3        
00AE30  2  27 33 63 43        .byte $27, $33, $63, $43, $64, $33, $ba, $60, $c9, $61
00AE34  2  64 33 BA 60  
00AE38  2  C9 61        
00AE3A  2  CE 0B E5 09        .byte $ce, $0b, $e5, $09, $ee, $0f, $7d, $ca, $7d, $47
00AE3E  2  EE 0F 7D CA  
00AE42  2  7D 47        
00AE44  2  FD                 .byte $fd
00AE45  2               
00AE45  2               ;level 2-2/7-2
00AE45  2               L_WaterArea2:
00AE45  2  41 01              .byte $41, $01
00AE47  2  B8 52 EA 41        .byte $b8, $52, $ea, $41, $27, $b2, $b3, $42, $16, $d4
00AE4B  2  27 B2 B3 42  
00AE4F  2  16 D4        
00AE51  2  4A 42 A5 51        .byte $4a, $42, $a5, $51, $a7, $31, $27, $d3, $08, $e2
00AE55  2  A7 31 27 D3  
00AE59  2  08 E2        
00AE5B  2  16 64 2C 04        .byte $16, $64, $2c, $04, $38, $42, $76, $64, $88, $62
00AE5F  2  38 42 76 64  
00AE63  2  88 62        
00AE65  2  DE 07 FE 01        .byte $de, $07, $fe, $01, $0d, $c9, $23, $32, $31, $51
00AE69  2  0D C9 23 32  
00AE6D  2  31 51        
00AE6F  2  98 52 0D C9        .byte $98, $52, $0d, $c9, $59, $42, $63, $53, $67, $31
00AE73  2  59 42 63 53  
00AE77  2  67 31        
00AE79  2  14 C2 36 31        .byte $14, $c2, $36, $31, $87, $53, $17, $e3, $29, $61
00AE7D  2  87 53 17 E3  
00AE81  2  29 61        
00AE83  2  30 62 3C 08        .byte $30, $62, $3c, $08, $42, $37, $59, $40, $6a, $42
00AE87  2  42 37 59 40  
00AE8B  2  6A 42        
00AE8D  2  99 40 C9 61        .byte $99, $40, $c9, $61, $d7, $63, $39, $d1, $58, $52
00AE91  2  D7 63 39 D1  
00AE95  2  58 52        
00AE97  2  C3 67 D3 31        .byte $c3, $67, $d3, $31, $dc, $06, $f7, $42, $fa, $42
00AE9B  2  DC 06 F7 42  
00AE9F  2  FA 42        
00AEA1  2  23 B1 43 67        .byte $23, $b1, $43, $67, $c3, $34, $c7, $34, $d1, $51
00AEA5  2  C3 34 C7 34  
00AEA9  2  D1 51        
00AEAB  2  43 B3 47 33        .byte $43, $b3, $47, $33, $9a, $30, $a9, $61, $b8, $62
00AEAF  2  9A 30 A9 61  
00AEB3  2  B8 62        
00AEB5  2  BE 0B D5 09        .byte $be, $0b, $d5, $09, $de, $0f, $0d, $ca, $7d, $47
00AEB9  2  DE 0F 0D CA  
00AEBD  2  7D 47        
00AEBF  2  FD                 .byte $fd
00AEC0  2               
00AEC0  2               ;water area used in level 8-4
00AEC0  2               L_WaterArea3:
00AEC0  2  49 0F              .byte $49, $0f
00AEC2  2  1E 01 39 73        .byte $1e, $01, $39, $73, $5e, $07, $ae, $0b, $1e, $82
00AEC6  2  5E 07 AE 0B  
00AECA  2  1E 82        
00AECC  2  6E 88 9E 02        .byte $6e, $88, $9e, $02, $0d, $04, $2e, $0b, $45, $09
00AED0  2  0D 04 2E 0B  
00AED4  2  45 09        
00AED6  2  4E 0F ED 47        .byte $4e, $0f, $ed, $47
00AEDA  2  FD                 .byte $fd
00AEDB  2               
00AEDB  2               ;-------------------------------------------------------------------------------------
00AEDB  2               
00AEDB  2               ;unused space
00AEDB  2  FF                 .byte $ff
00AEDC  2               
00AEDC  2               ;-------------------------------------------------------------------------------------
00AEDC  2               
00AEDC  2               ;indirect jump routine called when
00AEDC  2               ;$0770 is set to 1
00AEDC  2               GameMode:
00AEDC  2  AD 72 07           lda OperMode_Task
00AEDF  2  20 04 8E           jsr JumpEngine
00AEE2  2               
00AEE2  2  E4 8F              .word InitializeArea
00AEE4  2  67 85              .word ScreenRoutines
00AEE6  2  71 90              .word SecondaryGameSetup
00AEE8  2  EA AE              .word GameCoreRoutine
00AEEA  2               
00AEEA  2               ;-------------------------------------------------------------------------------------
00AEEA  2               
00AEEA  2               GameCoreRoutine:
00AEEA  2  AE 53 07           ldx CurrentPlayer          ;get which player is on the screen
00AEED  2  BD FC 06           lda SavedJoypadBits,x      ;use appropriate player's controller bits
00AEF0  2  8D FC 06           sta SavedJoypadBits        ;as the master controller bits
00AEF3  2  20 4A B0           jsr GameRoutines           ;execute one of many possible subs
00AEF6  2  AD 72 07           lda OperMode_Task          ;check major task of operating mode
00AEF9  2  C9 03              cmp #$03                   ;if we are supposed to be here,
00AEFB  2  B0 01              bcs GameEngine             ;branch to the game engine itself
00AEFD  2  60                 rts
00AEFE  2               
00AEFE  2               GameEngine:
00AEFE  2  20 24 B6                   jsr ProcFireball_Bubble    ;process fireballs and air bubbles
00AF01  2  A2 00                      ldx #$00
00AF03  2  86 08        ProcELoop:    stx ObjectOffset           ;put incremented offset in X as enemy object offset
00AF05  2  20 47 C0                   jsr EnemiesAndLoopsCore    ;process enemy objects
00AF08  2  20 C3 84                   jsr FloateyNumbersRoutine  ;process floatey numbers
00AF0B  2  E8                         inx
00AF0C  2  E0 06                      cpx #$06                   ;do these two subroutines until the whole buffer is done
00AF0E  2  D0 F3                      bne ProcELoop
00AF10  2  20 80 F1                   jsr GetPlayerOffscreenBits ;get offscreen bits for player object
00AF13  2  20 2A F1                   jsr RelativePlayerPosition ;get relative coordinates for player object
00AF16  2  20 E9 EE                   jsr PlayerGfxHandler       ;draw the player
00AF19  2  20 D4 BE                   jsr BlockObjMT_Updater     ;replace block objects with metatiles if necessary
00AF1C  2  A2 01                      ldx #$01
00AF1E  2  86 08                      stx ObjectOffset           ;set offset for second
00AF20  2  20 70 BE                   jsr BlockObjectsCore       ;process second block object
00AF23  2  CA                         dex
00AF24  2  86 08                      stx ObjectOffset           ;set offset for first
00AF26  2  20 70 BE                   jsr BlockObjectsCore       ;process first block object
00AF29  2  20 96 BB                   jsr MiscObjectsCore        ;process misc objects (hammer, jumping coins)
00AF2C  2  20 BC B9                   jsr ProcessCannons         ;process bullet bill cannons
00AF2F  2  20 B8 B7                   jsr ProcessWhirlpools      ;process whirlpools
00AF32  2  20 55 B8                   jsr FlagpoleRoutine        ;process the flagpole
00AF35  2  20 4F B7                   jsr RunGameTimer           ;count down the game timer
00AF38  2  20 E1 89                   jsr ColorRotation          ;cycle one of the background colors
00AF3B  2  A5 B5                      lda Player_Y_HighPos
00AF3D  2  C9 02                      cmp #$02                   ;if player is below the screen, don't bother with the music
00AF3F  2  10 11                      bpl NoChgMus
00AF41  2  AD 9F 07                   lda StarInvincibleTimer    ;if star mario invincibility timer at zero,
00AF44  2  F0 1E                      beq ClrPlrPal              ;skip this part
00AF46  2  C9 04                      cmp #$04
00AF48  2  D0 08                      bne NoChgMus               ;if not yet at a certain point, continue
00AF4A  2  AD 7F 07                   lda IntervalTimerControl   ;if interval timer not yet expired,
00AF4D  2  D0 03                      bne NoChgMus               ;branch ahead, don't bother with the music
00AF4F  2  20 ED 90                   jsr GetAreaMusic           ;to re-attain appropriate level music
00AF52  2  AC 9F 07     NoChgMus:     ldy StarInvincibleTimer    ;get invincibility timer
00AF55  2  A5 09                      lda FrameCounter           ;get frame counter
00AF57  2  C0 08                      cpy #$08                   ;if timer still above certain point,
00AF59  2  B0 02                      bcs CycleTwo               ;branch to cycle player's palette quickly
00AF5B  2  4A                         lsr                        ;otherwise, divide by 8 to cycle every eighth frame
00AF5C  2  4A                         lsr
00AF5D  2  4A           CycleTwo:     lsr                        ;if branched here, divide by 2 to cycle every other frame
00AF5E  2  20 88 B2                   jsr CyclePlayerPalette     ;do sub to cycle the palette (note: shares fire flower code)
00AF61  2  4C 67 AF                   jmp SaveAB                 ;then skip this sub to finish up the game engine
00AF64  2  20 9A B2     ClrPlrPal:    jsr ResetPalStar           ;do sub to clear player's palette bits in attributes
00AF67  2  A5 0A        SaveAB:       lda A_B_Buttons            ;save current A and B button
00AF69  2  85 0D                      sta PreviousA_B_Buttons    ;into temp variable to be used on next frame
00AF6B  2  A9 00                      lda #$00
00AF6D  2  85 0C                      sta Left_Right_Buttons     ;nullify left and right buttons temp variable
00AF6F  2  AD 73 07     UpdScrollVar: lda VRAM_Buffer_AddrCtrl
00AF72  2  C9 06                      cmp #$06                   ;if vram address controller set to 6 (one of two $0341s)
00AF74  2  F0 1C                      beq ExitEng                ;then branch to leave
00AF76  2  AD 1F 07                   lda AreaParserTaskNum      ;otherwise check number of tasks
00AF79  2  D0 14                      bne RunParser
00AF7B  2  AD 3D 07                   lda ScrollThirtyTwo        ;get horizontal scroll in 0-31 or $00-$20 range
00AF7E  2  C9 20                      cmp #$20                   ;check to see if exceeded $21
00AF80  2  30 10                      bmi ExitEng                ;branch to leave if not
00AF82  2  AD 3D 07                   lda ScrollThirtyTwo
00AF85  2  E9 20                      sbc #$20                   ;otherwise subtract $20 to set appropriately
00AF87  2  8D 3D 07                   sta ScrollThirtyTwo        ;and store
00AF8A  2  A9 00                      lda #$00                   ;reset vram buffer offset used in conjunction with
00AF8C  2  8D 40 03                   sta VRAM_Buffer2_Offset    ;level graphics buffer at $0341-$035f
00AF8F  2  20 B0 92     RunParser:    jsr AreaParserTaskHandler  ;update the name table with more level graphics
00AF92  2  60           ExitEng:      rts                        ;and after all that, we're finally done!
00AF93  2               
00AF93  2               ;-------------------------------------------------------------------------------------
00AF93  2               
00AF93  2               ScrollHandler:
00AF93  2  AD FF 06                 lda Player_X_Scroll       ;load value saved here
00AF96  2  18                       clc
00AF97  2  6D A1 03                 adc Platform_X_Scroll     ;add value used by left/right platforms
00AF9A  2  8D FF 06                 sta Player_X_Scroll       ;save as new value here to impose force on scroll
00AF9D  2  AD 23 07                 lda ScrollLock            ;check scroll lock flag
00AFA0  2  D0 59                    bne InitScrlAmt           ;skip a bunch of code here if set
00AFA2  2  AD 55 07                 lda Player_Pos_ForScroll
00AFA5  2  C9 50                    cmp #$50                  ;check player's horizontal screen position
00AFA7  2  90 52                    bcc InitScrlAmt           ;if less than 80 pixels to the right, branch
00AFA9  2  AD 85 07                 lda SideCollisionTimer    ;if timer related to player's side collision
00AFAC  2  D0 4D                    bne InitScrlAmt           ;not expired, branch
00AFAE  2  AC FF 06                 ldy Player_X_Scroll       ;get value and decrement by one
00AFB1  2  88                       dey                       ;if value originally set to zero or otherwise
00AFB2  2  30 47                    bmi InitScrlAmt           ;negative for left movement, branch
00AFB4  2  C8                       iny
00AFB5  2  C0 02                    cpy #$02                  ;if value $01, branch and do not decrement
00AFB7  2  90 01                    bcc ChkNearMid
00AFB9  2  88                       dey                       ;otherwise decrement by one
00AFBA  2  AD 55 07     ChkNearMid: lda Player_Pos_ForScroll
00AFBD  2  C9 70                    cmp #$70                  ;check player's horizontal screen position
00AFBF  2  90 03                    bcc ScrollScreen          ;if less than 112 pixels to the right, branch
00AFC1  2  AC FF 06                 ldy Player_X_Scroll       ;otherwise get original value undecremented
00AFC4  2               
00AFC4  2               ScrollScreen:
00AFC4  2  98                         tya
00AFC5  2  8D 75 07                   sta ScrollAmount          ;save value here
00AFC8  2  18                         clc
00AFC9  2  6D 3D 07                   adc ScrollThirtyTwo       ;add to value already set here
00AFCC  2  8D 3D 07                   sta ScrollThirtyTwo       ;save as new value here
00AFCF  2  98                         tya
00AFD0  2  18                         clc
00AFD1  2  6D 1C 07                   adc ScreenLeft_X_Pos      ;add to left side coordinate
00AFD4  2  8D 1C 07                   sta ScreenLeft_X_Pos      ;save as new left side coordinate
00AFD7  2  8D 3F 07                   sta HorizontalScroll      ;save here also
00AFDA  2  AD 1A 07                   lda ScreenLeft_PageLoc
00AFDD  2  69 00                      adc #$00                  ;add carry to page location for left
00AFDF  2  8D 1A 07                   sta ScreenLeft_PageLoc    ;side of the screen
00AFE2  2  29 01                      and #$01                  ;get LSB of page location
00AFE4  2  85 00                      sta $00                   ;save as temp variable for PPU register 1 mirror
00AFE6  2  AD 78 07                   lda Mirror_PPU_CTRL_REG1  ;get PPU register 1 mirror
00AFE9  2  29 FE                      and #%11111110            ;save all bits except d0
00AFEB  2  05 00                      ora $00                   ;get saved bit here and save in PPU register 1
00AFED  2  8D 78 07                   sta Mirror_PPU_CTRL_REG1  ;mirror to be used to set name table later
00AFF0  2  20 38 B0                   jsr GetScreenPosition     ;figure out where the right side is
00AFF3  2  A9 08                      lda #$08
00AFF5  2  8D 95 07                   sta ScrollIntervalTimer   ;set scroll timer (residual, not used elsewhere)
00AFF8  2  4C 00 B0                   jmp ChkPOffscr            ;skip this part
00AFFB  2  A9 00        InitScrlAmt:  lda #$00
00AFFD  2  8D 75 07                   sta ScrollAmount          ;initialize value here
00B000  2  A2 00        ChkPOffscr:   ldx #$00                  ;set X for player offset
00B002  2  20 F6 F1                   jsr GetXOffscreenBits     ;get horizontal offscreen bits for player
00B005  2  85 00                      sta $00                   ;save them here
00B007  2  A0 00                      ldy #$00                  ;load default offset (left side)
00B009  2  0A                         asl                       ;if d7 of offscreen bits are set,
00B00A  2  B0 07                      bcs KeepOnscr             ;branch with default offset
00B00C  2  C8                         iny                         ;otherwise use different offset (right side)
00B00D  2  A5 00                      lda $00
00B00F  2  29 20                      and #%00100000              ;check offscreen bits for d5 set
00B011  2  F0 1B                      beq InitPlatScrl            ;if not set, branch ahead of this part
00B013  2  B9 1C 07     KeepOnscr:    lda ScreenEdge_X_Pos,y      ;get left or right side coordinate based on offset
00B016  2  38                         sec
00B017  2  F9 34 B0                   sbc X_SubtracterData,y      ;subtract amount based on offset
00B01A  2  85 86                      sta Player_X_Position       ;store as player position to prevent movement further
00B01C  2  B9 1A 07                   lda ScreenEdge_PageLoc,y    ;get left or right page location based on offset
00B01F  2  E9 00                      sbc #$00                    ;subtract borrow
00B021  2  85 6D                      sta Player_PageLoc          ;save as player's page location
00B023  2  A5 0C                      lda Left_Right_Buttons      ;check saved controller bits
00B025  2  D9 36 B0                   cmp OffscrJoypadBitsData,y  ;against bits based on offset
00B028  2  F0 04                      beq InitPlatScrl            ;if not equal, branch
00B02A  2  A9 00                      lda #$00
00B02C  2  85 57                      sta Player_X_Speed          ;otherwise nullify horizontal speed of player
00B02E  2  A9 00        InitPlatScrl: lda #$00                    ;nullify platform force imposed on scroll
00B030  2  8D A1 03                   sta Platform_X_Scroll
00B033  2  60                         rts
00B034  2               
00B034  2               X_SubtracterData:
00B034  2  00 10              .byte $00, $10
00B036  2               
00B036  2               OffscrJoypadBitsData:
00B036  2  01 02              .byte $01, $02
00B038  2               
00B038  2               ;-------------------------------------------------------------------------------------
00B038  2               
00B038  2               GetScreenPosition:
00B038  2  AD 1C 07           lda ScreenLeft_X_Pos    ;get coordinate of screen's left boundary
00B03B  2  18                 clc
00B03C  2  69 FF              adc #$ff                ;add 255 pixels
00B03E  2  8D 1D 07           sta ScreenRight_X_Pos   ;store as coordinate of screen's right boundary
00B041  2  AD 1A 07           lda ScreenLeft_PageLoc  ;get page number where left boundary is
00B044  2  69 00              adc #$00                ;add carry from before
00B046  2  8D 1B 07           sta ScreenRight_PageLoc ;store as page number where right boundary is
00B049  2  60                 rts
00B04A  2               
00B04A  2               ;-------------------------------------------------------------------------------------
00B04A  2               
00B04A  2               GameRoutines:
00B04A  2  A5 0E              lda GameEngineSubroutine  ;run routine based on number (a few of these routines are
00B04C  2  20 04 8E           jsr JumpEngine            ;merely placeholders as conditions for other routines)
00B04F  2               
00B04F  2  31 91              .word Entrance_GameTimerSetup
00B051  2  C7 B1              .word Vine_AutoClimb
00B053  2  06 B2              .word SideExitPipeEntry
00B055  2  E5 B1              .word VerticalPipeEntry
00B057  2  A4 B2              .word FlagpoleSlide
00B059  2  CA B2              .word PlayerEndLevel
00B05B  2  CD 91              .word PlayerLoseLife
00B05D  2  69 B0              .word PlayerEntrance
00B05F  2  E9 B0              .word PlayerCtrlRoutine
00B061  2  33 B2              .word PlayerChangeSize
00B063  2  45 B2              .word PlayerInjuryBlink
00B065  2  69 B2              .word PlayerDeath
00B067  2  7D B2              .word PlayerFireFlower
00B069  2               
00B069  2               ;-------------------------------------------------------------------------------------
00B069  2               
00B069  2               PlayerEntrance:
00B069  2  AD 52 07                 lda AltEntranceControl    ;check for mode of alternate entry
00B06C  2  C9 02                    cmp #$02
00B06E  2  F0 2B                    beq EntrMode2             ;if found, branch to enter from pipe or with vine
00B070  2  A9 00                    lda #$00
00B072  2  A4 CE                    ldy Player_Y_Position     ;if vertical position above a certain
00B074  2  C0 30                    cpy #$30                  ;point, nullify controller bits and continue
00B076  2  90 6E                    bcc AutoControlPlayer     ;with player movement code, do not return
00B078  2  AD 10 07                 lda PlayerEntranceCtrl    ;check player entry bits from header
00B07B  2  C9 06                    cmp #$06
00B07D  2  F0 04                    beq ChkBehPipe            ;if set to 6 or 7, execute pipe intro code
00B07F  2  C9 07                    cmp #$07                  ;otherwise branch to normal entry
00B081  2  D0 50                    bne PlayerRdy
00B083  2  AD C4 03     ChkBehPipe: lda Player_SprAttrib      ;check for sprite attributes
00B086  2  D0 05                    bne IntroEntr             ;branch if found
00B088  2  A9 01                    lda #$01
00B08A  2  4C E6 B0                 jmp AutoControlPlayer     ;force player to walk to the right
00B08D  2  20 1F B2     IntroEntr:  jsr EnterSidePipe         ;execute sub to move player to the right
00B090  2  CE DE 06                 dec ChangeAreaTimer       ;decrement timer for change of area
00B093  2  D0 50                    bne ExitEntr              ;branch to exit if not yet expired
00B095  2  EE 69 07                 inc DisableIntermediate   ;set flag to skip world and lives display
00B098  2  4C 15 B3                 jmp NextArea              ;jump to increment to next area and set modes
00B09B  2  AD 58 07     EntrMode2:  lda JoypadOverride        ;if controller override bits set here,
00B09E  2  D0 0C                    bne VineEntr              ;branch to enter with vine
00B0A0  2  A9 FF                    lda #$ff                  ;otherwise, set value here then execute sub
00B0A2  2  20 00 B2                 jsr MovePlayerYAxis       ;to move player upwards (note $ff = -1)
00B0A5  2  A5 CE                    lda Player_Y_Position     ;check to see if player is at a specific coordinate
00B0A7  2  C9 91                    cmp #$91                  ;if player risen to a certain point (this requires pipes
00B0A9  2  90 28                    bcc PlayerRdy             ;to be at specific height to look/function right) branch
00B0AB  2  60                       rts                       ;to the last part, otherwise leave
00B0AC  2  AD 99 03     VineEntr:   lda VineHeight
00B0AF  2  C9 60                    cmp #$60                  ;check vine height
00B0B1  2  D0 32                    bne ExitEntr              ;if vine not yet reached maximum height, branch to leave
00B0B3  2  A5 CE                    lda Player_Y_Position     ;get player's vertical coordinate
00B0B5  2  C9 99                    cmp #$99                  ;check player's vertical coordinate against preset value
00B0B7  2  A0 00                    ldy #$00                  ;load default values to be written to
00B0B9  2  A9 01                    lda #$01                  ;this value moves player to the right off the vine
00B0BB  2  90 0A                    bcc OffVine               ;if vertical coordinate < preset value, use defaults
00B0BD  2  A9 03                    lda #$03
00B0BF  2  85 1D                    sta Player_State          ;otherwise set player state to climbing
00B0C1  2  C8                       iny                       ;increment value in Y
00B0C2  2  A9 08                    lda #$08                  ;set block in block buffer to cover hole, then
00B0C4  2  8D B4 05                 sta Block_Buffer_1+$b4    ;use same value to force player to climb
00B0C7  2  8C 16 07     OffVine:    sty DisableCollisionDet   ;set collision detection disable flag
00B0CA  2  20 E6 B0                 jsr AutoControlPlayer     ;use contents of A to move player up or right, execute sub
00B0CD  2  A5 86                    lda Player_X_Position
00B0CF  2  C9 48                    cmp #$48                  ;check player's horizontal position
00B0D1  2  90 12                    bcc ExitEntr              ;if not far enough to the right, branch to leave
00B0D3  2  A9 08        PlayerRdy:  lda #$08                  ;set routine to be executed by game engine next frame
00B0D5  2  85 0E                    sta GameEngineSubroutine
00B0D7  2  A9 01                    lda #$01                  ;set to face player to the right
00B0D9  2  85 33                    sta PlayerFacingDir
00B0DB  2  4A                       lsr                       ;init A
00B0DC  2  8D 52 07                 sta AltEntranceControl    ;init mode of entry
00B0DF  2  8D 16 07                 sta DisableCollisionDet   ;init collision detection disable flag
00B0E2  2  8D 58 07                 sta JoypadOverride        ;nullify controller override bits
00B0E5  2  60           ExitEntr:   rts                       ;leave!
00B0E6  2               
00B0E6  2               ;-------------------------------------------------------------------------------------
00B0E6  2               ;$07 - used to hold upper limit of high byte when player falls down hole
00B0E6  2               
00B0E6  2               AutoControlPlayer:
00B0E6  2  8D FC 06           sta SavedJoypadBits         ;override controller bits with contents of A if executing here
00B0E9  2               
00B0E9  2               PlayerCtrlRoutine:
00B0E9  2  A5 0E                    lda GameEngineSubroutine    ;check task here
00B0EB  2  C9 0B                    cmp #$0b                    ;if certain value is set, branch to skip controller bit loading
00B0ED  2  F0 3C                    beq SizeChk
00B0EF  2  AD 4E 07                 lda AreaType                ;are we in a water type area?
00B0F2  2  D0 10                    bne SaveJoyp                ;if not, branch
00B0F4  2  A4 B5                    ldy Player_Y_HighPos
00B0F6  2  88                       dey                         ;if not in vertical area between
00B0F7  2  D0 06                    bne DisJoyp                 ;status bar and bottom, branch
00B0F9  2  A5 CE                    lda Player_Y_Position
00B0FB  2  C9 D0                    cmp #$d0                    ;if nearing the bottom of the screen or
00B0FD  2  90 05                    bcc SaveJoyp                ;not in the vertical area between status bar or bottom,
00B0FF  2  A9 00        DisJoyp:    lda #$00                    ;disable controller bits
00B101  2  8D FC 06                 sta SavedJoypadBits
00B104  2  AD FC 06     SaveJoyp:   lda SavedJoypadBits         ;otherwise store A and B buttons in $0a
00B107  2  29 C0                    and #%11000000
00B109  2  85 0A                    sta A_B_Buttons
00B10B  2  AD FC 06                 lda SavedJoypadBits         ;store left and right buttons in $0c
00B10E  2  29 03                    and #%00000011
00B110  2  85 0C                    sta Left_Right_Buttons
00B112  2  AD FC 06                 lda SavedJoypadBits         ;store up and down buttons in $0b
00B115  2  29 0C                    and #%00001100
00B117  2  85 0B                    sta Up_Down_Buttons
00B119  2  29 04                    and #%00000100              ;check for pressing down
00B11B  2  F0 0E                    beq SizeChk                 ;if not, branch
00B11D  2  A5 1D                    lda Player_State            ;check player's state
00B11F  2  D0 0A                    bne SizeChk                 ;if not on the ground, branch
00B121  2  A4 0C                    ldy Left_Right_Buttons      ;check left and right
00B123  2  F0 06                    beq SizeChk                 ;if neither pressed, branch
00B125  2  A9 00                    lda #$00
00B127  2  85 0C                    sta Left_Right_Buttons      ;if pressing down while on the ground,
00B129  2  85 0B                    sta Up_Down_Buttons         ;nullify directional bits
00B12B  2  20 29 B3     SizeChk:    jsr PlayerMovementSubs      ;run movement subroutines
00B12E  2  A0 01                    ldy #$01                    ;is player small?
00B130  2  AD 54 07                 lda PlayerSize
00B133  2  D0 09                    bne ChkMoveDir
00B135  2  A0 00                    ldy #$00                    ;check for if crouching
00B137  2  AD 14 07                 lda CrouchingFlag
00B13A  2  F0 02                    beq ChkMoveDir              ;if not, branch ahead
00B13C  2  A0 02                    ldy #$02                    ;if big and crouching, load y with 2
00B13E  2  8C 99 04     ChkMoveDir: sty Player_BoundBoxCtrl     ;set contents of Y as player's bounding box size control
00B141  2  A9 01                    lda #$01                    ;set moving direction to right by default
00B143  2  A4 57                    ldy Player_X_Speed          ;check player's horizontal speed
00B145  2  F0 05                    beq PlayerSubs              ;if not moving at all horizontally, skip this part
00B147  2  10 01                    bpl SetMoveDir              ;if moving to the right, use default moving direction
00B149  2  0A                       asl                         ;otherwise change to move to the left
00B14A  2  85 45        SetMoveDir: sta Player_MovingDir        ;set moving direction
00B14C  2  20 93 AF     PlayerSubs: jsr ScrollHandler           ;move the screen if necessary
00B14F  2  20 80 F1                 jsr GetPlayerOffscreenBits  ;get player's offscreen bits
00B152  2  20 2A F1                 jsr RelativePlayerPosition  ;get coordinates relative to the screen
00B155  2  A2 00                    ldx #$00                    ;set offset for player object
00B157  2  20 9C E2                 jsr BoundingBoxCore         ;get player's bounding box coordinates
00B15A  2  20 64 DC                 jsr PlayerBGCollision       ;do collision detection and process
00B15D  2  A5 CE                    lda Player_Y_Position
00B15F  2  C9 40                    cmp #$40                    ;check to see if player is higher than 64th pixel
00B161  2  90 16                    bcc PlayerHole              ;if so, branch ahead
00B163  2  A5 0E                    lda GameEngineSubroutine
00B165  2  C9 05                    cmp #$05                    ;if running end-of-level routine, branch ahead
00B167  2  F0 10                    beq PlayerHole
00B169  2  C9 07                    cmp #$07                    ;if running player entrance routine, branch ahead
00B16B  2  F0 0C                    beq PlayerHole
00B16D  2  C9 04                    cmp #$04                    ;if running routines $00-$03, branch ahead
00B16F  2  90 08                    bcc PlayerHole
00B171  2  AD C4 03                 lda Player_SprAttrib
00B174  2  29 DF                    and #%11011111              ;otherwise nullify player's
00B176  2  8D C4 03                 sta Player_SprAttrib        ;background priority flag
00B179  2  A5 B5        PlayerHole: lda Player_Y_HighPos        ;check player's vertical high byte
00B17B  2  C9 02                    cmp #$02                    ;for below the screen
00B17D  2  30 3B                    bmi ExitCtrl                ;branch to leave if not that far down
00B17F  2  A2 01                    ldx #$01
00B181  2  8E 23 07                 stx ScrollLock              ;set scroll lock
00B184  2  A0 04                    ldy #$04
00B186  2  84 07                    sty $07                     ;set value here
00B188  2  A2 00                    ldx #$00                    ;use X as flag, and clear for cloud level
00B18A  2  AC 59 07                 ldy GameTimerExpiredFlag    ;check game timer expiration flag
00B18D  2  D0 05                    bne HoleDie                 ;if set, branch
00B18F  2  AC 43 07                 ldy CloudTypeOverride       ;check for cloud type override
00B192  2  D0 16                    bne ChkHoleX                ;skip to last part if found
00B194  2  E8           HoleDie:    inx                         ;set flag in X for player death
00B195  2  A4 0E                    ldy GameEngineSubroutine
00B197  2  C0 0B                    cpy #$0b                    ;check for some other routine running
00B199  2  F0 0F                    beq ChkHoleX                ;if so, branch ahead
00B19B  2  AC 12 07                 ldy DeathMusicLoaded        ;check value here
00B19E  2  D0 06                    bne HoleBottom              ;if already set, branch to next part
00B1A0  2  C8                       iny
00B1A1  2  84 FC                    sty EventMusicQueue         ;otherwise play death music
00B1A3  2  8C 12 07                 sty DeathMusicLoaded        ;and set value here
00B1A6  2  A0 06        HoleBottom: ldy #$06
00B1A8  2  84 07                    sty $07                     ;change value here
00B1AA  2  C5 07        ChkHoleX:   cmp $07                     ;compare vertical high byte with value set here
00B1AC  2  30 0C                    bmi ExitCtrl                ;if less, branch to leave
00B1AE  2  CA                       dex                         ;otherwise decrement flag in X
00B1AF  2  30 0A                    bmi CloudExit               ;if flag was clear, branch to set modes and other values
00B1B1  2  AC B1 07                 ldy EventMusicBuffer        ;check to see if music is still playing
00B1B4  2  D0 04                    bne ExitCtrl                ;branch to leave if so
00B1B6  2  A9 06                    lda #$06                    ;otherwise set to run lose life routine
00B1B8  2  85 0E                    sta GameEngineSubroutine    ;on next frame
00B1BA  2  60           ExitCtrl:   rts                         ;leave
00B1BB  2               
00B1BB  2               CloudExit:
00B1BB  2  A9 00              lda #$00
00B1BD  2  8D 58 07           sta JoypadOverride      ;clear controller override bits if any are set
00B1C0  2  20 DD B1           jsr SetEntr             ;do sub to set secondary mode
00B1C3  2  EE 52 07           inc AltEntranceControl  ;set mode of entry to 3
00B1C6  2  60                 rts
00B1C7  2               
00B1C7  2               ;-------------------------------------------------------------------------------------
00B1C7  2               
00B1C7  2               Vine_AutoClimb:
00B1C7  2  A5 B5                   lda Player_Y_HighPos   ;check to see whether player reached position
00B1C9  2  D0 06                   bne AutoClimb          ;above the status bar yet and if so, set modes
00B1CB  2  A5 CE                   lda Player_Y_Position
00B1CD  2  C9 E4                   cmp #$e4
00B1CF  2  90 0C                   bcc SetEntr
00B1D1  2  A9 08        AutoClimb: lda #%00001000         ;set controller bits override to up
00B1D3  2  8D 58 07                sta JoypadOverride
00B1D6  2  A0 03                   ldy #$03               ;set player state to climbing
00B1D8  2  84 1D                   sty Player_State
00B1DA  2  4C E6 B0                jmp AutoControlPlayer
00B1DD  2  A9 02        SetEntr:   lda #$02               ;set starting position to override
00B1DF  2  8D 52 07                sta AltEntranceControl
00B1E2  2  4C 13 B2                jmp ChgAreaMode        ;set modes
00B1E5  2               
00B1E5  2               ;-------------------------------------------------------------------------------------
00B1E5  2               
00B1E5  2               VerticalPipeEntry:
00B1E5  2  A9 01              lda #$01             ;set 1 as movement amount
00B1E7  2  20 00 B2           jsr MovePlayerYAxis  ;do sub to move player downwards
00B1EA  2  20 93 AF           jsr ScrollHandler    ;do sub to scroll screen with saved force if necessary
00B1ED  2  A0 00              ldy #$00             ;load default mode of entry
00B1EF  2  AD D6 06           lda WarpZoneControl  ;check warp zone control variable/flag
00B1F2  2  D0 17              bne ChgAreaPipe      ;if set, branch to use mode 0
00B1F4  2  C8                 iny
00B1F5  2  AD 4E 07           lda AreaType         ;check for castle level type
00B1F8  2  C9 03              cmp #$03
00B1FA  2  D0 0F              bne ChgAreaPipe      ;if not castle type level, use mode 1
00B1FC  2  C8                 iny
00B1FD  2  4C 0B B2           jmp ChgAreaPipe      ;otherwise use mode 2
00B200  2               
00B200  2               MovePlayerYAxis:
00B200  2  18                 clc
00B201  2  65 CE              adc Player_Y_Position ;add contents of A to player position
00B203  2  85 CE              sta Player_Y_Position
00B205  2  60                 rts
00B206  2               
00B206  2               ;-------------------------------------------------------------------------------------
00B206  2               
00B206  2               SideExitPipeEntry:
00B206  2  20 1F B2                  jsr EnterSidePipe         ;execute sub to move player to the right
00B209  2  A0 02                     ldy #$02
00B20B  2  CE DE 06     ChgAreaPipe: dec ChangeAreaTimer       ;decrement timer for change of area
00B20E  2  D0 0E                     bne ExitCAPipe
00B210  2  8C 52 07                  sty AltEntranceControl    ;when timer expires set mode of alternate entry
00B213  2  EE 74 07     ChgAreaMode: inc DisableScreenFlag     ;set flag to disable screen output
00B216  2  A9 00                     lda #$00
00B218  2  8D 72 07                  sta OperMode_Task         ;set secondary mode of operation
00B21B  2  8D 22 07                  sta Sprite0HitDetectFlag  ;disable sprite 0 check
00B21E  2  60           ExitCAPipe:  rts                       ;leave
00B21F  2               
00B21F  2               EnterSidePipe:
00B21F  2  A9 08                   lda #$08               ;set player's horizontal speed
00B221  2  85 57                   sta Player_X_Speed
00B223  2  A0 01                   ldy #$01               ;set controller right button by default
00B225  2  A5 86                   lda Player_X_Position  ;mask out higher nybble of player's
00B227  2  29 0F                   and #%00001111         ;horizontal position
00B229  2  D0 03                   bne RightPipe
00B22B  2  85 57                   sta Player_X_Speed     ;if lower nybble = 0, set as horizontal speed
00B22D  2  A8                      tay                    ;and nullify controller bit override here
00B22E  2  98           RightPipe: tya                    ;use contents of Y to
00B22F  2  20 E6 B0                jsr AutoControlPlayer  ;execute player control routine with ctrl bits nulled
00B232  2  60                      rts
00B233  2               
00B233  2               ;-------------------------------------------------------------------------------------
00B233  2               
00B233  2               PlayerChangeSize:
00B233  2  AD 47 07                  lda TimerControl    ;check master timer control
00B236  2  C9 F8                     cmp #$f8            ;for specific moment in time
00B238  2  D0 03                     bne EndChgSize      ;branch if before or after that point
00B23A  2  4C 55 B2                  jmp InitChangeSize  ;otherwise run code to get growing/shrinking going
00B23D  2  C9 C4        EndChgSize:  cmp #$c4            ;check again for another specific moment
00B23F  2  D0 03                     bne ExitChgSize     ;and branch to leave if before or after that point
00B241  2  20 73 B2                  jsr DonePlayerTask  ;otherwise do sub to init timer control and set routine
00B244  2  60           ExitChgSize: rts                 ;and then leave
00B245  2               
00B245  2               ;-------------------------------------------------------------------------------------
00B245  2               
00B245  2               PlayerInjuryBlink:
00B245  2  AD 47 07                lda TimerControl       ;check master timer control
00B248  2  C9 F0                   cmp #$f0               ;for specific moment in time
00B24A  2  B0 07                   bcs ExitBlink          ;branch if before that point
00B24C  2  C9 C8                   cmp #$c8               ;check again for another specific point
00B24E  2  F0 23                   beq DonePlayerTask     ;branch if at that point, and not before or after
00B250  2  4C E9 B0                jmp PlayerCtrlRoutine  ;otherwise run player control routine
00B253  2  D0 13        ExitBlink: bne ExitBoth           ;do unconditional branch to leave
00B255  2               
00B255  2               InitChangeSize:
00B255  2  AC 0B 07               ldy PlayerChangeSizeFlag  ;if growing/shrinking flag already set
00B258  2  D0 0E                  bne ExitBoth              ;then branch to leave
00B25A  2  8C 0D 07               sty PlayerAnimCtrl        ;otherwise initialize player's animation frame control
00B25D  2  EE 0B 07               inc PlayerChangeSizeFlag  ;set growing/shrinking flag
00B260  2  AD 54 07               lda PlayerSize
00B263  2  49 01                  eor #$01                  ;invert player's size
00B265  2  8D 54 07               sta PlayerSize
00B268  2  60           ExitBoth: rts                       ;leave
00B269  2               
00B269  2               ;-------------------------------------------------------------------------------------
00B269  2               ;$00 - used in CyclePlayerPalette to store current palette to cycle
00B269  2               
00B269  2               PlayerDeath:
00B269  2  AD 47 07           lda TimerControl       ;check master timer control
00B26C  2  C9 F0              cmp #$f0               ;for specific moment in time
00B26E  2  B0 33              bcs ExitDeath          ;branch to leave if before that point
00B270  2  4C E9 B0           jmp PlayerCtrlRoutine  ;otherwise run player control routine
00B273  2               
00B273  2               DonePlayerTask:
00B273  2  A9 00              lda #$00
00B275  2  8D 47 07           sta TimerControl          ;initialize master timer control to continue timers
00B278  2  A9 08              lda #$08
00B27A  2  85 0E              sta GameEngineSubroutine  ;set player control routine to run next frame
00B27C  2  60                 rts                       ;leave
00B27D  2               
00B27D  2               PlayerFireFlower:
00B27D  2  AD 47 07           lda TimerControl       ;check master timer control
00B280  2  C9 C0              cmp #$c0               ;for specific moment in time
00B282  2  F0 13              beq ResetPalFireFlower ;branch if at moment, not before or after
00B284  2  A5 09              lda FrameCounter       ;get frame counter
00B286  2  4A                 lsr
00B287  2  4A                 lsr                    ;divide by four to change every four frames
00B288  2               
00B288  2               CyclePlayerPalette:
00B288  2  29 03              and #$03              ;mask out all but d1-d0 (previously d3-d2)
00B28A  2  85 00              sta $00               ;store result here to use as palette bits
00B28C  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
00B28F  2  29 FC              and #%11111100        ;save any other bits but palette bits
00B291  2  05 00              ora $00               ;add palette bits
00B293  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00B296  2  60                 rts                   ;and leave
00B297  2               
00B297  2               ResetPalFireFlower:
00B297  2  20 73 B2           jsr DonePlayerTask    ;do sub to init timer control and run player control routine
00B29A  2               
00B29A  2               ResetPalStar:
00B29A  2  AD C4 03           lda Player_SprAttrib  ;get player attributes
00B29D  2  29 FC              and #%11111100        ;mask out palette bits to force palette 0
00B29F  2  8D C4 03           sta Player_SprAttrib  ;store as new player attributes
00B2A2  2  60                 rts                   ;and leave
00B2A3  2               
00B2A3  2               ExitDeath:
00B2A3  2  60                 rts          ;leave from death routine
00B2A4  2               
00B2A4  2               ;-------------------------------------------------------------------------------------
00B2A4  2               
00B2A4  2               FlagpoleSlide:
00B2A4  2  A5 1B                     lda Enemy_ID+5           ;check special use enemy slot
00B2A6  2  C9 30                     cmp #FlagpoleFlagObject  ;for flagpole flag object
00B2A8  2  D0 15                     bne NoFPObj              ;if not found, branch to something residual
00B2AA  2  AD 13 07                  lda FlagpoleSoundQueue   ;load flagpole sound
00B2AD  2  85 FF                     sta Square1SoundQueue    ;into square 1's sfx queue
00B2AF  2  A9 00                     lda #$00
00B2B1  2  8D 13 07                  sta FlagpoleSoundQueue   ;init flagpole sound queue
00B2B4  2  A4 CE                     ldy Player_Y_Position
00B2B6  2  C0 9E                     cpy #$9e                 ;check to see if player has slid down
00B2B8  2  B0 02                     bcs SlidePlayer          ;far enough, and if so, branch with no controller bits set
00B2BA  2  A9 04                     lda #$04                 ;otherwise force player to climb down (to slide)
00B2BC  2  4C E6 B0     SlidePlayer: jmp AutoControlPlayer    ;jump to player control routine
00B2BF  2  E6 0E        NoFPObj:     inc GameEngineSubroutine ;increment to next routine (this may
00B2C1  2  60                        rts                      ;be residual code)
00B2C2  2               
00B2C2  2               ;-------------------------------------------------------------------------------------
00B2C2  2               
00B2C2  2               Hidden1UpCoinAmts:
00B2C2  2  15 23 16 1B        .byte $15, $23, $16, $1b, $17, $18, $23, $63
00B2C6  2  17 18 23 63  
00B2CA  2               
00B2CA  2               PlayerEndLevel:
00B2CA  2  A9 01                  lda #$01                  ;force player to walk to the right
00B2CC  2  20 E6 B0               jsr AutoControlPlayer
00B2CF  2  A5 CE                  lda Player_Y_Position     ;check player's vertical position
00B2D1  2  C9 AE                  cmp #$ae
00B2D3  2  90 0E                  bcc ChkStop               ;if player is not yet off the flagpole, skip this part
00B2D5  2  AD 23 07               lda ScrollLock            ;if scroll lock not set, branch ahead to next part
00B2D8  2  F0 09                  beq ChkStop               ;because we only need to do this part once
00B2DA  2  A9 20                  lda #EndOfLevelMusic
00B2DC  2  85 FC                  sta EventMusicQueue       ;load win level music in event music queue
00B2DE  2  A9 00                  lda #$00
00B2E0  2  8D 23 07               sta ScrollLock            ;turn off scroll lock to skip this part later
00B2E3  2  AD 90 04     ChkStop:  lda Player_CollisionBits  ;get player collision bits
00B2E6  2  4A                     lsr                       ;check for d0 set
00B2E7  2  B0 0D                  bcs RdyNextA              ;if d0 set, skip to next part
00B2E9  2  AD 46 07               lda StarFlagTaskControl   ;if star flag task control already set,
00B2EC  2  D0 03                  bne InCastle              ;go ahead with the rest of the code
00B2EE  2  EE 46 07               inc StarFlagTaskControl   ;otherwise set task control now (this gets ball rolling!)
00B2F1  2  A9 20        InCastle: lda #%00100000            ;set player's background priority bit to
00B2F3  2  8D C4 03               sta Player_SprAttrib      ;give illusion of being inside the castle
00B2F6  2  AD 46 07     RdyNextA: lda StarFlagTaskControl
00B2F9  2  C9 05                  cmp #$05                  ;if star flag task control not yet set
00B2FB  2  D0 2B                  bne ExitNA                ;beyond last valid task number, branch to leave
00B2FD  2  EE 5C 07               inc LevelNumber           ;increment level number used for game logic
00B300  2  AD 5C 07               lda LevelNumber
00B303  2  C9 03                  cmp #$03                  ;check to see if we have yet reached level -4
00B305  2  D0 0E                  bne NextArea              ;and skip this last part here if not
00B307  2  AC 5F 07               ldy WorldNumber           ;get world number as offset
00B30A  2  AD 48 07               lda CoinTallyFor1Ups      ;check third area coin tally for bonus 1-ups
00B30D  2  D9 C2 B2               cmp Hidden1UpCoinAmts,y   ;against minimum value, if player has not collected
00B310  2  90 03                  bcc NextArea              ;at least this number of coins, leave flag clear
00B312  2  EE 5D 07               inc Hidden1UpFlag         ;otherwise set hidden 1-up box control flag
00B315  2  EE 60 07     NextArea: inc AreaNumber            ;increment area number used for address loader
00B318  2  20 03 9C               jsr LoadAreaPointer       ;get new level pointer
00B31B  2  EE 57 07               inc FetchNewGameTimerFlag ;set flag to load new game timer
00B31E  2  20 13 B2               jsr ChgAreaMode           ;do sub to set secondary mode, disable screen and sprite 0
00B321  2  8D 5B 07               sta HalfwayPage           ;reset halfway page to 0 (beginning)
00B324  2  A9 80                  lda #Silence
00B326  2  85 FC                  sta EventMusicQueue       ;silence music and leave
00B328  2  60           ExitNA:   rts
00B329  2               
00B329  2               ;-------------------------------------------------------------------------------------
00B329  2               
00B329  2               PlayerMovementSubs:
00B329  2  A9 00                   lda #$00                  ;set A to init crouch flag by default
00B32B  2  AC 54 07                ldy PlayerSize            ;is player small?
00B32E  2  D0 08                   bne SetCrouch             ;if so, branch
00B330  2  A5 1D                   lda Player_State          ;check state of player
00B332  2  D0 07                   bne ProcMove              ;if not on the ground, branch
00B334  2  A5 0B                   lda Up_Down_Buttons       ;load controller bits for up and down
00B336  2  29 04                   and #%00000100            ;single out bit for down button
00B338  2  8D 14 07     SetCrouch: sta CrouchingFlag         ;store value in crouch flag
00B33B  2  20 50 B4     ProcMove:  jsr PlayerPhysicsSub      ;run sub related to jumping and swimming
00B33E  2  AD 0B 07                lda PlayerChangeSizeFlag  ;if growing/shrinking flag set,
00B341  2  D0 16                   bne NoMoveSub             ;branch to leave
00B343  2  A5 1D                   lda Player_State
00B345  2  C9 03                   cmp #$03                  ;get player state
00B347  2  F0 05                   beq MoveSubs              ;if climbing, branch ahead, leave timer unset
00B349  2  A0 18                   ldy #$18
00B34B  2  8C 89 07                sty ClimbSideTimer        ;otherwise reset timer now
00B34E  2  20 04 8E     MoveSubs:  jsr JumpEngine
00B351  2               
00B351  2  5A B3              .word OnGroundStateSub
00B353  2  76 B3              .word JumpSwimSub
00B355  2  6D B3              .word FallingSub
00B357  2  CF B3              .word ClimbingSub
00B359  2               
00B359  2  60           NoMoveSub: rts
00B35A  2               
00B35A  2               ;-------------------------------------------------------------------------------------
00B35A  2               ;$00 - used by ClimbingSub to store high vertical adder
00B35A  2               
00B35A  2               OnGroundStateSub:
00B35A  2  20 8F B5              jsr GetPlayerAnimSpeed     ;do a sub to set animation frame timing
00B35D  2  A5 0C                 lda Left_Right_Buttons
00B35F  2  F0 02                 beq GndMove                ;if left/right controller bits not set, skip instruction
00B361  2  85 33                 sta PlayerFacingDir        ;otherwise set new facing direction
00B363  2  20 CC B5     GndMove: jsr ImposeFriction         ;do a sub to impose friction on player's walk/run
00B366  2  20 09 BF              jsr MovePlayerHorizontally ;do another sub to move player horizontally
00B369  2  8D FF 06              sta Player_X_Scroll        ;set returned value as player's movement speed for scroll
00B36C  2  60                    rts
00B36D  2               
00B36D  2               ;--------------------------------
00B36D  2               
00B36D  2               FallingSub:
00B36D  2  AD 0A 07           lda VerticalForceDown
00B370  2  8D 09 07           sta VerticalForce      ;dump vertical movement force for falling into main one
00B373  2  4C AC B3           jmp LRAir              ;movement force, then skip ahead to process left/right movement
00B376  2               
00B376  2               ;--------------------------------
00B376  2               
00B376  2               JumpSwimSub:
00B376  2  A4 9F                  ldy Player_Y_Speed         ;if player's vertical speed zero
00B378  2  10 13                  bpl DumpFall               ;or moving downwards, branch to falling
00B37A  2  A5 0A                  lda A_B_Buttons
00B37C  2  29 80                  and #A_Button              ;check to see if A button is being pressed
00B37E  2  25 0D                  and PreviousA_B_Buttons    ;and was pressed in previous frame
00B380  2  D0 11                  bne ProcSwim               ;if so, branch elsewhere
00B382  2  AD 08 07               lda JumpOrigin_Y_Position  ;get vertical position player jumped from
00B385  2  38                     sec
00B386  2  E5 CE                  sbc Player_Y_Position      ;subtract current from original vertical coordinate
00B388  2  CD 06 07               cmp DiffToHaltJump         ;compare to value set here to see if player is in mid-jump
00B38B  2  90 06                  bcc ProcSwim               ;or just starting to jump, if just starting, skip ahead
00B38D  2  AD 0A 07     DumpFall: lda VerticalForceDown      ;otherwise dump falling into main fractional
00B390  2  8D 09 07               sta VerticalForce
00B393  2  AD 04 07     ProcSwim: lda SwimmingFlag           ;if swimming flag not set,
00B396  2  F0 14                  beq LRAir                  ;branch ahead to last part
00B398  2  20 8F B5               jsr GetPlayerAnimSpeed     ;do a sub to get animation frame timing
00B39B  2  A5 CE                  lda Player_Y_Position
00B39D  2  C9 14                  cmp #$14                   ;check vertical position against preset value
00B39F  2  B0 05                  bcs LRWater                ;if not yet reached a certain position, branch ahead
00B3A1  2  A9 18                  lda #$18
00B3A3  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
00B3A6  2  A5 0C        LRWater:  lda Left_Right_Buttons     ;check left/right controller bits (check for swimming)
00B3A8  2  F0 02                  beq LRAir                  ;if not pressing any, skip
00B3AA  2  85 33                  sta PlayerFacingDir        ;otherwise set facing direction accordingly
00B3AC  2  A5 0C        LRAir:    lda Left_Right_Buttons     ;check left/right controller bits (check for jumping/falling)
00B3AE  2  F0 03                  beq JSMove                 ;if not pressing any, skip
00B3B0  2  20 CC B5               jsr ImposeFriction         ;otherwise process horizontal movement
00B3B3  2  20 09 BF     JSMove:   jsr MovePlayerHorizontally ;do a sub to move player horizontally
00B3B6  2  8D FF 06               sta Player_X_Scroll        ;set player's speed here, to be used for scroll later
00B3B9  2  A5 0E                  lda GameEngineSubroutine
00B3BB  2  C9 0B                  cmp #$0b                   ;check for specific routine selected
00B3BD  2  D0 05                  bne ExitMov1               ;branch if not set to run
00B3BF  2  A9 28                  lda #$28
00B3C1  2  8D 09 07               sta VerticalForce          ;otherwise set fractional
00B3C4  2  4C 4D BF     ExitMov1: jmp MovePlayerVertically   ;jump to move player vertically, then leave
00B3C7  2               
00B3C7  2               ;--------------------------------
00B3C7  2               
00B3C7  2               ClimbAdderLow:
00B3C7  2  0E 04 FC F2        .byte $0e, $04, $fc, $f2
00B3CB  2               ClimbAdderHigh:
00B3CB  2  00 00 FF FF        .byte $00, $00, $ff, $ff
00B3CF  2               
00B3CF  2               ClimbingSub:
00B3CF  2  AD 16 04                  lda Player_YMF_Dummy
00B3D2  2  18                        clc                      ;add movement force to dummy variable
00B3D3  2  6D 33 04                  adc Player_Y_MoveForce   ;save with carry
00B3D6  2  8D 16 04                  sta Player_YMF_Dummy
00B3D9  2  A0 00                     ldy #$00                 ;set default adder here
00B3DB  2  A5 9F                     lda Player_Y_Speed       ;get player's vertical speed
00B3DD  2  10 01                     bpl MoveOnVine           ;if not moving upwards, branch
00B3DF  2  88                        dey                      ;otherwise set adder to $ff
00B3E0  2  84 00        MoveOnVine:  sty $00                  ;store adder here
00B3E2  2  65 CE                     adc Player_Y_Position    ;add carry to player's vertical position
00B3E4  2  85 CE                     sta Player_Y_Position    ;and store to move player up or down
00B3E6  2  A5 B5                     lda Player_Y_HighPos
00B3E8  2  65 00                     adc $00                  ;add carry to player's page location
00B3EA  2  85 B5                     sta Player_Y_HighPos     ;and store
00B3EC  2  A5 0C                     lda Left_Right_Buttons   ;compare left/right controller bits
00B3EE  2  2D 90 04                  and Player_CollisionBits ;to collision flag
00B3F1  2  F0 2D                     beq InitCSTimer          ;if not set, skip to end
00B3F3  2  AC 89 07                  ldy ClimbSideTimer       ;otherwise check timer
00B3F6  2  D0 27                     bne ExitCSub             ;if timer not expired, branch to leave
00B3F8  2  A0 18                     ldy #$18
00B3FA  2  8C 89 07                  sty ClimbSideTimer       ;otherwise set timer now
00B3FD  2  A2 00                     ldx #$00                 ;set default offset here
00B3FF  2  A4 33                     ldy PlayerFacingDir      ;get facing direction
00B401  2  4A                        lsr                      ;move right button controller bit to carry
00B402  2  B0 02                     bcs ClimbFD              ;if controller right pressed, branch ahead
00B404  2  E8                        inx
00B405  2  E8                        inx                      ;otherwise increment offset by 2 bytes
00B406  2  88           ClimbFD:     dey                      ;check to see if facing right
00B407  2  F0 01                     beq CSetFDir             ;if so, branch, do not increment
00B409  2  E8                        inx                      ;otherwise increment by 1 byte
00B40A  2  A5 86        CSetFDir:    lda Player_X_Position
00B40C  2  18                        clc                      ;add or subtract from player's horizontal position
00B40D  2  7D C7 B3                  adc ClimbAdderLow,x      ;using value here as adder and X as offset
00B410  2  85 86                     sta Player_X_Position
00B412  2  A5 6D                     lda Player_PageLoc       ;add or subtract carry or borrow using value here
00B414  2  7D CB B3                  adc ClimbAdderHigh,x     ;from the player's page location
00B417  2  85 6D                     sta Player_PageLoc
00B419  2  A5 0C                     lda Left_Right_Buttons   ;get left/right controller bits again
00B41B  2  49 03                     eor #%00000011           ;invert them and store them while player
00B41D  2  85 33                     sta PlayerFacingDir      ;is on vine to face player in opposite direction
00B41F  2  60           ExitCSub:    rts                      ;then leave
00B420  2  8D 89 07     InitCSTimer: sta ClimbSideTimer       ;initialize timer here
00B423  2  60                        rts
00B424  2               
00B424  2               ;-------------------------------------------------------------------------------------
00B424  2               ;$00 - used to store offset to friction data
00B424  2               
00B424  2               JumpMForceData:
00B424  2  20 20 1E 28        .byte $20, $20, $1e, $28, $28, $0d, $04
00B428  2  28 0D 04     
00B42B  2               
00B42B  2               FallMForceData:
00B42B  2  70 70 60 90        .byte $70, $70, $60, $90, $90, $0a, $09
00B42F  2  90 0A 09     
00B432  2               
00B432  2               PlayerYSpdData:
00B432  2  FC FC FC FB        .byte $fc, $fc, $fc, $fb, $fb, $fe, $ff
00B436  2  FB FE FF     
00B439  2               
00B439  2               InitMForceData:
00B439  2  00 00 00 00        .byte $00, $00, $00, $00, $00, $80, $00
00B43D  2  00 80 00     
00B440  2               
00B440  2               MaxLeftXSpdData:
00B440  2  D8 E8 F0           .byte $d8, $e8, $f0
00B443  2               
00B443  2               MaxRightXSpdData:
00B443  2  28 18 10           .byte $28, $18, $10
00B446  2  0C                 .byte $0c ;used for pipe intros
00B447  2               
00B447  2               FrictionData:
00B447  2  E4 98 D0           .byte $e4, $98, $d0
00B44A  2               
00B44A  2               Climb_Y_SpeedData:
00B44A  2  00 FF 01           .byte $00, $ff, $01
00B44D  2               
00B44D  2               Climb_Y_MForceData:
00B44D  2  00 20 FF           .byte $00, $20, $ff
00B450  2               
00B450  2               PlayerPhysicsSub:
00B450  2  A5 1D                   lda Player_State          ;check player state
00B452  2  C9 03                   cmp #$03
00B454  2  D0 23                   bne CheckForJumping       ;if not climbing, branch
00B456  2  A0 00                   ldy #$00
00B458  2  A5 0B                   lda Up_Down_Buttons       ;get controller bits for up/down
00B45A  2  2D 90 04                and Player_CollisionBits  ;check against player's collision detection bits
00B45D  2  F0 06                   beq ProcClimb             ;if not pressing up or down, branch
00B45F  2  C8                      iny
00B460  2  29 08                   and #%00001000            ;check for pressing up
00B462  2  D0 01                   bne ProcClimb
00B464  2  C8                      iny
00B465  2  BE 4D B4     ProcClimb: ldx Climb_Y_MForceData,y  ;load value here
00B468  2  8E 33 04                stx Player_Y_MoveForce    ;store as vertical movement force
00B46B  2  A9 08                   lda #$08                  ;load default animation timing
00B46D  2  BE 4A B4                ldx Climb_Y_SpeedData,y   ;load some other value here
00B470  2  86 9F                   stx Player_Y_Speed        ;store as vertical speed
00B472  2  30 01                   bmi SetCAnim              ;if climbing down, use default animation timing value
00B474  2  4A                      lsr                       ;otherwise divide timer setting by 2
00B475  2  8D 0C 07     SetCAnim:  sta PlayerAnimTimerSet    ;store animation timer setting and leave
00B478  2  60                      rts
00B479  2               
00B479  2               CheckForJumping:
00B479  2  AD 0E 07             lda JumpspringAnimCtrl    ;if jumpspring animating,
00B47C  2  D0 0A                bne NoJump                ;skip ahead to something else
00B47E  2  A5 0A                lda A_B_Buttons           ;check for A button press
00B480  2  29 80                and #A_Button
00B482  2  F0 04                beq NoJump                ;if not, branch to something else
00B484  2  25 0D                and PreviousA_B_Buttons   ;if button not pressed in previous frame, branch
00B486  2  F0 03                beq ProcJumping
00B488  2  4C 1C B5     NoJump: jmp X_Physics             ;otherwise, jump to something else
00B48B  2               
00B48B  2               ProcJumping:
00B48B  2  A5 1D                   lda Player_State           ;check player state
00B48D  2  F0 11                   beq InitJS                 ;if on the ground, branch
00B48F  2  AD 04 07                lda SwimmingFlag           ;if swimming flag not set, jump to do something else
00B492  2  F0 F4                   beq NoJump                 ;to prevent midair jumping, otherwise continue
00B494  2  AD 82 07                lda JumpSwimTimer          ;if jump/swim timer nonzero, branch
00B497  2  D0 07                   bne InitJS
00B499  2  A5 9F                   lda Player_Y_Speed         ;check player's vertical speed
00B49B  2  10 03                   bpl InitJS                 ;if player's vertical speed motionless or down, branch
00B49D  2  4C 1C B5                jmp X_Physics              ;if timer at zero and player still rising, do not swim
00B4A0  2  A9 20        InitJS:    lda #$20                   ;set jump/swim timer
00B4A2  2  8D 82 07                sta JumpSwimTimer
00B4A5  2  A0 00                   ldy #$00                   ;initialize vertical force and dummy variable
00B4A7  2  8C 16 04                sty Player_YMF_Dummy
00B4AA  2  8C 33 04                sty Player_Y_MoveForce
00B4AD  2  A5 B5                   lda Player_Y_HighPos       ;get vertical high and low bytes of jump origin
00B4AF  2  8D 07 07                sta JumpOrigin_Y_HighPos   ;and store them next to each other here
00B4B2  2  A5 CE                   lda Player_Y_Position
00B4B4  2  8D 08 07                sta JumpOrigin_Y_Position
00B4B7  2  A9 01                   lda #$01                   ;set player state to jumping/swimming
00B4B9  2  85 1D                   sta Player_State
00B4BB  2  AD 00 07                lda Player_XSpeedAbsolute  ;check value related to walking/running speed
00B4BE  2  C9 09                   cmp #$09
00B4C0  2  90 10                   bcc ChkWtr                 ;branch if below certain values, increment Y
00B4C2  2  C8                      iny                        ;for each amount equal or exceeded
00B4C3  2  C9 10                   cmp #$10
00B4C5  2  90 0B                   bcc ChkWtr
00B4C7  2  C8                      iny
00B4C8  2  C9 19                   cmp #$19
00B4CA  2  90 06                   bcc ChkWtr
00B4CC  2  C8                      iny
00B4CD  2  C9 1C                   cmp #$1c
00B4CF  2  90 01                   bcc ChkWtr                 ;note that for jumping, range is 0-4 for Y
00B4D1  2  C8                      iny
00B4D2  2  A9 01        ChkWtr:    lda #$01                   ;set value here (apparently always set to 1)
00B4D4  2  8D 06 07                sta DiffToHaltJump
00B4D7  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00B4DA  2  F0 08                   beq GetYPhy
00B4DC  2  A0 05                   ldy #$05                   ;otherwise set Y to 5, range is 5-6
00B4DE  2  AD 7D 04                lda Whirlpool_Flag         ;if whirlpool flag not set, branch
00B4E1  2  F0 01                   beq GetYPhy
00B4E3  2  C8                      iny                        ;otherwise increment to 6
00B4E4  2  B9 24 B4     GetYPhy:   lda JumpMForceData,y       ;store appropriate jump/swim
00B4E7  2  8D 09 07                sta VerticalForce          ;data here
00B4EA  2  B9 2B B4                lda FallMForceData,y
00B4ED  2  8D 0A 07                sta VerticalForceDown
00B4F0  2  B9 39 B4                lda InitMForceData,y
00B4F3  2  8D 33 04                sta Player_Y_MoveForce
00B4F6  2  B9 32 B4                lda PlayerYSpdData,y
00B4F9  2  85 9F                   sta Player_Y_Speed
00B4FB  2  AD 04 07                lda SwimmingFlag           ;if swimming flag disabled, branch
00B4FE  2  F0 11                   beq PJumpSnd
00B500  2  A9 04                   lda #Sfx_EnemyStomp        ;load swim/goomba stomp sound into
00B502  2  85 FF                   sta Square1SoundQueue      ;square 1's sfx queue
00B504  2  A5 CE                   lda Player_Y_Position
00B506  2  C9 14                   cmp #$14                   ;check vertical low byte of player position
00B508  2  B0 12                   bcs X_Physics              ;if below a certain point, branch
00B50A  2  A9 00                   lda #$00                   ;otherwise reset player's vertical speed
00B50C  2  85 9F                   sta Player_Y_Speed         ;and jump to something else to keep player
00B50E  2  4C 1C B5                jmp X_Physics              ;from swimming above water level
00B511  2  A9 01        PJumpSnd:  lda #Sfx_BigJump           ;load big mario's jump sound by default
00B513  2  AC 54 07                ldy PlayerSize             ;is mario big?
00B516  2  F0 02                   beq SJumpSnd
00B518  2  A9 80                   lda #Sfx_SmallJump         ;if not, load small mario's jump sound
00B51A  2  85 FF        SJumpSnd:  sta Square1SoundQueue      ;store appropriate jump sound in square 1 sfx queue
00B51C  2  A0 00        X_Physics: ldy #$00
00B51E  2  84 00                   sty $00                    ;init value here
00B520  2  A5 1D                   lda Player_State           ;if mario is on the ground, branch
00B522  2  F0 09                   beq ProcPRun
00B524  2  AD 00 07                lda Player_XSpeedAbsolute  ;check something that seems to be related
00B527  2  C9 19                   cmp #$19                   ;to mario's speed
00B529  2  B0 33                   bcs GetXPhy                ;if =>$19 branch here
00B52B  2  90 18                   bcc ChkRFast               ;if not branch elsewhere
00B52D  2  C8           ProcPRun:  iny                        ;if mario on the ground, increment Y
00B52E  2  AD 4E 07                lda AreaType               ;check area type
00B531  2  F0 12                   beq ChkRFast               ;if water type, branch
00B533  2  88                      dey                        ;decrement Y by default for non-water type area
00B534  2  A5 0C                   lda Left_Right_Buttons     ;get left/right controller bits
00B536  2  C5 45                   cmp Player_MovingDir       ;check against moving direction
00B538  2  D0 0B                   bne ChkRFast               ;if controller bits <> moving direction, skip this part
00B53A  2  A5 0A                   lda A_B_Buttons            ;check for b button pressed
00B53C  2  29 40                   and #B_Button
00B53E  2  D0 19                   bne SetRTmr                ;if pressed, skip ahead to set timer
00B540  2  AD 83 07                lda RunningTimer           ;check for running timer set
00B543  2  D0 19                   bne GetXPhy                ;if set, branch
00B545  2  C8           ChkRFast:  iny                        ;if running timer not set or level type is water,
00B546  2  E6 00                   inc $00                    ;increment Y again and temp variable in memory
00B548  2  AD 03 07                lda RunningSpeed
00B54B  2  D0 07                   bne FastXSp                ;if running speed set here, branch
00B54D  2  AD 00 07                lda Player_XSpeedAbsolute
00B550  2  C9 21                   cmp #$21                   ;otherwise check player's walking/running speed
00B552  2  90 0A                   bcc GetXPhy                ;if less than a certain amount, branch ahead
00B554  2  E6 00        FastXSp:   inc $00                    ;if running speed set or speed => $21 increment $00
00B556  2  4C 5E B5                jmp GetXPhy                ;and jump ahead
00B559  2  A9 0A        SetRTmr:   lda #$0a                   ;if b button pressed, set running timer
00B55B  2  8D 83 07                sta RunningTimer
00B55E  2  B9 40 B4     GetXPhy:   lda MaxLeftXSpdData,y      ;get maximum speed to the left
00B561  2  8D 50 04                sta MaximumLeftSpeed
00B564  2  A5 0E                   lda GameEngineSubroutine   ;check for specific routine running
00B566  2  C9 07                   cmp #$07                   ;(player entrance)
00B568  2  D0 02                   bne GetXPhy2               ;if not running, skip and use old value of Y
00B56A  2  A0 03                   ldy #$03                   ;otherwise set Y to 3
00B56C  2  B9 43 B4     GetXPhy2:  lda MaxRightXSpdData,y     ;get maximum speed to the right
00B56F  2  8D 56 04                sta MaximumRightSpeed
00B572  2  A4 00                   ldy $00                    ;get other value in memory
00B574  2  B9 47 B4                lda FrictionData,y         ;get value using value in memory as offset
00B577  2  8D 02 07                sta FrictionAdderLow
00B57A  2  A9 00                   lda #$00
00B57C  2  8D 01 07                sta FrictionAdderHigh      ;init something here
00B57F  2  A5 33                   lda PlayerFacingDir
00B581  2  C5 45                   cmp Player_MovingDir       ;check facing direction against moving direction
00B583  2  F0 06                   beq ExitPhy                ;if the same, branch to leave
00B585  2  0E 02 07                asl FrictionAdderLow       ;otherwise shift d7 of friction adder low into carry
00B588  2  2E 01 07                rol FrictionAdderHigh      ;then rotate carry onto d0 of friction adder high
00B58B  2  60           ExitPhy:   rts                        ;and then leave
00B58C  2               
00B58C  2               ;-------------------------------------------------------------------------------------
00B58C  2               
00B58C  2               PlayerAnimTmrData:
00B58C  2  02 04 07           .byte $02, $04, $07
00B58F  2               
00B58F  2               GetPlayerAnimSpeed:
00B58F  2  A0 00                    ldy #$00                   ;initialize offset in Y
00B591  2  AD 00 07                 lda Player_XSpeedAbsolute  ;check player's walking/running speed
00B594  2  C9 1C                    cmp #$1c                   ;against preset amount
00B596  2  B0 15                    bcs SetRunSpd              ;if greater than a certain amount, branch ahead
00B598  2  C8                       iny                        ;otherwise increment Y
00B599  2  C9 0E                    cmp #$0e                   ;compare against lower amount
00B59B  2  B0 01                    bcs ChkSkid                ;if greater than this but not greater than first, skip increment
00B59D  2  C8                       iny                        ;otherwise increment Y again
00B59E  2  AD FC 06     ChkSkid:    lda SavedJoypadBits        ;get controller bits
00B5A1  2  29 7F                    and #%01111111             ;mask out A button
00B5A3  2  F0 20                    beq SetAnimSpd             ;if no other buttons pressed, branch ahead of all this
00B5A5  2  29 03                    and #$03                   ;mask out all others except left and right
00B5A7  2  C5 45                    cmp Player_MovingDir       ;check against moving direction
00B5A9  2  D0 08                    bne ProcSkid               ;if left/right controller bits <> moving direction, branch
00B5AB  2  A9 00                    lda #$00                   ;otherwise set zero value here
00B5AD  2  8D 03 07     SetRunSpd:  sta RunningSpeed           ;store zero or running speed here
00B5B0  2  4C C5 B5                 jmp SetAnimSpd
00B5B3  2  AD 00 07     ProcSkid:   lda Player_XSpeedAbsolute  ;check player's walking/running speed
00B5B6  2  C9 0B                    cmp #$0b                   ;against one last amount
00B5B8  2  B0 0B                    bcs SetAnimSpd             ;if greater than this amount, branch
00B5BA  2  A5 33                    lda PlayerFacingDir
00B5BC  2  85 45                    sta Player_MovingDir       ;otherwise use facing direction to set moving direction
00B5BE  2  A9 00                    lda #$00
00B5C0  2  85 57                    sta Player_X_Speed         ;nullify player's horizontal speed
00B5C2  2  8D 05 07                 sta Player_X_MoveForce     ;and dummy variable for player
00B5C5  2  B9 8C B5     SetAnimSpd: lda PlayerAnimTmrData,y    ;get animation timer setting using Y as offset
00B5C8  2  8D 0C 07                 sta PlayerAnimTimerSet
00B5CB  2  60                       rts
00B5CC  2               
00B5CC  2               ;-------------------------------------------------------------------------------------
00B5CC  2               
00B5CC  2               ImposeFriction:
00B5CC  2  2D 90 04                and Player_CollisionBits  ;perform AND between left/right controller bits and collision flag
00B5CF  2  C9 00                   cmp #$00                  ;then compare to zero (this instruction is redundant)
00B5D1  2  D0 08                   bne JoypFrict             ;if any bits set, branch to next part
00B5D3  2  A5 57                   lda Player_X_Speed
00B5D5  2  F0 49                   beq SetAbsSpd             ;if player has no horizontal speed, branch ahead to last part
00B5D7  2  10 23                   bpl RghtFrict             ;if player moving to the right, branch to slow
00B5D9  2  30 03                   bmi LeftFrict             ;otherwise logic dictates player moving left, branch to slow
00B5DB  2  4A           JoypFrict: lsr                       ;put right controller bit into carry
00B5DC  2  90 1E                   bcc RghtFrict             ;if left button pressed, carry = 0, thus branch
00B5DE  2  AD 05 07     LeftFrict: lda Player_X_MoveForce    ;load value set here
00B5E1  2  18                      clc
00B5E2  2  6D 02 07                adc FrictionAdderLow      ;add to it another value set here
00B5E5  2  8D 05 07                sta Player_X_MoveForce    ;store here
00B5E8  2  A5 57                   lda Player_X_Speed
00B5EA  2  6D 01 07                adc FrictionAdderHigh     ;add value plus carry to horizontal speed
00B5ED  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00B5EF  2  CD 56 04                cmp MaximumRightSpeed     ;compare against maximum value for right movement
00B5F2  2  30 23                   bmi XSpdSign              ;if horizontal speed greater negatively, branch
00B5F4  2  AD 56 04                lda MaximumRightSpeed     ;otherwise set preset value as horizontal speed
00B5F7  2  85 57                   sta Player_X_Speed        ;thus slowing the player's left movement down
00B5F9  2  4C 20 B6                jmp SetAbsSpd             ;skip to the end
00B5FC  2  AD 05 07     RghtFrict: lda Player_X_MoveForce    ;load value set here
00B5FF  2  38                      sec
00B600  2  ED 02 07                sbc FrictionAdderLow      ;subtract from it another value set here
00B603  2  8D 05 07                sta Player_X_MoveForce    ;store here
00B606  2  A5 57                   lda Player_X_Speed
00B608  2  ED 01 07                sbc FrictionAdderHigh     ;subtract value plus borrow from horizontal speed
00B60B  2  85 57                   sta Player_X_Speed        ;set as new horizontal speed
00B60D  2  CD 50 04                cmp MaximumLeftSpeed      ;compare against maximum value for left movement
00B610  2  10 05                   bpl XSpdSign              ;if horizontal speed greater positively, branch
00B612  2  AD 50 04                lda MaximumLeftSpeed      ;otherwise set preset value as horizontal speed
00B615  2  85 57                   sta Player_X_Speed        ;thus slowing the player's right movement down
00B617  2  C9 00        XSpdSign:  cmp #$00                  ;if player not moving or moving to the right,
00B619  2  10 05                   bpl SetAbsSpd             ;branch and leave horizontal speed value unmodified
00B61B  2  49 FF                   eor #$ff
00B61D  2  18                      clc                       ;otherwise get two's compliment to get absolute
00B61E  2  69 01                   adc #$01                  ;unsigned walking/running speed
00B620  2  8D 00 07     SetAbsSpd: sta Player_XSpeedAbsolute ;store walking/running speed here and leave
00B623  2  60                      rts
00B624  2               
00B624  2               ;-------------------------------------------------------------------------------------
00B624  2               ;$00 - used to store downward movement force in FireballObjCore
00B624  2               ;$02 - used to store maximum vertical speed in FireballObjCore
00B624  2               ;$07 - used to store pseudorandom bit in BubbleCheck
00B624  2               
00B624  2               ProcFireball_Bubble:
00B624  2  AD 56 07           lda PlayerStatus           ;check player's status
00B627  2  C9 02              cmp #$02
00B629  2  90 43              bcc ProcAirBubbles         ;if not fiery, branch
00B62B  2  A5 0A              lda A_B_Buttons
00B62D  2  29 40              and #B_Button              ;check for b button pressed
00B62F  2  F0 33              beq ProcFireballs          ;branch if not pressed
00B631  2  25 0D              and PreviousA_B_Buttons
00B633  2  D0 2F              bne ProcFireballs          ;if button pressed in previous frame, branch
00B635  2  AD CE 06           lda FireballCounter        ;load fireball counter
00B638  2  29 01              and #%00000001             ;get LSB and use as offset for buffer
00B63A  2  AA                 tax
00B63B  2  B5 24              lda Fireball_State,x       ;load fireball state
00B63D  2  D0 25              bne ProcFireballs          ;if not inactive, branch
00B63F  2  A4 B5              ldy Player_Y_HighPos       ;if player too high or too low, branch
00B641  2  88                 dey
00B642  2  D0 20              bne ProcFireballs
00B644  2  AD 14 07           lda CrouchingFlag          ;if player crouching, branch
00B647  2  D0 1B              bne ProcFireballs
00B649  2  A5 1D              lda Player_State           ;if player's state = climbing, branch
00B64B  2  C9 03              cmp #$03
00B64D  2  F0 15              beq ProcFireballs
00B64F  2  A9 20              lda #Sfx_Fireball          ;play fireball sound effect
00B651  2  85 FF              sta Square1SoundQueue
00B653  2  A9 02              lda #$02                   ;load state
00B655  2  95 24              sta Fireball_State,x
00B657  2  AC 0C 07           ldy PlayerAnimTimerSet     ;copy animation frame timer setting
00B65A  2  8C 11 07           sty FireballThrowingTimer  ;into fireball throwing timer
00B65D  2  88                 dey
00B65E  2  8C 81 07           sty PlayerAnimTimer        ;decrement and store in player's animation timer
00B661  2  EE CE 06           inc FireballCounter        ;increment fireball counter
00B664  2               
00B664  2               ProcFireballs:
00B664  2  A2 00              ldx #$00
00B666  2  20 89 B6           jsr FireballObjCore  ;process first fireball object
00B669  2  A2 01              ldx #$01
00B66B  2  20 89 B6           jsr FireballObjCore  ;process second fireball object, then do air bubbles
00B66E  2               
00B66E  2               ProcAirBubbles:
00B66E  2  AD 4E 07               lda AreaType                ;if not water type level, skip the rest of this
00B671  2  D0 13                  bne BublExit
00B673  2  A2 02                  ldx #$02                    ;otherwise load counter and use as offset
00B675  2  86 08        BublLoop: stx ObjectOffset            ;store offset
00B677  2  20 F9 B6               jsr BubbleCheck             ;check timers and coordinates, create air bubble
00B67A  2  20 31 F1               jsr RelativeBubblePosition  ;get relative coordinates
00B67D  2  20 91 F1               jsr GetBubbleOffscreenBits  ;get offscreen information
00B680  2  20 E1 ED               jsr DrawBubble              ;draw the air bubble
00B683  2  CA                     dex
00B684  2  10 EF                  bpl BublLoop                ;do this until all three are handled
00B686  2  60           BublExit: rts                         ;then leave
00B687  2               
00B687  2               FireballXSpdData:
00B687  2  40 C0              .byte $40, $c0
00B689  2               
00B689  2               FireballObjCore:
00B689  2  86 08                 stx ObjectOffset             ;store offset as current object
00B68B  2  B5 24                 lda Fireball_State,x         ;check for d7 = 1
00B68D  2  0A                    asl
00B68E  2  B0 63                 bcs FireballExplosion        ;if so, branch to get relative coordinates and draw explosion
00B690  2  B4 24                 ldy Fireball_State,x         ;if fireball inactive, branch to leave
00B692  2  F0 5E                 beq NoFBall
00B694  2  88                    dey                          ;if fireball state set to 1, skip this part and just run it
00B695  2  F0 27                 beq RunFB
00B697  2  A5 86                 lda Player_X_Position        ;get player's horizontal position
00B699  2  69 04                 adc #$04                     ;add four pixels and store as fireball's horizontal position
00B69B  2  95 8D                 sta Fireball_X_Position,x
00B69D  2  A5 6D                 lda Player_PageLoc           ;get player's page location
00B69F  2  69 00                 adc #$00                     ;add carry and store as fireball's page location
00B6A1  2  95 74                 sta Fireball_PageLoc,x
00B6A3  2  A5 CE                 lda Player_Y_Position        ;get player's vertical position and store
00B6A5  2  95 D5                 sta Fireball_Y_Position,x
00B6A7  2  A9 01                 lda #$01                     ;set high byte of vertical position
00B6A9  2  95 BC                 sta Fireball_Y_HighPos,x
00B6AB  2  A4 33                 ldy PlayerFacingDir          ;get player's facing direction
00B6AD  2  88                    dey                          ;decrement to use as offset here
00B6AE  2  B9 87 B6              lda FireballXSpdData,y       ;set horizontal speed of fireball accordingly
00B6B1  2  95 5E                 sta Fireball_X_Speed,x
00B6B3  2  A9 04                 lda #$04                     ;set vertical speed of fireball
00B6B5  2  95 A6                 sta Fireball_Y_Speed,x
00B6B7  2  A9 07                 lda #$07
00B6B9  2  9D A0 04              sta Fireball_BoundBoxCtrl,x  ;set bounding box size control for fireball
00B6BC  2  D6 24                 dec Fireball_State,x         ;decrement state to 1 to skip this part from now on
00B6BE  2  8A           RunFB:   txa                          ;add 7 to offset to use
00B6BF  2  18                    clc                          ;as fireball offset for next routines
00B6C0  2  69 07                 adc #$07
00B6C2  2  AA                    tax
00B6C3  2  A9 50                 lda #$50                     ;set downward movement force here
00B6C5  2  85 00                 sta $00
00B6C7  2  A9 03                 lda #$03                     ;set maximum speed here
00B6C9  2  85 02                 sta $02
00B6CB  2  A9 00                 lda #$00
00B6CD  2  20 D7 BF              jsr ImposeGravity            ;do sub here to impose gravity on fireball and move vertically
00B6D0  2  20 0F BF              jsr MoveObjectHorizontally   ;do another sub to move it horizontally
00B6D3  2  A6 08                 ldx ObjectOffset             ;return fireball offset to X
00B6D5  2  20 3B F1              jsr RelativeFireballPosition ;get relative coordinates
00B6D8  2  20 87 F1              jsr GetFireballOffscreenBits ;get offscreen information
00B6DB  2  20 2D E2              jsr GetFireballBoundBox      ;get bounding box coordinates
00B6DE  2  20 C8 E1              jsr FireballBGCollision      ;do fireball to background collision detection
00B6E1  2  AD D2 03              lda FBall_OffscreenBits      ;get fireball offscreen bits
00B6E4  2  29 CC                 and #%11001100               ;mask out certain bits
00B6E6  2  D0 06                 bne EraseFB                  ;if any bits still set, branch to kill fireball
00B6E8  2  20 D9 D6              jsr FireballEnemyCollision   ;do fireball to enemy collision detection and deal with collisions
00B6EB  2  4C DE EC              jmp DrawFireball             ;draw fireball appropriately and leave
00B6EE  2  A9 00        EraseFB: lda #$00                     ;erase fireball state
00B6F0  2  95 24                 sta Fireball_State,x
00B6F2  2  60           NoFBall: rts                          ;leave
00B6F3  2               
00B6F3  2               FireballExplosion:
00B6F3  2  20 3B F1           jsr RelativeFireballPosition
00B6F6  2  4C 09 ED           jmp DrawExplosion_Fireball
00B6F9  2               
00B6F9  2               BubbleCheck:
00B6F9  2  BD A8 07           lda PseudoRandomBitReg+1,x  ;get part of LSFR
00B6FC  2  29 01              and #$01
00B6FE  2  85 07              sta $07                     ;store pseudorandom bit here
00B700  2  B5 E4              lda Bubble_Y_Position,x     ;get vertical coordinate for air bubble
00B702  2  C9 F8              cmp #$f8                    ;if offscreen coordinate not set,
00B704  2  D0 2C              bne MoveBubl                ;branch to move air bubble
00B706  2  AD 92 07           lda AirBubbleTimer          ;if air bubble timer not expired,
00B709  2  D0 3F              bne ExitBubl                ;branch to leave, otherwise create new air bubble
00B70B  2               
00B70B  2               SetupBubble:
00B70B  2  A0 00                  ldy #$00                 ;load default value here
00B70D  2  A5 33                  lda PlayerFacingDir      ;get player's facing direction
00B70F  2  4A                     lsr                      ;move d0 to carry
00B710  2  90 02                  bcc PosBubl              ;branch to use default value if facing left
00B712  2  A0 08                  ldy #$08                 ;otherwise load alternate value here
00B714  2  98           PosBubl:  tya                      ;use value loaded as adder
00B715  2  65 86                  adc Player_X_Position    ;add to player's horizontal position
00B717  2  95 9C                  sta Bubble_X_Position,x  ;save as horizontal position for airbubble
00B719  2  A5 6D                  lda Player_PageLoc
00B71B  2  69 00                  adc #$00                 ;add carry to player's page location
00B71D  2  95 83                  sta Bubble_PageLoc,x     ;save as page location for airbubble
00B71F  2  A5 CE                  lda Player_Y_Position
00B721  2  18                     clc                      ;add eight pixels to player's vertical position
00B722  2  69 08                  adc #$08
00B724  2  95 E4                  sta Bubble_Y_Position,x  ;save as vertical position for air bubble
00B726  2  A9 01                  lda #$01
00B728  2  95 CB                  sta Bubble_Y_HighPos,x   ;set vertical high byte for air bubble
00B72A  2  A4 07                  ldy $07                  ;get pseudorandom bit, use as offset
00B72C  2  B9 4D B7               lda BubbleTimerData,y    ;get data for air bubble timer
00B72F  2  8D 92 07               sta AirBubbleTimer       ;set air bubble timer
00B732  2  A4 07        MoveBubl: ldy $07                  ;get pseudorandom bit again, use as offset
00B734  2  BD 2C 04               lda Bubble_YMF_Dummy,x
00B737  2  38                     sec                      ;subtract pseudorandom amount from dummy variable
00B738  2  F9 4B B7               sbc Bubble_MForceData,y
00B73B  2  9D 2C 04               sta Bubble_YMF_Dummy,x   ;save dummy variable
00B73E  2  B5 E4                  lda Bubble_Y_Position,x
00B740  2  E9 00                  sbc #$00                 ;subtract borrow from airbubble's vertical coordinate
00B742  2  C9 20                  cmp #$20                 ;if below the status bar,
00B744  2  B0 02                  bcs Y_Bubl               ;branch to go ahead and use to move air bubble upwards
00B746  2  A9 F8                  lda #$f8                 ;otherwise set offscreen coordinate
00B748  2  95 E4        Y_Bubl:   sta Bubble_Y_Position,x  ;store as new vertical coordinate for air bubble
00B74A  2  60           ExitBubl: rts                      ;leave
00B74B  2               
00B74B  2               Bubble_MForceData:
00B74B  2  FF 50              .byte $ff, $50
00B74D  2               
00B74D  2               BubbleTimerData:
00B74D  2  40 20              .byte $40, $20
00B74F  2               
00B74F  2               ;-------------------------------------------------------------------------------------
00B74F  2               
00B74F  2               RunGameTimer:
00B74F  2  AD 70 07                lda OperMode               ;get primary mode of operation
00B752  2  F0 4F                   beq ExGTimer               ;branch to leave if in title screen mode
00B754  2  A5 0E                   lda GameEngineSubroutine
00B756  2  C9 08                   cmp #$08                   ;if routine number less than eight running,
00B758  2  90 49                   bcc ExGTimer               ;branch to leave
00B75A  2  C9 0B                   cmp #$0b                   ;if running death routine,
00B75C  2  F0 45                   beq ExGTimer               ;branch to leave
00B75E  2  A5 B5                   lda Player_Y_HighPos
00B760  2  C9 02                   cmp #$02                   ;if player below the screen,
00B762  2  B0 3F                   bcs ExGTimer               ;branch to leave regardless of level type
00B764  2  AD 87 07                lda GameTimerCtrlTimer     ;if game timer control not yet expired,
00B767  2  D0 3A                   bne ExGTimer               ;branch to leave
00B769  2  AD F8 07                lda GameTimerDisplay
00B76C  2  0D F9 07                ora GameTimerDisplay+1     ;otherwise check game timer digits
00B76F  2  0D FA 07                ora GameTimerDisplay+2
00B772  2  F0 26                   beq TimeUpOn               ;if game timer digits at 000, branch to time-up code
00B774  2  AC F8 07                ldy GameTimerDisplay       ;otherwise check first digit
00B777  2  88                      dey                        ;if first digit not on 1,
00B778  2  D0 0C                   bne ResGTCtrl              ;branch to reset game timer control
00B77A  2  AD F9 07                lda GameTimerDisplay+1     ;otherwise check second and third digits
00B77D  2  0D FA 07                ora GameTimerDisplay+2
00B780  2  D0 04                   bne ResGTCtrl              ;if timer not at 100, branch to reset game timer control
00B782  2  A9 40                   lda #TimeRunningOutMusic
00B784  2  85 FC                   sta EventMusicQueue        ;otherwise load time running out music
00B786  2  A9 18        ResGTCtrl: lda #$18                   ;reset game timer control
00B788  2  8D 87 07                sta GameTimerCtrlTimer
00B78B  2  A0 23                   ldy #$23                   ;set offset for last digit
00B78D  2  A9 FF                   lda #$ff                   ;set value to decrement game timer digit
00B78F  2  8D 39 01                sta DigitModifier+5
00B792  2  20 5F 8F                jsr DigitsMathRoutine      ;do sub to decrement game timer slowly
00B795  2  A9 A4                   lda #$a4                   ;set status nybbles to update game timer display
00B797  2  4C 06 8F                jmp PrintStatusBarNumbers  ;do sub to update the display
00B79A  2  8D 56 07     TimeUpOn:  sta PlayerStatus           ;init player status (note A will always be zero here)
00B79D  2  20 31 D9                jsr ForceInjury            ;do sub to kill the player (note player is small here)
00B7A0  2  EE 59 07                inc GameTimerExpiredFlag   ;set game timer expiration flag
00B7A3  2  60           ExGTimer:  rts                        ;leave
00B7A4  2               
00B7A4  2               ;-------------------------------------------------------------------------------------
00B7A4  2               
00B7A4  2               WarpZoneObject:
00B7A4  2  AD 23 07           lda ScrollLock         ;check for scroll lock flag
00B7A7  2  F0 FA              beq ExGTimer           ;branch if not set to leave
00B7A9  2  A5 CE              lda Player_Y_Position  ;check to see if player's vertical coordinate has
00B7AB  2  25 B5              and Player_Y_HighPos   ;same bits set as in vertical high byte (why?)
00B7AD  2  D0 F4              bne ExGTimer           ;if so, branch to leave
00B7AF  2  8D 23 07           sta ScrollLock         ;otherwise nullify scroll lock flag
00B7B2  2  EE D6 06           inc WarpZoneControl    ;increment warp zone flag to make warp pipes for warp zone
00B7B5  2  4C 98 C9           jmp EraseEnemyObject   ;kill this object
00B7B8  2               
00B7B8  2               ;-------------------------------------------------------------------------------------
00B7B8  2               ;$00 - used in WhirlpoolActivate to store whirlpool length / 2, page location of center of whirlpool
00B7B8  2               ;and also to store movement force exerted on player
00B7B8  2               ;$01 - used in ProcessWhirlpools to store page location of right extent of whirlpool
00B7B8  2               ;and in WhirlpoolActivate to store center of whirlpool
00B7B8  2               ;$02 - used in ProcessWhirlpools to store right extent of whirlpool and in
00B7B8  2               ;WhirlpoolActivate to store maximum vertical speed
00B7B8  2               
00B7B8  2               ProcessWhirlpools:
00B7B8  2  AD 4E 07             lda AreaType                ;check for water type level
00B7BB  2  D0 37                bne ExitWh                  ;branch to leave if not found
00B7BD  2  8D 7D 04             sta Whirlpool_Flag          ;otherwise initialize whirlpool flag
00B7C0  2  AD 47 07             lda TimerControl            ;if master timer control set,
00B7C3  2  D0 2F                bne ExitWh                  ;branch to leave
00B7C5  2  A0 04                ldy #$04                    ;otherwise start with last whirlpool data
00B7C7  2  B9 71 04     WhLoop: lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B7CA  2  18                   clc
00B7CB  2  79 77 04             adc Whirlpool_Length,y      ;add length of whirlpool
00B7CE  2  85 02                sta $02                     ;store result as right extent here
00B7D0  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B7D3  2  F0 1C                beq NextWh                  ;if none or page 0, branch to get next data
00B7D5  2  69 00                adc #$00                    ;add carry
00B7D7  2  85 01                sta $01                     ;store result as page location of right extent here
00B7D9  2  A5 86                lda Player_X_Position       ;get player's horizontal position
00B7DB  2  38                   sec
00B7DC  2  F9 71 04             sbc Whirlpool_LeftExtent,y  ;subtract left extent
00B7DF  2  A5 6D                lda Player_PageLoc          ;get player's page location
00B7E1  2  F9 6B 04             sbc Whirlpool_PageLoc,y     ;subtract borrow
00B7E4  2  30 0B                bmi NextWh                  ;if player too far left, branch to get next data
00B7E6  2  A5 02                lda $02                     ;otherwise get right extent
00B7E8  2  38                   sec
00B7E9  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B7EB  2  A5 01                lda $01                     ;get right extent's page location
00B7ED  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B7EF  2  10 04                bpl WhirlpoolActivate       ;if player within right extent, branch to whirlpool code
00B7F1  2  88           NextWh: dey                         ;move onto next whirlpool data
00B7F2  2  10 D3                bpl WhLoop                  ;do this until all whirlpools are checked
00B7F4  2  60           ExitWh: rts                         ;leave
00B7F5  2               
00B7F5  2               WhirlpoolActivate:
00B7F5  2  B9 77 04             lda Whirlpool_Length,y      ;get length of whirlpool
00B7F8  2  4A                   lsr                         ;divide by 2
00B7F9  2  85 00                sta $00                     ;save here
00B7FB  2  B9 71 04             lda Whirlpool_LeftExtent,y  ;get left extent of whirlpool
00B7FE  2  18                   clc
00B7FF  2  65 00                adc $00                     ;add length divided by 2
00B801  2  85 01                sta $01                     ;save as center of whirlpool
00B803  2  B9 6B 04             lda Whirlpool_PageLoc,y     ;get page location
00B806  2  69 00                adc #$00                    ;add carry
00B808  2  85 00                sta $00                     ;save as page location of whirlpool center
00B80A  2  A5 09                lda FrameCounter            ;get frame counter
00B80C  2  4A                   lsr                         ;shift d0 into carry (to run on every other frame)
00B80D  2  90 2C                bcc WhPull                  ;if d0 not set, branch to last part of code
00B80F  2  A5 01                lda $01                     ;get center
00B811  2  38                   sec
00B812  2  E5 86                sbc Player_X_Position       ;subtract player's horizontal coordinate
00B814  2  A5 00                lda $00                     ;get page location of center
00B816  2  E5 6D                sbc Player_PageLoc          ;subtract borrow
00B818  2  10 0E                bpl LeftWh                  ;if player to the left of center, branch
00B81A  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player left, towards the center
00B81C  2  38                   sec
00B81D  2  E9 01                sbc #$01                    ;subtract one pixel
00B81F  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B821  2  A5 6D                lda Player_PageLoc
00B823  2  E9 00                sbc #$00                    ;subtract borrow
00B825  2  4C 39 B8             jmp SetPWh                  ;jump to set player's new page location
00B828  2  AD 90 04     LeftWh: lda Player_CollisionBits    ;get player's collision bits
00B82B  2  4A                   lsr                         ;shift d0 into carry
00B82C  2  90 0D                bcc WhPull                  ;if d0 not set, branch
00B82E  2  A5 86                lda Player_X_Position       ;otherwise slowly pull player right, towards the center
00B830  2  18                   clc
00B831  2  69 01                adc #$01                    ;add one pixel
00B833  2  85 86                sta Player_X_Position       ;set player's new horizontal coordinate
00B835  2  A5 6D                lda Player_PageLoc
00B837  2  69 00                adc #$00                    ;add carry
00B839  2  85 6D        SetPWh: sta Player_PageLoc          ;set player's new page location
00B83B  2  A9 10        WhPull: lda #$10
00B83D  2  85 00                sta $00                     ;set vertical movement force
00B83F  2  A9 01                lda #$01
00B841  2  8D 7D 04             sta Whirlpool_Flag          ;set whirlpool flag to be used later
00B844  2  85 02                sta $02                     ;also set maximum vertical speed
00B846  2  4A                   lsr
00B847  2  AA                   tax                         ;set X for player offset
00B848  2  4C D7 BF             jmp ImposeGravity           ;jump to put whirlpool effect on player vertically, do not return
00B84B  2               
00B84B  2               ;-------------------------------------------------------------------------------------
00B84B  2               
00B84B  2               FlagpoleScoreMods:
00B84B  2  05 02 08 04        .byte $05, $02, $08, $04, $01
00B84F  2  01           
00B850  2               
00B850  2               FlagpoleScoreDigits:
00B850  2  03 03 04 04        .byte $03, $03, $04, $04, $04
00B854  2  04           
00B855  2               
00B855  2               FlagpoleRoutine:
00B855  2  A2 05                   ldx #$05                  ;set enemy object offset
00B857  2  86 08                   stx ObjectOffset          ;to special use slot
00B859  2  B5 16                   lda Enemy_ID,x
00B85B  2  C9 30                   cmp #FlagpoleFlagObject   ;if flagpole flag not found,
00B85D  2  D0 56                   bne ExitFlagP             ;branch to leave
00B85F  2  A5 0E                   lda GameEngineSubroutine
00B861  2  C9 04                   cmp #$04                  ;if flagpole slide routine not running,
00B863  2  D0 31                   bne SkipScore             ;branch to near the end of code
00B865  2  A5 1D                   lda Player_State
00B867  2  C9 03                   cmp #$03                  ;if player state not climbing,
00B869  2  D0 2B                   bne SkipScore             ;branch to near the end of code
00B86B  2  B5 CF                   lda Enemy_Y_Position,x    ;check flagpole flag's vertical coordinate
00B86D  2  C9 AA                   cmp #$aa                  ;if flagpole flag down to a certain point,
00B86F  2  B0 28                   bcs GiveFPScr             ;branch to end the level
00B871  2  A5 CE                   lda Player_Y_Position     ;check player's vertical coordinate
00B873  2  C9 A2                   cmp #$a2                  ;if player down to a certain point,
00B875  2  B0 22                   bcs GiveFPScr             ;branch to end the level
00B877  2  BD 17 04                lda Enemy_YMF_Dummy,x
00B87A  2  69 FF                   adc #$ff                  ;add movement amount to dummy variable
00B87C  2  9D 17 04                sta Enemy_YMF_Dummy,x     ;save dummy variable
00B87F  2  B5 CF                   lda Enemy_Y_Position,x    ;get flag's vertical coordinate
00B881  2  69 01                   adc #$01                  ;add 1 plus carry to move flag, and
00B883  2  95 CF                   sta Enemy_Y_Position,x    ;store vertical coordinate
00B885  2  AD 0E 01                lda FlagpoleFNum_YMFDummy
00B888  2  38                      sec                       ;subtract movement amount from dummy variable
00B889  2  E9 FF                   sbc #$ff
00B88B  2  8D 0E 01                sta FlagpoleFNum_YMFDummy ;save dummy variable
00B88E  2  AD 0D 01                lda FlagpoleFNum_Y_Pos
00B891  2  E9 01                   sbc #$01                  ;subtract one plus borrow to move floatey number,
00B893  2  8D 0D 01                sta FlagpoleFNum_Y_Pos    ;and store vertical coordinate here
00B896  2  4C AC B8     SkipScore: jmp FPGfx                 ;jump to skip ahead and draw flag and floatey number
00B899  2  AC 0F 01     GiveFPScr: ldy FlagpoleScore         ;get score offset from earlier (when player touched flagpole)
00B89C  2  B9 4B B8                lda FlagpoleScoreMods,y   ;get amount to award player points
00B89F  2  BE 50 B8                ldx FlagpoleScoreDigits,y ;get digit with which to award points
00B8A2  2  9D 34 01                sta DigitModifier,x       ;store in digit modifier
00B8A5  2  20 27 BC                jsr AddToScore            ;do sub to award player points depending on height of collision
00B8A8  2  A9 05                   lda #$05
00B8AA  2  85 0E                   sta GameEngineSubroutine  ;set to run end-of-level subroutine on next frame
00B8AC  2  20 AF F1     FPGfx:     jsr GetEnemyOffscreenBits ;get offscreen information
00B8AF  2  20 52 F1                jsr RelativeEnemyPosition ;get relative coordinates
00B8B2  2  20 4B E5                jsr FlagpoleGfxHandler    ;draw flagpole flag and floatey number
00B8B5  2  60           ExitFlagP: rts
00B8B6  2               
00B8B6  2               ;-------------------------------------------------------------------------------------
00B8B6  2               
00B8B6  2               Jumpspring_Y_PosData:
00B8B6  2  08 10 08 00        .byte $08, $10, $08, $00
00B8BA  2               
00B8BA  2               JumpspringHandler:
00B8BA  2  20 AF F1                jsr GetEnemyOffscreenBits   ;get offscreen information
00B8BD  2  AD 47 07                lda TimerControl            ;check master timer control
00B8C0  2  D0 40                   bne DrawJSpr                ;branch to last section if set
00B8C2  2  AD 0E 07                lda JumpspringAnimCtrl      ;check jumpspring frame control
00B8C5  2  F0 3B                   beq DrawJSpr                ;branch to last section if not set
00B8C7  2  A8                      tay
00B8C8  2  88                      dey                         ;subtract one from frame control,
00B8C9  2  98                      tya                         ;the only way a poor nmos 6502 can
00B8CA  2  29 02                   and #%00000010              ;mask out all but d1, original value still in Y
00B8CC  2  D0 07                   bne DownJSpr                ;if set, branch to move player up
00B8CE  2  E6 CE                   inc Player_Y_Position
00B8D0  2  E6 CE                   inc Player_Y_Position       ;move player's vertical position down two pixels
00B8D2  2  4C D9 B8                jmp PosJSpr                 ;skip to next part
00B8D5  2  C6 CE        DownJSpr:  dec Player_Y_Position       ;move player's vertical position up two pixels
00B8D7  2  C6 CE                   dec Player_Y_Position
00B8D9  2  B5 58        PosJSpr:   lda Jumpspring_FixedYPos,x  ;get permanent vertical position
00B8DB  2  18                      clc
00B8DC  2  79 B6 B8                adc Jumpspring_Y_PosData,y  ;add value using frame control as offset
00B8DF  2  95 CF                   sta Enemy_Y_Position,x      ;store as new vertical position
00B8E1  2  C0 01                   cpy #$01                    ;check frame control offset (second frame is $00)
00B8E3  2  90 0F                   bcc BounceJS                ;if offset not yet at third frame ($01), skip to next part
00B8E5  2  A5 0A                   lda A_B_Buttons
00B8E7  2  29 80                   and #A_Button               ;check saved controller bits for A button press
00B8E9  2  F0 09                   beq BounceJS                ;skip to next part if A not pressed
00B8EB  2  25 0D                   and PreviousA_B_Buttons     ;check for A button pressed in previous frame
00B8ED  2  D0 05                   bne BounceJS                ;skip to next part if so
00B8EF  2  A9 F4                   lda #$f4
00B8F1  2  8D DB 06                sta JumpspringForce         ;otherwise write new jumpspring force here
00B8F4  2  C0 03        BounceJS:  cpy #$03                    ;check frame control offset again
00B8F6  2  D0 0A                   bne DrawJSpr                ;skip to last part if not yet at fifth frame ($03)
00B8F8  2  AD DB 06                lda JumpspringForce
00B8FB  2  85 9F                   sta Player_Y_Speed          ;store jumpspring force as player's new vertical speed
00B8FD  2  A9 00                   lda #$00
00B8FF  2  8D 0E 07                sta JumpspringAnimCtrl      ;initialize jumpspring frame control
00B902  2  20 52 F1     DrawJSpr:  jsr RelativeEnemyPosition   ;get jumpspring's relative coordinates
00B905  2  20 7D E8                jsr EnemyGfxHandler         ;draw jumpspring
00B908  2  20 7A D6                jsr OffscreenBoundsCheck    ;check to see if we need to kill it
00B90B  2  AD 0E 07                lda JumpspringAnimCtrl      ;if frame control at zero, don't bother
00B90E  2  F0 0D                   beq ExJSpring               ;trying to animate it, just leave
00B910  2  AD 86 07                lda JumpspringTimer
00B913  2  D0 08                   bne ExJSpring               ;if jumpspring timer not expired yet, leave
00B915  2  A9 04                   lda #$04
00B917  2  8D 86 07                sta JumpspringTimer         ;otherwise initialize jumpspring timer
00B91A  2  EE 0E 07                inc JumpspringAnimCtrl      ;increment frame control to animate jumpspring
00B91D  2  60           ExJSpring: rts                         ;leave
00B91E  2               
00B91E  2               ;-------------------------------------------------------------------------------------
00B91E  2               
00B91E  2               Setup_Vine:
00B91E  2  A9 2F                lda #VineObject          ;load identifier for vine object
00B920  2  95 16                sta Enemy_ID,x           ;store in buffer
00B922  2  A9 01                lda #$01
00B924  2  95 0F                sta Enemy_Flag,x         ;set flag for enemy object buffer
00B926  2  B9 76 00             lda Block_PageLoc,y
00B929  2  95 6E                sta Enemy_PageLoc,x      ;copy page location from previous object
00B92B  2  B9 8F 00             lda Block_X_Position,y
00B92E  2  95 87                sta Enemy_X_Position,x   ;copy horizontal coordinate from previous object
00B930  2  B9 D7 00             lda Block_Y_Position,y
00B933  2  95 CF                sta Enemy_Y_Position,x   ;copy vertical coordinate from previous object
00B935  2  AC 98 03             ldy VineFlagOffset       ;load vine flag/offset to next available vine slot
00B938  2  D0 03                bne NextVO               ;if set at all, don't bother to store vertical
00B93A  2  8D 9D 03             sta VineStart_Y_Position ;otherwise store vertical coordinate here
00B93D  2  8A           NextVO: txa                      ;store object offset to next available vine slot
00B93E  2  99 9A 03             sta VineObjOffset,y      ;using vine flag as offset
00B941  2  EE 98 03             inc VineFlagOffset       ;increment vine flag offset
00B944  2  A9 04                lda #Sfx_GrowVine
00B946  2  85 FE                sta Square2SoundQueue    ;load vine grow sound
00B948  2  60                   rts
00B949  2               
00B949  2               ;-------------------------------------------------------------------------------------
00B949  2               ;$06-$07 - used as address to block buffer data
00B949  2               ;$02 - used as vertical high nybble of block buffer offset
00B949  2               
00B949  2               VineHeightData:
00B949  2  30 60              .byte $30, $60
00B94B  2               
00B94B  2               VineObjectHandler:
00B94B  2  E0 05                   cpx #$05                  ;check enemy offset for special use slot
00B94D  2  D0 68                   bne ExitVH                ;if not in last slot, branch to leave
00B94F  2  AC 98 03                ldy VineFlagOffset
00B952  2  88                      dey                       ;decrement vine flag in Y, use as offset
00B953  2  AD 99 03                lda VineHeight
00B956  2  D9 49 B9                cmp VineHeightData,y      ;if vine has reached certain height,
00B959  2  F0 0F                   beq RunVSubs              ;branch ahead to skip this part
00B95B  2  A5 09                   lda FrameCounter          ;get frame counter
00B95D  2  4A                      lsr                       ;shift d1 into carry
00B95E  2  4A                      lsr
00B95F  2  90 09                   bcc RunVSubs              ;if d1 not set (2 frames every 4) skip this part
00B961  2  A5 D4                   lda Enemy_Y_Position+5
00B963  2  E9 01                   sbc #$01                  ;subtract vertical position of vine
00B965  2  85 D4                   sta Enemy_Y_Position+5    ;one pixel every frame it's time
00B967  2  EE 99 03                inc VineHeight            ;increment vine height
00B96A  2  AD 99 03     RunVSubs:  lda VineHeight            ;if vine still very small,
00B96D  2  C9 08                   cmp #$08                  ;branch to leave
00B96F  2  90 46                   bcc ExitVH
00B971  2  20 52 F1                jsr RelativeEnemyPosition ;get relative coordinates of vine,
00B974  2  20 AF F1                jsr GetEnemyOffscreenBits ;and any offscreen bits
00B977  2  A0 00                   ldy #$00                  ;initialize offset used in draw vine sub
00B979  2  20 35 E4     VDrawLoop: jsr DrawVine              ;draw vine
00B97C  2  C8                      iny                       ;increment offset
00B97D  2  CC 98 03                cpy VineFlagOffset        ;if offset in Y and offset here
00B980  2  D0 F7                   bne VDrawLoop             ;do not yet match, loop back to draw more vine
00B982  2  AD D1 03                lda Enemy_OffscreenBits
00B985  2  29 0C                   and #%00001100            ;mask offscreen bits
00B987  2  F0 10                   beq WrCMTile              ;if none of the saved offscreen bits set, skip ahead
00B989  2  88                      dey                       ;otherwise decrement Y to get proper offset again
00B98A  2  BE 9A 03     KillVine:  ldx VineObjOffset,y       ;get enemy object offset for this vine object
00B98D  2  20 98 C9                jsr EraseEnemyObject      ;kill this vine object
00B990  2  88                      dey                       ;decrement Y
00B991  2  10 F7                   bpl KillVine              ;if any vine objects left, loop back to kill it
00B993  2  8D 98 03                sta VineFlagOffset        ;initialize vine flag/offset
00B996  2  8D 99 03                sta VineHeight            ;initialize vine height
00B999  2  AD 99 03     WrCMTile:  lda VineHeight            ;check vine height
00B99C  2  C9 20                   cmp #$20                  ;if vine small (less than 32 pixels tall)
00B99E  2  90 17                   bcc ExitVH                ;then branch ahead to leave
00B9A0  2  A2 06                   ldx #$06                  ;set offset in X to last enemy slot
00B9A2  2  A9 01                   lda #$01                  ;set A to obtain horizontal in $04, but we don't care
00B9A4  2  A0 1B                   ldy #$1b                  ;set Y to offset to get block at ($04, $10) of coordinates
00B9A6  2  20 F0 E3                jsr BlockBufferCollision  ;do a sub to get block buffer address set, return contents
00B9A9  2  A4 02                   ldy $02
00B9AB  2  C0 D0                   cpy #$d0                  ;if vertical high nybble offset beyond extent of
00B9AD  2  B0 08                   bcs ExitVH                ;current block buffer, branch to leave, do not write
00B9AF  2  B1 06                   lda ($06),y               ;otherwise check contents of block buffer at
00B9B1  2  D0 04                   bne ExitVH                ;current offset, if not empty, branch to leave
00B9B3  2  A9 26                   lda #$26
00B9B5  2  91 06                   sta ($06),y               ;otherwise, write climbing metatile to block buffer
00B9B7  2  A6 08        ExitVH:    ldx ObjectOffset          ;get enemy object offset and leave
00B9B9  2  60                      rts
00B9BA  2               
00B9BA  2               ;-------------------------------------------------------------------------------------
00B9BA  2               
00B9BA  2               CannonBitmasks:
00B9BA  2  0F 07              .byte %00001111, %00000111
00B9BC  2               
00B9BC  2               ProcessCannons:
00B9BC  2  AD 4E 07                lda AreaType                ;get area type
00B9BF  2  F0 6F                   beq ExCannon                ;if water type area, branch to leave
00B9C1  2  A2 02                   ldx #$02
00B9C3  2  86 08        ThreeSChk: stx ObjectOffset            ;start at third enemy slot
00B9C5  2  B5 0F                   lda Enemy_Flag,x            ;check enemy buffer flag
00B9C7  2  D0 51                   bne Chk_BB                  ;if set, branch to check enemy
00B9C9  2  BD A8 07                lda PseudoRandomBitReg+1,x  ;otherwise get part of LSFR
00B9CC  2  AC CC 06                ldy SecondaryHardMode       ;get secondary hard mode flag, use as offset
00B9CF  2  39 BA B9                and CannonBitmasks,y        ;mask out bits of LSFR as decided by flag
00B9D2  2  C9 06                   cmp #$06                    ;check to see if lower nybble is above certain value
00B9D4  2  B0 44                   bcs Chk_BB                  ;if so, branch to check enemy
00B9D6  2  A8                      tay                         ;transfer masked contents of LSFR to Y as pseudorandom offset
00B9D7  2  B9 6B 04                lda Cannon_PageLoc,y        ;get page location
00B9DA  2  F0 3E                   beq Chk_BB                  ;if not set or on page 0, branch to check enemy
00B9DC  2  B9 7D 04                lda Cannon_Timer,y          ;get cannon timer
00B9DF  2  F0 08                   beq FireCannon              ;if expired, branch to fire cannon
00B9E1  2  E9 00                   sbc #$00                    ;otherwise subtract borrow (note carry will always be clear here)
00B9E3  2  99 7D 04                sta Cannon_Timer,y          ;to count timer down
00B9E6  2  4C 1A BA                jmp Chk_BB                  ;then jump ahead to check enemy
00B9E9  2               
00B9E9  2               FireCannon:
00B9E9  2  AD 47 07               lda TimerControl           ;if master timer control set,
00B9EC  2  D0 2C                  bne Chk_BB                 ;branch to check enemy
00B9EE  2  A9 0E                  lda #$0e                   ;otherwise we start creating one
00B9F0  2  99 7D 04               sta Cannon_Timer,y         ;first, reset cannon timer
00B9F3  2  B9 6B 04               lda Cannon_PageLoc,y       ;get page location of cannon
00B9F6  2  95 6E                  sta Enemy_PageLoc,x        ;save as page location of bullet bill
00B9F8  2  B9 71 04               lda Cannon_X_Position,y    ;get horizontal coordinate of cannon
00B9FB  2  95 87                  sta Enemy_X_Position,x     ;save as horizontal coordinate of bullet bill
00B9FD  2  B9 77 04               lda Cannon_Y_Position,y    ;get vertical coordinate of cannon
00BA00  2  38                     sec
00BA01  2  E9 08                  sbc #$08                   ;subtract eight pixels (because enemies are 24 pixels tall)
00BA03  2  95 CF                  sta Enemy_Y_Position,x     ;save as vertical coordinate of bullet bill
00BA05  2  A9 01                  lda #$01
00BA07  2  95 B6                  sta Enemy_Y_HighPos,x      ;set vertical high byte of bullet bill
00BA09  2  95 0F                  sta Enemy_Flag,x           ;set buffer flag
00BA0B  2  4A                     lsr                        ;shift right once to init A
00BA0C  2  95 1E                  sta Enemy_State,x          ;then initialize enemy's state
00BA0E  2  A9 09                  lda #$09
00BA10  2  9D 9A 04               sta Enemy_BoundBoxCtrl,x   ;set bounding box size control for bullet bill
00BA13  2  A9 33                  lda #BulletBill_CannonVar
00BA15  2  95 16                  sta Enemy_ID,x             ;load identifier for bullet bill (cannon variant)
00BA17  2  4C 2D BA               jmp Next3Slt               ;move onto next slot
00BA1A  2  B5 16        Chk_BB:   lda Enemy_ID,x             ;check enemy identifier for bullet bill (cannon variant)
00BA1C  2  C9 33                  cmp #BulletBill_CannonVar
00BA1E  2  D0 0D                  bne Next3Slt               ;if not found, branch to get next slot
00BA20  2  20 7A D6               jsr OffscreenBoundsCheck   ;otherwise, check to see if it went offscreen
00BA23  2  B5 0F                  lda Enemy_Flag,x           ;check enemy buffer flag
00BA25  2  F0 06                  beq Next3Slt               ;if not set, branch to get next slot
00BA27  2  20 AF F1               jsr GetEnemyOffscreenBits  ;otherwise, get offscreen information
00BA2A  2  20 33 BA               jsr BulletBillHandler      ;then do sub to handle bullet bill
00BA2D  2  CA           Next3Slt: dex                        ;move onto next slot
00BA2E  2  10 93                  bpl ThreeSChk              ;do this until first three slots are checked
00BA30  2  60           ExCannon: rts                        ;then leave
00BA31  2               
00BA31  2               ;--------------------------------
00BA31  2               
00BA31  2               BulletBillXSpdData:
00BA31  2  18 E8              .byte $18, $e8
00BA33  2               
00BA33  2               BulletBillHandler:
00BA33  2  AD 47 07                lda TimerControl          ;if master timer control set,
00BA36  2  D0 3E                   bne RunBBSubs             ;branch to run subroutines except movement sub
00BA38  2  B5 1E                   lda Enemy_State,x
00BA3A  2  D0 2E                   bne ChkDSte               ;if bullet bill's state set, branch to check defeated state
00BA3C  2  AD D1 03                lda Enemy_OffscreenBits   ;otherwise load offscreen bits
00BA3F  2  29 0C                   and #%00001100            ;mask out bits
00BA41  2  C9 0C                   cmp #%00001100            ;check to see if all bits are set
00BA43  2  F0 40                   beq KillBB                ;if so, branch to kill this object
00BA45  2  A0 01                   ldy #$01                  ;set to move right by default
00BA47  2  20 43 E1                jsr PlayerEnemyDiff       ;get horizontal difference between player and bullet bill
00BA4A  2  30 01                   bmi SetupBB               ;if enemy to the left of player, branch
00BA4C  2  C8                      iny                       ;otherwise increment to move left
00BA4D  2  94 46        SetupBB:   sty Enemy_MovingDir,x     ;set bullet bill's moving direction
00BA4F  2  88                      dey                       ;decrement to use as offset
00BA50  2  B9 31 BA                lda BulletBillXSpdData,y  ;get horizontal speed based on moving direction
00BA53  2  95 58                   sta Enemy_X_Speed,x       ;and store it
00BA55  2  A5 00                   lda $00                   ;get horizontal difference
00BA57  2  69 28                   adc #$28                  ;add 40 pixels
00BA59  2  C9 50                   cmp #$50                  ;if less than a certain amount, player is too close
00BA5B  2  90 28                   bcc KillBB                ;to cannon either on left or right side, thus branch
00BA5D  2  A9 01                   lda #$01
00BA5F  2  95 1E                   sta Enemy_State,x         ;otherwise set bullet bill's state
00BA61  2  A9 0A                   lda #$0a
00BA63  2  9D 8A 07                sta EnemyFrameTimer,x     ;set enemy frame timer
00BA66  2  A9 08                   lda #Sfx_Blast
00BA68  2  85 FE                   sta Square2SoundQueue     ;play fireworks/gunfire sound
00BA6A  2  B5 1E        ChkDSte:   lda Enemy_State,x         ;check enemy state for d5 set
00BA6C  2  29 20                   and #%00100000
00BA6E  2  F0 03                   beq BBFly                 ;if not set, skip to move horizontally
00BA70  2  20 63 BF                jsr MoveD_EnemyVertically ;otherwise do sub to move bullet bill vertically
00BA73  2  20 02 BF     BBFly:     jsr MoveEnemyHorizontally ;do sub to move bullet bill horizontally
00BA76  2  20 AF F1     RunBBSubs: jsr GetEnemyOffscreenBits ;get offscreen information
00BA79  2  20 52 F1                jsr RelativeEnemyPosition ;get relative coordinates
00BA7C  2  20 43 E2                jsr GetEnemyBoundBox      ;get bounding box coordinates
00BA7F  2  20 53 D8                jsr PlayerEnemyCollision  ;handle player to enemy collisions
00BA82  2  4C 7D E8                jmp EnemyGfxHandler       ;draw the bullet bill and leave
00BA85  2  20 98 C9     KillBB:    jsr EraseEnemyObject      ;kill bullet bill and leave
00BA88  2  60                      rts
00BA89  2               
00BA89  2               ;-------------------------------------------------------------------------------------
00BA89  2               
00BA89  2               HammerEnemyOfsData:
00BA89  2  04 04 04 05        .byte $04, $04, $04, $05, $05, $05
00BA8D  2  05 05        
00BA8F  2  06 06 06           .byte $06, $06, $06
00BA92  2               
00BA92  2               HammerXSpdData:
00BA92  2  10 F0              .byte $10, $f0
00BA94  2               
00BA94  2               SpawnHammerObj:
00BA94  2  AD A8 07               lda PseudoRandomBitReg+1 ;get pseudorandom bits from
00BA97  2  29 07                  and #%00000111           ;second part of LSFR
00BA99  2  D0 05                  bne SetMOfs              ;if any bits are set, branch and use as offset
00BA9B  2  AD A8 07               lda PseudoRandomBitReg+1
00BA9E  2  29 08                  and #%00001000           ;get d3 from same part of LSFR
00BAA0  2  A8           SetMOfs:  tay                      ;use either d3 or d2-d0 for offset here
00BAA1  2  B9 2A 00               lda Misc_State,y         ;if any values loaded in
00BAA4  2  D0 19                  bne NoHammer             ;$2a-$32 where offset is then leave with carry clear
00BAA6  2  BE 89 BA               ldx HammerEnemyOfsData,y ;get offset of enemy slot to check using Y as offset
00BAA9  2  B5 0F                  lda Enemy_Flag,x         ;check enemy buffer flag at offset
00BAAB  2  D0 12                  bne NoHammer             ;if buffer flag set, branch to leave with carry clear
00BAAD  2  A6 08                  ldx ObjectOffset         ;get original enemy object offset
00BAAF  2  8A                     txa
00BAB0  2  99 AE 06               sta HammerEnemyOffset,y  ;save here
00BAB3  2  A9 90                  lda #$90
00BAB5  2  99 2A 00               sta Misc_State,y         ;save hammer's state here
00BAB8  2  A9 07                  lda #$07
00BABA  2  99 A2 04               sta Misc_BoundBoxCtrl,y  ;set something else entirely, here
00BABD  2  38                     sec                      ;return with carry set
00BABE  2  60                     rts
00BABF  2  A6 08        NoHammer: ldx ObjectOffset         ;get original enemy object offset
00BAC1  2  18                     clc                      ;return with carry clear
00BAC2  2  60                     rts
00BAC3  2               
00BAC3  2               ;--------------------------------
00BAC3  2               ;$00 - used to set downward force
00BAC3  2               ;$01 - used to set upward force (residual)
00BAC3  2               ;$02 - used to set maximum speed
00BAC3  2               
00BAC3  2               ProcHammerObj:
00BAC3  2  AD 47 07               lda TimerControl           ;if master timer control set
00BAC6  2  D0 63                  bne RunHSubs               ;skip all of this code and go to last subs at the end
00BAC8  2  B5 2A                  lda Misc_State,x           ;otherwise get hammer's state
00BACA  2  29 7F                  and #%01111111             ;mask out d7
00BACC  2  BC AE 06               ldy HammerEnemyOffset,x    ;get enemy object offset that spawned this hammer
00BACF  2  C9 02                  cmp #$02                   ;check hammer's state
00BAD1  2  F0 20                  beq SetHSpd                ;if currently at 2, branch
00BAD3  2  B0 34                  bcs SetHPos                ;if greater than 2, branch elsewhere
00BAD5  2  8A                     txa
00BAD6  2  18                     clc                        ;add 13 bytes to use
00BAD7  2  69 0D                  adc #$0d                   ;proper misc object
00BAD9  2  AA                     tax                        ;return offset to X
00BADA  2  A9 10                  lda #$10
00BADC  2  85 00                  sta $00                    ;set downward movement force
00BADE  2  A9 0F                  lda #$0f
00BAE0  2  85 01                  sta $01                    ;set upward movement force (not used)
00BAE2  2  A9 04                  lda #$04
00BAE4  2  85 02                  sta $02                    ;set maximum vertical speed
00BAE6  2  A9 00                  lda #$00                   ;set A to impose gravity on hammer
00BAE8  2  20 D7 BF               jsr ImposeGravity          ;do sub to impose gravity on hammer and move vertically
00BAEB  2  20 0F BF               jsr MoveObjectHorizontally ;do sub to move it horizontally
00BAEE  2  A6 08                  ldx ObjectOffset           ;get original misc object offset
00BAF0  2  4C 28 BB               jmp RunAllH                ;branch to essential subroutines
00BAF3  2  A9 FE        SetHSpd:  lda #$fe
00BAF5  2  95 AC                  sta Misc_Y_Speed,x         ;set hammer's vertical speed
00BAF7  2  B9 1E 00               lda Enemy_State,y          ;get enemy object state
00BAFA  2  29 F7                  and #%11110111             ;mask out d3
00BAFC  2  99 1E 00               sta Enemy_State,y          ;store new state
00BAFF  2  B6 46                  ldx Enemy_MovingDir,y      ;get enemy's moving direction
00BB01  2  CA                     dex                        ;decrement to use as offset
00BB02  2  BD 92 BA               lda HammerXSpdData,x       ;get proper speed to use based on moving direction
00BB05  2  A6 08                  ldx ObjectOffset           ;reobtain hammer's buffer offset
00BB07  2  95 64                  sta Misc_X_Speed,x         ;set hammer's horizontal speed
00BB09  2  D6 2A        SetHPos:  dec Misc_State,x           ;decrement hammer's state
00BB0B  2  B9 87 00               lda Enemy_X_Position,y     ;get enemy's horizontal position
00BB0E  2  18                     clc
00BB0F  2  69 02                  adc #$02                   ;set position 2 pixels to the right
00BB11  2  95 93                  sta Misc_X_Position,x      ;store as hammer's horizontal position
00BB13  2  B9 6E 00               lda Enemy_PageLoc,y        ;get enemy's page location
00BB16  2  69 00                  adc #$00                   ;add carry
00BB18  2  95 7A                  sta Misc_PageLoc,x         ;store as hammer's page location
00BB1A  2  B9 CF 00               lda Enemy_Y_Position,y     ;get enemy's vertical position
00BB1D  2  38                     sec
00BB1E  2  E9 0A                  sbc #$0a                   ;move position 10 pixels upward
00BB20  2  95 DB                  sta Misc_Y_Position,x      ;store as hammer's vertical position
00BB22  2  A9 01                  lda #$01
00BB24  2  95 C2                  sta Misc_Y_HighPos,x       ;set hammer's vertical high byte
00BB26  2  D0 03                  bne RunHSubs               ;unconditional branch to skip first routine
00BB28  2  20 C4 D7     RunAllH:  jsr PlayerHammerCollision  ;handle collisions
00BB2B  2  20 9B F1     RunHSubs: jsr GetMiscOffscreenBits   ;get offscreen information
00BB2E  2  20 48 F1               jsr RelativeMiscPosition   ;get relative coordinates
00BB31  2  20 36 E2               jsr GetMiscBoundBox        ;get bounding box coordinates
00BB34  2  20 DC E4               jsr DrawHammer             ;draw the hammer
00BB37  2  60                     rts                        ;and we are done here
00BB38  2               
00BB38  2               ;-------------------------------------------------------------------------------------
00BB38  2               ;$02 - used to store vertical high nybble offset from block buffer routine
00BB38  2               ;$06 - used to store low byte of block buffer address
00BB38  2               
00BB38  2               CoinBlock:
00BB38  2  20 84 BB           jsr FindEmptyMiscSlot   ;set offset for empty or last misc object buffer slot
00BB3B  2  B5 76              lda Block_PageLoc,x     ;get page location of block object
00BB3D  2  99 7A 00           sta Misc_PageLoc,y      ;store as page location of misc object
00BB40  2  B5 8F              lda Block_X_Position,x  ;get horizontal coordinate of block object
00BB42  2  09 05              ora #$05                ;add 5 pixels
00BB44  2  99 93 00           sta Misc_X_Position,y   ;store as horizontal coordinate of misc object
00BB47  2  B5 D7              lda Block_Y_Position,x  ;get vertical coordinate of block object
00BB49  2  E9 10              sbc #$10                ;subtract 16 pixels
00BB4B  2  99 DB 00           sta Misc_Y_Position,y   ;store as vertical coordinate of misc object
00BB4E  2  4C 6C BB           jmp JCoinC              ;jump to rest of code as applies to this misc object
00BB51  2               
00BB51  2               SetupJumpCoin:
00BB51  2  20 84 BB             jsr FindEmptyMiscSlot  ;set offset for empty or last misc object buffer slot
00BB54  2  BD EA 03             lda Block_PageLoc2,x   ;get page location saved earlier
00BB57  2  99 7A 00             sta Misc_PageLoc,y     ;and save as page location for misc object
00BB5A  2  A5 06                lda $06                ;get low byte of block buffer offset
00BB5C  2  0A                   asl
00BB5D  2  0A                   asl                    ;multiply by 16 to use lower nybble
00BB5E  2  0A                   asl
00BB5F  2  0A                   asl
00BB60  2  09 05                ora #$05               ;add five pixels
00BB62  2  99 93 00             sta Misc_X_Position,y  ;save as horizontal coordinate for misc object
00BB65  2  A5 02                lda $02                ;get vertical high nybble offset from earlier
00BB67  2  69 20                adc #$20               ;add 32 pixels for the status bar
00BB69  2  99 DB 00             sta Misc_Y_Position,y  ;store as vertical coordinate
00BB6C  2  A9 FB        JCoinC: lda #$fb
00BB6E  2  99 AC 00             sta Misc_Y_Speed,y     ;set vertical speed
00BB71  2  A9 01                lda #$01
00BB73  2  99 C2 00             sta Misc_Y_HighPos,y   ;set vertical high byte
00BB76  2  99 2A 00             sta Misc_State,y       ;set state for misc object
00BB79  2  85 FE                sta Square2SoundQueue  ;load coin grab sound
00BB7B  2  86 08                stx ObjectOffset       ;store current control bit as misc object offset
00BB7D  2  20 FE BB             jsr GiveOneCoin        ;update coin tally on the screen and coin amount variable
00BB80  2  EE 48 07             inc CoinTallyFor1Ups   ;increment coin tally used to activate 1-up block flag
00BB83  2  60                   rts
00BB84  2               
00BB84  2               FindEmptyMiscSlot:
00BB84  2  A0 08                   ldy #$08                ;start at end of misc objects buffer
00BB86  2  B9 2A 00     FMiscLoop: lda Misc_State,y        ;get misc object state
00BB89  2  F0 07                   beq UseMiscS            ;branch if none found to use current offset
00BB8B  2  88                      dey                     ;decrement offset
00BB8C  2  C0 05                   cpy #$05                ;do this for three slots
00BB8E  2  D0 F6                   bne FMiscLoop           ;do this until all slots are checked
00BB90  2  A0 08                   ldy #$08                ;if no empty slots found, use last slot
00BB92  2  8C B7 06     UseMiscS:  sty JumpCoinMiscOffset  ;store offset of misc object buffer here (residual)
00BB95  2  60                      rts
00BB96  2               
00BB96  2               ;-------------------------------------------------------------------------------------
00BB96  2               
00BB96  2               MiscObjectsCore:
00BB96  2  A2 08                  ldx #$08          ;set at end of misc object buffer
00BB98  2  86 08        MiscLoop: stx ObjectOffset  ;store misc object offset here
00BB9A  2  B5 2A                  lda Misc_State,x  ;check misc object state
00BB9C  2  F0 56                  beq MiscLoopBack  ;branch to check next slot
00BB9E  2  0A                     asl               ;otherwise shift d7 into carry
00BB9F  2  90 06                  bcc ProcJumpCoin  ;if d7 not set, jumping coin, thus skip to rest of code here
00BBA1  2  20 C3 BA               jsr ProcHammerObj ;otherwise go to process hammer,
00BBA4  2  4C F4 BB               jmp MiscLoopBack  ;then check next slot
00BBA7  2               
00BBA7  2               ;--------------------------------
00BBA7  2               ;$00 - used to set downward force
00BBA7  2               ;$01 - used to set upward force (residual)
00BBA7  2               ;$02 - used to set maximum speed
00BBA7  2               
00BBA7  2               ProcJumpCoin:
00BBA7  2  B4 2A                   ldy Misc_State,x          ;check misc object state
00BBA9  2  88                      dey                       ;decrement to see if it's set to 1
00BBAA  2  F0 1D                   beq JCoinRun              ;if so, branch to handle jumping coin
00BBAC  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to either start off or as timer
00BBAE  2  B5 93                   lda Misc_X_Position,x     ;get horizontal coordinate for misc object
00BBB0  2  18                      clc                       ;whether its jumping coin (state 0 only) or floatey number
00BBB1  2  6D 75 07                adc ScrollAmount          ;add current scroll speed
00BBB4  2  95 93                   sta Misc_X_Position,x     ;store as new horizontal coordinate
00BBB6  2  B5 7A                   lda Misc_PageLoc,x        ;get page location
00BBB8  2  69 00                   adc #$00                  ;add carry
00BBBA  2  95 7A                   sta Misc_PageLoc,x        ;store as new page location
00BBBC  2  B5 2A                   lda Misc_State,x
00BBBE  2  C9 30                   cmp #$30                  ;check state of object for preset value
00BBC0  2  D0 26                   bne RunJCSubs             ;if not yet reached, branch to subroutines
00BBC2  2  A9 00                   lda #$00
00BBC4  2  95 2A                   sta Misc_State,x          ;otherwise nullify object state
00BBC6  2  4C F4 BB                jmp MiscLoopBack          ;and move onto next slot
00BBC9  2  8A           JCoinRun:  txa
00BBCA  2  18                      clc                       ;add 13 bytes to offset for next subroutine
00BBCB  2  69 0D                   adc #$0d
00BBCD  2  AA                      tax
00BBCE  2  A9 50                   lda #$50                  ;set downward movement amount
00BBD0  2  85 00                   sta $00
00BBD2  2  A9 06                   lda #$06                  ;set maximum vertical speed
00BBD4  2  85 02                   sta $02
00BBD6  2  4A                      lsr                       ;divide by 2 and set
00BBD7  2  85 01                   sta $01                   ;as upward movement amount (apparently residual)
00BBD9  2  A9 00                   lda #$00                  ;set A to impose gravity on jumping coin
00BBDB  2  20 D7 BF                jsr ImposeGravity         ;do sub to move coin vertically and impose gravity on it
00BBDE  2  A6 08                   ldx ObjectOffset          ;get original misc object offset
00BBE0  2  B5 AC                   lda Misc_Y_Speed,x        ;check vertical speed
00BBE2  2  C9 05                   cmp #$05
00BBE4  2  D0 02                   bne RunJCSubs             ;if not moving downward fast enough, keep state as-is
00BBE6  2  F6 2A                   inc Misc_State,x          ;otherwise increment state to change to floatey number
00BBE8  2  20 48 F1     RunJCSubs: jsr RelativeMiscPosition  ;get relative coordinates
00BBEB  2  20 9B F1                jsr GetMiscOffscreenBits  ;get offscreen information
00BBEE  2  20 36 E2                jsr GetMiscBoundBox       ;get bounding box coordinates (why?)
00BBF1  2  20 86 E6                jsr JCoinGfxHandler       ;draw the coin or floatey number
00BBF4  2               
00BBF4  2               MiscLoopBack:
00BBF4  2  CA                      dex                       ;decrement misc object offset
00BBF5  2  10 A1                   bpl MiscLoop              ;loop back until all misc objects handled
00BBF7  2  60                      rts                       ;then leave
00BBF8  2               
00BBF8  2               ;-------------------------------------------------------------------------------------
00BBF8  2               
00BBF8  2               CoinTallyOffsets:
00BBF8  2  17 1D              .byte $17, $1d
00BBFA  2               
00BBFA  2               ScoreOffsets:
00BBFA  2  0B 11              .byte $0b, $11
00BBFC  2               
00BBFC  2               StatusBarNybbles:
00BBFC  2  02 13              .byte $02, $13
00BBFE  2               
00BBFE  2               GiveOneCoin:
00BBFE  2  A9 01              lda #$01               ;set digit modifier to add 1 coin
00BC00  2  8D 39 01           sta DigitModifier+5    ;to the current player's coin tally
00BC03  2  AE 53 07           ldx CurrentPlayer      ;get current player on the screen
00BC06  2  BC F8 BB           ldy CoinTallyOffsets,x ;get offset for player's coin tally
00BC09  2  20 5F 8F           jsr DigitsMathRoutine  ;update the coin tally
00BC0C  2  EE 5E 07           inc CoinTally          ;increment onscreen player's coin amount
00BC0F  2  AD 5E 07           lda CoinTally
00BC12  2  C9 64              cmp #100               ;does player have 100 coins yet?
00BC14  2  D0 0C              bne CoinPoints         ;if not, skip all of this
00BC16  2  A9 00              lda #$00
00BC18  2  8D 5E 07           sta CoinTally          ;otherwise, reinitialize coin amount
00BC1B  2  EE 5A 07           inc NumberofLives      ;give the player an extra life
00BC1E  2  A9 40              lda #Sfx_ExtraLife
00BC20  2  85 FE              sta Square2SoundQueue  ;play 1-up sound
00BC22  2               
00BC22  2               CoinPoints:
00BC22  2  A9 02              lda #$02               ;set digit modifier to award
00BC24  2  8D 38 01           sta DigitModifier+4    ;200 points to the player
00BC27  2               
00BC27  2               AddToScore:
00BC27  2  AE 53 07           ldx CurrentPlayer      ;get current player
00BC2A  2  BC FA BB           ldy ScoreOffsets,x     ;get offset for player's score
00BC2D  2  20 5F 8F           jsr DigitsMathRoutine  ;update the score internally with value in digit modifier
00BC30  2               
00BC30  2               GetSBNybbles:
00BC30  2  AC 53 07           ldy CurrentPlayer      ;get current player
00BC33  2  B9 FC BB           lda StatusBarNybbles,y ;get nybbles based on player, use to update score and coins
00BC36  2               
00BC36  2               UpdateNumber:
00BC36  2  20 06 8F             jsr PrintStatusBarNumbers ;print status bar numbers based on nybbles, whatever they be
00BC39  2  AC 00 03             ldy VRAM_Buffer1_Offset
00BC3C  2  B9 FB 02             lda VRAM_Buffer1-6,y      ;check highest digit of score
00BC3F  2  D0 05                bne NoZSup                ;if zero, overwrite with space tile for zero suppression
00BC41  2  A9 24                lda #$24
00BC43  2  99 FB 02             sta VRAM_Buffer1-6,y
00BC46  2  A6 08        NoZSup: ldx ObjectOffset          ;get enemy object buffer offset
00BC48  2  60                   rts
00BC49  2               
00BC49  2               ;-------------------------------------------------------------------------------------
00BC49  2               
00BC49  2               SetupPowerUp:
00BC49  2  A9 2E                   lda #PowerUpObject        ;load power-up identifier into
00BC4B  2  85 1B                   sta Enemy_ID+5            ;special use slot of enemy object buffer
00BC4D  2  B5 76                   lda Block_PageLoc,x       ;store page location of block object
00BC4F  2  85 73                   sta Enemy_PageLoc+5       ;as page location of power-up object
00BC51  2  B5 8F                   lda Block_X_Position,x    ;store horizontal coordinate of block object
00BC53  2  85 8C                   sta Enemy_X_Position+5    ;as horizontal coordinate of power-up object
00BC55  2  A9 01                   lda #$01
00BC57  2  85 BB                   sta Enemy_Y_HighPos+5     ;set vertical high byte of power-up object
00BC59  2  B5 D7                   lda Block_Y_Position,x    ;get vertical coordinate of block object
00BC5B  2  38                      sec
00BC5C  2  E9 08                   sbc #$08                  ;subtract 8 pixels
00BC5E  2  85 D4                   sta Enemy_Y_Position+5    ;and use as vertical coordinate of power-up object
00BC60  2  A9 01        PwrUpJmp:  lda #$01                  ;this is a residual jump point in enemy object jump table
00BC62  2  85 23                   sta Enemy_State+5         ;set power-up object's state
00BC64  2  85 14                   sta Enemy_Flag+5          ;set buffer flag
00BC66  2  A9 03                   lda #$03
00BC68  2  8D 9F 04                sta Enemy_BoundBoxCtrl+5  ;set bounding box size control for power-up object
00BC6B  2  A5 39                   lda PowerUpType
00BC6D  2  C9 02                   cmp #$02                  ;check currently loaded power-up type
00BC6F  2  B0 0A                   bcs PutBehind             ;if star or 1-up, branch ahead
00BC71  2  AD 56 07                lda PlayerStatus          ;otherwise check player's current status
00BC74  2  C9 02                   cmp #$02
00BC76  2  90 01                   bcc StrType               ;if player not fiery, use status as power-up type
00BC78  2  4A                      lsr                       ;otherwise shift right to force fire flower type
00BC79  2  85 39        StrType:   sta PowerUpType           ;store type here
00BC7B  2  A9 20        PutBehind: lda #%00100000
00BC7D  2  8D CA 03                sta Enemy_SprAttrib+5     ;set background priority bit
00BC80  2  A9 02                   lda #Sfx_GrowPowerUp
00BC82  2  85 FE                   sta Square2SoundQueue     ;load power-up reveal sound and leave
00BC84  2  60                      rts
00BC85  2               
00BC85  2               ;-------------------------------------------------------------------------------------
00BC85  2               
00BC85  2               PowerUpObjHandler:
00BC85  2  A2 05                 ldx #$05                   ;set object offset for last slot in enemy object buffer
00BC87  2  86 08                 stx ObjectOffset
00BC89  2  A5 23                 lda Enemy_State+5          ;check power-up object's state
00BC8B  2  F0 5D                 beq ExitPUp                ;if not set, branch to leave
00BC8D  2  0A                    asl                        ;shift to check if d7 was set in object state
00BC8E  2  90 23                 bcc GrowThePowerUp         ;if not set, branch ahead to skip this part
00BC90  2  AD 47 07              lda TimerControl           ;if master timer control set,
00BC93  2  D0 43                 bne RunPUSubs              ;branch ahead to enemy object routines
00BC95  2  A5 39                 lda PowerUpType            ;check power-up type
00BC97  2  F0 11                 beq ShroomM                ;if normal mushroom, branch ahead to move it
00BC99  2  C9 03                 cmp #$03
00BC9B  2  F0 0D                 beq ShroomM                ;if 1-up mushroom, branch ahead to move it
00BC9D  2  C9 02                 cmp #$02
00BC9F  2  D0 37                 bne RunPUSubs              ;if not star, branch elsewhere to skip movement
00BCA1  2  20 F9 CA              jsr MoveJumpingEnemy       ;otherwise impose gravity on star power-up and make it jump
00BCA4  2  20 63 E1              jsr EnemyJump              ;note that green paratroopa shares the same code here
00BCA7  2  4C D8 BC              jmp RunPUSubs              ;then jump to other power-up subroutines
00BCAA  2  20 77 CA     ShroomM: jsr MoveNormalEnemy        ;do sub to make mushrooms move
00BCAD  2  20 C1 DF              jsr EnemyToBGCollisionDet  ;deal with collisions
00BCB0  2  4C D8 BC              jmp RunPUSubs              ;run the other subroutines
00BCB3  2               
00BCB3  2               GrowThePowerUp:
00BCB3  2  A5 09                   lda FrameCounter           ;get frame counter
00BCB5  2  29 03                   and #$03                   ;mask out all but 2 LSB
00BCB7  2  D0 19                   bne ChkPUSte               ;if any bits set here, branch
00BCB9  2  C6 D4                   dec Enemy_Y_Position+5     ;otherwise decrement vertical coordinate slowly
00BCBB  2  A5 23                   lda Enemy_State+5          ;load power-up object state
00BCBD  2  E6 23                   inc Enemy_State+5          ;increment state for next frame (to make power-up rise)
00BCBF  2  C9 11                   cmp #$11                   ;if power-up object state not yet past 16th pixel,
00BCC1  2  90 0F                   bcc ChkPUSte               ;branch ahead to last part here
00BCC3  2  A9 10                   lda #$10
00BCC5  2  95 58                   sta Enemy_X_Speed,x        ;otherwise set horizontal speed
00BCC7  2  A9 80                   lda #%10000000
00BCC9  2  85 23                   sta Enemy_State+5          ;and then set d7 in power-up object's state
00BCCB  2  0A                      asl                        ;shift once to init A
00BCCC  2  8D CA 03                sta Enemy_SprAttrib+5      ;initialize background priority bit set here
00BCCF  2  2A                      rol                        ;rotate A to set right moving direction
00BCD0  2  95 46                   sta Enemy_MovingDir,x      ;set moving direction
00BCD2  2  A5 23        ChkPUSte:  lda Enemy_State+5          ;check power-up object's state
00BCD4  2  C9 06                   cmp #$06                   ;for if power-up has risen enough
00BCD6  2  90 12                   bcc ExitPUp                ;if not, don't even bother running these routines
00BCD8  2  20 52 F1     RunPUSubs: jsr RelativeEnemyPosition  ;get coordinates relative to screen
00BCDB  2  20 AF F1                jsr GetEnemyOffscreenBits  ;get offscreen bits
00BCDE  2  20 43 E2                jsr GetEnemyBoundBox       ;get bounding box coordinates
00BCE1  2  20 D2 E6                jsr DrawPowerUp            ;draw the power-up object
00BCE4  2  20 53 D8                jsr PlayerEnemyCollision   ;check for collision with player
00BCE7  2  20 7A D6                jsr OffscreenBoundsCheck   ;check to see if it went offscreen
00BCEA  2  60           ExitPUp:   rts                        ;and we're done
00BCEB  2               
00BCEB  2               ;-------------------------------------------------------------------------------------
00BCEB  2               ;These apply to all routines in this section unless otherwise noted:
00BCEB  2               ;$00 - used to store metatile from block buffer routine
00BCEB  2               ;$02 - used to store vertical high nybble offset from block buffer routine
00BCEB  2               ;$05 - used to store metatile stored in A at beginning of PlayerHeadCollision
00BCEB  2               ;$06-$07 - used as block buffer address indirect
00BCEB  2               
00BCEB  2               BlockYPosAdderData:
00BCEB  2  04 12              .byte $04, $12
00BCED  2               
00BCED  2               PlayerHeadCollision:
00BCED  2  48                      pha                      ;store metatile number to stack
00BCEE  2  A9 11                   lda #$11                 ;load unbreakable block object state by default
00BCF0  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit here
00BCF3  2  AC 54 07                ldy PlayerSize           ;check player's size
00BCF6  2  D0 02                   bne DBlockSte            ;if small, branch
00BCF8  2  A9 12                   lda #$12                 ;otherwise load breakable block object state
00BCFA  2  95 26        DBlockSte: sta Block_State,x        ;store into block object buffer
00BCFC  2  20 6B 8A                jsr DestroyBlockMetatile ;store blank metatile in vram buffer to write to name table
00BCFF  2  AE EE 03                ldx SprDataOffset_Ctrl   ;load offset control bit
00BD02  2  A5 02                   lda $02                  ;get vertical high nybble offset used in block buffer routine
00BD04  2  9D E4 03                sta Block_Orig_YPos,x    ;set as vertical coordinate for block object
00BD07  2  A8                      tay
00BD08  2  A5 06                   lda $06                  ;get low byte of block buffer address used in same routine
00BD0A  2  9D E6 03                sta Block_BBuf_Low,x     ;save as offset here to be used later
00BD0D  2  B1 06                   lda ($06),y              ;get contents of block buffer at old address at $06, $07
00BD0F  2  20 F6 BD                jsr BlockBumpedChk       ;do a sub to check which block player bumped head on
00BD12  2  85 00                   sta $00                  ;store metatile here
00BD14  2  AC 54 07                ldy PlayerSize           ;check player's size
00BD17  2  D0 01                   bne ChkBrick             ;if small, use metatile itself as contents of A
00BD19  2  98                      tya                      ;otherwise init A (note: big = 0)
00BD1A  2  90 25        ChkBrick:  bcc PutMTileB            ;if no match was found in previous sub, skip ahead
00BD1C  2  A0 11                   ldy #$11                 ;otherwise load unbreakable state into block object buffer
00BD1E  2  94 26                   sty Block_State,x        ;note this applies to both player sizes
00BD20  2  A9 C4                   lda #$c4                 ;load empty block metatile into A for now
00BD22  2  A4 00                   ldy $00                  ;get metatile from before
00BD24  2  C0 58                   cpy #$58                 ;is it brick with coins (with line)?
00BD26  2  F0 04                   beq StartBTmr            ;if so, branch
00BD28  2  C0 5D                   cpy #$5d                 ;is it brick with coins (without line)?
00BD2A  2  D0 15                   bne PutMTileB            ;if not, branch ahead to store empty block metatile
00BD2C  2  AD BC 06     StartBTmr: lda BrickCoinTimerFlag   ;check brick coin timer flag
00BD2F  2  D0 08                   bne ContBTmr             ;if set, timer expired or counting down, thus branch
00BD31  2  A9 0B                   lda #$0b
00BD33  2  8D 9D 07                sta BrickCoinTimer       ;if not set, set brick coin timer
00BD36  2  EE BC 06                inc BrickCoinTimerFlag   ;and set flag linked to it
00BD39  2  AD 9D 07     ContBTmr:  lda BrickCoinTimer       ;check brick coin timer
00BD3C  2  D0 02                   bne PutOldMT             ;if not yet expired, branch to use current metatile
00BD3E  2  A0 C4                   ldy #$c4                 ;otherwise use empty block metatile
00BD40  2  98           PutOldMT:  tya                      ;put metatile into A
00BD41  2  9D E8 03     PutMTileB: sta Block_Metatile,x     ;store whatever metatile be appropriate here
00BD44  2  20 84 BD                jsr InitBlock_XY_Pos     ;get block object horizontal coordinates saved
00BD47  2  A4 02                   ldy $02                  ;get vertical high nybble offset
00BD49  2  A9 23                   lda #$23
00BD4B  2  91 06                   sta ($06),y              ;write blank metatile $23 to block buffer
00BD4D  2  A9 10                   lda #$10
00BD4F  2  8D 84 07                sta BlockBounceTimer     ;set block bounce timer
00BD52  2  68                      pla                      ;pull original metatile from stack
00BD53  2  85 05                   sta $05                  ;and save here
00BD55  2  A0 00                   ldy #$00                 ;set default offset
00BD57  2  AD 14 07                lda CrouchingFlag        ;is player crouching?
00BD5A  2  D0 05                   bne SmallBP              ;if so, branch to increment offset
00BD5C  2  AD 54 07                lda PlayerSize           ;is player big?
00BD5F  2  F0 01                   beq BigBP                ;if so, branch to use default offset
00BD61  2  C8           SmallBP:   iny                      ;increment for small or big and crouching
00BD62  2  A5 CE        BigBP:     lda Player_Y_Position    ;get player's vertical coordinate
00BD64  2  18                      clc
00BD65  2  79 EB BC                adc BlockYPosAdderData,y ;add value determined by size
00BD68  2  29 F0                   and #$f0                 ;mask out low nybble to get 16-pixel correspondence
00BD6A  2  95 D7                   sta Block_Y_Position,x   ;save as vertical coordinate for block object
00BD6C  2  B4 26                   ldy Block_State,x        ;get block object state
00BD6E  2  C0 11                   cpy #$11
00BD70  2  F0 06                   beq Unbreak              ;if set to value loaded for unbreakable, branch
00BD72  2  20 02 BE                jsr BrickShatter         ;execute code for breakable brick
00BD75  2  4C 7B BD                jmp InvOBit              ;skip subroutine to do last part of code here
00BD78  2  20 9B BD     Unbreak:   jsr BumpBlock            ;execute code for unbreakable brick or question block
00BD7B  2  AD EE 03     InvOBit:   lda SprDataOffset_Ctrl   ;invert control bit used by block objects
00BD7E  2  49 01                   eor #$01                 ;and floatey numbers
00BD80  2  8D EE 03                sta SprDataOffset_Ctrl
00BD83  2  60                      rts                      ;leave!
00BD84  2               
00BD84  2               ;--------------------------------
00BD84  2               
00BD84  2               InitBlock_XY_Pos:
00BD84  2  A5 86              lda Player_X_Position   ;get player's horizontal coordinate
00BD86  2  18                 clc
00BD87  2  69 08              adc #$08                ;add eight pixels
00BD89  2  29 F0              and #$f0                ;mask out low nybble to give 16-pixel correspondence
00BD8B  2  95 8F              sta Block_X_Position,x  ;save as horizontal coordinate for block object
00BD8D  2  A5 6D              lda Player_PageLoc
00BD8F  2  69 00              adc #$00                ;add carry to page location of player
00BD91  2  95 76              sta Block_PageLoc,x     ;save as page location of block object
00BD93  2  9D EA 03           sta Block_PageLoc2,x    ;save elsewhere to be used later
00BD96  2  A5 B5              lda Player_Y_HighPos
00BD98  2  95 BE              sta Block_Y_HighPos,x   ;save vertical high byte of player into
00BD9A  2  60                 rts                     ;vertical high byte of block object and leave
00BD9B  2               
00BD9B  2               ;--------------------------------
00BD9B  2               
00BD9B  2               BumpBlock:
00BD9B  2  20 1F BE                jsr CheckTopOfBlock     ;check to see if there's a coin directly above this block
00BD9E  2  A9 02                   lda #Sfx_Bump
00BDA0  2  85 FF                   sta Square1SoundQueue   ;play bump sound
00BDA2  2  A9 00                   lda #$00
00BDA4  2  95 60                   sta Block_X_Speed,x     ;initialize horizontal speed for block object
00BDA6  2  9D 3C 04                sta Block_Y_MoveForce,x ;init fractional movement force
00BDA9  2  85 9F                   sta Player_Y_Speed      ;init player's vertical speed
00BDAB  2  A9 FE                   lda #$fe
00BDAD  2  95 A8                   sta Block_Y_Speed,x     ;set vertical speed for block object
00BDAF  2  A5 05                   lda $05                 ;get original metatile from stack
00BDB1  2  20 F6 BD                jsr BlockBumpedChk      ;do a sub to check which block player bumped head on
00BDB4  2  90 31                   bcc ExitBlockChk        ;if no match was found, branch to leave
00BDB6  2  98                      tya                     ;move block number to A
00BDB7  2  C9 09                   cmp #$09                ;if block number was within 0-8 range,
00BDB9  2  90 02                   bcc BlockCode           ;branch to use current number
00BDBB  2  E9 05                   sbc #$05                ;otherwise subtract 5 for second set to get proper number
00BDBD  2  20 04 8E     BlockCode: jsr JumpEngine          ;run appropriate subroutine depending on block number
00BDC0  2               
00BDC0  2  D2 BD              .word MushFlowerBlock
00BDC2  2  38 BB              .word CoinBlock
00BDC4  2  38 BB              .word CoinBlock
00BDC6  2  D8 BD              .word ExtraLifeMushBlock
00BDC8  2  D2 BD              .word MushFlowerBlock
00BDCA  2  DF BD              .word VineBlock
00BDCC  2  D5 BD              .word StarBlock
00BDCE  2  38 BB              .word CoinBlock
00BDD0  2  D8 BD              .word ExtraLifeMushBlock
00BDD2  2               
00BDD2  2               ;--------------------------------
00BDD2  2               
00BDD2  2               MushFlowerBlock:
00BDD2  2  A9 00              lda #$00       ;load mushroom/fire flower into power-up type
00BDD4  2  2C                 .byte $2c        ;BIT instruction opcode
00BDD5  2               
00BDD5  2               StarBlock:
00BDD5  2  A9 02              lda #$02       ;load star into power-up type
00BDD7  2  2C                 .byte $2c        ;BIT instruction opcode
00BDD8  2               
00BDD8  2               ExtraLifeMushBlock:
00BDD8  2  A9 03              lda #$03         ;load 1-up mushroom into power-up type
00BDDA  2  85 39              sta $39          ;store correct power-up type
00BDDC  2  4C 49 BC           jmp SetupPowerUp
00BDDF  2               
00BDDF  2               VineBlock:
00BDDF  2  A2 05              ldx #$05                ;load last slot for enemy object buffer
00BDE1  2  AC EE 03           ldy SprDataOffset_Ctrl  ;get control bit
00BDE4  2  20 1E B9           jsr Setup_Vine          ;set up vine object
00BDE7  2               
00BDE7  2               ExitBlockChk:
00BDE7  2  60                 rts                     ;leave
00BDE8  2               
00BDE8  2               ;--------------------------------
00BDE8  2               
00BDE8  2               BrickQBlockMetatiles:
00BDE8  2  C1 C0 5F 60        .byte $c1, $c0, $5f, $60 ;used by question blocks
00BDEC  2               
00BDEC  2                     ;these two sets are functionally identical, but look different
00BDEC  2  55 56 57 58        .byte $55, $56, $57, $58, $59 ;used by ground level types
00BDF0  2  59           
00BDF1  2  5A 5B 5C 5D        .byte $5a, $5b, $5c, $5d, $5e ;used by other level types
00BDF5  2  5E           
00BDF6  2               
00BDF6  2               BlockBumpedChk:
00BDF6  2  A0 0D                     ldy #$0d                    ;start at end of metatile data
00BDF8  2  D9 E8 BD     BumpChkLoop: cmp BrickQBlockMetatiles,y  ;check to see if current metatile matches
00BDFB  2  F0 04                     beq MatchBump               ;metatile found in block buffer, branch if so
00BDFD  2  88                        dey                         ;otherwise move onto next metatile
00BDFE  2  10 F8                     bpl BumpChkLoop             ;do this until all metatiles are checked
00BE00  2  18                        clc                         ;if none match, return with carry clear
00BE01  2  60           MatchBump:   rts                         ;note carry is set if found match
00BE02  2               
00BE02  2               ;--------------------------------
00BE02  2               
00BE02  2               BrickShatter:
00BE02  2  20 1F BE           jsr CheckTopOfBlock    ;check to see if there's a coin directly above this block
00BE05  2  A9 01              lda #Sfx_BrickShatter
00BE07  2  9D EC 03           sta Block_RepFlag,x    ;set flag for block object to immediately replace metatile
00BE0A  2  85 FD              sta NoiseSoundQueue    ;load brick shatter sound
00BE0C  2  20 41 BE           jsr SpawnBrickChunks   ;create brick chunk objects
00BE0F  2  A9 FE              lda #$fe
00BE11  2  85 9F              sta Player_Y_Speed     ;set vertical speed for player
00BE13  2  A9 05              lda #$05
00BE15  2  8D 39 01           sta DigitModifier+5    ;set digit modifier to give player 50 points
00BE18  2  20 27 BC           jsr AddToScore         ;do sub to update the score
00BE1B  2  AE EE 03           ldx SprDataOffset_Ctrl ;load control bit and leave
00BE1E  2  60                 rts
00BE1F  2               
00BE1F  2               ;--------------------------------
00BE1F  2               
00BE1F  2               CheckTopOfBlock:
00BE1F  2  AE EE 03            ldx SprDataOffset_Ctrl  ;load control bit
00BE22  2  A4 02               ldy $02                 ;get vertical high nybble offset used in block buffer
00BE24  2  F0 1A               beq TopEx               ;branch to leave if set to zero, because we're at the top
00BE26  2  98                  tya                     ;otherwise set to A
00BE27  2  38                  sec
00BE28  2  E9 10               sbc #$10                ;subtract $10 to move up one row in the block buffer
00BE2A  2  85 02               sta $02                 ;store as new vertical high nybble offset
00BE2C  2  A8                  tay
00BE2D  2  B1 06               lda ($06),y             ;get contents of block buffer in same column, one row up
00BE2F  2  C9 C2               cmp #$c2                ;is it a coin? (not underwater)
00BE31  2  D0 0D               bne TopEx               ;if not, branch to leave
00BE33  2  A9 00               lda #$00
00BE35  2  91 06               sta ($06),y             ;otherwise put blank metatile where coin was
00BE37  2  20 4D 8A            jsr RemoveCoin_Axe      ;write blank metatile to vram buffer
00BE3A  2  AE EE 03            ldx SprDataOffset_Ctrl  ;get control bit
00BE3D  2  20 51 BB            jsr SetupJumpCoin       ;create jumping coin object and update coin variables
00BE40  2  60           TopEx: rts                     ;leave!
00BE41  2               
00BE41  2               ;--------------------------------
00BE41  2               
00BE41  2               SpawnBrickChunks:
00BE41  2  B5 8F              lda Block_X_Position,x     ;set horizontal coordinate of block object
00BE43  2  9D F1 03           sta Block_Orig_XPos,x      ;as original horizontal coordinate here
00BE46  2  A9 F0              lda #$f0
00BE48  2  95 60              sta Block_X_Speed,x        ;set horizontal speed for brick chunk objects
00BE4A  2  95 62              sta Block_X_Speed+2,x
00BE4C  2  A9 FA              lda #$fa
00BE4E  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed for one
00BE50  2  A9 FC              lda #$fc
00BE52  2  95 AA              sta Block_Y_Speed+2,x      ;set lower vertical speed for the other
00BE54  2  A9 00              lda #$00
00BE56  2  9D 3C 04           sta Block_Y_MoveForce,x    ;init fractional movement force for both
00BE59  2  9D 3E 04           sta Block_Y_MoveForce+2,x
00BE5C  2  B5 76              lda Block_PageLoc,x
00BE5E  2  95 78              sta Block_PageLoc+2,x      ;copy page location
00BE60  2  B5 8F              lda Block_X_Position,x
00BE62  2  95 91              sta Block_X_Position+2,x   ;copy horizontal coordinate
00BE64  2  B5 D7              lda Block_Y_Position,x
00BE66  2  18                 clc                        ;add 8 pixels to vertical coordinate
00BE67  2  69 08              adc #$08                   ;and save as vertical coordinate for one of them
00BE69  2  95 D9              sta Block_Y_Position+2,x
00BE6B  2  A9 FA              lda #$fa
00BE6D  2  95 A8              sta Block_Y_Speed,x        ;set vertical speed...again??? (redundant)
00BE6F  2  60                 rts
00BE70  2               
00BE70  2               ;-------------------------------------------------------------------------------------
00BE70  2               
00BE70  2               BlockObjectsCore:
00BE70  2  B5 26                lda Block_State,x           ;get state of block object
00BE72  2  F0 5D                beq UpdSte                  ;if not set, branch to leave
00BE74  2  29 0F                and #$0f                    ;mask out high nybble
00BE76  2  48                   pha                         ;push to stack
00BE77  2  A8                   tay                         ;put in Y for now
00BE78  2  8A                   txa
00BE79  2  18                   clc
00BE7A  2  69 09                adc #$09                    ;add 9 bytes to offset (note two block objects are created
00BE7C  2  AA                   tax                         ;when using brick chunks, but only one offset for both)
00BE7D  2  88                   dey                         ;decrement Y to check for solid block state
00BE7E  2  F0 33                beq BouncingBlockHandler    ;branch if found, otherwise continue for brick chunks
00BE80  2  20 A4 BF             jsr ImposeGravityBlock      ;do sub to impose gravity on one block object object
00BE83  2  20 0F BF             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BE86  2  8A                   txa
00BE87  2  18                   clc                         ;move onto next block object
00BE88  2  69 02                adc #$02
00BE8A  2  AA                   tax
00BE8B  2  20 A4 BF             jsr ImposeGravityBlock      ;do sub to impose gravity on other block object
00BE8E  2  20 0F BF             jsr MoveObjectHorizontally  ;do another sub to move horizontally
00BE91  2  A6 08                ldx ObjectOffset            ;get block object offset used for both
00BE93  2  20 59 F1             jsr RelativeBlockPosition   ;get relative coordinates
00BE96  2  20 B6 F1             jsr GetBlockOffscreenBits   ;get offscreen information
00BE99  2  20 53 EC             jsr DrawBrickChunks         ;draw the brick chunks
00BE9C  2  68                   pla                         ;get lower nybble of saved state
00BE9D  2  B4 BE                ldy Block_Y_HighPos,x       ;check vertical high byte of block object
00BE9F  2  F0 30                beq UpdSte                  ;if above the screen, branch to kill it
00BEA1  2  48                   pha                         ;otherwise save state back into stack
00BEA2  2  A9 F0                lda #$f0
00BEA4  2  D5 D9                cmp Block_Y_Position+2,x    ;check to see if bottom block object went
00BEA6  2  B0 02                bcs ChkTop                  ;to the bottom of the screen, and branch if not
00BEA8  2  95 D9                sta Block_Y_Position+2,x    ;otherwise set offscreen coordinate
00BEAA  2  B5 D7        ChkTop: lda Block_Y_Position,x      ;get top block object's vertical coordinate
00BEAC  2  C9 F0                cmp #$f0                    ;see if it went to the bottom of the screen
00BEAE  2  68                   pla                         ;pull block object state from stack
00BEAF  2  90 20                bcc UpdSte                  ;if not, branch to save state
00BEB1  2  B0 1C                bcs KillBlock               ;otherwise do unconditional branch to kill it
00BEB3  2               
00BEB3  2               BouncingBlockHandler:
00BEB3  2  20 A4 BF                jsr ImposeGravityBlock     ;do sub to impose gravity on block object
00BEB6  2  A6 08                   ldx ObjectOffset           ;get block object offset
00BEB8  2  20 59 F1                jsr RelativeBlockPosition  ;get relative coordinates
00BEBB  2  20 B6 F1                jsr GetBlockOffscreenBits  ;get offscreen information
00BEBE  2  20 D1 EB                jsr DrawBlock              ;draw the block
00BEC1  2  B5 D7                   lda Block_Y_Position,x     ;get vertical coordinate
00BEC3  2  29 0F                   and #$0f                   ;mask out high nybble
00BEC5  2  C9 05                   cmp #$05                   ;check to see if low nybble wrapped around
00BEC7  2  68                      pla                        ;pull state from stack
00BEC8  2  B0 07                   bcs UpdSte                 ;if still above amount, not time to kill block yet, thus branch
00BECA  2  A9 01                   lda #$01
00BECC  2  9D EC 03                sta Block_RepFlag,x        ;otherwise set flag to replace metatile
00BECF  2  A9 00        KillBlock: lda #$00                   ;if branched here, nullify object state
00BED1  2  95 26        UpdSte:    sta Block_State,x          ;store contents of A in block object state
00BED3  2  60                      rts
00BED4  2               
00BED4  2               ;-------------------------------------------------------------------------------------
00BED4  2               ;$02 - used to store offset to block buffer
00BED4  2               ;$06-$07 - used to store block buffer address
00BED4  2               
00BED4  2               BlockObjMT_Updater:
00BED4  2  A2 01                    ldx #$01                  ;set offset to start with second block object
00BED6  2  86 08        UpdateLoop: stx ObjectOffset          ;set offset here
00BED8  2  AD 01 03                 lda VRAM_Buffer1          ;if vram buffer already being used here,
00BEDB  2  D0 21                    bne NextBUpd              ;branch to move onto next block object
00BEDD  2  BD EC 03                 lda Block_RepFlag,x       ;if flag for block object already clear,
00BEE0  2  F0 1C                    beq NextBUpd              ;branch to move onto next block object
00BEE2  2  BD E6 03                 lda Block_BBuf_Low,x      ;get low byte of block buffer
00BEE5  2  85 06                    sta $06                   ;store into block buffer address
00BEE7  2  A9 05                    lda #$05
00BEE9  2  85 07                    sta $07                   ;set high byte of block buffer address
00BEEB  2  BD E4 03                 lda Block_Orig_YPos,x     ;get original vertical coordinate of block object
00BEEE  2  85 02                    sta $02                   ;store here and use as offset to block buffer
00BEF0  2  A8                       tay
00BEF1  2  BD E8 03                 lda Block_Metatile,x      ;get metatile to be written
00BEF4  2  91 06                    sta ($06),y               ;write it to the block buffer
00BEF6  2  20 61 8A                 jsr ReplaceBlockMetatile  ;do sub to replace metatile where block object is
00BEF9  2  A9 00                    lda #$00
00BEFB  2  9D EC 03                 sta Block_RepFlag,x       ;clear block object flag
00BEFE  2  CA           NextBUpd:   dex                       ;decrement block object offset
00BEFF  2  10 D5                    bpl UpdateLoop            ;do this until both block objects are dealt with
00BF01  2  60                       rts                       ;then leave
00BF02  2               
00BF02  2               ;-------------------------------------------------------------------------------------
00BF02  2               ;$00 - used to store high nybble of horizontal speed as adder
00BF02  2               ;$01 - used to store low nybble of horizontal speed
00BF02  2               ;$02 - used to store adder to page location
00BF02  2               
00BF02  2               MoveEnemyHorizontally:
00BF02  2  E8                 inx                         ;increment offset for enemy offset
00BF03  2  20 0F BF           jsr MoveObjectHorizontally  ;position object horizontally according to
00BF06  2  A6 08              ldx ObjectOffset            ;counters, return with saved value in A,
00BF08  2  60                 rts                         ;put enemy offset back in X and leave
00BF09  2               
00BF09  2               MovePlayerHorizontally:
00BF09  2  AD 0E 07           lda JumpspringAnimCtrl  ;if jumpspring currently animating,
00BF0C  2  D0 3E              bne ExXMove             ;branch to leave
00BF0E  2  AA                 tax                     ;otherwise set zero for offset to use player's stuff
00BF0F  2               
00BF0F  2               MoveObjectHorizontally:
00BF0F  2  B5 57                  lda SprObject_X_Speed,x     ;get currently saved value (horizontal
00BF11  2  0A                     asl                         ;speed, secondary counter, whatever)
00BF12  2  0A                     asl                         ;and move low nybble to high
00BF13  2  0A                     asl
00BF14  2  0A                     asl
00BF15  2  85 01                  sta $01                     ;store result here
00BF17  2  B5 57                  lda SprObject_X_Speed,x     ;get saved value again
00BF19  2  4A                     lsr                         ;move high nybble to low
00BF1A  2  4A                     lsr
00BF1B  2  4A                     lsr
00BF1C  2  4A                     lsr
00BF1D  2  C9 08                  cmp #$08                    ;if < 8, branch, do not change
00BF1F  2  90 02                  bcc SaveXSpd
00BF21  2  09 F0                  ora #%11110000              ;otherwise alter high nybble
00BF23  2  85 00        SaveXSpd: sta $00                     ;save result here
00BF25  2  A0 00                  ldy #$00                    ;load default Y value here
00BF27  2  C9 00                  cmp #$00                    ;if result positive, leave Y alone
00BF29  2  10 01                  bpl UseAdder
00BF2B  2  88                     dey                         ;otherwise decrement Y
00BF2C  2  84 02        UseAdder: sty $02                     ;save Y here
00BF2E  2  BD 00 04               lda SprObject_X_MoveForce,x ;get whatever number's here
00BF31  2  18                     clc
00BF32  2  65 01                  adc $01                     ;add low nybble moved to high
00BF34  2  9D 00 04               sta SprObject_X_MoveForce,x ;store result here
00BF37  2  A9 00                  lda #$00                    ;init A
00BF39  2  2A                     rol                         ;rotate carry into d0
00BF3A  2  48                     pha                         ;push onto stack
00BF3B  2  6A                     ror                         ;rotate d0 back onto carry
00BF3C  2  B5 86                  lda SprObject_X_Position,x
00BF3E  2  65 00                  adc $00                     ;add carry plus saved value (high nybble moved to low
00BF40  2  95 86                  sta SprObject_X_Position,x  ;plus $f0 if necessary) to object's horizontal position
00BF42  2  B5 6D                  lda SprObject_PageLoc,x
00BF44  2  65 02                  adc $02                     ;add carry plus other saved value to the
00BF46  2  95 6D                  sta SprObject_PageLoc,x     ;object's page location and save
00BF48  2  68                     pla
00BF49  2  18                     clc                         ;pull old carry from stack and add
00BF4A  2  65 00                  adc $00                     ;to high nybble moved to low
00BF4C  2  60           ExXMove:  rts                         ;and leave
00BF4D  2               
00BF4D  2               ;-------------------------------------------------------------------------------------
00BF4D  2               ;$00 - used for downward force
00BF4D  2               ;$01 - used for upward force
00BF4D  2               ;$02 - used for maximum vertical speed
00BF4D  2               
00BF4D  2               MovePlayerVertically:
00BF4D  2  A2 00                 ldx #$00                ;set X for player offset
00BF4F  2  AD 47 07              lda TimerControl
00BF52  2  D0 05                 bne NoJSChk             ;if master timer control set, branch ahead
00BF54  2  AD 0E 07              lda JumpspringAnimCtrl  ;otherwise check to see if jumpspring is animating
00BF57  2  D0 F3                 bne ExXMove             ;branch to leave if so
00BF59  2  AD 09 07     NoJSChk: lda VerticalForce       ;dump vertical force
00BF5C  2  85 00                 sta $00
00BF5E  2  A9 04                 lda #$04                ;set maximum vertical speed here
00BF60  2  4C AD BF              jmp ImposeGravitySprObj ;then jump to move player vertically
00BF63  2               
00BF63  2               ;--------------------------------
00BF63  2               
00BF63  2               MoveD_EnemyVertically:
00BF63  2  A0 3D              ldy #$3d           ;set quick movement amount downwards
00BF65  2  B5 1E              lda Enemy_State,x  ;then check enemy state
00BF67  2  C9 05              cmp #$05           ;if not set to unique state for spiny's egg, go ahead
00BF69  2  D0 02              bne ContVMove      ;and use, otherwise set different movement amount, continue on
00BF6B  2               
00BF6B  2               MoveFallingPlatform:
00BF6B  2  A0 20                   ldy #$20       ;set movement amount
00BF6D  2  4C 94 BF     ContVMove: jmp SetHiMax   ;jump to skip the rest of this
00BF70  2               
00BF70  2               ;--------------------------------
00BF70  2               
00BF70  2               MoveRedPTroopaDown:
00BF70  2  A0 00              ldy #$00            ;set Y to move downwards
00BF72  2  4C 77 BF           jmp MoveRedPTroopa  ;skip to movement routine
00BF75  2               
00BF75  2               MoveRedPTroopaUp:
00BF75  2  A0 01              ldy #$01            ;set Y to move upwards
00BF77  2               
00BF77  2               MoveRedPTroopa:
00BF77  2  E8                 inx                 ;increment X for enemy offset
00BF78  2  A9 03              lda #$03
00BF7A  2  85 00              sta $00             ;set downward movement amount here
00BF7C  2  A9 06              lda #$06
00BF7E  2  85 01              sta $01             ;set upward movement amount here
00BF80  2  A9 02              lda #$02
00BF82  2  85 02              sta $02             ;set maximum speed here
00BF84  2  98                 tya                 ;set movement direction in A, and
00BF85  2  4C D1 BF           jmp RedPTroopaGrav  ;jump to move this thing
00BF88  2               
00BF88  2               ;--------------------------------
00BF88  2               
00BF88  2               MoveDropPlatform:
00BF88  2  A0 7F              ldy #$7f      ;set movement amount for drop platform
00BF8A  2  D0 02              bne SetMdMax  ;skip ahead of other value set here
00BF8C  2               
00BF8C  2               MoveEnemySlowVert:
00BF8C  2  A0 0F                  ldy #$0f         ;set movement amount for bowser/other objects
00BF8E  2  A9 02        SetMdMax: lda #$02         ;set maximum speed in A
00BF90  2  D0 04                  bne SetXMoveAmt  ;unconditional branch
00BF92  2               
00BF92  2               ;--------------------------------
00BF92  2               
00BF92  2               MoveJ_EnemyVertically:
00BF92  2  A0 1C                     ldy #$1c                ;set movement amount for podoboo/other objects
00BF94  2  A9 03        SetHiMax:    lda #$03                ;set maximum speed in A
00BF96  2  84 00        SetXMoveAmt: sty $00                 ;set movement amount here
00BF98  2  E8                        inx                     ;increment X for enemy offset
00BF99  2  20 AD BF                  jsr ImposeGravitySprObj ;do a sub to move enemy object downwards
00BF9C  2  A6 08                     ldx ObjectOffset        ;get enemy object buffer offset and leave
00BF9E  2  60                        rts
00BF9F  2               
00BF9F  2               ;--------------------------------
00BF9F  2               
00BF9F  2               MaxSpdBlockData:
00BF9F  2  06 08              .byte $06, $08
00BFA1  2               
00BFA1  2               ResidualGravityCode:
00BFA1  2  A0 00              ldy #$00       ;this part appears to be residual,
00BFA3  2  2C                 .byte $2c        ;no code branches or jumps to it...
00BFA4  2               
00BFA4  2               ImposeGravityBlock:
00BFA4  2  A0 01              ldy #$01       ;set offset for maximum speed
00BFA6  2  A9 50              lda #$50       ;set movement amount here
00BFA8  2  85 00              sta $00
00BFAA  2  B9 9F BF           lda MaxSpdBlockData,y    ;get maximum speed
00BFAD  2               
00BFAD  2               ImposeGravitySprObj:
00BFAD  2  85 02              sta $02            ;set maximum speed here
00BFAF  2  A9 00              lda #$00           ;set value to move downwards
00BFB1  2  4C D7 BF           jmp ImposeGravity  ;jump to the code that actually moves it
00BFB4  2               
00BFB4  2               ;--------------------------------
00BFB4  2               
00BFB4  2               MovePlatformDown:
00BFB4  2  A9 00              lda #$00    ;save value to stack (if branching here, execute next
00BFB6  2  2C                 .byte $2c     ;part as BIT instruction)
00BFB7  2               
00BFB7  2               MovePlatformUp:
00BFB7  2  A9 01                   lda #$01        ;save value to stack
00BFB9  2  48                      pha
00BFBA  2  B4 16                   ldy Enemy_ID,x  ;get enemy object identifier
00BFBC  2  E8                      inx             ;increment offset for enemy object
00BFBD  2  A9 05                   lda #$05        ;load default value here
00BFBF  2  C0 29                   cpy #$29        ;residual comparison, object #29 never executes
00BFC1  2  D0 02                   bne SetDplSpd   ;this code, thus unconditional branch here
00BFC3  2  A9 09                   lda #$09        ;residual code
00BFC5  2  85 00        SetDplSpd: sta $00         ;save downward movement amount here
00BFC7  2  A9 0A                   lda #$0a        ;save upward movement amount here
00BFC9  2  85 01                   sta $01
00BFCB  2  A9 03                   lda #$03        ;save maximum vertical speed here
00BFCD  2  85 02                   sta $02
00BFCF  2  68                      pla             ;get value from stack
00BFD0  2  A8                      tay             ;use as Y, then move onto code shared by red koopa
00BFD1  2               
00BFD1  2               RedPTroopaGrav:
00BFD1  2  20 D7 BF           jsr ImposeGravity  ;do a sub to move object gradually
00BFD4  2  A6 08              ldx ObjectOffset   ;get enemy object offset and leave
00BFD6  2  60                 rts
00BFD7  2               
00BFD7  2               ;-------------------------------------------------------------------------------------
00BFD7  2               ;$00 - used for downward force
00BFD7  2               ;$01 - used for upward force
00BFD7  2               ;$07 - used as adder for vertical position
00BFD7  2               
00BFD7  2               ImposeGravity:
00BFD7  2  48                    pha                          ;push value to stack
00BFD8  2  BD 16 04              lda SprObject_YMF_Dummy,x
00BFDB  2  18                    clc                          ;add value in movement force to contents of dummy variable
00BFDC  2  7D 33 04              adc SprObject_Y_MoveForce,x
00BFDF  2  9D 16 04              sta SprObject_YMF_Dummy,x
00BFE2  2  A0 00                 ldy #$00                     ;set Y to zero by default
00BFE4  2  B5 9F                 lda SprObject_Y_Speed,x      ;get current vertical speed
00BFE6  2  10 01                 bpl AlterYP                  ;if currently moving downwards, do not decrement Y
00BFE8  2  88                    dey                          ;otherwise decrement Y
00BFE9  2  84 07        AlterYP: sty $07                      ;store Y here
00BFEB  2  75 CE                 adc SprObject_Y_Position,x   ;add vertical position to vertical speed plus carry
00BFED  2  95 CE                 sta SprObject_Y_Position,x   ;store as new vertical position
00BFEF  2  B5 B5                 lda SprObject_Y_HighPos,x
00BFF1  2  65 07                 adc $07                      ;add carry plus contents of $07 to vertical high byte
00BFF3  2  95 B5                 sta SprObject_Y_HighPos,x    ;store as new vertical high byte
00BFF5  2  BD 33 04              lda SprObject_Y_MoveForce,x
00BFF8  2  18                    clc
00BFF9  2  65 00                 adc $00                      ;add downward movement amount to contents of $0433
00BFFB  2  9D 33 04              sta SprObject_Y_MoveForce,x
00BFFE  2  B5 9F                 lda SprObject_Y_Speed,x      ;add carry to vertical speed and store
00C000  2  69 00                 adc #$00
00C002  2  95 9F                 sta SprObject_Y_Speed,x
00C004  2  C5 02                 cmp $02                      ;compare to maximum speed
00C006  2  30 10                 bmi ChkUpM                   ;if less than preset value, skip this part
00C008  2  BD 33 04              lda SprObject_Y_MoveForce,x
00C00B  2  C9 80                 cmp #$80                     ;if less positively than preset maximum, skip this part
00C00D  2  90 09                 bcc ChkUpM
00C00F  2  A5 02                 lda $02
00C011  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00C013  2  A9 00                 lda #$00
00C015  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00C018  2  68           ChkUpM:  pla                          ;get value from stack
00C019  2  F0 2B                 beq ExVMove                  ;if set to zero, branch to leave
00C01B  2  A5 02                 lda $02
00C01D  2  49 FF                 eor #%11111111               ;otherwise get two's compliment of maximum speed
00C01F  2  A8                    tay
00C020  2  C8                    iny
00C021  2  84 07                 sty $07                      ;store two's compliment here
00C023  2  BD 33 04              lda SprObject_Y_MoveForce,x
00C026  2  38                    sec                          ;subtract upward movement amount from contents
00C027  2  E5 01                 sbc $01                      ;of movement force, note that $01 is twice as large as $00,
00C029  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;thus it effectively undoes add we did earlier
00C02C  2  B5 9F                 lda SprObject_Y_Speed,x
00C02E  2  E9 00                 sbc #$00                     ;subtract borrow from vertical speed and store
00C030  2  95 9F                 sta SprObject_Y_Speed,x
00C032  2  C5 07                 cmp $07                      ;compare vertical speed to two's compliment
00C034  2  10 10                 bpl ExVMove                  ;if less negatively than preset maximum, skip this part
00C036  2  BD 33 04              lda SprObject_Y_MoveForce,x
00C039  2  C9 80                 cmp #$80                     ;check if fractional part is above certain amount,
00C03B  2  B0 09                 bcs ExVMove                  ;and if so, branch to leave
00C03D  2  A5 07                 lda $07
00C03F  2  95 9F                 sta SprObject_Y_Speed,x      ;keep vertical speed within maximum value
00C041  2  A9 FF                 lda #$ff
00C043  2  9D 33 04              sta SprObject_Y_MoveForce,x  ;clear fractional
00C046  2  60           ExVMove: rts                          ;leave!
00C047  2               
00C047  2               ;-------------------------------------------------------------------------------------
00C047  2               
00C047  2               EnemiesAndLoopsCore:
00C047  2  B5 0F                    lda Enemy_Flag,x         ;check data here for MSB set
00C049  2  48                       pha                      ;save in stack
00C04A  2  0A                       asl
00C04B  2  B0 12                    bcs ChkBowserF           ;if MSB set in enemy flag, branch ahead of jumps
00C04D  2  68                       pla                      ;get from stack
00C04E  2  F0 03                    beq ChkAreaTsk           ;if data zero, branch
00C050  2  4C 82 C8                 jmp RunEnemyObjectsCore  ;otherwise, jump to run enemy subroutines
00C053  2  AD 1F 07     ChkAreaTsk: lda AreaParserTaskNum    ;check number of tasks to perform
00C056  2  29 07                    and #$07
00C058  2  C9 07                    cmp #$07                 ;if at a specific task, jump and leave
00C05A  2  F0 0E                    beq ExitELCore
00C05C  2  4C CC C0                 jmp ProcLoopCommand      ;otherwise, jump to process loop command/load enemies
00C05F  2  68           ChkBowserF: pla                      ;get data from stack
00C060  2  29 0F                    and #%00001111           ;mask out high nybble
00C062  2  A8                       tay
00C063  2  B9 0F 00                 lda Enemy_Flag,y         ;use as pointer and load same place with different offset
00C066  2  D0 02                    bne ExitELCore
00C068  2  95 0F                    sta Enemy_Flag,x         ;if second enemy flag not set, also clear first one
00C06A  2  60           ExitELCore: rts
00C06B  2               
00C06B  2               ;--------------------------------
00C06B  2               
00C06B  2               ;loop command data
00C06B  2               LoopCmdWorldNumber:
00C06B  2  03 03 06 06        .byte $03, $03, $06, $06, $06, $06, $06, $06, $07, $07, $07
00C06F  2  06 06 06 06  
00C073  2  07 07 07     
00C076  2               
00C076  2               LoopCmdPageNumber:
00C076  2  05 09 04 05        .byte $05, $09, $04, $05, $06, $08, $09, $0a, $06, $0b, $10
00C07A  2  06 08 09 0A  
00C07E  2  06 0B 10     
00C081  2               
00C081  2               LoopCmdYPosition:
00C081  2  40 B0 B0 80        .byte $40, $b0, $b0, $80, $40, $40, $80, $40, $f0, $f0, $f0
00C085  2  40 40 80 40  
00C089  2  F0 F0 F0     
00C08C  2               
00C08C  2               ExecGameLoopback:
00C08C  2  A5 6D              lda Player_PageLoc        ;send player back four pages
00C08E  2  38                 sec
00C08F  2  E9 04              sbc #$04
00C091  2  85 6D              sta Player_PageLoc
00C093  2  AD 25 07           lda CurrentPageLoc        ;send current page back four pages
00C096  2  38                 sec
00C097  2  E9 04              sbc #$04
00C099  2  8D 25 07           sta CurrentPageLoc
00C09C  2  AD 1A 07           lda ScreenLeft_PageLoc    ;subtract four from page location
00C09F  2  38                 sec                       ;of screen's left border
00C0A0  2  E9 04              sbc #$04
00C0A2  2  8D 1A 07           sta ScreenLeft_PageLoc
00C0A5  2  AD 1B 07           lda ScreenRight_PageLoc   ;do the same for the page location
00C0A8  2  38                 sec                       ;of screen's right border
00C0A9  2  E9 04              sbc #$04
00C0AB  2  8D 1B 07           sta ScreenRight_PageLoc
00C0AE  2  AD 2A 07           lda AreaObjectPageLoc     ;subtract four from page control
00C0B1  2  38                 sec                       ;for area objects
00C0B2  2  E9 04              sbc #$04
00C0B4  2  8D 2A 07           sta AreaObjectPageLoc
00C0B7  2  A9 00              lda #$00                  ;initialize page select for both
00C0B9  2  8D 3B 07           sta EnemyObjectPageSel    ;area and enemy objects
00C0BC  2  8D 2B 07           sta AreaObjectPageSel
00C0BF  2  8D 39 07           sta EnemyDataOffset       ;initialize enemy object data offset
00C0C2  2  8D 3A 07           sta EnemyObjectPageLoc    ;and enemy object page control
00C0C5  2  B9 F8 9B           lda AreaDataOfsLoopback,y ;adjust area object offset based on
00C0C8  2  8D 2C 07           sta AreaDataOffset        ;which loop command we encountered
00C0CB  2  60                 rts
00C0CC  2               
00C0CC  2               ProcLoopCommand:
00C0CC  2  AD 45 07               lda LoopCommand           ;check if loop command was found
00C0CF  2  F0 5E                  beq ChkEnemyFrenzy
00C0D1  2  AD 26 07               lda CurrentColumnPos      ;check to see if we're still on the first page
00C0D4  2  D0 59                  bne ChkEnemyFrenzy        ;if not, do not loop yet
00C0D6  2  A0 0B                  ldy #$0b                  ;start at the end of each set of loop data
00C0D8  2  88           FindLoop: dey
00C0D9  2  30 54                  bmi ChkEnemyFrenzy        ;if all data is checked and not match, do not loop
00C0DB  2  AD 5F 07               lda WorldNumber           ;check to see if one of the world numbers
00C0DE  2  D9 6B C0               cmp LoopCmdWorldNumber,y  ;matches our current world number
00C0E1  2  D0 F5                  bne FindLoop
00C0E3  2  AD 25 07               lda CurrentPageLoc        ;check to see if one of the page numbers
00C0E6  2  D9 76 C0               cmp LoopCmdPageNumber,y   ;matches the page we're currently on
00C0E9  2  D0 ED                  bne FindLoop
00C0EB  2  A5 CE                  lda Player_Y_Position     ;check to see if the player is at the correct position
00C0ED  2  D9 81 C0               cmp LoopCmdYPosition,y    ;if not, branch to check for world 7
00C0F0  2  D0 23                  bne WrongChk
00C0F2  2  A5 1D                  lda Player_State          ;check to see if the player is
00C0F4  2  C9 00                  cmp #$00                  ;on solid ground (i.e. not jumping or falling)
00C0F6  2  D0 1D                  bne WrongChk              ;if not, player fails to pass loop, and loopback
00C0F8  2  AD 5F 07               lda WorldNumber           ;are we in world 7? (check performed on correct
00C0FB  2  C9 06                  cmp #World7               ;vertical position and on solid ground)
00C0FD  2  D0 23                  bne InitMLp               ;if not, initialize flags used there, otherwise
00C0FF  2  EE D9 06               inc MultiLoopCorrectCntr  ;increment counter for correct progression
00C102  2  EE DA 06     IncMLoop: inc MultiLoopPassCntr     ;increment master multi-part counter
00C105  2  AD DA 06               lda MultiLoopPassCntr     ;have we done all three parts?
00C108  2  C9 03                  cmp #$03
00C10A  2  D0 1E                  bne InitLCmd              ;if not, skip this part
00C10C  2  AD D9 06               lda MultiLoopCorrectCntr  ;if so, have we done them all correctly?
00C10F  2  C9 03                  cmp #$03
00C111  2  F0 0F                  beq InitMLp               ;if so, branch past unnecessary check here
00C113  2  D0 07                  bne DoLpBack              ;unconditional branch if previous branch fails
00C115  2  AD 5F 07     WrongChk: lda WorldNumber           ;are we in world 7? (check performed on
00C118  2  C9 06                  cmp #World7               ;incorrect vertical position or not on solid ground)
00C11A  2  F0 E6                  beq IncMLoop
00C11C  2  20 8C C0     DoLpBack: jsr ExecGameLoopback      ;if player is not in right place, loop back
00C11F  2  20 71 D0               jsr KillAllEnemies
00C122  2  A9 00        InitMLp:  lda #$00                  ;initialize counters used for multi-part loop commands
00C124  2  8D DA 06               sta MultiLoopPassCntr
00C127  2  8D D9 06               sta MultiLoopCorrectCntr
00C12A  2  A9 00        InitLCmd: lda #$00                  ;initialize loop command flag
00C12C  2  8D 45 07               sta LoopCommand
00C12F  2               
00C12F  2               ;--------------------------------
00C12F  2               
00C12F  2               ChkEnemyFrenzy:
00C12F  2  AD CD 06           lda EnemyFrenzyQueue  ;check for enemy object in frenzy queue
00C132  2  F0 10              beq ProcessEnemyData  ;if not, skip this part
00C134  2  95 16              sta Enemy_ID,x        ;store as enemy object identifier here
00C136  2  A9 01              lda #$01
00C138  2  95 0F              sta Enemy_Flag,x      ;activate enemy object flag
00C13A  2  A9 00              lda #$00
00C13C  2  95 1E              sta Enemy_State,x     ;initialize state and frenzy queue
00C13E  2  8D CD 06           sta EnemyFrenzyQueue
00C141  2  4C 26 C2           jmp InitEnemyObject   ;and then jump to deal with this enemy
00C144  2               
00C144  2               ;--------------------------------
00C144  2               ;$06 - used to hold page location of extended right boundary
00C144  2               ;$07 - used to hold high nybble of position of extended right boundary
00C144  2               
00C144  2               ProcessEnemyData:
00C144  2  AC 39 07             ldy EnemyDataOffset      ;get offset of enemy object data
00C147  2  B1 E9                lda (EnemyData),y        ;load first byte
00C149  2  C9 FF                cmp #$ff                 ;check for EOD terminator
00C14B  2  D0 03                bne CheckEndofBuffer
00C14D  2  4C 16 C2             jmp CheckFrenzyBuffer    ;if found, jump to check frenzy buffer, otherwise
00C150  2               
00C150  2               CheckEndofBuffer:
00C150  2  29 0F                and #%00001111           ;check for special row $0e
00C152  2  C9 0E                cmp #$0e
00C154  2  F0 0E                beq CheckRightBounds     ;if found, branch, otherwise
00C156  2  E0 05                cpx #$05                 ;check for end of buffer
00C158  2  90 0A                bcc CheckRightBounds     ;if not at end of buffer, branch
00C15A  2  C8                   iny
00C15B  2  B1 E9                lda (EnemyData),y        ;check for specific value here
00C15D  2  29 3F                and #%00111111           ;not sure what this was intended for, exactly
00C15F  2  C9 2E                cmp #$2e                 ;this part is quite possibly residual code
00C161  2  F0 01                beq CheckRightBounds     ;but it has the effect of keeping enemies out of
00C163  2  60                   rts                      ;the sixth slot
00C164  2               
00C164  2               CheckRightBounds:
00C164  2  AD 1D 07             lda ScreenRight_X_Pos    ;add 48 to pixel coordinate of right boundary
00C167  2  18                   clc
00C168  2  69 30                adc #$30
00C16A  2  29 F0                and #%11110000           ;store high nybble
00C16C  2  85 07                sta $07
00C16E  2  AD 1B 07             lda ScreenRight_PageLoc  ;add carry to page location of right boundary
00C171  2  69 00                adc #$00
00C173  2  85 06                sta $06                  ;store page location + carry
00C175  2  AC 39 07             ldy EnemyDataOffset
00C178  2  C8                   iny
00C179  2  B1 E9                lda (EnemyData),y        ;if MSB of enemy object is clear, branch to check for row $0f
00C17B  2  0A                   asl
00C17C  2  90 0B                bcc CheckPageCtrlRow
00C17E  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select already set, do not set again
00C181  2  D0 06                bne CheckPageCtrlRow
00C183  2  EE 3B 07             inc EnemyObjectPageSel   ;otherwise, if MSB is set, set page select
00C186  2  EE 3A 07             inc EnemyObjectPageLoc   ;and increment page control
00C189  2               
00C189  2               CheckPageCtrlRow:
00C189  2  88                   dey
00C18A  2  B1 E9                lda (EnemyData),y        ;reread first byte
00C18C  2  29 0F                and #$0f
00C18E  2  C9 0F                cmp #$0f                 ;check for special row $0f
00C190  2  D0 19                bne PositionEnemyObj     ;if not found, branch to position enemy object
00C192  2  AD 3B 07             lda EnemyObjectPageSel   ;if page select set,
00C195  2  D0 14                bne PositionEnemyObj     ;branch without reading second byte
00C197  2  C8                   iny
00C198  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte, mask out 2 MSB
00C19A  2  29 3F                and #%00111111
00C19C  2  8D 3A 07             sta EnemyObjectPageLoc   ;store as page control for enemy object data
00C19F  2  EE 39 07             inc EnemyDataOffset      ;increment enemy object data offset 2 bytes
00C1A2  2  EE 39 07             inc EnemyDataOffset
00C1A5  2  EE 3B 07             inc EnemyObjectPageSel   ;set page select for enemy object data and
00C1A8  2  4C CC C0             jmp ProcLoopCommand      ;jump back to process loop commands again
00C1AB  2               
00C1AB  2               PositionEnemyObj:
00C1AB  2  AD 3A 07             lda EnemyObjectPageLoc   ;store page control as page location
00C1AE  2  95 6E                sta Enemy_PageLoc,x      ;for enemy object
00C1B0  2  B1 E9                lda (EnemyData),y        ;get first byte of enemy object
00C1B2  2  29 F0                and #%11110000
00C1B4  2  95 87                sta Enemy_X_Position,x   ;store column position
00C1B6  2  CD 1D 07             cmp ScreenRight_X_Pos    ;check column position against right boundary
00C1B9  2  B5 6E                lda Enemy_PageLoc,x      ;without subtracting, then subtract borrow
00C1BB  2  ED 1B 07             sbc ScreenRight_PageLoc  ;from page location
00C1BE  2  B0 0B                bcs CheckRightExtBounds  ;if enemy object beyond or at boundary, branch
00C1C0  2  B1 E9                lda (EnemyData),y
00C1C2  2  29 0F                and #%00001111           ;check for special row $0e
00C1C4  2  C9 0E                cmp #$0e                 ;if found, jump elsewhere
00C1C6  2  F0 69                beq ParseRow0e
00C1C8  2  4C 50 C2             jmp CheckThreeBytes      ;if not found, unconditional jump
00C1CB  2               
00C1CB  2               CheckRightExtBounds:
00C1CB  2  A5 07                lda $07                  ;check right boundary + 48 against
00C1CD  2  D5 87                cmp Enemy_X_Position,x   ;column position without subtracting,
00C1CF  2  A5 06                lda $06                  ;then subtract borrow from page control temp
00C1D1  2  F5 6E                sbc Enemy_PageLoc,x      ;plus carry
00C1D3  2  90 41                bcc CheckFrenzyBuffer    ;if enemy object beyond extended boundary, branch
00C1D5  2  A9 01                lda #$01                 ;store value in vertical high byte
00C1D7  2  95 B6                sta Enemy_Y_HighPos,x
00C1D9  2  B1 E9                lda (EnemyData),y        ;get first byte again
00C1DB  2  0A                   asl                      ;multiply by four to get the vertical
00C1DC  2  0A                   asl                      ;coordinate
00C1DD  2  0A                   asl
00C1DE  2  0A                   asl
00C1DF  2  95 CF                sta Enemy_Y_Position,x
00C1E1  2  C9 E0                cmp #$e0                 ;do one last check for special row $0e
00C1E3  2  F0 4C                beq ParseRow0e           ;(necessary if branched to $c1cb)
00C1E5  2  C8                   iny
00C1E6  2  B1 E9                lda (EnemyData),y        ;get second byte of object
00C1E8  2  29 40                and #%01000000           ;check to see if hard mode bit is set
00C1EA  2  F0 05                beq CheckForEnemyGroup   ;if not, branch to check for group enemy objects
00C1EC  2  AD CC 06             lda SecondaryHardMode    ;if set, check to see if secondary hard mode flag
00C1EF  2  F0 6D                beq Inc2B                ;is on, and if not, branch to skip this object completely
00C1F1  2               
00C1F1  2               CheckForEnemyGroup:
00C1F1  2  B1 E9                lda (EnemyData),y      ;get second byte and mask out 2 MSB
00C1F3  2  29 3F                and #%00111111
00C1F5  2  C9 37                cmp #$37               ;check for value below $37
00C1F7  2  90 04                bcc BuzzyBeetleMutate
00C1F9  2  C9 3F                cmp #$3f               ;if $37 or greater, check for value
00C1FB  2  90 31                bcc DoGroup            ;below $3f, branch if below $3f
00C1FD  2               
00C1FD  2               BuzzyBeetleMutate:
00C1FD  2  C9 06                cmp #Goomba          ;if below $37, check for goomba
00C1FF  2  D0 07                bne StrID            ;value ($3f or more always fails)
00C201  2  AC 6A 07             ldy PrimaryHardMode  ;check if primary hard mode flag is set
00C204  2  F0 02                beq StrID            ;and if so, change goomba to buzzy beetle
00C206  2  A9 02                lda #BuzzyBeetle
00C208  2  95 16        StrID:  sta Enemy_ID,x       ;store enemy object number into buffer
00C20A  2  A9 01                lda #$01
00C20C  2  95 0F                sta Enemy_Flag,x     ;set flag for enemy in buffer
00C20E  2  20 26 C2             jsr InitEnemyObject
00C211  2  B5 0F                lda Enemy_Flag,x     ;check to see if flag is set
00C213  2  D0 49                bne Inc2B            ;if not, leave, otherwise branch
00C215  2  60                   rts
00C216  2               
00C216  2               CheckFrenzyBuffer:
00C216  2  AD CB 06             lda EnemyFrenzyBuffer    ;if enemy object stored in frenzy buffer
00C219  2  D0 09                bne StrFre               ;then branch ahead to store in enemy object buffer
00C21B  2  AD 98 03             lda VineFlagOffset       ;otherwise check vine flag offset
00C21E  2  C9 01                cmp #$01
00C220  2  D0 0B                bne ExEPar               ;if other value <> 1, leave
00C222  2  A9 2F                lda #VineObject          ;otherwise put vine in enemy identifier
00C224  2  95 16        StrFre: sta Enemy_ID,x           ;store contents of frenzy buffer into enemy identifier value
00C226  2               
00C226  2               InitEnemyObject:
00C226  2  A9 00                lda #$00                 ;initialize enemy state
00C228  2  95 1E                sta Enemy_State,x
00C22A  2  20 6C C2             jsr CheckpointEnemyID    ;jump ahead to run jump engine and subroutines
00C22D  2  60           ExEPar: rts                      ;then leave
00C22E  2               
00C22E  2               DoGroup:
00C22E  2  4C 1B C7             jmp HandleGroupEnemies   ;handle enemy group objects
00C231  2               
00C231  2               ParseRow0e:
00C231  2  C8                   iny                      ;increment Y to load third byte of object
00C232  2  C8                   iny
00C233  2  B1 E9                lda (EnemyData),y
00C235  2  4A                   lsr                      ;move 3 MSB to the bottom, effectively
00C236  2  4A                   lsr                      ;making %xxx00000 into %00000xxx
00C237  2  4A                   lsr
00C238  2  4A                   lsr
00C239  2  4A                   lsr
00C23A  2  CD 5F 07             cmp WorldNumber          ;is it the same world number as we're on?
00C23D  2  D0 0E                bne NotUse               ;if not, do not use (this allows multiple uses
00C23F  2  88                   dey                      ;of the same area, like the underground bonus areas)
00C240  2  B1 E9                lda (EnemyData),y        ;otherwise, get second byte and use as offset
00C242  2  8D 50 07             sta AreaPointer          ;to addresses for level and enemy object data
00C245  2  C8                   iny
00C246  2  B1 E9                lda (EnemyData),y        ;get third byte again, and this time mask out
00C248  2  29 1F                and #%00011111           ;the 3 MSB from before, save as page number to be
00C24A  2  8D 51 07             sta EntrancePage         ;used upon entry to area, if area is entered
00C24D  2  4C 5B C2     NotUse: jmp Inc3B
00C250  2               
00C250  2               CheckThreeBytes:
00C250  2  AC 39 07             ldy EnemyDataOffset      ;load current offset for enemy object data
00C253  2  B1 E9                lda (EnemyData),y        ;get first byte
00C255  2  29 0F                and #%00001111           ;check for special row $0e
00C257  2  C9 0E                cmp #$0e
00C259  2  D0 03                bne Inc2B
00C25B  2  EE 39 07     Inc3B:  inc EnemyDataOffset      ;if row = $0e, increment three bytes
00C25E  2  EE 39 07     Inc2B:  inc EnemyDataOffset      ;otherwise increment two bytes
00C261  2  EE 39 07             inc EnemyDataOffset
00C264  2  A9 00                lda #$00                 ;init page select for enemy objects
00C266  2  8D 3B 07             sta EnemyObjectPageSel
00C269  2  A6 08                ldx ObjectOffset         ;reload current offset in enemy buffers
00C26B  2  60                   rts                      ;and leave
00C26C  2               
00C26C  2               CheckpointEnemyID:
00C26C  2  B5 16                lda Enemy_ID,x
00C26E  2  C9 15                cmp #$15                     ;check enemy object identifier for $15 or greater
00C270  2  B0 0D                bcs InitEnemyRoutines        ;and branch straight to the jump engine if found
00C272  2  A8                   tay                          ;save identifier in Y register for now
00C273  2  B5 CF                lda Enemy_Y_Position,x
00C275  2  69 08                adc #$08                     ;add eight pixels to what will eventually be the
00C277  2  95 CF                sta Enemy_Y_Position,x       ;enemy object's vertical coordinate ($00-$14 only)
00C279  2  A9 01                lda #$01
00C27B  2  9D D8 03             sta EnemyOffscrBitsMasked,x  ;set offscreen masked bit
00C27E  2  98                   tya                          ;get identifier back and use as offset for jump engine
00C27F  2               
00C27F  2               InitEnemyRoutines:
00C27F  2  20 04 8E             jsr JumpEngine
00C282  2               
00C282  2               ;jump engine table for newly loaded enemy objects
00C282  2               
00C282  2  0E C3              .word InitNormalEnemy  ;for objects $00-$0f
00C284  2  0E C3              .word InitNormalEnemy
00C286  2  0E C3              .word InitNormalEnemy
00C288  2  1E C3              .word InitRedKoopa
00C28A  2  F0 C2              .word NoInitCode
00C28C  2  28 C3              .word InitHammerBro
00C28E  2  F1 C2              .word InitGoomba
00C290  2  42 C3              .word InitBloober
00C292  2  6B C3              .word InitBulletBill
00C294  2  F0 C2              .word NoInitCode
00C296  2  75 C3              .word InitCheepCheep
00C298  2  75 C3              .word InitCheepCheep
00C29A  2  F7 C2              .word InitPodoboo
00C29C  2  87 C7              .word InitPiranhaPlant
00C29E  2  D1 C7              .word InitJumpGPTroopa
00C2A0  2  4A C3              .word InitRedPTroopa
00C2A2  2               
00C2A2  2  3D C3              .word InitHorizFlySwimEnemy  ;for objects $10-$1f
00C2A4  2  85 C3              .word InitLakitu
00C2A6  2  A0 C7              .word InitEnemyFrenzy
00C2A8  2  F0 C2              .word NoInitCode
00C2AA  2  A0 C7              .word InitEnemyFrenzy
00C2AC  2  A0 C7              .word InitEnemyFrenzy
00C2AE  2  A0 C7              .word InitEnemyFrenzy
00C2B0  2  A0 C7              .word InitEnemyFrenzy
00C2B2  2  B8 C7              .word EndFrenzy
00C2B4  2  F0 C2              .word NoInitCode
00C2B6  2  F0 C2              .word NoInitCode
00C2B8  2  5C C4              .word InitShortFirebar
00C2BA  2  5C C4              .word InitShortFirebar
00C2BC  2  5C C4              .word InitShortFirebar
00C2BE  2  5C C4              .word InitShortFirebar
00C2C0  2  59 C4              .word InitLongFirebar
00C2C2  2               
00C2C2  2  F0 C2              .word NoInitCode ;for objects $20-$2f
00C2C4  2  F0 C2              .word NoInitCode
00C2C6  2  F0 C2              .word NoInitCode
00C2C8  2  F0 C2              .word NoInitCode
00C2CA  2  DF C7              .word InitBalPlatform
00C2CC  2  12 C8              .word InitVertPlatform
00C2CE  2  3F C8              .word LargeLiftUp
00C2D0  2  45 C8              .word LargeLiftDown
00C2D2  2  0B C8              .word InitHoriPlatform
00C2D4  2  03 C8              .word InitDropPlatform
00C2D6  2  0B C8              .word InitHoriPlatform
00C2D8  2  4B C8              .word PlatLiftUp
00C2DA  2  57 C8              .word PlatLiftDown
00C2DC  2  49 C5              .word InitBowser
00C2DE  2  60 BC              .word PwrUpJmp   ;possibly dummy value
00C2E0  2  1E B9              .word Setup_Vine
00C2E2  2               
00C2E2  2  F0 C2              .word NoInitCode ;for objects $30-$36
00C2E4  2  F0 C2              .word NoInitCode
00C2E6  2  F0 C2              .word NoInitCode
00C2E8  2  F0 C2              .word NoInitCode
00C2EA  2  F0 C2              .word NoInitCode
00C2EC  2  07 C3              .word InitRetainerObj
00C2EE  2  81 C8              .word EndOfEnemyInitCode
00C2F0  2               
00C2F0  2               ;-------------------------------------------------------------------------------------
00C2F0  2               
00C2F0  2               NoInitCode:
00C2F0  2  60                 rts               ;this executed when enemy object has no init code
00C2F1  2               
00C2F1  2               ;--------------------------------
00C2F1  2               
00C2F1  2               InitGoomba:
00C2F1  2  20 0E C3           jsr InitNormalEnemy  ;set appropriate horizontal speed
00C2F4  2  4C 46 C3           jmp SmallBBox        ;set $09 as bounding box control, set other values
00C2F7  2               
00C2F7  2               ;--------------------------------
00C2F7  2               
00C2F7  2               InitPodoboo:
00C2F7  2  A9 02              lda #$02                  ;set enemy position to below
00C2F9  2  95 B6              sta Enemy_Y_HighPos,x     ;the bottom of the screen
00C2FB  2  95 CF              sta Enemy_Y_Position,x
00C2FD  2  4A                 lsr
00C2FE  2  9D 96 07           sta EnemyIntervalTimer,x  ;set timer for enemy
00C301  2  4A                 lsr
00C302  2  95 1E              sta Enemy_State,x         ;initialize enemy state, then jump to use
00C304  2  4C 46 C3           jmp SmallBBox             ;$09 as bounding box size and set other things
00C307  2               
00C307  2               ;--------------------------------
00C307  2               
00C307  2               InitRetainerObj:
00C307  2  A9 B8              lda #$b8                ;set fixed vertical position for
00C309  2  95 CF              sta Enemy_Y_Position,x  ;princess/mushroom retainer object
00C30B  2  60                 rts
00C30C  2               
00C30C  2               ;--------------------------------
00C30C  2               
00C30C  2               NormalXSpdData:
00C30C  2  F8 F4              .byte $f8, $f4
00C30E  2               
00C30E  2               InitNormalEnemy:
00C30E  2  A0 01                 ldy #$01              ;load offset of 1 by default
00C310  2  AD 6A 07              lda PrimaryHardMode   ;check for primary hard mode flag set
00C313  2  D0 01                 bne GetESpd
00C315  2  88                    dey                   ;if not set, decrement offset
00C316  2  B9 0C C3     GetESpd: lda NormalXSpdData,y  ;get appropriate horizontal speed
00C319  2  95 58        SetESpd: sta Enemy_X_Speed,x   ;store as speed for enemy object
00C31B  2  4C 5A C3              jmp TallBBox          ;branch to set bounding box control and other data
00C31E  2               
00C31E  2               ;--------------------------------
00C31E  2               
00C31E  2               InitRedKoopa:
00C31E  2  20 0E C3           jsr InitNormalEnemy   ;load appropriate horizontal speed
00C321  2  A9 01              lda #$01              ;set enemy state for red koopa troopa $03
00C323  2  95 1E              sta Enemy_State,x
00C325  2  60                 rts
00C326  2               
00C326  2               ;--------------------------------
00C326  2               
00C326  2               HBroWalkingTimerData:
00C326  2  80 50              .byte $80, $50
00C328  2               
00C328  2               InitHammerBro:
00C328  2  A9 00              lda #$00                    ;init horizontal speed and timer used by hammer bro
00C32A  2  9D A2 03           sta HammerThrowingTimer,x   ;apparently to time hammer throwing
00C32D  2  95 58              sta Enemy_X_Speed,x
00C32F  2  AC CC 06           ldy SecondaryHardMode       ;get secondary hard mode flag
00C332  2  B9 26 C3           lda HBroWalkingTimerData,y
00C335  2  9D 96 07           sta EnemyIntervalTimer,x    ;set value as delay for hammer bro to walk left
00C338  2  A9 0B              lda #$0b                    ;set specific value for bounding box size control
00C33A  2  4C 5C C3           jmp SetBBox
00C33D  2               
00C33D  2               ;--------------------------------
00C33D  2               
00C33D  2               InitHorizFlySwimEnemy:
00C33D  2  A9 00              lda #$00        ;initialize horizontal speed
00C33F  2  4C 19 C3           jmp SetESpd
00C342  2               
00C342  2               ;--------------------------------
00C342  2               
00C342  2               InitBloober:
00C342  2  A9 00                   lda #$00               ;initialize horizontal speed
00C344  2  95 58                   sta BlooperMoveSpeed,x
00C346  2  A9 09        SmallBBox: lda #$09               ;set specific bounding box size control
00C348  2  D0 12                   bne SetBBox            ;unconditional branch
00C34A  2               
00C34A  2               ;--------------------------------
00C34A  2               
00C34A  2               InitRedPTroopa:
00C34A  2  A0 30                  ldy #$30                    ;load central position adder for 48 pixels down
00C34C  2  B5 CF                  lda Enemy_Y_Position,x      ;set vertical coordinate into location to
00C34E  2  9D 01 04               sta RedPTroopaOrigXPos,x    ;be used as original vertical coordinate
00C351  2  10 02                  bpl GetCent                 ;if vertical coordinate < $80
00C353  2  A0 E0                  ldy #$e0                    ;if => $80, load position adder for 32 pixels up
00C355  2  98           GetCent:  tya                         ;send central position adder to A
00C356  2  75 CF                  adc Enemy_Y_Position,x      ;add to current vertical coordinate
00C358  2  95 58                  sta RedPTroopaCenterYPos,x  ;store as central vertical coordinate
00C35A  2  A9 03        TallBBox: lda #$03                    ;set specific bounding box size control
00C35C  2  9D 9A 04     SetBBox:  sta Enemy_BoundBoxCtrl,x    ;set bounding box control here
00C35F  2  A9 02                  lda #$02                    ;set moving direction for left
00C361  2  95 46                  sta Enemy_MovingDir,x
00C363  2  A9 00        InitVStf: lda #$00                    ;initialize vertical speed
00C365  2  95 A0                  sta Enemy_Y_Speed,x         ;and movement force
00C367  2  9D 34 04               sta Enemy_Y_MoveForce,x
00C36A  2  60                     rts
00C36B  2               
00C36B  2               ;--------------------------------
00C36B  2               
00C36B  2               InitBulletBill:
00C36B  2  A9 02              lda #$02                  ;set moving direction for left
00C36D  2  95 46              sta Enemy_MovingDir,x
00C36F  2  A9 09              lda #$09                  ;set bounding box control for $09
00C371  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C374  2  60                 rts
00C375  2               
00C375  2               ;--------------------------------
00C375  2               
00C375  2               InitCheepCheep:
00C375  2  20 46 C3           jsr SmallBBox              ;set vertical bounding box, speed, init others
00C378  2  BD A7 07           lda PseudoRandomBitReg,x   ;check one portion of LSFR
00C37B  2  29 10              and #%00010000             ;get d4 from it
00C37D  2  95 58              sta CheepCheepMoveMFlag,x  ;save as movement flag of some sort
00C37F  2  B5 CF              lda Enemy_Y_Position,x
00C381  2  9D 34 04           sta CheepCheepOrigYPos,x   ;save original vertical coordinate here
00C384  2  60                 rts
00C385  2               
00C385  2               ;--------------------------------
00C385  2               
00C385  2               InitLakitu:
00C385  2  AD CB 06           lda EnemyFrenzyBuffer      ;check to see if an enemy is already in
00C388  2  D0 0B              bne KillLakitu             ;the frenzy buffer, and branch to kill lakitu if so
00C38A  2               
00C38A  2               SetupLakitu:
00C38A  2  A9 00              lda #$00                   ;erase counter for lakitu's reappearance
00C38C  2  8D D1 06           sta LakituReappearTimer
00C38F  2  20 3D C3           jsr InitHorizFlySwimEnemy  ;set $03 as bounding box, set other attributes
00C392  2  4C D9 C7           jmp TallBBox2              ;set $03 as bounding box again (not necessary) and leave
00C395  2               
00C395  2               KillLakitu:
00C395  2  4C 98 C9           jmp EraseEnemyObject
00C398  2               
00C398  2               ;--------------------------------
00C398  2               ;$01-$03 - used to hold pseudorandom difference adjusters
00C398  2               
00C398  2               PRDiffAdjustData:
00C398  2  26 2C 32 38        .byte $26, $2c, $32, $38
00C39C  2  20 22 24 26        .byte $20, $22, $24, $26
00C3A0  2  13 14 15 16        .byte $13, $14, $15, $16
00C3A4  2               
00C3A4  2               LakituAndSpinyHandler:
00C3A4  2  AD 8F 07               lda FrenzyEnemyTimer    ;if timer here not expired, leave
00C3A7  2  D0 3C                  bne ExLSHand
00C3A9  2  E0 05                  cpx #$05                ;if we are on the special use slot, leave
00C3AB  2  B0 38                  bcs ExLSHand
00C3AD  2  A9 80                  lda #$80                ;set timer
00C3AF  2  8D 8F 07               sta FrenzyEnemyTimer
00C3B2  2  A0 04                  ldy #$04                ;start with the last enemy slot
00C3B4  2  B9 16 00     ChkLak:   lda Enemy_ID,y          ;check all enemy slots to see
00C3B7  2  C9 11                  cmp #Lakitu             ;if lakitu is on one of them
00C3B9  2  F0 2B                  beq CreateSpiny         ;if so, branch out of this loop
00C3BB  2  88                     dey                     ;otherwise check another slot
00C3BC  2  10 F6                  bpl ChkLak              ;loop until all slots are checked
00C3BE  2  EE D1 06               inc LakituReappearTimer ;increment reappearance timer
00C3C1  2  AD D1 06               lda LakituReappearTimer
00C3C4  2  C9 07                  cmp #$07                ;check to see if we're up to a certain value yet
00C3C6  2  90 1D                  bcc ExLSHand            ;if not, leave
00C3C8  2  A2 04                  ldx #$04                ;start with the last enemy slot again
00C3CA  2  B5 0F        ChkNoEn:  lda Enemy_Flag,x        ;check enemy buffer flag for non-active enemy slot
00C3CC  2  F0 05                  beq CreateL             ;branch out of loop if found
00C3CE  2  CA                     dex                     ;otherwise check next slot
00C3CF  2  10 F9                  bpl ChkNoEn             ;branch until all slots are checked
00C3D1  2  30 10                  bmi RetEOfs             ;if no empty slots were found, branch to leave
00C3D3  2  A9 00        CreateL:  lda #$00                ;initialize enemy state
00C3D5  2  95 1E                  sta Enemy_State,x
00C3D7  2  A9 11                  lda #Lakitu             ;create lakitu enemy object
00C3D9  2  95 16                  sta Enemy_ID,x
00C3DB  2  20 8A C3               jsr SetupLakitu         ;do a sub to set up lakitu
00C3DE  2  A9 20                  lda #$20
00C3E0  2  20 D8 C5               jsr PutAtRightExtent    ;finish setting up lakitu
00C3E3  2  A6 08        RetEOfs:  ldx ObjectOffset        ;get enemy object buffer offset again and leave
00C3E5  2  60           ExLSHand: rts
00C3E6  2               
00C3E6  2               ;--------------------------------
00C3E6  2               
00C3E6  2               CreateSpiny:
00C3E6  2  A5 CE                  lda Player_Y_Position      ;if player above a certain point, branch to leave
00C3E8  2  C9 2C                  cmp #$2c
00C3EA  2  90 F9                  bcc ExLSHand
00C3EC  2  B9 1E 00               lda Enemy_State,y          ;if lakitu is not in normal state, branch to leave
00C3EF  2  D0 F4                  bne ExLSHand
00C3F1  2  B9 6E 00               lda Enemy_PageLoc,y        ;store horizontal coordinates (high and low) of lakitu
00C3F4  2  95 6E                  sta Enemy_PageLoc,x        ;into the coordinates of the spiny we're going to create
00C3F6  2  B9 87 00               lda Enemy_X_Position,y
00C3F9  2  95 87                  sta Enemy_X_Position,x
00C3FB  2  A9 01                  lda #$01                   ;put spiny within vertical screen unit
00C3FD  2  95 B6                  sta Enemy_Y_HighPos,x
00C3FF  2  B9 CF 00               lda Enemy_Y_Position,y     ;put spiny eight pixels above where lakitu is
00C402  2  38                     sec
00C403  2  E9 08                  sbc #$08
00C405  2  95 CF                  sta Enemy_Y_Position,x
00C407  2  BD A7 07               lda PseudoRandomBitReg,x   ;get 2 LSB of LSFR and save to Y
00C40A  2  29 03                  and #%00000011
00C40C  2  A8                     tay
00C40D  2  A2 02                  ldx #$02
00C40F  2  B9 98 C3     DifLoop:  lda PRDiffAdjustData,y     ;get three values and save them
00C412  2  95 01                  sta $01,x                  ;to $01-$03
00C414  2  C8                     iny
00C415  2  C8                     iny                        ;increment Y four bytes for each value
00C416  2  C8                     iny
00C417  2  C8                     iny
00C418  2  CA                     dex                        ;decrement X for each one
00C419  2  10 F4                  bpl DifLoop                ;loop until all three are written
00C41B  2  A6 08                  ldx ObjectOffset           ;get enemy object buffer offset
00C41D  2  20 6C CF               jsr PlayerLakituDiff       ;move enemy, change direction, get value - difference
00C420  2  A4 57                  ldy Player_X_Speed         ;check player's horizontal speed
00C422  2  C0 08                  cpy #$08
00C424  2  B0 0E                  bcs SetSpSpd               ;if moving faster than a certain amount, branch elsewhere
00C426  2  A8                     tay                        ;otherwise save value in A to Y for now
00C427  2  BD A8 07               lda PseudoRandomBitReg+1,x
00C42A  2  29 03                  and #%00000011             ;get one of the LSFR parts and save the 2 LSB
00C42C  2  F0 05                  beq UsePosv                ;branch if neither bits are set
00C42E  2  98                     tya
00C42F  2  49 FF                  eor #%11111111             ;otherwise get two's compliment of Y
00C431  2  A8                     tay
00C432  2  C8                     iny
00C433  2  98           UsePosv:  tya                        ;put value from A in Y back to A (they will be lost anyway)
00C434  2  20 46 C3     SetSpSpd: jsr SmallBBox              ;set bounding box control, init attributes, lose contents of A
00C437  2  A0 02                  ldy #$02
00C439  2  95 58                  sta Enemy_X_Speed,x        ;set horizontal speed to zero because previous contents
00C43B  2  C9 00                  cmp #$00                   ;of A were lost...branch here will never be taken for
00C43D  2  30 01                  bmi SpinyRte               ;the same reason
00C43F  2  88                     dey
00C440  2  94 46        SpinyRte: sty Enemy_MovingDir,x      ;set moving direction to the right
00C442  2  A9 FD                  lda #$fd
00C444  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to move upwards
00C446  2  A9 01                  lda #$01
00C448  2  95 0F                  sta Enemy_Flag,x           ;enable enemy object by setting flag
00C44A  2  A9 05                  lda #$05
00C44C  2  95 1E                  sta Enemy_State,x          ;put spiny in egg state and leave
00C44E  2  60           ChpChpEx: rts
00C44F  2               
00C44F  2               ;--------------------------------
00C44F  2               
00C44F  2               FirebarSpinSpdData:
00C44F  2  28 38 28 38        .byte $28, $38, $28, $38, $28
00C453  2  28           
00C454  2               
00C454  2               FirebarSpinDirData:
00C454  2  00 00 10 10        .byte $00, $00, $10, $10, $00
00C458  2  00           
00C459  2               
00C459  2               InitLongFirebar:
00C459  2  20 75 C5           jsr DuplicateEnemyObj       ;create enemy object for long firebar
00C45C  2               
00C45C  2               InitShortFirebar:
00C45C  2  A9 00              lda #$00                    ;initialize low byte of spin state
00C45E  2  95 58              sta FirebarSpinState_Low,x
00C460  2  B5 16              lda Enemy_ID,x              ;subtract $1b from enemy identifier
00C462  2  38                 sec                         ;to get proper offset for firebar data
00C463  2  E9 1B              sbc #$1b
00C465  2  A8                 tay
00C466  2  B9 4F C4           lda FirebarSpinSpdData,y    ;get spinning speed of firebar
00C469  2  9D 88 03           sta FirebarSpinSpeed,x
00C46C  2  B9 54 C4           lda FirebarSpinDirData,y    ;get spinning direction of firebar
00C46F  2  95 34              sta FirebarSpinDirection,x
00C471  2  B5 CF              lda Enemy_Y_Position,x
00C473  2  18                 clc                         ;add four pixels to vertical coordinate
00C474  2  69 04              adc #$04
00C476  2  95 CF              sta Enemy_Y_Position,x
00C478  2  B5 87              lda Enemy_X_Position,x
00C47A  2  18                 clc                         ;add four pixels to horizontal coordinate
00C47B  2  69 04              adc #$04
00C47D  2  95 87              sta Enemy_X_Position,x
00C47F  2  B5 6E              lda Enemy_PageLoc,x
00C481  2  69 00              adc #$00                    ;add carry to page location
00C483  2  95 6E              sta Enemy_PageLoc,x
00C485  2  4C D9 C7           jmp TallBBox2               ;set bounding box control (not used) and leave
00C488  2               
00C488  2               ;--------------------------------
00C488  2               ;$00-$01 - used to hold pseudorandom bits
00C488  2               
00C488  2               FlyCCXPositionData:
00C488  2  80 30 40 80        .byte $80, $30, $40, $80
00C48C  2  30 50 50 70        .byte $30, $50, $50, $70
00C490  2  20 40 80 A0        .byte $20, $40, $80, $a0
00C494  2  70 40 90 68        .byte $70, $40, $90, $68
00C498  2               
00C498  2               FlyCCXSpeedData:
00C498  2  0E 05 06 0E        .byte $0e, $05, $06, $0e
00C49C  2  1C 20 10 0C        .byte $1c, $20, $10, $0c
00C4A0  2  1E 22 18 14        .byte $1e, $22, $18, $14
00C4A4  2               
00C4A4  2               FlyCCTimerData:
00C4A4  2  10 60 20 48        .byte $10, $60, $20, $48
00C4A8  2               
00C4A8  2               InitFlyingCheepCheep:
00C4A8  2  AD 8F 07              lda FrenzyEnemyTimer       ;if timer here not expired yet, branch to leave
00C4AB  2  D0 A1                 bne ChpChpEx
00C4AD  2  20 46 C3              jsr SmallBBox              ;jump to set bounding box size $09 and init other values
00C4B0  2  BD A8 07              lda PseudoRandomBitReg+1,x
00C4B3  2  29 03                 and #%00000011             ;set pseudorandom offset here
00C4B5  2  A8                    tay
00C4B6  2  B9 A4 C4              lda FlyCCTimerData,y       ;load timer with pseudorandom offset
00C4B9  2  8D 8F 07              sta FrenzyEnemyTimer
00C4BC  2  A0 03                 ldy #$03                   ;load Y with default value
00C4BE  2  AD CC 06              lda SecondaryHardMode
00C4C1  2  F0 01                 beq MaxCC                  ;if secondary hard mode flag not set, do not increment Y
00C4C3  2  C8                    iny                        ;otherwise, increment Y to allow as many as four onscreen
00C4C4  2  84 00        MaxCC:   sty $00                    ;store whatever pseudorandom bits are in Y
00C4C6  2  E4 00                 cpx $00                    ;compare enemy object buffer offset with Y
00C4C8  2  B0 84                 bcs ChpChpEx               ;if X => Y, branch to leave
00C4CA  2  BD A7 07              lda PseudoRandomBitReg,x
00C4CD  2  29 03                 and #%00000011             ;get last two bits of LSFR, first part
00C4CF  2  85 00                 sta $00                    ;and store in two places
00C4D1  2  85 01                 sta $01
00C4D3  2  A9 FB                 lda #$fb                   ;set vertical speed for cheep-cheep
00C4D5  2  95 A0                 sta Enemy_Y_Speed,x
00C4D7  2  A9 00                 lda #$00                   ;load default value
00C4D9  2  A4 57                 ldy Player_X_Speed         ;check player's horizontal speed
00C4DB  2  F0 07                 beq GSeed                  ;if player not moving left or right, skip this part
00C4DD  2  A9 04                 lda #$04
00C4DF  2  C0 19                 cpy #$19                   ;if moving to the right but not very quickly,
00C4E1  2  90 01                 bcc GSeed                  ;do not change A
00C4E3  2  0A                    asl                        ;otherwise, multiply A by 2
00C4E4  2  48           GSeed:   pha                        ;save to stack
00C4E5  2  18                    clc
00C4E6  2  65 00                 adc $00                    ;add to last two bits of LSFR we saved earlier
00C4E8  2  85 00                 sta $00                    ;save it there
00C4EA  2  BD A8 07              lda PseudoRandomBitReg+1,x
00C4ED  2  29 03                 and #%00000011             ;if neither of the last two bits of second LSFR set,
00C4EF  2  F0 07                 beq RSeed                  ;skip this part and save contents of $00
00C4F1  2  BD A9 07              lda PseudoRandomBitReg+2,x
00C4F4  2  29 0F                 and #%00001111             ;otherwise overwrite with lower nybble of
00C4F6  2  85 00                 sta $00                    ;third LSFR part
00C4F8  2  68           RSeed:   pla                        ;get value from stack we saved earlier
00C4F9  2  18                    clc
00C4FA  2  65 01                 adc $01                    ;add to last two bits of LSFR we saved in other place
00C4FC  2  A8                    tay                        ;use as pseudorandom offset here
00C4FD  2  B9 98 C4              lda FlyCCXSpeedData,y      ;get horizontal speed using pseudorandom offset
00C500  2  95 58                 sta Enemy_X_Speed,x
00C502  2  A9 01                 lda #$01                   ;set to move towards the right
00C504  2  95 46                 sta Enemy_MovingDir,x
00C506  2  A5 57                 lda Player_X_Speed         ;if player moving left or right, branch ahead of this part
00C508  2  D0 12                 bne D2XPos1
00C50A  2  A4 00                 ldy $00                    ;get first LSFR or third LSFR lower nybble
00C50C  2  98                    tya                        ;and check for d1 set
00C50D  2  29 02                 and #%00000010
00C50F  2  F0 0B                 beq D2XPos1                ;if d1 not set, branch
00C511  2  B5 58                 lda Enemy_X_Speed,x
00C513  2  49 FF                 eor #$ff                   ;if d1 set, change horizontal speed
00C515  2  18                    clc                        ;into two's compliment, thus moving in the opposite
00C516  2  69 01                 adc #$01                   ;direction
00C518  2  95 58                 sta Enemy_X_Speed,x
00C51A  2  F6 46                 inc Enemy_MovingDir,x      ;increment to move towards the left
00C51C  2  98           D2XPos1: tya                        ;get first LSFR or third LSFR lower nybble again
00C51D  2  29 02                 and #%00000010
00C51F  2  F0 0F                 beq D2XPos2                ;check for d1 set again, branch again if not set
00C521  2  A5 86                 lda Player_X_Position      ;get player's horizontal position
00C523  2  18                    clc
00C524  2  79 88 C4              adc FlyCCXPositionData,y   ;if d1 set, add value obtained from pseudorandom offset
00C527  2  95 87                 sta Enemy_X_Position,x     ;and save as enemy's horizontal position
00C529  2  A5 6D                 lda Player_PageLoc         ;get player's page location
00C52B  2  69 00                 adc #$00                   ;add carry and jump past this part
00C52D  2  4C 3C C5              jmp FinCCSt
00C530  2  A5 86        D2XPos2: lda Player_X_Position      ;get player's horizontal position
00C532  2  38                    sec
00C533  2  F9 88 C4              sbc FlyCCXPositionData,y   ;if d1 not set, subtract value obtained from pseudorandom
00C536  2  95 87                 sta Enemy_X_Position,x     ;offset and save as enemy's horizontal position
00C538  2  A5 6D                 lda Player_PageLoc         ;get player's page location
00C53A  2  E9 00                 sbc #$00                   ;subtract borrow
00C53C  2  95 6E        FinCCSt: sta Enemy_PageLoc,x        ;save as enemy's page location
00C53E  2  A9 01                 lda #$01
00C540  2  95 0F                 sta Enemy_Flag,x           ;set enemy's buffer flag
00C542  2  95 B6                 sta Enemy_Y_HighPos,x      ;set enemy's high vertical byte
00C544  2  A9 F8                 lda #$f8
00C546  2  95 CF                 sta Enemy_Y_Position,x     ;put enemy below the screen, and we are done
00C548  2  60                    rts
00C549  2               
00C549  2               ;--------------------------------
00C549  2               
00C549  2               InitBowser:
00C549  2  20 75 C5           jsr DuplicateEnemyObj     ;jump to create another bowser object
00C54C  2  8E 68 03           stx BowserFront_Offset    ;save offset of first here
00C54F  2  A9 00              lda #$00
00C551  2  8D 63 03           sta BowserBodyControls    ;initialize bowser's body controls
00C554  2  8D 69 03           sta BridgeCollapseOffset  ;and bridge collapse offset
00C557  2  B5 87              lda Enemy_X_Position,x
00C559  2  8D 66 03           sta BowserOrigXPos        ;store original horizontal position here
00C55C  2  A9 DF              lda #$df
00C55E  2  8D 90 07           sta BowserFireBreathTimer ;store something here
00C561  2  95 46              sta Enemy_MovingDir,x     ;and in moving direction
00C563  2  A9 20              lda #$20
00C565  2  8D 64 03           sta BowserFeetCounter     ;set bowser's feet timer and in enemy timer
00C568  2  9D 8A 07           sta EnemyFrameTimer,x
00C56B  2  A9 05              lda #$05
00C56D  2  8D 83 04           sta BowserHitPoints       ;give bowser 5 hit points
00C570  2  4A                 lsr
00C571  2  8D 65 03           sta BowserMovementSpeed   ;set default movement speed here
00C574  2  60                 rts
00C575  2               
00C575  2               ;--------------------------------
00C575  2               
00C575  2               DuplicateEnemyObj:
00C575  2  A0 FF                ldy #$ff                ;start at beginning of enemy slots
00C577  2  C8           FSLoop: iny                     ;increment one slot
00C578  2  B9 0F 00             lda Enemy_Flag,y        ;check enemy buffer flag for empty slot
00C57B  2  D0 FA                bne FSLoop              ;if set, branch and keep checking
00C57D  2  8C CF 06             sty DuplicateObj_Offset ;otherwise set offset here
00C580  2  8A                   txa                     ;transfer original enemy buffer offset
00C581  2  09 80                ora #%10000000          ;store with d7 set as flag in new enemy
00C583  2  99 0F 00             sta Enemy_Flag,y        ;slot as well as enemy offset
00C586  2  B5 6E                lda Enemy_PageLoc,x
00C588  2  99 6E 00             sta Enemy_PageLoc,y     ;copy page location and horizontal coordinates
00C58B  2  B5 87                lda Enemy_X_Position,x  ;from original enemy to new enemy
00C58D  2  99 87 00             sta Enemy_X_Position,y
00C590  2  A9 01                lda #$01
00C592  2  95 0F                sta Enemy_Flag,x        ;set flag as normal for original enemy
00C594  2  99 B6 00             sta Enemy_Y_HighPos,y   ;set high vertical byte for new enemy
00C597  2  B5 CF                lda Enemy_Y_Position,x
00C599  2  99 CF 00             sta Enemy_Y_Position,y  ;copy vertical coordinate from original to new
00C59C  2  60           FlmEx:  rts                     ;and then leave
00C59D  2               
00C59D  2               ;--------------------------------
00C59D  2               
00C59D  2               FlameYPosData:
00C59D  2  90 80 70 90        .byte $90, $80, $70, $90
00C5A1  2               
00C5A1  2               FlameYMFAdderData:
00C5A1  2  FF 01              .byte $ff, $01
00C5A3  2               
00C5A3  2               InitBowserFlame:
00C5A3  2  AD 8F 07             lda FrenzyEnemyTimer        ;if timer not expired yet, branch to leave
00C5A6  2  D0 F4                bne FlmEx
00C5A8  2  9D 34 04             sta Enemy_Y_MoveForce,x     ;reset something here
00C5AB  2  A5 FD                lda NoiseSoundQueue
00C5AD  2  09 02                ora #Sfx_BowserFlame        ;load bowser's flame sound into queue
00C5AF  2  85 FD                sta NoiseSoundQueue
00C5B1  2  AC 68 03             ldy BowserFront_Offset      ;get bowser's buffer offset
00C5B4  2  B9 16 00             lda Enemy_ID,y              ;check for bowser
00C5B7  2  C9 2D                cmp #Bowser
00C5B9  2  F0 31                beq SpawnFromMouth          ;branch if found
00C5BB  2  20 D9 D1             jsr SetFlameTimer           ;get timer data based on flame counter
00C5BE  2  18                   clc
00C5BF  2  69 20                adc #$20                    ;add 32 frames by default
00C5C1  2  AC CC 06             ldy SecondaryHardMode
00C5C4  2  F0 03                beq SetFrT                  ;if secondary mode flag not set, use as timer setting
00C5C6  2  38                   sec
00C5C7  2  E9 10                sbc #$10                    ;otherwise subtract 16 frames for secondary hard mode
00C5C9  2  8D 8F 07     SetFrT: sta FrenzyEnemyTimer        ;set timer accordingly
00C5CC  2  BD A7 07             lda PseudoRandomBitReg,x
00C5CF  2  29 03                and #%00000011              ;get 2 LSB from first part of LSFR
00C5D1  2  9D 17 04             sta BowserFlamePRandomOfs,x ;set here
00C5D4  2  A8                   tay                         ;use as offset
00C5D5  2  B9 9D C5             lda FlameYPosData,y         ;load vertical position based on pseudorandom offset
00C5D8  2               
00C5D8  2               PutAtRightExtent:
00C5D8  2  95 CF              sta Enemy_Y_Position,x    ;set vertical position
00C5DA  2  AD 1D 07           lda ScreenRight_X_Pos
00C5DD  2  18                 clc
00C5DE  2  69 20              adc #$20                  ;place enemy 32 pixels beyond right side of screen
00C5E0  2  95 87              sta Enemy_X_Position,x
00C5E2  2  AD 1B 07           lda ScreenRight_PageLoc
00C5E5  2  69 00              adc #$00                  ;add carry
00C5E7  2  95 6E              sta Enemy_PageLoc,x
00C5E9  2  4C 1F C6           jmp FinishFlame           ;skip this part to finish setting values
00C5EC  2               
00C5EC  2               SpawnFromMouth:
00C5EC  2  B9 87 00            lda Enemy_X_Position,y    ;get bowser's horizontal position
00C5EF  2  38                  sec
00C5F0  2  E9 0E               sbc #$0e                  ;subtract 14 pixels
00C5F2  2  95 87               sta Enemy_X_Position,x    ;save as flame's horizontal position
00C5F4  2  B9 6E 00            lda Enemy_PageLoc,y
00C5F7  2  95 6E               sta Enemy_PageLoc,x       ;copy page location from bowser to flame
00C5F9  2  B9 CF 00            lda Enemy_Y_Position,y
00C5FC  2  18                  clc                       ;add 8 pixels to bowser's vertical position
00C5FD  2  69 08               adc #$08
00C5FF  2  95 CF               sta Enemy_Y_Position,x    ;save as flame's vertical position
00C601  2  BD A7 07            lda PseudoRandomBitReg,x
00C604  2  29 03               and #%00000011            ;get 2 LSB from first part of LSFR
00C606  2  9D 17 04            sta Enemy_YMF_Dummy,x     ;save here
00C609  2  A8                  tay                       ;use as offset
00C60A  2  B9 9D C5            lda FlameYPosData,y       ;get value here using bits as offset
00C60D  2  A0 00               ldy #$00                  ;load default offset
00C60F  2  D5 CF               cmp Enemy_Y_Position,x    ;compare value to flame's current vertical position
00C611  2  90 01               bcc SetMF                 ;if less, do not increment offset
00C613  2  C8                  iny                       ;otherwise increment now
00C614  2  B9 A1 C5     SetMF: lda FlameYMFAdderData,y   ;get value here and save
00C617  2  9D 34 04            sta Enemy_Y_MoveForce,x   ;to vertical movement force
00C61A  2  A9 00               lda #$00
00C61C  2  8D CB 06            sta EnemyFrenzyBuffer     ;clear enemy frenzy buffer
00C61F  2               
00C61F  2               FinishFlame:
00C61F  2  A9 08              lda #$08                 ;set $08 for bounding box control
00C621  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x
00C624  2  A9 01              lda #$01                 ;set high byte of vertical and
00C626  2  95 B6              sta Enemy_Y_HighPos,x    ;enemy buffer flag
00C628  2  95 0F              sta Enemy_Flag,x
00C62A  2  4A                 lsr
00C62B  2  9D 01 04           sta Enemy_X_MoveForce,x  ;initialize horizontal movement force, and
00C62E  2  95 1E              sta Enemy_State,x        ;enemy state
00C630  2  60                 rts
00C631  2               
00C631  2               ;--------------------------------
00C631  2               
00C631  2               FireworksXPosData:
00C631  2  00 30 60 60        .byte $00, $30, $60, $60, $00, $20
00C635  2  00 20        
00C637  2               
00C637  2               FireworksYPosData:
00C637  2  60 40 70 40        .byte $60, $40, $70, $40, $60, $30
00C63B  2  60 30        
00C63D  2               
00C63D  2               InitFireworks:
00C63D  2  AD 8F 07               lda FrenzyEnemyTimer         ;if timer not expired yet, branch to leave
00C640  2  D0 47                  bne ExitFWk
00C642  2  A9 20                  lda #$20                     ;otherwise reset timer
00C644  2  8D 8F 07               sta FrenzyEnemyTimer
00C647  2  CE D7 06               dec FireworksCounter         ;decrement for each explosion
00C64A  2  A0 06                  ldy #$06                     ;start at last slot
00C64C  2  88           StarFChk: dey
00C64D  2  B9 16 00               lda Enemy_ID,y               ;check for presence of star flag object
00C650  2  C9 31                  cmp #StarFlagObject          ;if there isn't a star flag object,
00C652  2  D0 F8                  bne StarFChk                 ;routine goes into infinite loop = crash
00C654  2  B9 87 00               lda Enemy_X_Position,y
00C657  2  38                     sec                          ;get horizontal coordinate of star flag object, then
00C658  2  E9 30                  sbc #$30                     ;subtract 48 pixels from it and save to
00C65A  2  48                     pha                          ;the stack
00C65B  2  B9 6E 00               lda Enemy_PageLoc,y
00C65E  2  E9 00                  sbc #$00                     ;subtract the carry from the page location
00C660  2  85 00                  sta $00                      ;of the star flag object
00C662  2  AD D7 06               lda FireworksCounter         ;get fireworks counter
00C665  2  18                     clc
00C666  2  79 1E 00               adc Enemy_State,y            ;add state of star flag object (possibly not necessary)
00C669  2  A8                     tay                          ;use as offset
00C66A  2  68                     pla                          ;get saved horizontal coordinate of star flag - 48 pixels
00C66B  2  18                     clc
00C66C  2  79 31 C6               adc FireworksXPosData,y      ;add number based on offset of fireworks counter
00C66F  2  95 87                  sta Enemy_X_Position,x       ;store as the fireworks object horizontal coordinate
00C671  2  A5 00                  lda $00
00C673  2  69 00                  adc #$00                     ;add carry and store as page location for
00C675  2  95 6E                  sta Enemy_PageLoc,x          ;the fireworks object
00C677  2  B9 37 C6               lda FireworksYPosData,y      ;get vertical position using same offset
00C67A  2  95 CF                  sta Enemy_Y_Position,x       ;and store as vertical coordinate for fireworks object
00C67C  2  A9 01                  lda #$01
00C67E  2  95 B6                  sta Enemy_Y_HighPos,x        ;store in vertical high byte
00C680  2  95 0F                  sta Enemy_Flag,x             ;and activate enemy buffer flag
00C682  2  4A                     lsr
00C683  2  95 58                  sta ExplosionGfxCounter,x    ;initialize explosion counter
00C685  2  A9 08                  lda #$08
00C687  2  95 A0                  sta ExplosionTimerCounter,x  ;set explosion timing counter
00C689  2  60           ExitFWk:  rts
00C68A  2               
00C68A  2               ;--------------------------------
00C68A  2               
00C68A  2               Bitmasks:
00C68A  2  01 02 04 08        .byte %00000001, %00000010, %00000100, %00001000, %00010000, %00100000, %01000000, %10000000
00C68E  2  10 20 40 80  
00C692  2               
00C692  2               Enemy17YPosData:
00C692  2  40 30 90 50        .byte $40, $30, $90, $50, $20, $60, $a0, $70
00C696  2  20 60 A0 70  
00C69A  2               
00C69A  2               SwimCC_IDData:
00C69A  2  0A 0B              .byte $0a, $0b
00C69C  2               
00C69C  2               BulletBillCheepCheep:
00C69C  2  AD 8F 07              lda FrenzyEnemyTimer      ;if timer not expired yet, branch to leave
00C69F  2  D0 6F                 bne ExF17
00C6A1  2  AD 4E 07              lda AreaType              ;are we in a water-type level?
00C6A4  2  D0 57                 bne DoBulletBills         ;if not, branch elsewhere
00C6A6  2  E0 03                 cpx #$03                  ;are we past third enemy slot?
00C6A8  2  B0 66                 bcs ExF17                 ;if so, branch to leave
00C6AA  2  A0 00                 ldy #$00                  ;load default offset
00C6AC  2  BD A7 07              lda PseudoRandomBitReg,x
00C6AF  2  C9 AA                 cmp #$aa                  ;check first part of LSFR against preset value
00C6B1  2  90 01                 bcc ChkW2                 ;if less than preset, do not increment offset
00C6B3  2  C8                    iny                       ;otherwise increment
00C6B4  2  AD 5F 07     ChkW2:   lda WorldNumber           ;check world number
00C6B7  2  C9 01                 cmp #World2
00C6B9  2  F0 01                 beq Get17ID               ;if we're on world 2, do not increment offset
00C6BB  2  C8                    iny                       ;otherwise increment
00C6BC  2  98           Get17ID: tya
00C6BD  2  29 01                 and #%00000001            ;mask out all but last bit of offset
00C6BF  2  A8                    tay
00C6C0  2  B9 9A C6              lda SwimCC_IDData,y       ;load identifier for cheep-cheeps
00C6C3  2  95 16        Set17ID: sta Enemy_ID,x            ;store whatever's in A as enemy identifier
00C6C5  2  AD DD 06              lda BitMFilter
00C6C8  2  C9 FF                 cmp #$ff                  ;if not all bits set, skip init part and compare bits
00C6CA  2  D0 05                 bne GetRBit
00C6CC  2  A9 00                 lda #$00                  ;initialize vertical position filter
00C6CE  2  8D DD 06              sta BitMFilter
00C6D1  2  BD A7 07     GetRBit: lda PseudoRandomBitReg,x  ;get first part of LSFR
00C6D4  2  29 07                 and #%00000111            ;mask out all but 3 LSB
00C6D6  2  A8           ChkRBit: tay                       ;use as offset
00C6D7  2  B9 8A C6              lda Bitmasks,y            ;load bitmask
00C6DA  2  2C DD 06              bit BitMFilter            ;perform AND on filter without changing it
00C6DD  2  F0 07                 beq AddFBit
00C6DF  2  C8                    iny                       ;increment offset
00C6E0  2  98                    tya
00C6E1  2  29 07                 and #%00000111            ;mask out all but 3 LSB thus keeping it 0-7
00C6E3  2  4C D6 C6              jmp ChkRBit               ;do another check
00C6E6  2  0D DD 06     AddFBit: ora BitMFilter            ;add bit to already set bits in filter
00C6E9  2  8D DD 06              sta BitMFilter            ;and store
00C6EC  2  B9 92 C6              lda Enemy17YPosData,y     ;load vertical position using offset
00C6EF  2  20 D8 C5              jsr PutAtRightExtent      ;set vertical position and other values
00C6F2  2  9D 17 04              sta Enemy_YMF_Dummy,x     ;initialize dummy variable
00C6F5  2  A9 20                 lda #$20                  ;set timer
00C6F7  2  8D 8F 07              sta FrenzyEnemyTimer
00C6FA  2  4C 6C C2              jmp CheckpointEnemyID     ;process our new enemy object
00C6FD  2               
00C6FD  2               DoBulletBills:
00C6FD  2  A0 FF                  ldy #$ff                   ;start at beginning of enemy slots
00C6FF  2  C8           BB_SLoop: iny                        ;move onto the next slot
00C700  2  C0 05                  cpy #$05                   ;branch to play sound if we've done all slots
00C702  2  B0 0D                  bcs FireBulletBill
00C704  2  B9 0F 00               lda Enemy_Flag,y           ;if enemy buffer flag not set,
00C707  2  F0 F6                  beq BB_SLoop               ;loop back and check another slot
00C709  2  B9 16 00               lda Enemy_ID,y
00C70C  2  C9 08                  cmp #BulletBill_FrenzyVar  ;check enemy identifier for
00C70E  2  D0 EF                  bne BB_SLoop               ;bullet bill object (frenzy variant)
00C710  2  60           ExF17:    rts                        ;if found, leave
00C711  2               
00C711  2               FireBulletBill:
00C711  2  A5 FE              lda Square2SoundQueue
00C713  2  09 08              ora #Sfx_Blast            ;play fireworks/gunfire sound
00C715  2  85 FE              sta Square2SoundQueue
00C717  2  A9 08              lda #BulletBill_FrenzyVar ;load identifier for bullet bill object
00C719  2  D0 A8              bne Set17ID               ;unconditional branch
00C71B  2               
00C71B  2               ;--------------------------------
00C71B  2               ;$00 - used to store Y position of group enemies
00C71B  2               ;$01 - used to store enemy ID
00C71B  2               ;$02 - used to store page location of right side of screen
00C71B  2               ;$03 - used to store X position of right side of screen
00C71B  2               
00C71B  2               HandleGroupEnemies:
00C71B  2  A0 00                ldy #$00                  ;load value for green koopa troopa
00C71D  2  38                   sec
00C71E  2  E9 37                sbc #$37                  ;subtract $37 from second byte read
00C720  2  48                   pha                       ;save result in stack for now
00C721  2  C9 04                cmp #$04                  ;was byte in $3b-$3e range?
00C723  2  B0 0B                bcs SnglID                ;if so, branch
00C725  2  48                   pha                       ;save another copy to stack
00C726  2  A0 06                ldy #Goomba               ;load value for goomba enemy
00C728  2  AD 6A 07             lda PrimaryHardMode       ;if primary hard mode flag not set,
00C72B  2  F0 02                beq PullID                ;branch, otherwise change to value
00C72D  2  A0 02                ldy #BuzzyBeetle          ;for buzzy beetle
00C72F  2  68           PullID: pla                       ;get second copy from stack
00C730  2  84 01        SnglID: sty $01                   ;save enemy id here
00C732  2  A0 B0                ldy #$b0                  ;load default y coordinate
00C734  2  29 02                and #$02                  ;check to see if d1 was set
00C736  2  F0 02                beq SetYGp                ;if so, move y coordinate up,
00C738  2  A0 70                ldy #$70                  ;otherwise branch and use default
00C73A  2  84 00        SetYGp: sty $00                   ;save y coordinate here
00C73C  2  AD 1B 07             lda ScreenRight_PageLoc   ;get page number of right edge of screen
00C73F  2  85 02                sta $02                   ;save here
00C741  2  AD 1D 07             lda ScreenRight_X_Pos     ;get pixel coordinate of right edge
00C744  2  85 03                sta $03                   ;save here
00C746  2  A0 02                ldy #$02                  ;load two enemies by default
00C748  2  68                   pla                       ;get first copy from stack
00C749  2  4A                   lsr                       ;check to see if d0 was set
00C74A  2  90 01                bcc CntGrp                ;if not, use default value
00C74C  2  C8                   iny                       ;otherwise increment to three enemies
00C74D  2  8C D3 06     CntGrp: sty NumberofGroupEnemies  ;save number of enemies here
00C750  2  A2 FF        GrLoop: ldx #$ff                  ;start at beginning of enemy buffers
00C752  2  E8           GSltLp: inx                       ;increment and branch if past
00C753  2  E0 05                cpx #$05                  ;end of buffers
00C755  2  B0 2D                bcs NextED
00C757  2  B5 0F                lda Enemy_Flag,x          ;check to see if enemy is already
00C759  2  D0 F7                bne GSltLp                ;stored in buffer, and branch if so
00C75B  2  A5 01                lda $01
00C75D  2  95 16                sta Enemy_ID,x            ;store enemy object identifier
00C75F  2  A5 02                lda $02
00C761  2  95 6E                sta Enemy_PageLoc,x       ;store page location for enemy object
00C763  2  A5 03                lda $03
00C765  2  95 87                sta Enemy_X_Position,x    ;store x coordinate for enemy object
00C767  2  18                   clc
00C768  2  69 18                adc #$18                  ;add 24 pixels for next enemy
00C76A  2  85 03                sta $03
00C76C  2  A5 02                lda $02                   ;add carry to page location for
00C76E  2  69 00                adc #$00                  ;next enemy
00C770  2  85 02                sta $02
00C772  2  A5 00                lda $00                   ;store y coordinate for enemy object
00C774  2  95 CF                sta Enemy_Y_Position,x
00C776  2  A9 01                lda #$01                  ;activate flag for buffer, and
00C778  2  95 B6                sta Enemy_Y_HighPos,x     ;put enemy within the screen vertically
00C77A  2  95 0F                sta Enemy_Flag,x
00C77C  2  20 6C C2             jsr CheckpointEnemyID     ;process each enemy object separately
00C77F  2  CE D3 06             dec NumberofGroupEnemies  ;do this until we run out of enemy objects
00C782  2  D0 CC                bne GrLoop
00C784  2  4C 5E C2     NextED: jmp Inc2B                 ;jump to increment data offset and leave
00C787  2               
00C787  2               ;--------------------------------
00C787  2               
00C787  2               InitPiranhaPlant:
00C787  2  A9 01              lda #$01                     ;set initial speed
00C789  2  95 58              sta PiranhaPlant_Y_Speed,x
00C78B  2  4A                 lsr
00C78C  2  95 1E              sta Enemy_State,x            ;initialize enemy state and what would normally
00C78E  2  95 A0              sta PiranhaPlant_MoveFlag,x  ;be used as vertical speed, but not in this case
00C790  2  B5 CF              lda Enemy_Y_Position,x
00C792  2  9D 34 04           sta PiranhaPlantDownYPos,x   ;save original vertical coordinate here
00C795  2  38                 sec
00C796  2  E9 18              sbc #$18
00C798  2  9D 17 04           sta PiranhaPlantUpYPos,x     ;save original vertical coordinate - 24 pixels here
00C79B  2  A9 09              lda #$09
00C79D  2  4C DB C7           jmp SetBBox2                 ;set specific value for bounding box control
00C7A0  2               
00C7A0  2               ;--------------------------------
00C7A0  2               
00C7A0  2               InitEnemyFrenzy:
00C7A0  2  B5 16              lda Enemy_ID,x        ;load enemy identifier
00C7A2  2  8D CB 06           sta EnemyFrenzyBuffer ;save in enemy frenzy buffer
00C7A5  2  38                 sec
00C7A6  2  E9 12              sbc #$12              ;subtract 12 and use as offset for jump engine
00C7A8  2  20 04 8E           jsr JumpEngine
00C7AB  2               
00C7AB  2               ;frenzy object jump table
00C7AB  2  A4 C3              .word LakituAndSpinyHandler
00C7AD  2  B7 C7              .word NoFrenzyCode
00C7AF  2  A8 C4              .word InitFlyingCheepCheep
00C7B1  2  A3 C5              .word InitBowserFlame
00C7B3  2  3D C6              .word InitFireworks
00C7B5  2  9C C6              .word BulletBillCheepCheep
00C7B7  2               
00C7B7  2               ;--------------------------------
00C7B7  2               
00C7B7  2               NoFrenzyCode:
00C7B7  2  60                 rts
00C7B8  2               
00C7B8  2               ;--------------------------------
00C7B8  2               
00C7B8  2               EndFrenzy:
00C7B8  2  A0 05                   ldy #$05               ;start at last slot
00C7BA  2  B9 16 00     LakituChk: lda Enemy_ID,y         ;check enemy identifiers
00C7BD  2  C9 11                   cmp #Lakitu            ;for lakitu
00C7BF  2  D0 05                   bne NextFSlot
00C7C1  2  A9 01                   lda #$01               ;if found, set state
00C7C3  2  99 1E 00                sta Enemy_State,y
00C7C6  2  88           NextFSlot: dey                    ;move onto the next slot
00C7C7  2  10 F1                   bpl LakituChk          ;do this until all slots are checked
00C7C9  2  A9 00                   lda #$00
00C7CB  2  8D CB 06                sta EnemyFrenzyBuffer  ;empty enemy frenzy buffer
00C7CE  2  95 0F                   sta Enemy_Flag,x       ;disable enemy buffer flag for this object
00C7D0  2  60                      rts
00C7D1  2               
00C7D1  2               ;--------------------------------
00C7D1  2               
00C7D1  2               InitJumpGPTroopa:
00C7D1  2  A9 02                   lda #$02                  ;set for movement to the left
00C7D3  2  95 46                   sta Enemy_MovingDir,x
00C7D5  2  A9 F8                   lda #$f8                  ;set horizontal speed
00C7D7  2  95 58                   sta Enemy_X_Speed,x
00C7D9  2  A9 03        TallBBox2: lda #$03                  ;set specific value for bounding box control
00C7DB  2  9D 9A 04     SetBBox2:  sta Enemy_BoundBoxCtrl,x  ;set bounding box control then leave
00C7DE  2  60                      rts
00C7DF  2               
00C7DF  2               ;--------------------------------
00C7DF  2               
00C7DF  2               InitBalPlatform:
00C7DF  2  D6 CF                dec Enemy_Y_Position,x    ;raise vertical position by two pixels
00C7E1  2  D6 CF                dec Enemy_Y_Position,x
00C7E3  2  AC CC 06             ldy SecondaryHardMode     ;if secondary hard mode flag not set,
00C7E6  2  D0 05                bne AlignP                ;branch ahead
00C7E8  2  A0 02                ldy #$02                  ;otherwise set value here
00C7EA  2  20 71 C8             jsr PosPlatform           ;do a sub to add or subtract pixels
00C7ED  2  A0 FF        AlignP: ldy #$ff                  ;set default value here for now
00C7EF  2  AD A0 03             lda BalPlatformAlignment  ;get current balance platform alignment
00C7F2  2  95 1E                sta Enemy_State,x         ;set platform alignment to object state here
00C7F4  2  10 02                bpl SetBPA                ;if old alignment $ff, put $ff as alignment for negative
00C7F6  2  8A                   txa                       ;if old contents already $ff, put
00C7F7  2  A8                   tay                       ;object offset as alignment to make next positive
00C7F8  2  8C A0 03     SetBPA: sty BalPlatformAlignment  ;store whatever value's in Y here
00C7FB  2  A9 00                lda #$00
00C7FD  2  95 46                sta Enemy_MovingDir,x     ;init moving direction
00C7FF  2  A8                   tay                       ;init Y
00C800  2  20 71 C8             jsr PosPlatform           ;do a sub to add 8 pixels, then run shared code here
00C803  2               
00C803  2               ;--------------------------------
00C803  2               
00C803  2               InitDropPlatform:
00C803  2  A9 FF              lda #$ff
00C805  2  9D A2 03           sta PlatformCollisionFlag,x  ;set some value here
00C808  2  4C 28 C8           jmp CommonPlatCode           ;then jump ahead to execute more code
00C80B  2               
00C80B  2               ;--------------------------------
00C80B  2               
00C80B  2               InitHoriPlatform:
00C80B  2  A9 00              lda #$00
00C80D  2  95 58              sta XMoveSecondaryCounter,x  ;init one of the moving counters
00C80F  2  4C 28 C8           jmp CommonPlatCode           ;jump ahead to execute more code
00C812  2               
00C812  2               ;--------------------------------
00C812  2               
00C812  2               InitVertPlatform:
00C812  2  A0 40               ldy #$40                    ;set default value here
00C814  2  B5 CF               lda Enemy_Y_Position,x      ;check vertical position
00C816  2  10 07               bpl SetYO                   ;if above a certain point, skip this part
00C818  2  49 FF               eor #$ff
00C81A  2  18                  clc                         ;otherwise get two's compliment
00C81B  2  69 01               adc #$01
00C81D  2  A0 C0               ldy #$c0                    ;get alternate value to add to vertical position
00C81F  2  9D 01 04     SetYO: sta YPlatformTopYPos,x      ;save as top vertical position
00C822  2  98                  tya
00C823  2  18                  clc                         ;load value from earlier, add number of pixels
00C824  2  75 CF               adc Enemy_Y_Position,x      ;to vertical position
00C826  2  95 58               sta YPlatformCenterYPos,x   ;save result as central vertical position
00C828  2               
00C828  2               ;--------------------------------
00C828  2               
00C828  2               CommonPlatCode:
00C828  2  20 63 C3             jsr InitVStf              ;do a sub to init certain other values
00C82B  2  A9 05        SPBBox: lda #$05                  ;set default bounding box size control
00C82D  2  AC 4E 07             ldy AreaType
00C830  2  C0 03                cpy #$03                  ;check for castle-type level
00C832  2  F0 07                beq CasPBB                ;use default value if found
00C834  2  AC CC 06             ldy SecondaryHardMode     ;otherwise check for secondary hard mode flag
00C837  2  D0 02                bne CasPBB                ;if set, use default value
00C839  2  A9 06                lda #$06                  ;use alternate value if not castle or secondary not set
00C83B  2  9D 9A 04     CasPBB: sta Enemy_BoundBoxCtrl,x  ;set bounding box size control here and leave
00C83E  2  60                   rts
00C83F  2               
00C83F  2               ;--------------------------------
00C83F  2               
00C83F  2               LargeLiftUp:
00C83F  2  20 4B C8           jsr PlatLiftUp       ;execute code for platforms going up
00C842  2  4C 48 C8           jmp LargeLiftBBox    ;overwrite bounding box for large platforms
00C845  2               
00C845  2               LargeLiftDown:
00C845  2  20 57 C8           jsr PlatLiftDown     ;execute code for platforms going down
00C848  2               
00C848  2               LargeLiftBBox:
00C848  2  4C 2B C8           jmp SPBBox           ;jump to overwrite bounding box size control
00C84B  2               
00C84B  2               ;--------------------------------
00C84B  2               
00C84B  2               PlatLiftUp:
00C84B  2  A9 10              lda #$10                 ;set movement amount here
00C84D  2  9D 34 04           sta Enemy_Y_MoveForce,x
00C850  2  A9 FF              lda #$ff                 ;set moving speed for platforms going up
00C852  2  95 A0              sta Enemy_Y_Speed,x
00C854  2  4C 60 C8           jmp CommonSmallLift      ;skip ahead to part we should be executing
00C857  2               
00C857  2               ;--------------------------------
00C857  2               
00C857  2               PlatLiftDown:
00C857  2  A9 F0              lda #$f0                 ;set movement amount here
00C859  2  9D 34 04           sta Enemy_Y_MoveForce,x
00C85C  2  A9 00              lda #$00                 ;set moving speed for platforms going down
00C85E  2  95 A0              sta Enemy_Y_Speed,x
00C860  2               
00C860  2               ;--------------------------------
00C860  2               
00C860  2               CommonSmallLift:
00C860  2  A0 01              ldy #$01
00C862  2  20 71 C8           jsr PosPlatform           ;do a sub to add 12 pixels due to preset value
00C865  2  A9 04              lda #$04
00C867  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box control for small platforms
00C86A  2  60                 rts
00C86B  2               
00C86B  2               ;--------------------------------
00C86B  2               
00C86B  2               PlatPosDataLow:
00C86B  2  08 0C F8           .byte $08,$0c,$f8
00C86E  2               
00C86E  2               PlatPosDataHigh:
00C86E  2  00 00 FF           .byte $00,$00,$ff
00C871  2               
00C871  2               PosPlatform:
00C871  2  B5 87              lda Enemy_X_Position,x  ;get horizontal coordinate
00C873  2  18                 clc
00C874  2  79 6B C8           adc PlatPosDataLow,y    ;add or subtract pixels depending on offset
00C877  2  95 87              sta Enemy_X_Position,x  ;store as new horizontal coordinate
00C879  2  B5 6E              lda Enemy_PageLoc,x
00C87B  2  79 6E C8           adc PlatPosDataHigh,y   ;add or subtract page location depending on offset
00C87E  2  95 6E              sta Enemy_PageLoc,x     ;store as new page location
00C880  2  60                 rts                     ;and go back
00C881  2               
00C881  2               ;--------------------------------
00C881  2               
00C881  2               EndOfEnemyInitCode:
00C881  2  60                 rts
00C882  2               
00C882  2               ;-------------------------------------------------------------------------------------
00C882  2               
00C882  2               RunEnemyObjectsCore:
00C882  2  A6 08               ldx ObjectOffset  ;get offset for enemy object buffer
00C884  2  A9 00               lda #$00          ;load value 0 for jump engine by default
00C886  2  B4 16               ldy Enemy_ID,x
00C888  2  C0 15               cpy #$15          ;if enemy object < $15, use default value
00C88A  2  90 03               bcc JmpEO
00C88C  2  98                  tya               ;otherwise subtract $14 from the value and use
00C88D  2  E9 14               sbc #$14          ;as value for jump engine
00C88F  2  20 04 8E     JmpEO: jsr JumpEngine
00C892  2               
00C892  2  E0 C8              .word RunNormalEnemies  ;for objects $00-$14
00C894  2               
00C894  2  35 C9              .word RunBowserFlame    ;for objects $15-$1f
00C896  2  95 D2              .word RunFireworks
00C898  2  D6 C8              .word NoRunCode
00C89A  2  D6 C8              .word NoRunCode
00C89C  2  D6 C8              .word NoRunCode
00C89E  2  D6 C8              .word NoRunCode
00C8A0  2  47 C9              .word RunFirebarObj
00C8A2  2  47 C9              .word RunFirebarObj
00C8A4  2  47 C9              .word RunFirebarObj
00C8A6  2  47 C9              .word RunFirebarObj
00C8A8  2  47 C9              .word RunFirebarObj
00C8AA  2               
00C8AA  2  47 C9              .word RunFirebarObj     ;for objects $20-$2f
00C8AC  2  47 C9              .word RunFirebarObj
00C8AE  2  47 C9              .word RunFirebarObj
00C8B0  2  D6 C8              .word NoRunCode
00C8B2  2  65 C9              .word RunLargePlatform
00C8B4  2  65 C9              .word RunLargePlatform
00C8B6  2  65 C9              .word RunLargePlatform
00C8B8  2  65 C9              .word RunLargePlatform
00C8BA  2  65 C9              .word RunLargePlatform
00C8BC  2  65 C9              .word RunLargePlatform
00C8BE  2  65 C9              .word RunLargePlatform
00C8C0  2  4D C9              .word RunSmallPlatform
00C8C2  2  4D C9              .word RunSmallPlatform
00C8C4  2  65 D0              .word RunBowser
00C8C6  2  85 BC              .word PowerUpObjHandler
00C8C8  2  4B B9              .word VineObjectHandler
00C8CA  2               
00C8CA  2  D6 C8              .word NoRunCode         ;for objects $30-$35
00C8CC  2  D9 D2              .word RunStarFlagObj
00C8CE  2  BA B8              .word JumpspringHandler
00C8D0  2  D6 C8              .word NoRunCode
00C8D2  2  A4 B7              .word WarpZoneObject
00C8D4  2  D7 C8              .word RunRetainerObj
00C8D6  2               
00C8D6  2               ;--------------------------------
00C8D6  2               
00C8D6  2               NoRunCode:
00C8D6  2  60                 rts
00C8D7  2               
00C8D7  2               ;--------------------------------
00C8D7  2               
00C8D7  2               RunRetainerObj:
00C8D7  2  20 AF F1           jsr GetEnemyOffscreenBits
00C8DA  2  20 52 F1           jsr RelativeEnemyPosition
00C8DD  2  4C 7D E8           jmp EnemyGfxHandler
00C8E0  2               
00C8E0  2               ;--------------------------------
00C8E0  2               
00C8E0  2               RunNormalEnemies:
00C8E0  2  A9 00                  lda #$00                  ;init sprite attributes
00C8E2  2  9D C5 03               sta Enemy_SprAttrib,x
00C8E5  2  20 AF F1               jsr GetEnemyOffscreenBits
00C8E8  2  20 52 F1               jsr RelativeEnemyPosition
00C8EB  2  20 7D E8               jsr EnemyGfxHandler
00C8EE  2  20 43 E2               jsr GetEnemyBoundBox
00C8F1  2  20 C1 DF               jsr EnemyToBGCollisionDet
00C8F4  2  20 33 DA               jsr EnemiesCollision
00C8F7  2  20 53 D8               jsr PlayerEnemyCollision
00C8FA  2  AC 47 07               ldy TimerControl          ;if master timer control set, skip to last routine
00C8FD  2  D0 03                  bne SkipMove
00C8FF  2  20 05 C9               jsr EnemyMovementSubs
00C902  2  4C 7A D6     SkipMove: jmp OffscreenBoundsCheck
00C905  2               
00C905  2               EnemyMovementSubs:
00C905  2  B5 16              lda Enemy_ID,x
00C907  2  20 04 8E           jsr JumpEngine
00C90A  2               
00C90A  2  77 CA              .word MoveNormalEnemy      ;only objects $00-$14 use this table
00C90C  2  77 CA              .word MoveNormalEnemy
00C90E  2  77 CA              .word MoveNormalEnemy
00C910  2  77 CA              .word MoveNormalEnemy
00C912  2  77 CA              .word MoveNormalEnemy
00C914  2  D8 C9              .word ProcHammerBro
00C916  2  77 CA              .word MoveNormalEnemy
00C918  2  89 CB              .word MoveBloober
00C91A  2  36 CC              .word MoveBulletBill
00C91C  2  34 C9              .word NoMoveCode
00C91E  2  4A CC              .word MoveSwimmingCheepCheep
00C920  2  4A CC              .word MoveSwimmingCheepCheep
00C922  2  B0 C9              .word MovePodoboo
00C924  2  B0 D3              .word MovePiranhaPlant
00C926  2  F9 CA              .word MoveJumpingEnemy
00C928  2  FF CA              .word ProcMoveRedPTroopa
00C92A  2  25 CB              .word MoveFlyGreenPTroopa
00C92C  2  28 CF              .word MoveLakitu
00C92E  2  77 CA              .word MoveNormalEnemy
00C930  2  34 C9              .word NoMoveCode   ;dummy
00C932  2  DF CE              .word MoveFlyingCheepCheep
00C934  2               
00C934  2               ;--------------------------------
00C934  2               
00C934  2               NoMoveCode:
00C934  2  60                 rts
00C935  2               
00C935  2               ;--------------------------------
00C935  2               
00C935  2               RunBowserFlame:
00C935  2  20 EB D1           jsr ProcBowserFlame
00C938  2  20 AF F1           jsr GetEnemyOffscreenBits
00C93B  2  20 52 F1           jsr RelativeEnemyPosition
00C93E  2  20 43 E2           jsr GetEnemyBoundBox
00C941  2  20 53 D8           jsr PlayerEnemyCollision
00C944  2  4C 7A D6           jmp OffscreenBoundsCheck
00C947  2               
00C947  2               ;--------------------------------
00C947  2               
00C947  2               RunFirebarObj:
00C947  2  20 3C CD           jsr ProcFirebar
00C94A  2  4C 7A D6           jmp OffscreenBoundsCheck
00C94D  2               
00C94D  2               ;--------------------------------
00C94D  2               
00C94D  2               RunSmallPlatform:
00C94D  2  20 AF F1           jsr GetEnemyOffscreenBits
00C950  2  20 52 F1           jsr RelativeEnemyPosition
00C953  2  20 4C E2           jsr SmallPlatformBoundBox
00C956  2  20 7B DB           jsr SmallPlatformCollision
00C959  2  20 52 F1           jsr RelativeEnemyPosition
00C95C  2  20 66 ED           jsr DrawSmallPlatform
00C95F  2  20 55 D6           jsr MoveSmallPlatform
00C962  2  4C 7A D6           jmp OffscreenBoundsCheck
00C965  2               
00C965  2               ;--------------------------------
00C965  2               
00C965  2               RunLargePlatform:
00C965  2  20 AF F1             jsr GetEnemyOffscreenBits
00C968  2  20 52 F1             jsr RelativeEnemyPosition
00C96B  2  20 73 E2             jsr LargePlatformBoundBox
00C96E  2  20 45 DB             jsr LargePlatformCollision
00C971  2  AD 47 07             lda TimerControl             ;if master timer control set,
00C974  2  D0 03                bne SkipPT                   ;skip subroutine tree
00C976  2  20 82 C9             jsr LargePlatformSubroutines
00C979  2  20 52 F1     SkipPT: jsr RelativeEnemyPosition
00C97C  2  20 C8 E5             jsr DrawLargePlatform
00C97F  2  4C 7A D6             jmp OffscreenBoundsCheck
00C982  2               
00C982  2               ;--------------------------------
00C982  2               
00C982  2               LargePlatformSubroutines:
00C982  2  B5 16              lda Enemy_ID,x  ;subtract $24 to get proper offset for jump table
00C984  2  38                 sec
00C985  2  E9 24              sbc #$24
00C987  2  20 04 8E           jsr JumpEngine
00C98A  2               
00C98A  2  32 D4              .word BalancePlatform   ;table used by objects $24-$2a
00C98C  2  D3 D5              .word YMovingPlatform
00C98E  2  4F D6              .word MoveLargeLiftPlat
00C990  2  4F D6              .word MoveLargeLiftPlat
00C992  2  07 D6              .word XMovingPlatform
00C994  2  31 D6              .word DropPlatform
00C996  2  3D D6              .word RightPlatform
00C998  2               
00C998  2               ;-------------------------------------------------------------------------------------
00C998  2               
00C998  2               EraseEnemyObject:
00C998  2  A9 00              lda #$00                 ;clear all enemy object variables
00C99A  2  95 0F              sta Enemy_Flag,x
00C99C  2  95 16              sta Enemy_ID,x
00C99E  2  95 1E              sta Enemy_State,x
00C9A0  2  9D 10 01           sta FloateyNum_Control,x
00C9A3  2  9D 96 07           sta EnemyIntervalTimer,x
00C9A6  2  9D 25 01           sta ShellChainCounter,x
00C9A9  2  9D C5 03           sta Enemy_SprAttrib,x
00C9AC  2  9D 8A 07           sta EnemyFrameTimer,x
00C9AF  2  60                 rts
00C9B0  2               
00C9B0  2               ;-------------------------------------------------------------------------------------
00C9B0  2               
00C9B0  2               MovePodoboo:
00C9B0  2  BD 96 07           lda EnemyIntervalTimer,x   ;check enemy timer
00C9B3  2  D0 16              bne PdbM                   ;branch to move enemy if not expired
00C9B5  2  20 F7 C2           jsr InitPodoboo            ;otherwise set up podoboo again
00C9B8  2  BD A8 07           lda PseudoRandomBitReg+1,x ;get part of LSFR
00C9BB  2  09 80              ora #%10000000             ;set d7
00C9BD  2  9D 34 04           sta Enemy_Y_MoveForce,x    ;store as movement force
00C9C0  2  29 0F              and #%00001111             ;mask out high nybble
00C9C2  2  09 06              ora #$06                   ;set for at least six intervals
00C9C4  2  9D 96 07           sta EnemyIntervalTimer,x   ;store as new enemy timer
00C9C7  2  A9 F9              lda #$f9
00C9C9  2  95 A0              sta Enemy_Y_Speed,x        ;set vertical speed to move podoboo upwards
00C9CB  2  4C 92 BF     PdbM: jmp MoveJ_EnemyVertically  ;branch to impose gravity on podoboo
00C9CE  2               
00C9CE  2               ;--------------------------------
00C9CE  2               ;$00 - used in HammerBroJumpCode as bitmask
00C9CE  2               
00C9CE  2               HammerThrowTmrData:
00C9CE  2  30 1C              .byte $30, $1c
00C9D0  2               
00C9D0  2               XSpeedAdderData:
00C9D0  2  00 E8 00 18        .byte $00, $e8, $00, $18
00C9D4  2               
00C9D4  2               RevivedXSpeed:
00C9D4  2  08 F8 0C F4        .byte $08, $f8, $0c, $f4
00C9D8  2               
00C9D8  2               ProcHammerBro:
00C9D8  2  B5 1E               lda Enemy_State,x          ;check hammer bro's enemy state for d5 set
00C9DA  2  29 20               and #%00100000
00C9DC  2  F0 03               beq ChkJH                  ;if not set, go ahead with code
00C9DE  2  4C E5 CA            jmp MoveDefeatedEnemy      ;otherwise jump to something else
00C9E1  2  B5 3C        ChkJH: lda HammerBroJumpTimer,x   ;check jump timer
00C9E3  2  F0 2D               beq HammerBroJumpCode      ;if expired, branch to jump
00C9E5  2  D6 3C               dec HammerBroJumpTimer,x   ;otherwise decrement jump timer
00C9E7  2  AD D1 03            lda Enemy_OffscreenBits
00C9EA  2  29 0C               and #%00001100             ;check offscreen bits
00C9EC  2  D0 6A               bne MoveHammerBroXDir      ;if hammer bro a little offscreen, skip to movement code
00C9EE  2  BD A2 03            lda HammerThrowingTimer,x  ;check hammer throwing timer
00C9F1  2  D0 17               bne DecHT                  ;if not expired, skip ahead, do not throw hammer
00C9F3  2  AC CC 06            ldy SecondaryHardMode      ;otherwise get secondary hard mode flag
00C9F6  2  B9 CE C9            lda HammerThrowTmrData,y   ;get timer data using flag as offset
00C9F9  2  9D A2 03            sta HammerThrowingTimer,x  ;set as new timer
00C9FC  2  20 94 BA            jsr SpawnHammerObj         ;do a sub here to spawn hammer object
00C9FF  2  90 09               bcc DecHT                  ;if carry clear, hammer not spawned, skip to decrement timer
00CA01  2  B5 1E               lda Enemy_State,x
00CA03  2  09 08               ora #%00001000             ;set d3 in enemy state for hammer throw
00CA05  2  95 1E               sta Enemy_State,x
00CA07  2  4C 58 CA            jmp MoveHammerBroXDir      ;jump to move hammer bro
00CA0A  2  DE A2 03     DecHT: dec HammerThrowingTimer,x  ;decrement timer
00CA0D  2  4C 58 CA            jmp MoveHammerBroXDir      ;jump to move hammer bro
00CA10  2               
00CA10  2               HammerBroJumpLData:
00CA10  2  20 37              .byte $20, $37
00CA12  2               
00CA12  2               HammerBroJumpCode:
00CA12  2  B5 1E               lda Enemy_State,x           ;get hammer bro's enemy state
00CA14  2  29 07               and #%00000111              ;mask out all but 3 LSB
00CA16  2  C9 01               cmp #$01                    ;check for d0 set (for jumping)
00CA18  2  F0 3E               beq MoveHammerBroXDir       ;if set, branch ahead to moving code
00CA1A  2  A9 00               lda #$00                    ;load default value here
00CA1C  2  85 00               sta $00                     ;save into temp variable for now
00CA1E  2  A0 FA               ldy #$fa                    ;set default vertical speed
00CA20  2  B5 CF               lda Enemy_Y_Position,x      ;check hammer bro's vertical coordinate
00CA22  2  30 13               bmi SetHJ                   ;if on the bottom half of the screen, use current speed
00CA24  2  A0 FD               ldy #$fd                    ;otherwise set alternate vertical speed
00CA26  2  C9 70               cmp #$70                    ;check to see if hammer bro is above the middle of screen
00CA28  2  E6 00               inc $00                     ;increment preset value to $01
00CA2A  2  90 0B               bcc SetHJ                   ;if above the middle of the screen, use current speed and $01
00CA2C  2  C6 00               dec $00                     ;otherwise return value to $00
00CA2E  2  BD A8 07            lda PseudoRandomBitReg+1,x  ;get part of LSFR, mask out all but LSB
00CA31  2  29 01               and #$01
00CA33  2  D0 02               bne SetHJ                   ;if d0 of LSFR set, branch and use current speed and $00
00CA35  2  A0 FA               ldy #$fa                    ;otherwise reset to default vertical speed
00CA37  2  94 A0        SetHJ: sty Enemy_Y_Speed,x         ;set vertical speed for jumping
00CA39  2  B5 1E               lda Enemy_State,x           ;set d0 in enemy state for jumping
00CA3B  2  09 01               ora #$01
00CA3D  2  95 1E               sta Enemy_State,x
00CA3F  2  A5 00               lda $00                     ;load preset value here to use as bitmask
00CA41  2  3D A9 07            and PseudoRandomBitReg+2,x  ;and do bit-wise comparison with part of LSFR
00CA44  2  A8                  tay                         ;then use as offset
00CA45  2  AD CC 06            lda SecondaryHardMode       ;check secondary hard mode flag
00CA48  2  D0 01               bne HJump
00CA4A  2  A8                  tay                         ;if secondary hard mode flag clear, set offset to 0
00CA4B  2  B9 10 CA     HJump: lda HammerBroJumpLData,y    ;get jump length timer data using offset from before
00CA4E  2  9D 8A 07            sta EnemyFrameTimer,x       ;save in enemy timer
00CA51  2  BD A8 07            lda PseudoRandomBitReg+1,x
00CA54  2  09 C0               ora #%11000000              ;get contents of part of LSFR, set d7 and d6, then
00CA56  2  95 3C               sta HammerBroJumpTimer,x    ;store in jump timer
00CA58  2               
00CA58  2               MoveHammerBroXDir:
00CA58  2  A0 FC                 ldy #$fc                  ;move hammer bro a little to the left
00CA5A  2  A5 09                 lda FrameCounter
00CA5C  2  29 40                 and #%01000000            ;change hammer bro's direction every 64 frames
00CA5E  2  D0 02                 bne Shimmy
00CA60  2  A0 04                 ldy #$04                  ;if d6 set in counter, move him a little to the right
00CA62  2  94 58        Shimmy:  sty Enemy_X_Speed,x       ;store horizontal speed
00CA64  2  A0 01                 ldy #$01                  ;set to face right by default
00CA66  2  20 43 E1              jsr PlayerEnemyDiff       ;get horizontal difference between player and hammer bro
00CA69  2  30 0A                 bmi SetShim               ;if enemy to the left of player, skip this part
00CA6B  2  C8                    iny                       ;set to face left
00CA6C  2  BD 96 07              lda EnemyIntervalTimer,x  ;check walking timer
00CA6F  2  D0 04                 bne SetShim               ;if not yet expired, skip to set moving direction
00CA71  2  A9 F8                 lda #$f8
00CA73  2  95 58                 sta Enemy_X_Speed,x       ;otherwise, make the hammer bro walk left towards player
00CA75  2  94 46        SetShim: sty Enemy_MovingDir,x     ;set moving direction
00CA77  2               
00CA77  2               MoveNormalEnemy:
00CA77  2  A0 00               ldy #$00                   ;init Y to leave horizontal movement as-is
00CA79  2  B5 1E               lda Enemy_State,x
00CA7B  2  29 40               and #%01000000             ;check enemy state for d6 set, if set skip
00CA7D  2  D0 19               bne FallE                  ;to move enemy vertically, then horizontally if necessary
00CA7F  2  B5 1E               lda Enemy_State,x
00CA81  2  0A                  asl                        ;check enemy state for d7 set
00CA82  2  B0 30               bcs SteadM                 ;if set, branch to move enemy horizontally
00CA84  2  B5 1E               lda Enemy_State,x
00CA86  2  29 20               and #%00100000             ;check enemy state for d5 set
00CA88  2  D0 5B               bne MoveDefeatedEnemy      ;if set, branch to move defeated enemy object
00CA8A  2  B5 1E               lda Enemy_State,x
00CA8C  2  29 07               and #%00000111             ;check d2-d0 of enemy state for any set bits
00CA8E  2  F0 24               beq SteadM                 ;if enemy in normal state, branch to move enemy horizontally
00CA90  2  C9 05               cmp #$05
00CA92  2  F0 04               beq FallE                  ;if enemy in state used by spiny's egg, go ahead here
00CA94  2  C9 03               cmp #$03
00CA96  2  B0 30               bcs ReviveStunned          ;if enemy in states $03 or $04, skip ahead to yet another part
00CA98  2  20 63 BF     FallE: jsr MoveD_EnemyVertically  ;do a sub here to move enemy downwards
00CA9B  2  A0 00               ldy #$00
00CA9D  2  B5 1E               lda Enemy_State,x          ;check for enemy state $02
00CA9F  2  C9 02               cmp #$02
00CAA1  2  F0 0C               beq MEHor                  ;if found, branch to move enemy horizontally
00CAA3  2  29 40               and #%01000000             ;check for d6 set
00CAA5  2  F0 0D               beq SteadM                 ;if not set, branch to something else
00CAA7  2  B5 16               lda Enemy_ID,x
00CAA9  2  C9 2E               cmp #PowerUpObject         ;check for power-up object
00CAAB  2  F0 07               beq SteadM
00CAAD  2  D0 03               bne SlowM                  ;if any other object where d6 set, jump to set Y
00CAAF  2  4C 02 BF     MEHor: jmp MoveEnemyHorizontally  ;jump here to move enemy horizontally for <> $2e and d6 set
00CAB2  2               
00CAB2  2  A0 01        SlowM:  ldy #$01                  ;if branched here, increment Y to slow horizontal movement
00CAB4  2  B5 58        SteadM: lda Enemy_X_Speed,x       ;get current horizontal speed
00CAB6  2  48                   pha                       ;save to stack
00CAB7  2  10 02                bpl AddHS                 ;if not moving or moving right, skip, leave Y alone
00CAB9  2  C8                   iny
00CABA  2  C8                   iny                       ;otherwise increment Y to next data
00CABB  2  18           AddHS:  clc
00CABC  2  79 D0 C9             adc XSpeedAdderData,y     ;add value here to slow enemy down if necessary
00CABF  2  95 58                sta Enemy_X_Speed,x       ;save as horizontal speed temporarily
00CAC1  2  20 02 BF             jsr MoveEnemyHorizontally ;then do a sub to move horizontally
00CAC4  2  68                   pla
00CAC5  2  95 58                sta Enemy_X_Speed,x       ;get old horizontal speed from stack and return to
00CAC7  2  60                   rts                       ;original memory location, then leave
00CAC8  2               
00CAC8  2               ReviveStunned:
00CAC8  2  BD 96 07              lda EnemyIntervalTimer,x  ;if enemy timer not expired yet,
00CACB  2  D0 1E                 bne ChkKillGoomba         ;skip ahead to something else
00CACD  2  95 1E                 sta Enemy_State,x         ;otherwise initialize enemy state to normal
00CACF  2  A5 09                 lda FrameCounter
00CAD1  2  29 01                 and #$01                  ;get d0 of frame counter
00CAD3  2  A8                    tay                       ;use as Y and increment for movement direction
00CAD4  2  C8                    iny
00CAD5  2  94 46                 sty Enemy_MovingDir,x     ;store as pseudorandom movement direction
00CAD7  2  88                    dey                       ;decrement for use as pointer
00CAD8  2  AD 6A 07              lda PrimaryHardMode       ;check primary hard mode flag
00CADB  2  F0 02                 beq SetRSpd               ;if not set, use pointer as-is
00CADD  2  C8                    iny
00CADE  2  C8                    iny                       ;otherwise increment 2 bytes to next data
00CADF  2  B9 D4 C9     SetRSpd: lda RevivedXSpeed,y       ;load and store new horizontal speed
00CAE2  2  95 58                 sta Enemy_X_Speed,x       ;and leave
00CAE4  2  60                    rts
00CAE5  2               
00CAE5  2               MoveDefeatedEnemy:
00CAE5  2  20 63 BF           jsr MoveD_EnemyVertically      ;execute sub to move defeated enemy downwards
00CAE8  2  4C 02 BF           jmp MoveEnemyHorizontally      ;now move defeated enemy horizontally
00CAEB  2               
00CAEB  2               ChkKillGoomba:
00CAEB  2  C9 0E                cmp #$0e              ;check to see if enemy timer has reached
00CAED  2  D0 09                bne NKGmba            ;a certain point, and branch to leave if not
00CAEF  2  B5 16                lda Enemy_ID,x
00CAF1  2  C9 06                cmp #Goomba           ;check for goomba object
00CAF3  2  D0 03                bne NKGmba            ;branch if not found
00CAF5  2  20 98 C9             jsr EraseEnemyObject  ;otherwise, kill this goomba object
00CAF8  2  60           NKGmba: rts                   ;leave!
00CAF9  2               
00CAF9  2               ;--------------------------------
00CAF9  2               
00CAF9  2               MoveJumpingEnemy:
00CAF9  2  20 92 BF           jsr MoveJ_EnemyVertically  ;do a sub to impose gravity on green paratroopa
00CAFC  2  4C 02 BF           jmp MoveEnemyHorizontally  ;jump to move enemy horizontally
00CAFF  2               
00CAFF  2               ;--------------------------------
00CAFF  2               
00CAFF  2               ProcMoveRedPTroopa:
00CAFF  2  B5 A0                  lda Enemy_Y_Speed,x
00CB01  2  1D 34 04               ora Enemy_Y_MoveForce,x     ;check for any vertical force or speed
00CB04  2  D0 13                  bne MoveRedPTUpOrDown       ;branch if any found
00CB06  2  9D 17 04               sta Enemy_YMF_Dummy,x       ;initialize something here
00CB09  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. original vertical coordinate
00CB0B  2  DD 01 04               cmp RedPTroopaOrigXPos,x
00CB0E  2  B0 09                  bcs MoveRedPTUpOrDown       ;if current => original, skip ahead to more code
00CB10  2  A5 09                  lda FrameCounter            ;get frame counter
00CB12  2  29 07                  and #%00000111              ;mask out all but 3 LSB
00CB14  2  D0 02                  bne NoIncPT                 ;if any bits set, branch to leave
00CB16  2  F6 CF                  inc Enemy_Y_Position,x      ;otherwise increment red paratroopa's vertical position
00CB18  2  60           NoIncPT:  rts                         ;leave
00CB19  2               
00CB19  2               MoveRedPTUpOrDown:
00CB19  2  B5 CF                  lda Enemy_Y_Position,x      ;check current vs. central vertical coordinate
00CB1B  2  D5 58                  cmp RedPTroopaCenterYPos,x
00CB1D  2  90 03                  bcc MovPTDwn                ;if current < central, jump to move downwards
00CB1F  2  4C 75 BF               jmp MoveRedPTroopaUp        ;otherwise jump to move upwards
00CB22  2  4C 70 BF     MovPTDwn: jmp MoveRedPTroopaDown      ;move downwards
00CB25  2               
00CB25  2               ;--------------------------------
00CB25  2               ;$00 - used to store adder for movement, also used as adder for platform
00CB25  2               ;$01 - used to store maximum value for secondary counter
00CB25  2               
00CB25  2               MoveFlyGreenPTroopa:
00CB25  2  20 45 CB             jsr XMoveCntr_GreenPTroopa ;do sub to increment primary and secondary counters
00CB28  2  20 66 CB             jsr MoveWithXMCntrs        ;do sub to move green paratroopa accordingly, and horizontally
00CB2B  2  A0 01                ldy #$01                   ;set Y to move green paratroopa down
00CB2D  2  A5 09                lda FrameCounter
00CB2F  2  29 03                and #%00000011             ;check frame counter 2 LSB for any bits set
00CB31  2  D0 11                bne NoMGPT                 ;branch to leave if set to move up/down every fourth frame
00CB33  2  A5 09                lda FrameCounter
00CB35  2  29 40                and #%01000000             ;check frame counter for d6 set
00CB37  2  D0 02                bne YSway                  ;branch to move green paratroopa down if set
00CB39  2  A0 FF                ldy #$ff                   ;otherwise set Y to move green paratroopa up
00CB3B  2  84 00        YSway:  sty $00                    ;store adder here
00CB3D  2  B5 CF                lda Enemy_Y_Position,x
00CB3F  2  18                   clc                        ;add or subtract from vertical position
00CB40  2  65 00                adc $00                    ;to give green paratroopa a wavy flight
00CB42  2  95 CF                sta Enemy_Y_Position,x
00CB44  2  60           NoMGPT: rts                        ;leave!
00CB45  2               
00CB45  2               XMoveCntr_GreenPTroopa:
00CB45  2  A9 13                 lda #$13                    ;load preset maximum value for secondary counter
00CB47  2               
00CB47  2               XMoveCntr_Platform:
00CB47  2  85 01                 sta $01                     ;store value here
00CB49  2  A5 09                 lda FrameCounter
00CB4B  2  29 03                 and #%00000011              ;branch to leave if not on
00CB4D  2  D0 0D                 bne NoIncXM                 ;every fourth frame
00CB4F  2  B4 58                 ldy XMoveSecondaryCounter,x ;get secondary counter
00CB51  2  B5 A0                 lda XMovePrimaryCounter,x   ;get primary counter
00CB53  2  4A                    lsr
00CB54  2  B0 0A                 bcs DecSeXM                 ;if d0 of primary counter set, branch elsewhere
00CB56  2  C4 01                 cpy $01                     ;compare secondary counter to preset maximum value
00CB58  2  F0 03                 beq IncPXM                  ;if equal, branch ahead of this part
00CB5A  2  F6 58                 inc XMoveSecondaryCounter,x ;increment secondary counter and leave
00CB5C  2  60           NoIncXM: rts
00CB5D  2  F6 A0        IncPXM:  inc XMovePrimaryCounter,x   ;increment primary counter and leave
00CB5F  2  60                    rts
00CB60  2  98           DecSeXM: tya                         ;put secondary counter in A
00CB61  2  F0 FA                 beq IncPXM                  ;if secondary counter at zero, branch back
00CB63  2  D6 58                 dec XMoveSecondaryCounter,x ;otherwise decrement secondary counter and leave
00CB65  2  60                    rts
00CB66  2               
00CB66  2               MoveWithXMCntrs:
00CB66  2  B5 58                 lda XMoveSecondaryCounter,x  ;save secondary counter to stack
00CB68  2  48                    pha
00CB69  2  A0 01                 ldy #$01                     ;set value here by default
00CB6B  2  B5 A0                 lda XMovePrimaryCounter,x
00CB6D  2  29 02                 and #%00000010               ;if d1 of primary counter is
00CB6F  2  D0 0B                 bne XMRight                  ;set, branch ahead of this part here
00CB71  2  B5 58                 lda XMoveSecondaryCounter,x
00CB73  2  49 FF                 eor #$ff                     ;otherwise change secondary
00CB75  2  18                    clc                          ;counter to two's compliment
00CB76  2  69 01                 adc #$01
00CB78  2  95 58                 sta XMoveSecondaryCounter,x
00CB7A  2  A0 02                 ldy #$02                     ;load alternate value here
00CB7C  2  94 46        XMRight: sty Enemy_MovingDir,x        ;store as moving direction
00CB7E  2  20 02 BF              jsr MoveEnemyHorizontally
00CB81  2  85 00                 sta $00                      ;save value obtained from sub here
00CB83  2  68                    pla                          ;get secondary counter from stack
00CB84  2  95 58                 sta XMoveSecondaryCounter,x  ;and return to original place
00CB86  2  60                    rts
00CB87  2               
00CB87  2               ;--------------------------------
00CB87  2               
00CB87  2               BlooberBitmasks:
00CB87  2  3F 03              .byte %00111111, %00000011
00CB89  2               
00CB89  2               MoveBloober:
00CB89  2  B5 1E                lda Enemy_State,x
00CB8B  2  29 20                and #%00100000             ;check enemy state for d5 set
00CB8D  2  D0 4D                bne MoveDefeatedBloober    ;branch if set to move defeated bloober
00CB8F  2  AC CC 06             ldy SecondaryHardMode      ;use secondary hard mode flag as offset
00CB92  2  BD A8 07             lda PseudoRandomBitReg+1,x ;get LSFR
00CB95  2  39 87 CB             and BlooberBitmasks,y      ;mask out bits in LSFR using bitmask loaded with offset
00CB98  2  D0 12                bne BlooberSwim            ;if any bits set, skip ahead to make swim
00CB9A  2  8A                   txa
00CB9B  2  4A                   lsr                        ;check to see if on second or fourth slot (1 or 3)
00CB9C  2  90 04                bcc FBLeft                 ;if not, branch to figure out moving direction
00CB9E  2  A4 45                ldy Player_MovingDir       ;otherwise, load player's moving direction and
00CBA0  2  B0 08                bcs SBMDir                 ;do an unconditional branch to set
00CBA2  2  A0 02        FBLeft: ldy #$02                   ;set left moving direction by default
00CBA4  2  20 43 E1             jsr PlayerEnemyDiff        ;get horizontal difference between player and bloober
00CBA7  2  10 01                bpl SBMDir                 ;if enemy to the right of player, keep left
00CBA9  2  88                   dey                        ;otherwise decrement to set right moving direction
00CBAA  2  94 46        SBMDir: sty Enemy_MovingDir,x      ;set moving direction of bloober, then continue on here
00CBAC  2               
00CBAC  2               BlooberSwim:
00CBAC  2  20 DF CB            jsr ProcSwimmingB        ;execute sub to make bloober swim characteristically
00CBAF  2  B5 CF               lda Enemy_Y_Position,x   ;get vertical coordinate
00CBB1  2  38                  sec
00CBB2  2  FD 34 04            sbc Enemy_Y_MoveForce,x  ;subtract movement force
00CBB5  2  C9 20               cmp #$20                 ;check to see if position is above edge of status bar
00CBB7  2  90 02               bcc SwimX                ;if so, don't do it
00CBB9  2  95 CF               sta Enemy_Y_Position,x   ;otherwise, set new vertical position, make bloober swim
00CBBB  2  B4 46        SwimX: ldy Enemy_MovingDir,x    ;check moving direction
00CBBD  2  88                  dey
00CBBE  2  D0 0E               bne LeftSwim             ;if moving to the left, branch to second part
00CBC0  2  B5 87               lda Enemy_X_Position,x
00CBC2  2  18                  clc                      ;add movement speed to horizontal coordinate
00CBC3  2  75 58               adc BlooperMoveSpeed,x
00CBC5  2  95 87               sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00CBC7  2  B5 6E               lda Enemy_PageLoc,x
00CBC9  2  69 00               adc #$00                 ;add carry to page location
00CBCB  2  95 6E               sta Enemy_PageLoc,x      ;store as new page location and leave
00CBCD  2  60                  rts
00CBCE  2               
00CBCE  2               LeftSwim:
00CBCE  2  B5 87              lda Enemy_X_Position,x
00CBD0  2  38                 sec                      ;subtract movement speed from horizontal coordinate
00CBD1  2  F5 58              sbc BlooperMoveSpeed,x
00CBD3  2  95 87              sta Enemy_X_Position,x   ;store result as new horizontal coordinate
00CBD5  2  B5 6E              lda Enemy_PageLoc,x
00CBD7  2  E9 00              sbc #$00                 ;subtract borrow from page location
00CBD9  2  95 6E              sta Enemy_PageLoc,x      ;store as new page location and leave
00CBDB  2  60                 rts
00CBDC  2               
00CBDC  2               MoveDefeatedBloober:
00CBDC  2  4C 8C BF           jmp MoveEnemySlowVert    ;jump to move defeated bloober downwards
00CBDF  2               
00CBDF  2               ProcSwimmingB:
00CBDF  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00CBE1  2  29 02                and #%00000010            ;check for d1 set
00CBE3  2  D0 37                bne ChkForFloatdown       ;branch if set
00CBE5  2  A5 09                lda FrameCounter
00CBE7  2  29 07                and #%00000111            ;get 3 LSB of frame counter
00CBE9  2  48                   pha                       ;and save it to the stack
00CBEA  2  B5 A0                lda BlooperMoveCounter,x  ;get enemy's movement counter
00CBEC  2  4A                   lsr                       ;check for d0 set
00CBED  2  B0 15                bcs SlowSwim              ;branch if set
00CBEF  2  68                   pla                       ;pull 3 LSB of frame counter from the stack
00CBF0  2  D0 11                bne BSwimE                ;branch to leave, execute code only every eighth frame
00CBF2  2  BD 34 04             lda Enemy_Y_MoveForce,x
00CBF5  2  18                   clc                       ;add to movement force to speed up swim
00CBF6  2  69 01                adc #$01
00CBF8  2  9D 34 04             sta Enemy_Y_MoveForce,x   ;set movement force
00CBFB  2  95 58                sta BlooperMoveSpeed,x    ;set as movement speed
00CBFD  2  C9 02                cmp #$02
00CBFF  2  D0 02                bne BSwimE                ;if certain horizontal speed, branch to leave
00CC01  2  F6 A0                inc BlooperMoveCounter,x  ;otherwise increment movement counter
00CC03  2  60           BSwimE: rts
00CC04  2               
00CC04  2               SlowSwim:
00CC04  2  68                  pla                      ;pull 3 LSB of frame counter from the stack
00CC05  2  D0 14               bne NoSSw                ;branch to leave, execute code only every eighth frame
00CC07  2  BD 34 04            lda Enemy_Y_MoveForce,x
00CC0A  2  38                  sec                      ;subtract from movement force to slow swim
00CC0B  2  E9 01               sbc #$01
00CC0D  2  9D 34 04            sta Enemy_Y_MoveForce,x  ;set movement force
00CC10  2  95 58               sta BlooperMoveSpeed,x   ;set as movement speed
00CC12  2  D0 07               bne NoSSw                ;if any speed, branch to leave
00CC14  2  F6 A0               inc BlooperMoveCounter,x ;otherwise increment movement counter
00CC16  2  A9 02               lda #$02
00CC18  2  9D 96 07            sta EnemyIntervalTimer,x ;set enemy's timer
00CC1B  2  60           NoSSw: rts                      ;leave
00CC1C  2               
00CC1C  2               ChkForFloatdown:
00CC1C  2  BD 96 07           lda EnemyIntervalTimer,x ;get enemy timer
00CC1F  2  F0 08              beq ChkNearPlayer        ;branch if expired
00CC21  2               
00CC21  2               Floatdown:
00CC21  2  A5 09              lda FrameCounter        ;get frame counter
00CC23  2  4A                 lsr                     ;check for d0 set
00CC24  2  B0 02              bcs NoFD                ;branch to leave on every other frame
00CC26  2  F6 CF              inc Enemy_Y_Position,x  ;otherwise increment vertical coordinate
00CC28  2  60           NoFD: rts                     ;leave
00CC29  2               
00CC29  2               ChkNearPlayer:
00CC29  2  B5 CF              lda Enemy_Y_Position,x    ;get vertical coordinate
00CC2B  2  69 10              adc #$10                  ;add sixteen pixels
00CC2D  2  C5 CE              cmp Player_Y_Position     ;compare result with player's vertical coordinate
00CC2F  2  90 F0              bcc Floatdown             ;if modified vertical less than player's, branch
00CC31  2  A9 00              lda #$00
00CC33  2  95 A0              sta BlooperMoveCounter,x  ;otherwise nullify movement counter
00CC35  2  60                 rts
00CC36  2               
00CC36  2               ;--------------------------------
00CC36  2               
00CC36  2               MoveBulletBill:
00CC36  2  B5 1E                 lda Enemy_State,x          ;check bullet bill's enemy object state for d5 set
00CC38  2  29 20                 and #%00100000
00CC3A  2  F0 03                 beq NotDefB                ;if not set, continue with movement code
00CC3C  2  4C 92 BF              jmp MoveJ_EnemyVertically  ;otherwise jump to move defeated bullet bill downwards
00CC3F  2  A9 E8        NotDefB: lda #$e8                   ;set bullet bill's horizontal speed
00CC41  2  95 58                 sta Enemy_X_Speed,x        ;and move it accordingly (note: this bullet bill
00CC43  2  4C 02 BF              jmp MoveEnemyHorizontally  ;object occurs in frenzy object $17, not from cannons)
00CC46  2               
00CC46  2               ;--------------------------------
00CC46  2               ;$02 - used to hold preset values
00CC46  2               ;$03 - used to hold enemy state
00CC46  2               
00CC46  2               SwimCCXMoveData:
00CC46  2  40 80              .byte $40, $80
00CC48  2  04 04              .byte $04, $04 ;residual data, not used
00CC4A  2               
00CC4A  2               MoveSwimmingCheepCheep:
00CC4A  2  B5 1E                lda Enemy_State,x         ;check cheep-cheep's enemy object state
00CC4C  2  29 20                and #%00100000            ;for d5 set
00CC4E  2  F0 03                beq CCSwim                ;if not set, continue with movement code
00CC50  2  4C 8C BF             jmp MoveEnemySlowVert     ;otherwise jump to move defeated cheep-cheep downwards
00CC53  2  85 03        CCSwim: sta $03                   ;save enemy state in $03
00CC55  2  B5 16                lda Enemy_ID,x            ;get enemy identifier
00CC57  2  38                   sec
00CC58  2  E9 0A                sbc #$0a                  ;subtract ten for cheep-cheep identifiers
00CC5A  2  A8                   tay                       ;use as offset
00CC5B  2  B9 46 CC             lda SwimCCXMoveData,y     ;load value here
00CC5E  2  85 02                sta $02
00CC60  2  BD 01 04             lda Enemy_X_MoveForce,x   ;load horizontal force
00CC63  2  38                   sec
00CC64  2  E5 02                sbc $02                   ;subtract preset value from horizontal force
00CC66  2  9D 01 04             sta Enemy_X_MoveForce,x   ;store as new horizontal force
00CC69  2  B5 87                lda Enemy_X_Position,x    ;get horizontal coordinate
00CC6B  2  E9 00                sbc #$00                  ;subtract borrow (thus moving it slowly)
00CC6D  2  95 87                sta Enemy_X_Position,x    ;and save as new horizontal coordinate
00CC6F  2  B5 6E                lda Enemy_PageLoc,x
00CC71  2  E9 00                sbc #$00                  ;subtract borrow again, this time from the
00CC73  2  95 6E                sta Enemy_PageLoc,x       ;page location, then save
00CC75  2  A9 20                lda #$20
00CC77  2  85 02                sta $02                   ;save new value here
00CC79  2  E0 02                cpx #$02                  ;check enemy object offset
00CC7B  2  90 49                bcc ExSwCC                ;if in first or second slot, branch to leave
00CC7D  2  B5 58                lda CheepCheepMoveMFlag,x ;check movement flag
00CC7F  2  C9 10                cmp #$10                  ;if movement speed set to $00,
00CC81  2  90 16                bcc CCSwimUpwards         ;branch to move upwards
00CC83  2  BD 17 04             lda Enemy_YMF_Dummy,x
00CC86  2  18                   clc
00CC87  2  65 02                adc $02                   ;add preset value to dummy variable to get carry
00CC89  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00CC8C  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00CC8E  2  65 03                adc $03                   ;add carry to it plus enemy state to slowly move it downwards
00CC90  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00CC92  2  B5 B6                lda Enemy_Y_HighPos,x
00CC94  2  69 00                adc #$00                  ;add carry to page location and
00CC96  2  4C AC CC             jmp ChkSwimYPos           ;jump to end of movement code
00CC99  2               
00CC99  2               CCSwimUpwards:
00CC99  2  BD 17 04             lda Enemy_YMF_Dummy,x
00CC9C  2  38                   sec
00CC9D  2  E5 02                sbc $02                   ;subtract preset value to dummy variable to get borrow
00CC9F  2  9D 17 04             sta Enemy_YMF_Dummy,x     ;and save dummy
00CCA2  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00CCA4  2  E5 03                sbc $03                   ;subtract borrow to it plus enemy state to slowly move it upwards
00CCA6  2  95 CF                sta Enemy_Y_Position,x    ;save as new vertical coordinate
00CCA8  2  B5 B6                lda Enemy_Y_HighPos,x
00CCAA  2  E9 00                sbc #$00                  ;subtract borrow from page location
00CCAC  2               
00CCAC  2               ChkSwimYPos:
00CCAC  2  95 B6                sta Enemy_Y_HighPos,x     ;save new page location here
00CCAE  2  A0 00                ldy #$00                  ;load movement speed to upwards by default
00CCB0  2  B5 CF                lda Enemy_Y_Position,x    ;get vertical coordinate
00CCB2  2  38                   sec
00CCB3  2  FD 34 04             sbc CheepCheepOrigYPos,x  ;subtract original coordinate from current
00CCB6  2  10 07                bpl YPDiff                ;if result positive, skip to next part
00CCB8  2  A0 10                ldy #$10                  ;otherwise load movement speed to downwards
00CCBA  2  49 FF                eor #$ff
00CCBC  2  18                   clc                       ;get two's compliment of result
00CCBD  2  69 01                adc #$01                  ;to obtain total difference of original vs. current
00CCBF  2  C9 0F        YPDiff: cmp #$0f                  ;if difference between original vs. current vertical
00CCC1  2  90 03                bcc ExSwCC                ;coordinates < 15 pixels, leave movement speed alone
00CCC3  2  98                   tya
00CCC4  2  95 58                sta CheepCheepMoveMFlag,x ;otherwise change movement speed
00CCC6  2  60           ExSwCC: rts                       ;leave
00CCC7  2               
00CCC7  2               ;--------------------------------
00CCC7  2               ;$00 - used as counter for firebar parts
00CCC7  2               ;$01 - used for oscillated high byte of spin state or to hold horizontal adder
00CCC7  2               ;$02 - used for oscillated high byte of spin state or to hold vertical adder
00CCC7  2               ;$03 - used for mirror data
00CCC7  2               ;$04 - used to store player's sprite 1 X coordinate
00CCC7  2               ;$05 - used to evaluate mirror data
00CCC7  2               ;$06 - used to store either screen X coordinate or sprite data offset
00CCC7  2               ;$07 - used to store screen Y coordinate
00CCC7  2               ;$ed - used to hold maximum length of firebar
00CCC7  2               ;$ef - used to hold high byte of spinstate
00CCC7  2               
00CCC7  2               ;horizontal adder is at first byte + high byte of spinstate,
00CCC7  2               ;vertical adder is same + 8 bytes, two's compliment
00CCC7  2               ;if greater than $08 for proper oscillation
00CCC7  2               FirebarPosLookupTbl:
00CCC7  2  00 01 03 04        .byte $00, $01, $03, $04, $05, $06, $07, $07, $08
00CCCB  2  05 06 07 07  
00CCCF  2  08           
00CCD0  2  00 03 06 09        .byte $00, $03, $06, $09, $0b, $0d, $0e, $0f, $10
00CCD4  2  0B 0D 0E 0F  
00CCD8  2  10           
00CCD9  2  00 04 09 0D        .byte $00, $04, $09, $0d, $10, $13, $16, $17, $18
00CCDD  2  10 13 16 17  
00CCE1  2  18           
00CCE2  2  00 06 0C 12        .byte $00, $06, $0c, $12, $16, $1a, $1d, $1f, $20
00CCE6  2  16 1A 1D 1F  
00CCEA  2  20           
00CCEB  2  00 07 0F 16        .byte $00, $07, $0f, $16, $1c, $21, $25, $27, $28
00CCEF  2  1C 21 25 27  
00CCF3  2  28           
00CCF4  2  00 09 12 1B        .byte $00, $09, $12, $1b, $21, $27, $2c, $2f, $30
00CCF8  2  21 27 2C 2F  
00CCFC  2  30           
00CCFD  2  00 0B 15 1F        .byte $00, $0b, $15, $1f, $27, $2e, $33, $37, $38
00CD01  2  27 2E 33 37  
00CD05  2  38           
00CD06  2  00 0C 18 24        .byte $00, $0c, $18, $24, $2d, $35, $3b, $3e, $40
00CD0A  2  2D 35 3B 3E  
00CD0E  2  40           
00CD0F  2  00 0E 1B 28        .byte $00, $0e, $1b, $28, $32, $3b, $42, $46, $48
00CD13  2  32 3B 42 46  
00CD17  2  48           
00CD18  2  00 0F 1F 2D        .byte $00, $0f, $1f, $2d, $38, $42, $4a, $4e, $50
00CD1C  2  38 42 4A 4E  
00CD20  2  50           
00CD21  2  00 11 22 31        .byte $00, $11, $22, $31, $3e, $49, $51, $56, $58
00CD25  2  3E 49 51 56  
00CD29  2  58           
00CD2A  2               
00CD2A  2               FirebarMirrorData:
00CD2A  2  01 03 02 00        .byte $01, $03, $02, $00
00CD2E  2               
00CD2E  2               FirebarTblOffsets:
00CD2E  2  00 09 12 1B        .byte $00, $09, $12, $1b, $24, $2d
00CD32  2  24 2D        
00CD34  2  36 3F 48 51        .byte $36, $3f, $48, $51, $5a, $63
00CD38  2  5A 63        
00CD3A  2               
00CD3A  2               FirebarYPos:
00CD3A  2  0C 18              .byte $0c, $18
00CD3C  2               
00CD3C  2               ProcFirebar:
00CD3C  2  20 AF F1               jsr GetEnemyOffscreenBits   ;get offscreen information
00CD3F  2  AD D1 03               lda Enemy_OffscreenBits     ;check for d3 set
00CD42  2  29 08                  and #%00001000              ;if so, branch to leave
00CD44  2  D0 74                  bne SkipFBar
00CD46  2  AD 47 07               lda TimerControl            ;if master timer control set, branch
00CD49  2  D0 0A                  bne SusFbar                 ;ahead of this part
00CD4B  2  BD 88 03               lda FirebarSpinSpeed,x      ;load spinning speed of firebar
00CD4E  2  20 10 D4               jsr FirebarSpin             ;modify current spinstate
00CD51  2  29 1F                  and #%00011111              ;mask out all but 5 LSB
00CD53  2  95 A0                  sta FirebarSpinState_High,x ;and store as new high byte of spinstate
00CD55  2  B5 A0        SusFbar:  lda FirebarSpinState_High,x ;get high byte of spinstate
00CD57  2  B4 16                  ldy Enemy_ID,x              ;check enemy identifier
00CD59  2  C0 1F                  cpy #$1f
00CD5B  2  90 0D                  bcc SetupGFB                ;if < $1f (long firebar), branch
00CD5D  2  C9 08                  cmp #$08                    ;check high byte of spinstate
00CD5F  2  F0 04                  beq SkpFSte                 ;if eight, branch to change
00CD61  2  C9 18                  cmp #$18
00CD63  2  D0 05                  bne SetupGFB                ;if not at twenty-four branch to not change
00CD65  2  18           SkpFSte:  clc
00CD66  2  69 01                  adc #$01                    ;add one to spinning thing to avoid horizontal state
00CD68  2  95 A0                  sta FirebarSpinState_High,x
00CD6A  2  85 EF        SetupGFB: sta $ef                     ;save high byte of spinning thing, modified or otherwise
00CD6C  2  20 52 F1               jsr RelativeEnemyPosition   ;get relative coordinates to screen
00CD6F  2  20 8E CE               jsr GetFirebarPosition      ;do a sub here (residual, too early to be used now)
00CD72  2  BC E5 06               ldy Enemy_SprDataOffset,x   ;get OAM data offset
00CD75  2  AD B9 03               lda Enemy_Rel_YPos          ;get relative vertical coordinate
00CD78  2  99 00 02               sta Sprite_Y_Position,y     ;store as Y in OAM data
00CD7B  2  85 07                  sta $07                     ;also save here
00CD7D  2  AD AE 03               lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00CD80  2  99 03 02               sta Sprite_X_Position,y     ;store as X in OAM data
00CD83  2  85 06                  sta $06                     ;also save here
00CD85  2  A9 01                  lda #$01
00CD87  2  85 00                  sta $00                     ;set $01 value here (not necessary)
00CD89  2  20 08 CE               jsr FirebarCollision        ;draw fireball part and do collision detection
00CD8C  2  A0 05                  ldy #$05                    ;load value for short firebars by default
00CD8E  2  B5 16                  lda Enemy_ID,x
00CD90  2  C9 1F                  cmp #$1f                    ;are we doing a long firebar?
00CD92  2  90 02                  bcc SetMFbar                ;no, branch then
00CD94  2  A0 0B                  ldy #$0b                    ;otherwise load value for long firebars
00CD96  2  84 ED        SetMFbar: sty $ed                     ;store maximum value for length of firebars
00CD98  2  A9 00                  lda #$00
00CD9A  2  85 00                  sta $00                     ;initialize counter here
00CD9C  2  A5 EF        DrawFbar: lda $ef                     ;load high byte of spinstate
00CD9E  2  20 8E CE               jsr GetFirebarPosition      ;get fireball position data depending on firebar part
00CDA1  2  20 BB CD               jsr DrawFirebar_Collision   ;position it properly, draw it and do collision detection
00CDA4  2  A5 00                  lda $00                     ;check which firebar part
00CDA6  2  C9 04                  cmp #$04
00CDA8  2  D0 08                  bne NextFbar
00CDAA  2  AC CF 06               ldy DuplicateObj_Offset     ;if we arrive at fifth firebar part,
00CDAD  2  B9 E5 06               lda Enemy_SprDataOffset,y   ;get offset from long firebar and load OAM data offset
00CDB0  2  85 06                  sta $06                     ;using long firebar offset, then store as new one here
00CDB2  2  E6 00        NextFbar: inc $00                     ;move onto the next firebar part
00CDB4  2  A5 00                  lda $00
00CDB6  2  C5 ED                  cmp $ed                     ;if we end up at the maximum part, go on and leave
00CDB8  2  90 E2                  bcc DrawFbar                ;otherwise go back and do another
00CDBA  2  60           SkipFBar: rts
00CDBB  2               
00CDBB  2               DrawFirebar_Collision:
00CDBB  2  A5 03                 lda $03                  ;store mirror data elsewhere
00CDBD  2  85 05                 sta $05
00CDBF  2  A4 06                 ldy $06                  ;load OAM data offset for firebar
00CDC1  2  A5 01                 lda $01                  ;load horizontal adder we got from position loader
00CDC3  2  46 05                 lsr $05                  ;shift LSB of mirror data
00CDC5  2  B0 04                 bcs AddHA                ;if carry was set, skip this part
00CDC7  2  49 FF                 eor #$ff
00CDC9  2  69 01                 adc #$01                 ;otherwise get two's compliment of horizontal adder
00CDCB  2  18           AddHA:   clc                      ;add horizontal coordinate relative to screen to
00CDCC  2  6D AE 03              adc Enemy_Rel_XPos       ;horizontal adder, modified or otherwise
00CDCF  2  99 03 02              sta Sprite_X_Position,y  ;store as X coordinate here
00CDD2  2  85 06                 sta $06                  ;store here for now, note offset is saved in Y still
00CDD4  2  CD AE 03              cmp Enemy_Rel_XPos       ;compare X coordinate of sprite to original X of firebar
00CDD7  2  B0 09                 bcs SubtR1               ;if sprite coordinate => original coordinate, branch
00CDD9  2  AD AE 03              lda Enemy_Rel_XPos
00CDDC  2  38                    sec                      ;otherwise subtract sprite X from the
00CDDD  2  E5 06                 sbc $06                  ;original one and skip this part
00CDDF  2  4C E6 CD              jmp ChkFOfs
00CDE2  2  38           SubtR1:  sec                      ;subtract original X from the
00CDE3  2  ED AE 03              sbc Enemy_Rel_XPos       ;current sprite X
00CDE6  2  C9 59        ChkFOfs: cmp #$59                 ;if difference of coordinates within a certain range,
00CDE8  2  90 04                 bcc VAHandl              ;continue by handling vertical adder
00CDEA  2  A9 F8                 lda #$f8                 ;otherwise, load offscreen Y coordinate
00CDEC  2  D0 15                 bne SetVFbr              ;and unconditionally branch to move sprite offscreen
00CDEE  2  AD B9 03     VAHandl: lda Enemy_Rel_YPos       ;if vertical relative coordinate offscreen,
00CDF1  2  C9 F8                 cmp #$f8                 ;skip ahead of this part and write into sprite Y coordinate
00CDF3  2  F0 0E                 beq SetVFbr
00CDF5  2  A5 02                 lda $02                  ;load vertical adder we got from position loader
00CDF7  2  46 05                 lsr $05                  ;shift LSB of mirror data one more time
00CDF9  2  B0 04                 bcs AddVA                ;if carry was set, skip this part
00CDFB  2  49 FF                 eor #$ff
00CDFD  2  69 01                 adc #$01                 ;otherwise get two's compliment of second part
00CDFF  2  18           AddVA:   clc                      ;add vertical coordinate relative to screen to
00CE00  2  6D B9 03              adc Enemy_Rel_YPos       ;the second data, modified or otherwise
00CE03  2  99 00 02     SetVFbr: sta Sprite_Y_Position,y  ;store as Y coordinate here
00CE06  2  85 07                 sta $07                  ;also store here for now
00CE08  2               
00CE08  2               FirebarCollision:
00CE08  2  20 ED EC              jsr DrawFirebar          ;run sub here to draw current tile of firebar
00CE0B  2  98                    tya                      ;return OAM data offset and save
00CE0C  2  48                    pha                      ;to the stack for now
00CE0D  2  AD 9F 07              lda StarInvincibleTimer  ;if star mario invincibility timer
00CE10  2  0D 47 07              ora TimerControl         ;or master timer controls set
00CE13  2  D0 70                 bne NoColFB              ;then skip all of this
00CE15  2  85 05                 sta $05                  ;otherwise initialize counter
00CE17  2  A4 B5                 ldy Player_Y_HighPos
00CE19  2  88                    dey                      ;if player's vertical high byte offscreen,
00CE1A  2  D0 69                 bne NoColFB              ;skip all of this
00CE1C  2  A4 CE                 ldy Player_Y_Position    ;get player's vertical position
00CE1E  2  AD 54 07              lda PlayerSize           ;get player's size
00CE21  2  D0 05                 bne AdjSm                ;if player small, branch to alter variables
00CE23  2  AD 14 07              lda CrouchingFlag
00CE26  2  F0 09                 beq BigJp                ;if player big and not crouching, jump ahead
00CE28  2  E6 05        AdjSm:   inc $05                  ;if small or big but crouching, execute this part
00CE2A  2  E6 05                 inc $05                  ;first increment our counter twice (setting $02 as flag)
00CE2C  2  98                    tya
00CE2D  2  18                    clc                      ;then add 24 pixels to the player's
00CE2E  2  69 18                 adc #$18                 ;vertical coordinate
00CE30  2  A8                    tay
00CE31  2  98           BigJp:   tya                      ;get vertical coordinate, altered or otherwise, from Y
00CE32  2  38           FBCLoop: sec                      ;subtract vertical position of firebar
00CE33  2  E5 07                 sbc $07                  ;from the vertical coordinate of the player
00CE35  2  10 05                 bpl ChkVFBD              ;if player lower on the screen than firebar,
00CE37  2  49 FF                 eor #$ff                 ;skip two's compliment part
00CE39  2  18                    clc                      ;otherwise get two's compliment
00CE3A  2  69 01                 adc #$01
00CE3C  2  C9 08        ChkVFBD: cmp #$08                 ;if difference => 8 pixels, skip ahead of this part
00CE3E  2  B0 1C                 bcs Chk2Ofs
00CE40  2  A5 06                 lda $06                  ;if firebar on far right on the screen, skip this,
00CE42  2  C9 F0                 cmp #$f0                 ;because, really, what's the point?
00CE44  2  B0 16                 bcs Chk2Ofs
00CE46  2  AD 07 02              lda Sprite_X_Position+4  ;get OAM X coordinate for sprite #1
00CE49  2  18                    clc
00CE4A  2  69 04                 adc #$04                 ;add four pixels
00CE4C  2  85 04                 sta $04                  ;store here
00CE4E  2  38                    sec                      ;subtract horizontal coordinate of firebar
00CE4F  2  E5 06                 sbc $06                  ;from the X coordinate of player's sprite 1
00CE51  2  10 05                 bpl ChkFBCl              ;if modded X coordinate to the right of firebar
00CE53  2  49 FF                 eor #$ff                 ;skip two's compliment part
00CE55  2  18                    clc                      ;otherwise get two's compliment
00CE56  2  69 01                 adc #$01
00CE58  2  C9 08        ChkFBCl: cmp #$08                 ;if difference < 8 pixels, collision, thus branch
00CE5A  2  90 13                 bcc ChgSDir              ;to process
00CE5C  2  A5 05        Chk2Ofs: lda $05                  ;if value of $02 was set earlier for whatever reason,
00CE5E  2  C9 02                 cmp #$02                 ;branch to increment OAM offset and leave, no collision
00CE60  2  F0 23                 beq NoColFB
00CE62  2  A4 05                 ldy $05                  ;otherwise get temp here and use as offset
00CE64  2  A5 CE                 lda Player_Y_Position
00CE66  2  18                    clc
00CE67  2  79 3A CD              adc FirebarYPos,y        ;add value loaded with offset to player's vertical coordinate
00CE6A  2  E6 05                 inc $05                  ;then increment temp and jump back
00CE6C  2  4C 32 CE              jmp FBCLoop
00CE6F  2  A2 01        ChgSDir: ldx #$01                 ;set movement direction by default
00CE71  2  A5 04                 lda $04                  ;if OAM X coordinate of player's sprite 1
00CE73  2  C5 06                 cmp $06                  ;is greater than horizontal coordinate of firebar
00CE75  2  B0 01                 bcs SetSDir              ;then do not alter movement direction
00CE77  2  E8                    inx                      ;otherwise increment it
00CE78  2  86 46        SetSDir: stx Enemy_MovingDir      ;store movement direction here
00CE7A  2  A2 00                 ldx #$00
00CE7C  2  A5 00                 lda $00                  ;save value written to $00 to stack
00CE7E  2  48                    pha
00CE7F  2  20 2C D9              jsr InjurePlayer         ;perform sub to hurt or kill player
00CE82  2  68                    pla
00CE83  2  85 00                 sta $00                  ;get value of $00 from stack
00CE85  2  68           NoColFB: pla                      ;get OAM data offset
00CE86  2  18                    clc                      ;add four to it and save
00CE87  2  69 04                 adc #$04
00CE89  2  85 06                 sta $06
00CE8B  2  A6 08                 ldx ObjectOffset         ;get enemy object buffer offset and leave
00CE8D  2  60                    rts
00CE8E  2               
00CE8E  2               GetFirebarPosition:
00CE8E  2  48                      pha                        ;save high byte of spinstate to the stack
00CE8F  2  29 0F                   and #%00001111             ;mask out low nybble
00CE91  2  C9 09                   cmp #$09
00CE93  2  90 05                   bcc GetHAdder              ;if lower than $09, branch ahead
00CE95  2  49 0F                   eor #%00001111             ;otherwise get two's compliment to oscillate
00CE97  2  18                      clc
00CE98  2  69 01                   adc #$01
00CE9A  2  85 01        GetHAdder: sta $01                    ;store result, modified or not, here
00CE9C  2  A4 00                   ldy $00                    ;load number of firebar ball where we're at
00CE9E  2  B9 2E CD                lda FirebarTblOffsets,y    ;load offset to firebar position data
00CEA1  2  18                      clc
00CEA2  2  65 01                   adc $01                    ;add oscillated high byte of spinstate
00CEA4  2  A8                      tay                        ;to offset here and use as new offset
00CEA5  2  B9 C7 CC                lda FirebarPosLookupTbl,y  ;get data here and store as horizontal adder
00CEA8  2  85 01                   sta $01
00CEAA  2  68                      pla                        ;pull whatever was in A from the stack
00CEAB  2  48                      pha                        ;save it again because we still need it
00CEAC  2  18                      clc
00CEAD  2  69 08                   adc #$08                   ;add eight this time, to get vertical adder
00CEAF  2  29 0F                   and #%00001111             ;mask out high nybble
00CEB1  2  C9 09                   cmp #$09                   ;if lower than $09, branch ahead
00CEB3  2  90 05                   bcc GetVAdder
00CEB5  2  49 0F                   eor #%00001111             ;otherwise get two's compliment
00CEB7  2  18                      clc
00CEB8  2  69 01                   adc #$01
00CEBA  2  85 02        GetVAdder: sta $02                    ;store result here
00CEBC  2  A4 00                   ldy $00
00CEBE  2  B9 2E CD                lda FirebarTblOffsets,y    ;load offset to firebar position data again
00CEC1  2  18                      clc
00CEC2  2  65 02                   adc $02                    ;this time add value in $02 to offset here and use as offset
00CEC4  2  A8                      tay
00CEC5  2  B9 C7 CC                lda FirebarPosLookupTbl,y  ;get data here and store as vertica adder
00CEC8  2  85 02                   sta $02
00CECA  2  68                      pla                        ;pull out whatever was in A one last time
00CECB  2  4A                      lsr                        ;divide by eight or shift three to the right
00CECC  2  4A                      lsr
00CECD  2  4A                      lsr
00CECE  2  A8                      tay                        ;use as offset
00CECF  2  B9 2A CD                lda FirebarMirrorData,y    ;load mirroring data here
00CED2  2  85 03                   sta $03                    ;store
00CED4  2  60                      rts
00CED5  2               
00CED5  2               ;--------------------------------
00CED5  2               
00CED5  2               PRandomSubtracter:
00CED5  2  F8 A0 70 BD        .byte $f8, $a0, $70, $bd, $00
00CED9  2  00           
00CEDA  2               
00CEDA  2               FlyCCBPriority:
00CEDA  2  20 20 20 00        .byte $20, $20, $20, $00, $00
00CEDE  2  00           
00CEDF  2               
00CEDF  2               MoveFlyingCheepCheep:
00CEDF  2  B5 1E                lda Enemy_State,x          ;check cheep-cheep's enemy state
00CEE1  2  29 20                and #%00100000             ;for d5 set
00CEE3  2  F0 08                beq FlyCC                  ;branch to continue code if not set
00CEE5  2  A9 00                lda #$00
00CEE7  2  9D C5 03             sta Enemy_SprAttrib,x      ;otherwise clear sprite attributes
00CEEA  2  4C 92 BF             jmp MoveJ_EnemyVertically  ;and jump to move defeated cheep-cheep downwards
00CEED  2  20 02 BF     FlyCC:  jsr MoveEnemyHorizontally  ;move cheep-cheep horizontally based on speed and force
00CEF0  2  A0 0D                ldy #$0d                   ;set vertical movement amount
00CEF2  2  A9 05                lda #$05                   ;set maximum speed
00CEF4  2  20 96 BF             jsr SetXMoveAmt            ;branch to impose gravity on flying cheep-cheep
00CEF7  2  BD 34 04             lda Enemy_Y_MoveForce,x
00CEFA  2  4A                   lsr                        ;get vertical movement force and
00CEFB  2  4A                   lsr                        ;move high nybble to low
00CEFC  2  4A                   lsr
00CEFD  2  4A                   lsr
00CEFE  2  A8                   tay                        ;save as offset (note this tends to go into reach of code)
00CEFF  2  B5 CF                lda Enemy_Y_Position,x     ;get vertical position
00CF01  2  38                   sec                        ;subtract pseudorandom value based on offset from position
00CF02  2  F9 D5 CE             sbc PRandomSubtracter,y
00CF05  2  10 05                bpl AddCCF                  ;if result within top half of screen, skip this part
00CF07  2  49 FF                eor #$ff
00CF09  2  18                   clc                        ;otherwise get two's compliment
00CF0A  2  69 01                adc #$01
00CF0C  2  C9 08        AddCCF: cmp #$08                   ;if result or two's compliment greater than eight,
00CF0E  2  B0 0E                bcs BPGet                  ;skip to the end without changing movement force
00CF10  2  BD 34 04             lda Enemy_Y_MoveForce,x
00CF13  2  18                   clc
00CF14  2  69 10                adc #$10                   ;otherwise add to it
00CF16  2  9D 34 04             sta Enemy_Y_MoveForce,x
00CF19  2  4A                   lsr                        ;move high nybble to low again
00CF1A  2  4A                   lsr
00CF1B  2  4A                   lsr
00CF1C  2  4A                   lsr
00CF1D  2  A8                   tay
00CF1E  2  B9 DA CE     BPGet:  lda FlyCCBPriority,y       ;load bg priority data and store (this is very likely
00CF21  2  9D C5 03             sta Enemy_SprAttrib,x      ;broken or residual code, value is overwritten before
00CF24  2  60                   rts                        ;drawing it next frame), then leave
00CF25  2               
00CF25  2               ;--------------------------------
00CF25  2               ;$00 - used to hold horizontal difference
00CF25  2               ;$01-$03 - used to hold difference adjusters
00CF25  2               
00CF25  2               LakituDiffAdj:
00CF25  2  15 30 40           .byte $15, $30, $40
00CF28  2               
00CF28  2               MoveLakitu:
00CF28  2  B5 1E                 lda Enemy_State,x          ;check lakitu's enemy state
00CF2A  2  29 20                 and #%00100000             ;for d5 set
00CF2C  2  F0 03                 beq ChkLS                  ;if not set, continue with code
00CF2E  2  4C 63 BF              jmp MoveD_EnemyVertically  ;otherwise jump to move defeated lakitu downwards
00CF31  2  B5 1E        ChkLS:   lda Enemy_State,x          ;if lakitu's enemy state not set at all,
00CF33  2  F0 0B                 beq Fr12S                  ;go ahead and continue with code
00CF35  2  A9 00                 lda #$00
00CF37  2  95 A0                 sta LakituMoveDirection,x  ;otherwise initialize moving direction to move to left
00CF39  2  8D CB 06              sta EnemyFrenzyBuffer      ;initialize frenzy buffer
00CF3C  2  A9 10                 lda #$10
00CF3E  2  D0 13                 bne SetLSpd                ;load horizontal speed and do unconditional branch
00CF40  2  A9 12        Fr12S:   lda #Spiny
00CF42  2  8D CB 06              sta EnemyFrenzyBuffer      ;set spiny identifier in frenzy buffer
00CF45  2  A0 02                 ldy #$02
00CF47  2  B9 25 CF     LdLDa:   lda LakituDiffAdj,y        ;load values
00CF4A  2  99 01 00              sta $0001,y                ;store in zero page
00CF4D  2  88                    dey
00CF4E  2  10 F7                 bpl LdLDa                  ;do this until all values are stired
00CF50  2  20 6C CF              jsr PlayerLakituDiff       ;execute sub to set speed and create spinys
00CF53  2  95 58        SetLSpd: sta LakituMoveSpeed,x      ;set movement speed returned from sub
00CF55  2  A0 01                 ldy #$01                   ;set moving direction to right by default
00CF57  2  B5 A0                 lda LakituMoveDirection,x
00CF59  2  29 01                 and #$01                   ;get LSB of moving direction
00CF5B  2  D0 0A                 bne SetLMov                ;if set, branch to the end to use moving direction
00CF5D  2  B5 58                 lda LakituMoveSpeed,x
00CF5F  2  49 FF                 eor #$ff                   ;get two's compliment of moving speed
00CF61  2  18                    clc
00CF62  2  69 01                 adc #$01
00CF64  2  95 58                 sta LakituMoveSpeed,x      ;store as new moving speed
00CF66  2  C8                    iny                        ;increment moving direction to left
00CF67  2  94 46        SetLMov: sty Enemy_MovingDir,x      ;store moving direction
00CF69  2  4C 02 BF              jmp MoveEnemyHorizontally  ;move lakitu horizontally
00CF6C  2               
00CF6C  2               PlayerLakituDiff:
00CF6C  2  A0 00                   ldy #$00                   ;set Y for default value
00CF6E  2  20 43 E1                jsr PlayerEnemyDiff        ;get horizontal difference between enemy and player
00CF71  2  10 0A                   bpl ChkLakDif              ;branch if enemy is to the right of the player
00CF73  2  C8                      iny                        ;increment Y for left of player
00CF74  2  A5 00                   lda $00
00CF76  2  49 FF                   eor #$ff                   ;get two's compliment of low byte of horizontal difference
00CF78  2  18                      clc
00CF79  2  69 01                   adc #$01                   ;store two's compliment as horizontal difference
00CF7B  2  85 00                   sta $00
00CF7D  2  A5 00        ChkLakDif: lda $00                    ;get low byte of horizontal difference
00CF7F  2  C9 3C                   cmp #$3c                   ;if within a certain distance of player, branch
00CF81  2  90 1C                   bcc ChkPSpeed
00CF83  2  A9 3C                   lda #$3c                   ;otherwise set maximum distance
00CF85  2  85 00                   sta $00
00CF87  2  B5 16                   lda Enemy_ID,x             ;check if lakitu is in our current enemy slot
00CF89  2  C9 11                   cmp #Lakitu
00CF8B  2  D0 12                   bne ChkPSpeed              ;if not, branch elsewhere
00CF8D  2  98                      tya                        ;compare contents of Y, now in A
00CF8E  2  D5 A0                   cmp LakituMoveDirection,x  ;to what is being used as horizontal movement direction
00CF90  2  F0 0D                   beq ChkPSpeed              ;if moving toward the player, branch, do not alter
00CF92  2  B5 A0                   lda LakituMoveDirection,x  ;if moving to the left beyond maximum distance,
00CF94  2  F0 06                   beq SetLMovD               ;branch and alter without delay
00CF96  2  D6 58                   dec LakituMoveSpeed,x      ;decrement horizontal speed
00CF98  2  B5 58                   lda LakituMoveSpeed,x      ;if horizontal speed not yet at zero, branch to leave
00CF9A  2  D0 40                   bne ExMoveLak
00CF9C  2  98           SetLMovD:  tya                        ;set horizontal direction depending on horizontal
00CF9D  2  95 A0                   sta LakituMoveDirection,x  ;difference between enemy and player if necessary
00CF9F  2  A5 00        ChkPSpeed: lda $00
00CFA1  2  29 3C                   and #%00111100             ;mask out all but four bits in the middle
00CFA3  2  4A                      lsr                        ;divide masked difference by four
00CFA4  2  4A                      lsr
00CFA5  2  85 00                   sta $00                    ;store as new value
00CFA7  2  A0 00                   ldy #$00                   ;init offset
00CFA9  2  A5 57                   lda Player_X_Speed
00CFAB  2  F0 24                   beq SubDifAdj              ;if player not moving horizontally, branch
00CFAD  2  AD 75 07                lda ScrollAmount
00CFB0  2  F0 1F                   beq SubDifAdj              ;if scroll speed not set, branch to same place
00CFB2  2  C8                      iny                        ;otherwise increment offset
00CFB3  2  A5 57                   lda Player_X_Speed
00CFB5  2  C9 19                   cmp #$19                   ;if player not running, branch
00CFB7  2  90 08                   bcc ChkSpinyO
00CFB9  2  AD 75 07                lda ScrollAmount
00CFBC  2  C9 02                   cmp #$02                   ;if scroll speed below a certain amount, branch
00CFBE  2  90 01                   bcc ChkSpinyO              ;to same place
00CFC0  2  C8                      iny                        ;otherwise increment once more
00CFC1  2  B5 16        ChkSpinyO: lda Enemy_ID,x             ;check for spiny object
00CFC3  2  C9 12                   cmp #Spiny
00CFC5  2  D0 04                   bne ChkEmySpd              ;branch if not found
00CFC7  2  A5 57                   lda Player_X_Speed         ;if player not moving, skip this part
00CFC9  2  D0 06                   bne SubDifAdj
00CFCB  2  B5 A0        ChkEmySpd: lda Enemy_Y_Speed,x        ;check vertical speed
00CFCD  2  D0 02                   bne SubDifAdj              ;branch if nonzero
00CFCF  2  A0 00                   ldy #$00                   ;otherwise reinit offset
00CFD1  2  B9 01 00     SubDifAdj: lda $0001,y                ;get one of three saved values from earlier
00CFD4  2  A4 00                   ldy $00                    ;get saved horizontal difference
00CFD6  2  38           SPixelLak: sec                        ;subtract one for each pixel of horizontal difference
00CFD7  2  E9 01                   sbc #$01                   ;from one of three saved values
00CFD9  2  88                      dey
00CFDA  2  10 FA                   bpl SPixelLak              ;branch until all pixels are subtracted, to adjust difference
00CFDC  2  60           ExMoveLak: rts                        ;leave!!!
00CFDD  2               
00CFDD  2               ;-------------------------------------------------------------------------------------
00CFDD  2               ;$04-$05 - used to store name table address in little endian order
00CFDD  2               
00CFDD  2               BridgeCollapseData:
00CFDD  2  1A                 .byte $1a ;axe
00CFDE  2  58                 .byte $58 ;chain
00CFDF  2  98 96 94 92        .byte $98, $96, $94, $92, $90, $8e, $8c ;bridge
00CFE3  2  90 8E 8C     
00CFE6  2  8A 88 86 84        .byte $8a, $88, $86, $84, $82, $80
00CFEA  2  82 80        
00CFEC  2               
00CFEC  2               BridgeCollapse:
00CFEC  2  AE 68 03            ldx BowserFront_Offset    ;get enemy offset for bowser
00CFEF  2  B5 16               lda Enemy_ID,x            ;check enemy object identifier for bowser
00CFF1  2  C9 2D               cmp #Bowser               ;if not found, branch ahead,
00CFF3  2  D0 10               bne SetM2                 ;metatile removal not necessary
00CFF5  2  86 08               stx ObjectOffset          ;store as enemy offset here
00CFF7  2  B5 1E               lda Enemy_State,x         ;if bowser in normal state, skip all of this
00CFF9  2  F0 1A               beq RemoveBridge
00CFFB  2  29 40               and #%01000000            ;if bowser's state has d6 clear, skip to silence music
00CFFD  2  F0 06               beq SetM2
00CFFF  2  B5 CF               lda Enemy_Y_Position,x    ;check bowser's vertical coordinate
00D001  2  C9 E0               cmp #$e0                  ;if bowser not yet low enough, skip this part ahead
00D003  2  90 0A               bcc MoveD_Bowser
00D005  2  A9 80        SetM2: lda #Silence              ;silence music
00D007  2  85 FC               sta EventMusicQueue
00D009  2  EE 72 07            inc OperMode_Task         ;move onto next secondary mode in autoctrl mode
00D00C  2  4C 71 D0            jmp KillAllEnemies        ;jump to empty all enemy slots and then leave
00D00F  2               
00D00F  2               MoveD_Bowser:
00D00F  2  20 8C BF            jsr MoveEnemySlowVert     ;do a sub to move bowser downwards
00D012  2  4C 7B D1            jmp BowserGfxHandler      ;jump to draw bowser's front and rear, then leave
00D015  2               
00D015  2               RemoveBridge:
00D015  2  CE 64 03              dec BowserFeetCounter     ;decrement timer to control bowser's feet
00D018  2  D0 44                 bne NoBFall               ;if not expired, skip all of this
00D01A  2  A9 04                 lda #$04
00D01C  2  8D 64 03              sta BowserFeetCounter     ;otherwise, set timer now
00D01F  2  AD 63 03              lda BowserBodyControls
00D022  2  49 01                 eor #$01                  ;invert bit to control bowser's feet
00D024  2  8D 63 03              sta BowserBodyControls
00D027  2  A9 22                 lda #$22                  ;put high byte of name table address here for now
00D029  2  85 05                 sta $05
00D02B  2  AC 69 03              ldy BridgeCollapseOffset  ;get bridge collapse offset here
00D02E  2  B9 DD CF              lda BridgeCollapseData,y  ;load low byte of name table address and store here
00D031  2  85 04                 sta $04
00D033  2  AC 00 03              ldy VRAM_Buffer1_Offset   ;increment vram buffer offset
00D036  2  C8                    iny
00D037  2  A2 0C                 ldx #$0c                  ;set offset for tile data for sub to draw blank metatile
00D039  2  20 CD 8A              jsr RemBridge             ;do sub here to remove bowser's bridge metatiles
00D03C  2  A6 08                 ldx ObjectOffset          ;get enemy offset
00D03E  2  20 8F 8A              jsr MoveVOffset           ;set new vram buffer offset
00D041  2  A9 08                 lda #Sfx_Blast            ;load the fireworks/gunfire sound into the square 2 sfx
00D043  2  85 FE                 sta Square2SoundQueue     ;queue while at the same time loading the brick
00D045  2  A9 01                 lda #Sfx_BrickShatter     ;shatter sound into the noise sfx queue thus
00D047  2  85 FD                 sta NoiseSoundQueue       ;producing the unique sound of the bridge collapsing
00D049  2  EE 69 03              inc BridgeCollapseOffset  ;increment bridge collapse offset
00D04C  2  AD 69 03              lda BridgeCollapseOffset
00D04F  2  C9 0F                 cmp #$0f                  ;if bridge collapse offset has not yet reached
00D051  2  D0 0B                 bne NoBFall               ;the end, go ahead and skip this part
00D053  2  20 63 C3              jsr InitVStf              ;initialize whatever vertical speed bowser has
00D056  2  A9 40                 lda #%01000000
00D058  2  95 1E                 sta Enemy_State,x         ;set bowser's state to one of defeated states (d6 set)
00D05A  2  A9 80                 lda #Sfx_BowserFall
00D05C  2  85 FE                 sta Square2SoundQueue     ;play bowser defeat sound
00D05E  2  4C 7B D1     NoBFall: jmp BowserGfxHandler      ;jump to code that draws bowser
00D061  2               
00D061  2               ;--------------------------------
00D061  2               
00D061  2               PRandomRange:
00D061  2  21 41 11 31        .byte $21, $41, $11, $31
00D065  2               
00D065  2               RunBowser:
00D065  2  B5 1E              lda Enemy_State,x       ;if d5 in enemy state is not set
00D067  2  29 20              and #%00100000          ;then branch elsewhere to run bowser
00D069  2  F0 14              beq BowserControl
00D06B  2  B5 CF              lda Enemy_Y_Position,x  ;otherwise check vertical position
00D06D  2  C9 E0              cmp #$e0                ;if above a certain point, branch to move defeated bowser
00D06F  2  90 9E              bcc MoveD_Bowser        ;otherwise proceed to KillAllEnemies
00D071  2               
00D071  2               KillAllEnemies:
00D071  2  A2 04                  ldx #$04              ;start with last enemy slot
00D073  2  20 98 C9     KillLoop: jsr EraseEnemyObject  ;branch to kill enemy objects
00D076  2  CA                     dex                   ;move onto next enemy slot
00D077  2  10 FA                  bpl KillLoop          ;do this until all slots are emptied
00D079  2  8D CB 06               sta EnemyFrenzyBuffer ;empty frenzy buffer
00D07C  2  A6 08                  ldx ObjectOffset      ;get enemy object offset and leave
00D07E  2  60                     rts
00D07F  2               
00D07F  2               BowserControl:
00D07F  2  A9 00                   lda #$00
00D081  2  8D CB 06                sta EnemyFrenzyBuffer      ;empty frenzy buffer
00D084  2  AD 47 07                lda TimerControl           ;if master timer control not set,
00D087  2  F0 03                   beq ChkMouth               ;skip jump and execute code here
00D089  2  4C 39 D1                jmp SkipToFB               ;otherwise, jump over a bunch of code
00D08C  2  AD 63 03     ChkMouth:  lda BowserBodyControls     ;check bowser's mouth
00D08F  2  10 03                   bpl FeetTmr                ;if bit clear, go ahead with code here
00D091  2  4C 0F D1                jmp HammerChk              ;otherwise skip a whole section starting here
00D094  2  CE 64 03     FeetTmr:   dec BowserFeetCounter      ;decrement timer to control bowser's feet
00D097  2  D0 0D                   bne ResetMDr               ;if not expired, skip this part
00D099  2  A9 20                   lda #$20                   ;otherwise, reset timer
00D09B  2  8D 64 03                sta BowserFeetCounter
00D09E  2  AD 63 03                lda BowserBodyControls     ;and invert bit used
00D0A1  2  49 01                   eor #%00000001             ;to control bowser's feet
00D0A3  2  8D 63 03                sta BowserBodyControls
00D0A6  2  A5 09        ResetMDr:  lda FrameCounter           ;check frame counter
00D0A8  2  29 0F                   and #%00001111             ;if not on every sixteenth frame, skip
00D0AA  2  D0 04                   bne B_FaceP                ;ahead to continue code
00D0AC  2  A9 02                   lda #$02                   ;otherwise reset moving/facing direction every
00D0AE  2  95 46                   sta Enemy_MovingDir,x      ;sixteen frames
00D0B0  2  BD 8A 07     B_FaceP:   lda EnemyFrameTimer,x      ;if timer set here expired,
00D0B3  2  F0 1C                   beq GetPRCmp               ;branch to next section
00D0B5  2  20 43 E1                jsr PlayerEnemyDiff        ;get horizontal difference between player and bowser,
00D0B8  2  10 17                   bpl GetPRCmp               ;and branch if bowser to the right of the player
00D0BA  2  A9 01                   lda #$01
00D0BC  2  95 46                   sta Enemy_MovingDir,x      ;set bowser to move and face to the right
00D0BE  2  A9 02                   lda #$02
00D0C0  2  8D 65 03                sta BowserMovementSpeed    ;set movement speed
00D0C3  2  A9 20                   lda #$20
00D0C5  2  9D 8A 07                sta EnemyFrameTimer,x      ;set timer here
00D0C8  2  8D 90 07                sta BowserFireBreathTimer  ;set timer used for bowser's flame
00D0CB  2  B5 87                   lda Enemy_X_Position,x
00D0CD  2  C9 C8                   cmp #$c8                   ;if bowser to the right past a certain point,
00D0CF  2  B0 3E                   bcs HammerChk              ;skip ahead to some other section
00D0D1  2  A5 09        GetPRCmp:  lda FrameCounter           ;get frame counter
00D0D3  2  29 03                   and #%00000011
00D0D5  2  D0 38                   bne HammerChk              ;execute this code every fourth frame, otherwise branch
00D0D7  2  B5 87                   lda Enemy_X_Position,x
00D0D9  2  CD 66 03                cmp BowserOrigXPos         ;if bowser not at original horizontal position,
00D0DC  2  D0 0C                   bne GetDToO                ;branch to skip this part
00D0DE  2  BD A7 07                lda PseudoRandomBitReg,x
00D0E1  2  29 03                   and #%00000011             ;get pseudorandom offset
00D0E3  2  A8                      tay
00D0E4  2  B9 61 D0                lda PRandomRange,y         ;load value using pseudorandom offset
00D0E7  2  8D DC 06                sta MaxRangeFromOrigin     ;and store here
00D0EA  2  B5 87        GetDToO:   lda Enemy_X_Position,x
00D0EC  2  18                      clc                        ;add movement speed to bowser's horizontal
00D0ED  2  6D 65 03                adc BowserMovementSpeed    ;coordinate and save as new horizontal position
00D0F0  2  95 87                   sta Enemy_X_Position,x
00D0F2  2  B4 46                   ldy Enemy_MovingDir,x
00D0F4  2  C0 01                   cpy #$01                   ;if bowser moving and facing to the right, skip ahead
00D0F6  2  F0 17                   beq HammerChk
00D0F8  2  A0 FF                   ldy #$ff                   ;set default movement speed here (move left)
00D0FA  2  38                      sec                        ;get difference of current vs. original
00D0FB  2  ED 66 03                sbc BowserOrigXPos         ;horizontal position
00D0FE  2  10 07                   bpl CompDToO               ;if current position to the right of original, skip ahead
00D100  2  49 FF                   eor #$ff
00D102  2  18                      clc                        ;get two's compliment
00D103  2  69 01                   adc #$01
00D105  2  A0 01                   ldy #$01                   ;set alternate movement speed here (move right)
00D107  2  CD DC 06     CompDToO:  cmp MaxRangeFromOrigin     ;compare difference with pseudorandom value
00D10A  2  90 03                   bcc HammerChk              ;if difference < pseudorandom value, leave speed alone
00D10C  2  8C 65 03                sty BowserMovementSpeed    ;otherwise change bowser's movement speed
00D10F  2  BD 8A 07     HammerChk: lda EnemyFrameTimer,x      ;if timer set here not expired yet, skip ahead to
00D112  2  D0 28                   bne MakeBJump              ;some other section of code
00D114  2  20 8C BF                jsr MoveEnemySlowVert      ;otherwise start by moving bowser downwards
00D117  2  AD 5F 07                lda WorldNumber            ;check world number
00D11A  2  C9 05                   cmp #World6
00D11C  2  90 09                   bcc SetHmrTmr              ;if world 1-5, skip this part (not time to throw hammers yet)
00D11E  2  A5 09                   lda FrameCounter
00D120  2  29 03                   and #%00000011             ;check to see if it's time to execute sub
00D122  2  D0 03                   bne SetHmrTmr              ;if not, skip sub, otherwise
00D124  2  20 94 BA                jsr SpawnHammerObj         ;execute sub on every fourth frame to spawn misc object (hammer)
00D127  2  B5 CF        SetHmrTmr: lda Enemy_Y_Position,x     ;get current vertical position
00D129  2  C9 80                   cmp #$80                   ;if still above a certain point
00D12B  2  90 1C                   bcc ChkFireB               ;then skip to world number check for flames
00D12D  2  BD A7 07                lda PseudoRandomBitReg,x
00D130  2  29 03                   and #%00000011             ;get pseudorandom offset
00D132  2  A8                      tay
00D133  2  B9 61 D0                lda PRandomRange,y         ;get value using pseudorandom offset
00D136  2  9D 8A 07                sta EnemyFrameTimer,x      ;set for timer here
00D139  2  4C 49 D1     SkipToFB:  jmp ChkFireB               ;jump to execute flames code
00D13C  2  C9 01        MakeBJump: cmp #$01                   ;if timer not yet about to expire,
00D13E  2  D0 09                   bne ChkFireB               ;skip ahead to next part
00D140  2  D6 CF                   dec Enemy_Y_Position,x     ;otherwise decrement vertical coordinate
00D142  2  20 63 C3                jsr InitVStf               ;initialize movement amount
00D145  2  A9 FE                   lda #$fe
00D147  2  95 A0                   sta Enemy_Y_Speed,x        ;set vertical speed to move bowser upwards
00D149  2  AD 5F 07     ChkFireB:  lda WorldNumber            ;check world number here
00D14C  2  C9 07                   cmp #World8                ;world 8?
00D14E  2  F0 04                   beq SpawnFBr               ;if so, execute this part here
00D150  2  C9 05                   cmp #World6                ;world 6-7?
00D152  2  B0 27                   bcs BowserGfxHandler       ;if so, skip this part here
00D154  2  AD 90 07     SpawnFBr:  lda BowserFireBreathTimer  ;check timer here
00D157  2  D0 22                   bne BowserGfxHandler       ;if not expired yet, skip all of this
00D159  2  A9 20                   lda #$20
00D15B  2  8D 90 07                sta BowserFireBreathTimer  ;set timer here
00D15E  2  AD 63 03                lda BowserBodyControls
00D161  2  49 80                   eor #%10000000             ;invert bowser's mouth bit to open
00D163  2  8D 63 03                sta BowserBodyControls     ;and close bowser's mouth
00D166  2  30 E1                   bmi ChkFireB               ;if bowser's mouth open, loop back
00D168  2  20 D9 D1                jsr SetFlameTimer          ;get timing for bowser's flame
00D16B  2  AC CC 06                ldy SecondaryHardMode
00D16E  2  F0 03                   beq SetFBTmr               ;if secondary hard mode flag not set, skip this
00D170  2  38                      sec
00D171  2  E9 10                   sbc #$10                   ;otherwise subtract from value in A
00D173  2  8D 90 07     SetFBTmr:  sta BowserFireBreathTimer  ;set value as timer here
00D176  2  A9 15                   lda #BowserFlame           ;put bowser's flame identifier
00D178  2  8D CB 06                sta EnemyFrenzyBuffer      ;in enemy frenzy buffer
00D17B  2               
00D17B  2               ;--------------------------------
00D17B  2               
00D17B  2               BowserGfxHandler:
00D17B  2  20 BC D1               jsr ProcessBowserHalf    ;do a sub here to process bowser's front
00D17E  2  A0 10                  ldy #$10                 ;load default value here to position bowser's rear
00D180  2  B5 46                  lda Enemy_MovingDir,x    ;check moving direction
00D182  2  4A                     lsr
00D183  2  90 02                  bcc CopyFToR             ;if moving left, use default
00D185  2  A0 F0                  ldy #$f0                 ;otherwise load alternate positioning value here
00D187  2  98           CopyFToR: tya                      ;move bowser's rear object position value to A
00D188  2  18                     clc
00D189  2  75 87                  adc Enemy_X_Position,x   ;add to bowser's front object horizontal coordinate
00D18B  2  AC CF 06               ldy DuplicateObj_Offset  ;get bowser's rear object offset
00D18E  2  99 87 00               sta Enemy_X_Position,y   ;store A as bowser's rear horizontal coordinate
00D191  2  B5 CF                  lda Enemy_Y_Position,x
00D193  2  18                     clc                      ;add eight pixels to bowser's front object
00D194  2  69 08                  adc #$08                 ;vertical coordinate and store as vertical coordinate
00D196  2  99 CF 00               sta Enemy_Y_Position,y   ;for bowser's rear
00D199  2  B5 1E                  lda Enemy_State,x
00D19B  2  99 1E 00               sta Enemy_State,y        ;copy enemy state directly from front to rear
00D19E  2  B5 46                  lda Enemy_MovingDir,x
00D1A0  2  99 46 00               sta Enemy_MovingDir,y    ;copy moving direction also
00D1A3  2  A5 08                  lda ObjectOffset         ;save enemy object offset of front to stack
00D1A5  2  48                     pha
00D1A6  2  AE CF 06               ldx DuplicateObj_Offset  ;put enemy object offset of rear as current
00D1A9  2  86 08                  stx ObjectOffset
00D1AB  2  A9 2D                  lda #Bowser              ;set bowser's enemy identifier
00D1AD  2  95 16                  sta Enemy_ID,x           ;store in bowser's rear object
00D1AF  2  20 BC D1               jsr ProcessBowserHalf    ;do a sub here to process bowser's rear
00D1B2  2  68                     pla
00D1B3  2  85 08                  sta ObjectOffset         ;get original enemy object offset
00D1B5  2  AA                     tax
00D1B6  2  A9 00                  lda #$00                 ;nullify bowser's front/rear graphics flag
00D1B8  2  8D 6A 03               sta BowserGfxFlag
00D1BB  2  60           ExBGfxH:  rts                      ;leave!
00D1BC  2               
00D1BC  2               ProcessBowserHalf:
00D1BC  2  EE 6A 03           inc BowserGfxFlag         ;increment bowser's graphics flag, then run subroutines
00D1BF  2  20 D7 C8           jsr RunRetainerObj        ;to get offscreen bits, relative position and draw bowser (finally!)
00D1C2  2  B5 1E              lda Enemy_State,x
00D1C4  2  D0 F5              bne ExBGfxH               ;if either enemy object not in normal state, branch to leave
00D1C6  2  A9 0A              lda #$0a
00D1C8  2  9D 9A 04           sta Enemy_BoundBoxCtrl,x  ;set bounding box size control
00D1CB  2  20 43 E2           jsr GetEnemyBoundBox      ;get bounding box coordinates
00D1CE  2  4C 53 D8           jmp PlayerEnemyCollision  ;do player-to-enemy collision detection
00D1D1  2               
00D1D1  2               ;-------------------------------------------------------------------------------------
00D1D1  2               ;$00 - used to hold movement force and tile number
00D1D1  2               ;$01 - used to hold sprite attribute data
00D1D1  2               
00D1D1  2               FlameTimerData:
00D1D1  2  BF 40 BF BF        .byte $bf, $40, $bf, $bf, $bf, $40, $40, $bf
00D1D5  2  BF 40 40 BF  
00D1D9  2               
00D1D9  2               SetFlameTimer:
00D1D9  2  AC 67 03           ldy BowserFlameTimerCtrl  ;load counter as offset
00D1DC  2  EE 67 03           inc BowserFlameTimerCtrl  ;increment
00D1DF  2  AD 67 03           lda BowserFlameTimerCtrl  ;mask out all but 3 LSB
00D1E2  2  29 07              and #%00000111            ;to keep in range of 0-7
00D1E4  2  8D 67 03           sta BowserFlameTimerCtrl
00D1E7  2  B9 D1 D1           lda FlameTimerData,y      ;load value to be used then leave
00D1EA  2  60           ExFl: rts
00D1EB  2               
00D1EB  2               ProcBowserFlame:
00D1EB  2  AD 47 07              lda TimerControl            ;if master timer control flag set,
00D1EE  2  D0 30                 bne SetGfxF                 ;skip all of this
00D1F0  2  A9 40                 lda #$40                    ;load default movement force
00D1F2  2  AC CC 06              ldy SecondaryHardMode
00D1F5  2  F0 02                 beq SFlmX                   ;if secondary hard mode flag not set, use default
00D1F7  2  A9 60                 lda #$60                    ;otherwise load alternate movement force to go faster
00D1F9  2  85 00        SFlmX:   sta $00                     ;store value here
00D1FB  2  BD 01 04              lda Enemy_X_MoveForce,x
00D1FE  2  38                    sec                         ;subtract value from movement force
00D1FF  2  E5 00                 sbc $00
00D201  2  9D 01 04              sta Enemy_X_MoveForce,x     ;save new value
00D204  2  B5 87                 lda Enemy_X_Position,x
00D206  2  E9 01                 sbc #$01                    ;subtract one from horizontal position to move
00D208  2  95 87                 sta Enemy_X_Position,x      ;to the left
00D20A  2  B5 6E                 lda Enemy_PageLoc,x
00D20C  2  E9 00                 sbc #$00                    ;subtract borrow from page location
00D20E  2  95 6E                 sta Enemy_PageLoc,x
00D210  2  BC 17 04              ldy BowserFlamePRandomOfs,x ;get some value here and use as offset
00D213  2  B5 CF                 lda Enemy_Y_Position,x      ;load vertical coordinate
00D215  2  D9 9D C5              cmp FlameYPosData,y         ;compare against coordinate data using $0417,x as offset
00D218  2  F0 06                 beq SetGfxF                 ;if equal, branch and do not modify coordinate
00D21A  2  18                    clc
00D21B  2  7D 34 04              adc Enemy_Y_MoveForce,x     ;otherwise add value here to coordinate and store
00D21E  2  95 CF                 sta Enemy_Y_Position,x      ;as new vertical coordinate
00D220  2  20 52 F1     SetGfxF: jsr RelativeEnemyPosition   ;get new relative coordinates
00D223  2  B5 1E                 lda Enemy_State,x           ;if bowser's flame not in normal state,
00D225  2  D0 C3                 bne ExFl                    ;branch to leave
00D227  2  A9 51                 lda #$51                    ;otherwise, continue
00D229  2  85 00                 sta $00                     ;write first tile number
00D22B  2  A0 02                 ldy #$02                    ;load attributes without vertical flip by default
00D22D  2  A5 09                 lda FrameCounter
00D22F  2  29 02                 and #%00000010              ;invert vertical flip bit every 2 frames
00D231  2  F0 02                 beq FlmeAt                  ;if d1 not set, write default value
00D233  2  A0 82                 ldy #$82                    ;otherwise write value with vertical flip bit set
00D235  2  84 01        FlmeAt:  sty $01                     ;set bowser's flame sprite attributes here
00D237  2  BC E5 06              ldy Enemy_SprDataOffset,x   ;get OAM data offset
00D23A  2  A2 00                 ldx #$00
00D23C  2               
00D23C  2               DrawFlameLoop:
00D23C  2  AD B9 03              lda Enemy_Rel_YPos         ;get Y relative coordinate of current enemy object
00D23F  2  99 00 02              sta Sprite_Y_Position,y    ;write into Y coordinate of OAM data
00D242  2  A5 00                 lda $00
00D244  2  99 01 02              sta Sprite_Tilenumber,y    ;write current tile number into OAM data
00D247  2  E6 00                 inc $00                    ;increment tile number to draw more bowser's flame
00D249  2  A5 01                 lda $01
00D24B  2  99 02 02              sta Sprite_Attributes,y    ;write saved attributes into OAM data
00D24E  2  AD AE 03              lda Enemy_Rel_XPos
00D251  2  99 03 02              sta Sprite_X_Position,y    ;write X relative coordinate of current enemy object
00D254  2  18                    clc
00D255  2  69 08                 adc #$08
00D257  2  8D AE 03              sta Enemy_Rel_XPos         ;then add eight to it and store
00D25A  2  C8                    iny
00D25B  2  C8                    iny
00D25C  2  C8                    iny
00D25D  2  C8                    iny                        ;increment Y four times to move onto the next OAM
00D25E  2  E8                    inx                        ;move onto the next OAM, and branch if three
00D25F  2  E0 03                 cpx #$03                   ;have not yet been done
00D261  2  90 D9                 bcc DrawFlameLoop
00D263  2  A6 08                 ldx ObjectOffset           ;reload original enemy offset
00D265  2  20 AF F1              jsr GetEnemyOffscreenBits  ;get offscreen information
00D268  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00D26B  2  AD D1 03              lda Enemy_OffscreenBits    ;get enemy object offscreen bits
00D26E  2  4A                    lsr                        ;move d0 to carry and result to stack
00D26F  2  48                    pha
00D270  2  90 05                 bcc M3FOfs                 ;branch if carry not set
00D272  2  A9 F8                 lda #$f8                   ;otherwise move sprite offscreen, this part likely
00D274  2  99 0C 02              sta Sprite_Y_Position+12,y ;residual since flame is only made of three sprites
00D277  2  68           M3FOfs:  pla                        ;get bits from stack
00D278  2  4A                    lsr                        ;move d1 to carry and move bits back to stack
00D279  2  48                    pha
00D27A  2  90 05                 bcc M2FOfs                 ;branch if carry not set again
00D27C  2  A9 F8                 lda #$f8                   ;otherwise move third sprite offscreen
00D27E  2  99 08 02              sta Sprite_Y_Position+8,y
00D281  2  68           M2FOfs:  pla                        ;get bits from stack again
00D282  2  4A                    lsr                        ;move d2 to carry and move bits back to stack again
00D283  2  48                    pha
00D284  2  90 05                 bcc M1FOfs                 ;branch if carry not set yet again
00D286  2  A9 F8                 lda #$f8                   ;otherwise move second sprite offscreen
00D288  2  99 04 02              sta Sprite_Y_Position+4,y
00D28B  2  68           M1FOfs:  pla                        ;get bits from stack one last time
00D28C  2  4A                    lsr                        ;move d3 to carry
00D28D  2  90 05                 bcc ExFlmeD                ;branch if carry not set one last time
00D28F  2  A9 F8                 lda #$f8
00D291  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move first sprite offscreen
00D294  2  60           ExFlmeD: rts                        ;leave
00D295  2               
00D295  2               ;--------------------------------
00D295  2               
00D295  2               RunFireworks:
00D295  2  D6 A0                   dec ExplosionTimerCounter,x ;decrement explosion timing counter here
00D297  2  D0 0C                   bne SetupExpl               ;if not expired, skip this part
00D299  2  A9 08                   lda #$08
00D29B  2  95 A0                   sta ExplosionTimerCounter,x ;reset counter
00D29D  2  F6 58                   inc ExplosionGfxCounter,x   ;increment explosion graphics counter
00D29F  2  B5 58                   lda ExplosionGfxCounter,x
00D2A1  2  C9 03                   cmp #$03                    ;check explosion graphics counter
00D2A3  2  B0 18                   bcs FireworksSoundScore     ;if at a certain point, branch to kill this object
00D2A5  2  20 52 F1     SetupExpl: jsr RelativeEnemyPosition   ;get relative coordinates of explosion
00D2A8  2  AD B9 03                lda Enemy_Rel_YPos          ;copy relative coordinates
00D2AB  2  8D BA 03                sta Fireball_Rel_YPos       ;from the enemy object to the fireball object
00D2AE  2  AD AE 03                lda Enemy_Rel_XPos          ;first vertical, then horizontal
00D2B1  2  8D AF 03                sta Fireball_Rel_XPos
00D2B4  2  BC E5 06                ldy Enemy_SprDataOffset,x   ;get OAM data offset
00D2B7  2  B5 58                   lda ExplosionGfxCounter,x   ;get explosion graphics counter
00D2B9  2  20 17 ED                jsr DrawExplosion_Fireworks ;do a sub to draw the explosion then leave
00D2BC  2  60                      rts
00D2BD  2               
00D2BD  2               FireworksSoundScore:
00D2BD  2  A9 00              lda #$00               ;disable enemy buffer flag
00D2BF  2  95 0F              sta Enemy_Flag,x
00D2C1  2  A9 08              lda #Sfx_Blast         ;play fireworks/gunfire sound
00D2C3  2  85 FE              sta Square2SoundQueue
00D2C5  2  A9 05              lda #$05               ;set part of score modifier for 500 points
00D2C7  2  8D 38 01           sta DigitModifier+4
00D2CA  2  4C 36 D3           jmp EndAreaPoints     ;jump to award points accordingly then leave
00D2CD  2               
00D2CD  2               ;--------------------------------
00D2CD  2               
00D2CD  2               StarFlagYPosAdder:
00D2CD  2  00 00 08 08        .byte $00, $00, $08, $08
00D2D1  2               
00D2D1  2               StarFlagXPosAdder:
00D2D1  2  00 08 00 08        .byte $00, $08, $00, $08
00D2D5  2               
00D2D5  2               StarFlagTileData:
00D2D5  2  54 55 56 57        .byte $54, $55, $56, $57
00D2D9  2               
00D2D9  2               RunStarFlagObj:
00D2D9  2  A9 00              lda #$00                 ;initialize enemy frenzy buffer
00D2DB  2  8D CB 06           sta EnemyFrenzyBuffer
00D2DE  2  AD 46 07           lda StarFlagTaskControl  ;check star flag object task number here
00D2E1  2  C9 05              cmp #$05                 ;if greater than 5, branch to exit
00D2E3  2  B0 2C              bcs StarFlagExit
00D2E5  2  20 04 8E           jsr JumpEngine           ;otherwise jump to appropriate sub
00D2E8  2               
00D2E8  2  11 D3              .word StarFlagExit
00D2EA  2  F2 D2              .word GameTimerFireworks
00D2EC  2  12 D3              .word AwardGameTimerPoints
00D2EE  2  4E D3              .word RaiseFlagSetoffFWorks
00D2F0  2  A2 D3              .word DelayToAreaEnd
00D2F2  2               
00D2F2  2               GameTimerFireworks:
00D2F2  2  A0 05                ldy #$05               ;set default state for star flag object
00D2F4  2  AD FA 07             lda GameTimerDisplay+2 ;get game timer's last digit
00D2F7  2  C9 01                cmp #$01
00D2F9  2  F0 0E                beq SetFWC             ;if last digit of game timer set to 1, skip ahead
00D2FB  2  A0 03                ldy #$03               ;otherwise load new value for state
00D2FD  2  C9 03                cmp #$03
00D2FF  2  F0 08                beq SetFWC             ;if last digit of game timer set to 3, skip ahead
00D301  2  A0 00                ldy #$00               ;otherwise load one more potential value for state
00D303  2  C9 06                cmp #$06
00D305  2  F0 02                beq SetFWC             ;if last digit of game timer set to 6, skip ahead
00D307  2  A9 FF                lda #$ff               ;otherwise set value for no fireworks
00D309  2  8D D7 06     SetFWC: sta FireworksCounter   ;set fireworks counter here
00D30C  2  94 1E                sty Enemy_State,x      ;set whatever state we have in star flag object
00D30E  2               
00D30E  2               IncrementSFTask1:
00D30E  2  EE 46 07           inc StarFlagTaskControl  ;increment star flag object task number
00D311  2               
00D311  2               StarFlagExit:
00D311  2  60                 rts                      ;leave
00D312  2               
00D312  2               AwardGameTimerPoints:
00D312  2  AD F8 07              lda GameTimerDisplay   ;check all game timer digits for any intervals left
00D315  2  0D F9 07              ora GameTimerDisplay+1
00D318  2  0D FA 07              ora GameTimerDisplay+2
00D31B  2  F0 F1                 beq IncrementSFTask1   ;if no time left on game timer at all, branch to next task
00D31D  2  A5 09                 lda FrameCounter
00D31F  2  29 04                 and #%00000100         ;check frame counter for d2 set (skip ahead
00D321  2  F0 04                 beq NoTTick            ;for four frames every four frames) branch if not set
00D323  2  A9 10                 lda #Sfx_TimerTick
00D325  2  85 FE                 sta Square2SoundQueue  ;load timer tick sound
00D327  2  A0 23        NoTTick: ldy #$23               ;set offset here to subtract from game timer's last digit
00D329  2  A9 FF                 lda #$ff               ;set adder here to $ff, or -1, to subtract one
00D32B  2  8D 39 01              sta DigitModifier+5    ;from the last digit of the game timer
00D32E  2  20 5F 8F              jsr DigitsMathRoutine  ;subtract digit
00D331  2  A9 05                 lda #$05               ;set now to add 50 points
00D333  2  8D 39 01              sta DigitModifier+5    ;per game timer interval subtracted
00D336  2               
00D336  2               EndAreaPoints:
00D336  2  A0 0B                 ldy #$0b               ;load offset for mario's score by default
00D338  2  AD 53 07              lda CurrentPlayer      ;check player on the screen
00D33B  2  F0 02                 beq ELPGive            ;if mario, do not change
00D33D  2  A0 11                 ldy #$11               ;otherwise load offset for luigi's score
00D33F  2  20 5F 8F     ELPGive: jsr DigitsMathRoutine  ;award 50 points per game timer interval
00D342  2  AD 53 07              lda CurrentPlayer      ;get player on the screen (or 500 points per
00D345  2  0A                    asl                    ;fireworks explosion if branched here from there)
00D346  2  0A                    asl                    ;shift to high nybble
00D347  2  0A                    asl
00D348  2  0A                    asl
00D349  2  09 04                 ora #%00000100         ;add four to set nybble for game timer
00D34B  2  4C 36 BC              jmp UpdateNumber       ;jump to print the new score and game timer
00D34E  2               
00D34E  2               RaiseFlagSetoffFWorks:
00D34E  2  B5 CF                 lda Enemy_Y_Position,x  ;check star flag's vertical position
00D350  2  C9 72                 cmp #$72                ;against preset value
00D352  2  90 05                 bcc SetoffF             ;if star flag higher vertically, branch to other code
00D354  2  D6 CF                 dec Enemy_Y_Position,x  ;otherwise, raise star flag by one pixel
00D356  2  4C 65 D3              jmp DrawStarFlag        ;and skip this part here
00D359  2  AD D7 06     SetoffF: lda FireworksCounter    ;check fireworks counter
00D35C  2  F0 38                 beq DrawFlagSetTimer    ;if no fireworks left to go off, skip this part
00D35E  2  30 36                 bmi DrawFlagSetTimer    ;if no fireworks set to go off, skip this part
00D360  2  A9 16                 lda #Fireworks
00D362  2  8D CB 06              sta EnemyFrenzyBuffer   ;otherwise set fireworks object in frenzy queue
00D365  2               
00D365  2               DrawStarFlag:
00D365  2  20 52 F1              jsr RelativeEnemyPosition  ;get relative coordinates of star flag
00D368  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get OAM data offset
00D36B  2  A2 03                 ldx #$03                   ;do four sprites
00D36D  2  AD B9 03     DSFLoop: lda Enemy_Rel_YPos         ;get relative vertical coordinate
00D370  2  18                    clc
00D371  2  7D CD D2              adc StarFlagYPosAdder,x    ;add Y coordinate adder data
00D374  2  99 00 02              sta Sprite_Y_Position,y    ;store as Y coordinate
00D377  2  BD D5 D2              lda StarFlagTileData,x     ;get tile number
00D37A  2  99 01 02              sta Sprite_Tilenumber,y    ;store as tile number
00D37D  2  A9 22                 lda #$22                   ;set palette and background priority bits
00D37F  2  99 02 02              sta Sprite_Attributes,y    ;store as attributes
00D382  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00D385  2  18                    clc
00D386  2  7D D1 D2              adc StarFlagXPosAdder,x    ;add X coordinate adder data
00D389  2  99 03 02              sta Sprite_X_Position,y    ;store as X coordinate
00D38C  2  C8                    iny
00D38D  2  C8                    iny                        ;increment OAM data offset four bytes
00D38E  2  C8                    iny                        ;for next sprite
00D38F  2  C8                    iny
00D390  2  CA                    dex                        ;move onto next sprite
00D391  2  10 DA                 bpl DSFLoop                ;do this until all sprites are done
00D393  2  A6 08                 ldx ObjectOffset           ;get enemy object offset and leave
00D395  2  60                    rts
00D396  2               
00D396  2               DrawFlagSetTimer:
00D396  2  20 65 D3           jsr DrawStarFlag          ;do sub to draw star flag
00D399  2  A9 06              lda #$06
00D39B  2  9D 96 07           sta EnemyIntervalTimer,x  ;set interval timer here
00D39E  2               
00D39E  2               IncrementSFTask2:
00D39E  2  EE 46 07           inc StarFlagTaskControl   ;move onto next task
00D3A1  2  60                 rts
00D3A2  2               
00D3A2  2               DelayToAreaEnd:
00D3A2  2  20 65 D3           jsr DrawStarFlag          ;do sub to draw star flag
00D3A5  2  BD 96 07           lda EnemyIntervalTimer,x  ;if interval timer set in previous task
00D3A8  2  D0 05              bne StarFlagExit2         ;not yet expired, branch to leave
00D3AA  2  AD B1 07           lda EventMusicBuffer      ;if event music buffer empty,
00D3AD  2  F0 EF              beq IncrementSFTask2      ;branch to increment task
00D3AF  2               
00D3AF  2               StarFlagExit2:
00D3AF  2  60                 rts                       ;otherwise leave
00D3B0  2               
00D3B0  2               ;--------------------------------
00D3B0  2               ;$00 - used to store horizontal difference between player and piranha plant
00D3B0  2               
00D3B0  2               MovePiranhaPlant:
00D3B0  2  B5 1E              lda Enemy_State,x           ;check enemy state
00D3B2  2  D0 56              bne PutinPipe               ;if set at all, branch to leave
00D3B4  2  BD 8A 07           lda EnemyFrameTimer,x       ;check enemy's timer here
00D3B7  2  D0 51              bne PutinPipe               ;branch to end if not yet expired
00D3B9  2  B5 A0              lda PiranhaPlant_MoveFlag,x ;check movement flag
00D3BB  2  D0 23              bne SetupToMovePPlant       ;if moving, skip to part ahead
00D3BD  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;if currently rising, branch
00D3BF  2  30 14              bmi ReversePlantSpeed       ;to move enemy upwards out of pipe
00D3C1  2  20 43 E1           jsr PlayerEnemyDiff         ;get horizontal difference between player and
00D3C4  2  10 09              bpl ChkPlayerNearPipe       ;piranha plant, and branch if enemy to right of player
00D3C6  2  A5 00              lda $00                     ;otherwise get saved horizontal difference
00D3C8  2  49 FF              eor #$ff
00D3CA  2  18                 clc                         ;and change to two's compliment
00D3CB  2  69 01              adc #$01
00D3CD  2  85 00              sta $00                     ;save as new horizontal difference
00D3CF  2               
00D3CF  2               ChkPlayerNearPipe:
00D3CF  2  A5 00              lda $00                     ;get saved horizontal difference
00D3D1  2  C9 21              cmp #$21
00D3D3  2  90 35              bcc PutinPipe               ;if player within a certain distance, branch to leave
00D3D5  2               
00D3D5  2               ReversePlantSpeed:
00D3D5  2  B5 58              lda PiranhaPlant_Y_Speed,x  ;get vertical speed
00D3D7  2  49 FF              eor #$ff
00D3D9  2  18                 clc                         ;change to two's compliment
00D3DA  2  69 01              adc #$01
00D3DC  2  95 58              sta PiranhaPlant_Y_Speed,x  ;save as new vertical speed
00D3DE  2  F6 A0              inc PiranhaPlant_MoveFlag,x ;increment to set movement flag
00D3E0  2               
00D3E0  2               SetupToMovePPlant:
00D3E0  2  BD 34 04           lda PiranhaPlantDownYPos,x  ;get original vertical coordinate (lowest point)
00D3E3  2  B4 58              ldy PiranhaPlant_Y_Speed,x  ;get vertical speed
00D3E5  2  10 03              bpl RiseFallPiranhaPlant    ;branch if moving downwards
00D3E7  2  BD 17 04           lda PiranhaPlantUpYPos,x    ;otherwise get other vertical coordinate (highest point)
00D3EA  2               
00D3EA  2               RiseFallPiranhaPlant:
00D3EA  2  85 00              sta $00                     ;save vertical coordinate here
00D3EC  2  A5 09              lda FrameCounter            ;get frame counter
00D3EE  2  4A                 lsr
00D3EF  2  90 19              bcc PutinPipe               ;branch to leave if d0 set (execute code every other frame)
00D3F1  2  AD 47 07           lda TimerControl            ;get master timer control
00D3F4  2  D0 14              bne PutinPipe               ;branch to leave if set (likely not necessary)
00D3F6  2  B5 CF              lda Enemy_Y_Position,x      ;get current vertical coordinate
00D3F8  2  18                 clc
00D3F9  2  75 58              adc PiranhaPlant_Y_Speed,x  ;add vertical speed to move up or down
00D3FB  2  95 CF              sta Enemy_Y_Position,x      ;save as new vertical coordinate
00D3FD  2  C5 00              cmp $00                     ;compare against low or high coordinate
00D3FF  2  D0 09              bne PutinPipe               ;branch to leave if not yet reached
00D401  2  A9 00              lda #$00
00D403  2  95 A0              sta PiranhaPlant_MoveFlag,x ;otherwise clear movement flag
00D405  2  A9 40              lda #$40
00D407  2  9D 8A 07           sta EnemyFrameTimer,x       ;set timer to delay piranha plant movement
00D40A  2               
00D40A  2               PutinPipe:
00D40A  2  A9 20              lda #%00100000              ;set background priority bit in sprite
00D40C  2  9D C5 03           sta Enemy_SprAttrib,x       ;attributes to give illusion of being inside pipe
00D40F  2  60                 rts                         ;then leave
00D410  2               
00D410  2               ;-------------------------------------------------------------------------------------
00D410  2               ;$07 - spinning speed
00D410  2               
00D410  2               FirebarSpin:
00D410  2  85 07              sta $07                     ;save spinning speed here
00D412  2  B5 34              lda FirebarSpinDirection,x  ;check spinning direction
00D414  2  D0 0E              bne SpinCounterClockwise    ;if moving counter-clockwise, branch to other part
00D416  2  A0 18              ldy #$18                    ;possibly residual ldy
00D418  2  B5 58              lda FirebarSpinState_Low,x
00D41A  2  18                 clc                         ;add spinning speed to what would normally be
00D41B  2  65 07              adc $07                     ;the horizontal speed
00D41D  2  95 58              sta FirebarSpinState_Low,x
00D41F  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00D421  2  69 00              adc #$00
00D423  2  60                 rts
00D424  2               
00D424  2               SpinCounterClockwise:
00D424  2  A0 08              ldy #$08                    ;possibly residual ldy
00D426  2  B5 58              lda FirebarSpinState_Low,x
00D428  2  38                 sec                         ;subtract spinning speed to what would normally be
00D429  2  E5 07              sbc $07                     ;the horizontal speed
00D42B  2  95 58              sta FirebarSpinState_Low,x
00D42D  2  B5 A0              lda FirebarSpinState_High,x ;add carry to what would normally be the vertical speed
00D42F  2  E9 00              sbc #$00
00D431  2  60                 rts
00D432  2               
00D432  2               ;-------------------------------------------------------------------------------------
00D432  2               ;$00 - used to hold collision flag, Y movement force + 5 or low byte of name table for rope
00D432  2               ;$01 - used to hold high byte of name table for rope
00D432  2               ;$02 - used to hold page location of rope
00D432  2               
00D432  2               BalancePlatform:
00D432  2  B5 B6               lda Enemy_Y_HighPos,x       ;check high byte of vertical position
00D434  2  C9 03               cmp #$03
00D436  2  D0 03               bne DoBPl
00D438  2  4C 98 C9            jmp EraseEnemyObject        ;if far below screen, kill the object
00D43B  2  B5 1E        DoBPl: lda Enemy_State,x           ;get object's state (set to $ff or other platform offset)
00D43D  2  10 01               bpl CheckBalPlatform        ;if doing other balance platform, branch to leave
00D43F  2  60                  rts
00D440  2               
00D440  2               CheckBalPlatform:
00D440  2  A8                  tay                         ;save offset from state as Y
00D441  2  BD A2 03            lda PlatformCollisionFlag,x ;get collision flag of platform
00D444  2  85 00               sta $00                     ;store here
00D446  2  B5 46               lda Enemy_MovingDir,x       ;get moving direction
00D448  2  F0 03               beq ChkForFall
00D44A  2  4C BB D5            jmp PlatformFall            ;if set, jump here
00D44D  2               
00D44D  2               ChkForFall:
00D44D  2  A9 2D               lda #$2d                    ;check if platform is above a certain point
00D44F  2  D5 CF               cmp Enemy_Y_Position,x
00D451  2  90 0F               bcc ChkOtherForFall         ;if not, branch elsewhere
00D453  2  C4 00               cpy $00                     ;if collision flag is set to same value as
00D455  2  F0 08               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00D457  2  18                  clc
00D458  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00D45A  2  95 CF               sta Enemy_Y_Position,x      ;of current platform and branch elsewhere
00D45C  2  4C B1 D5            jmp StopPlatforms           ;to make platforms stop
00D45F  2               
00D45F  2               MakePlatformFall:
00D45F  2  4C 98 D5            jmp InitPlatformFall        ;make platforms fall
00D462  2               
00D462  2               ChkOtherForFall:
00D462  2  D9 CF 00            cmp Enemy_Y_Position,y      ;check if other platform is above a certain point
00D465  2  90 0D               bcc ChkToMoveBalPlat        ;if not, branch elsewhere
00D467  2  E4 00               cpx $00                     ;if collision flag is set to same value as
00D469  2  F0 F4               beq MakePlatformFall        ;enemy state, branch to make platforms fall
00D46B  2  18                  clc
00D46C  2  69 02               adc #$02                    ;otherwise add 2 pixels to vertical position
00D46E  2  99 CF 00            sta Enemy_Y_Position,y      ;of other platform and branch elsewhere
00D471  2  4C B1 D5            jmp StopPlatforms           ;jump to stop movement and do not return
00D474  2               
00D474  2               ChkToMoveBalPlat:
00D474  2  B5 CF                lda Enemy_Y_Position,x      ;save vertical position to stack
00D476  2  48                   pha
00D477  2  BD A2 03             lda PlatformCollisionFlag,x ;get collision flag
00D47A  2  10 18                bpl ColFlg                  ;branch if collision
00D47C  2  BD 34 04             lda Enemy_Y_MoveForce,x
00D47F  2  18                   clc                         ;add $05 to contents of moveforce, whatever they be
00D480  2  69 05                adc #$05
00D482  2  85 00                sta $00                     ;store here
00D484  2  B5 A0                lda Enemy_Y_Speed,x
00D486  2  69 00                adc #$00                    ;add carry to vertical speed
00D488  2  30 1A                bmi PlatDn                  ;branch if moving downwards
00D48A  2  D0 0C                bne PlatUp                  ;branch elsewhere if moving upwards
00D48C  2  A5 00                lda $00
00D48E  2  C9 0B                cmp #$0b                    ;check if there's still a little force left
00D490  2  90 0C                bcc PlatSt                  ;if not enough, branch to stop movement
00D492  2  B0 04                bcs PlatUp                  ;otherwise keep branch to move upwards
00D494  2  C5 08        ColFlg: cmp ObjectOffset            ;if collision flag matches
00D496  2  F0 0C                beq PlatDn                  ;current enemy object offset, branch
00D498  2  20 B7 BF     PlatUp: jsr MovePlatformUp          ;do a sub to move upwards
00D49B  2  4C A7 D4             jmp DoOtherPlatform         ;jump ahead to remaining code
00D49E  2  20 B1 D5     PlatSt: jsr StopPlatforms           ;do a sub to stop movement
00D4A1  2  4C A7 D4             jmp DoOtherPlatform         ;jump ahead to remaining code
00D4A4  2  20 B4 BF     PlatDn: jsr MovePlatformDown        ;do a sub to move downwards
00D4A7  2               
00D4A7  2               DoOtherPlatform:
00D4A7  2  B4 1E               ldy Enemy_State,x           ;get offset of other platform
00D4A9  2  68                  pla                         ;get old vertical coordinate from stack
00D4AA  2  38                  sec
00D4AB  2  F5 CF               sbc Enemy_Y_Position,x      ;get difference of old vs. new coordinate
00D4AD  2  18                  clc
00D4AE  2  79 CF 00            adc Enemy_Y_Position,y      ;add difference to vertical coordinate of other
00D4B1  2  99 CF 00            sta Enemy_Y_Position,y      ;platform to move it in the opposite direction
00D4B4  2  BD A2 03            lda PlatformCollisionFlag,x ;if no collision, skip this part here
00D4B7  2  30 04               bmi DrawEraseRope
00D4B9  2  AA                  tax                         ;put offset which collision occurred here
00D4BA  2  20 21 DC            jsr PositionPlayerOnVPlat   ;and use it to position player accordingly
00D4BD  2               
00D4BD  2               DrawEraseRope:
00D4BD  2  A4 08                 ldy ObjectOffset            ;get enemy object offset
00D4BF  2  B9 A0 00              lda Enemy_Y_Speed,y         ;check to see if current platform is
00D4C2  2  19 34 04              ora Enemy_Y_MoveForce,y     ;moving at all
00D4C5  2  F0 77                 beq ExitRp                  ;if not, skip all of this and branch to leave
00D4C7  2  AE 00 03              ldx VRAM_Buffer1_Offset     ;get vram buffer offset
00D4CA  2  E0 20                 cpx #$20                    ;if offset beyond a certain point, go ahead
00D4CC  2  B0 70                 bcs ExitRp                  ;and skip this, branch to leave
00D4CE  2  B9 A0 00              lda Enemy_Y_Speed,y
00D4D1  2  48                    pha                         ;save two copies of vertical speed to stack
00D4D2  2  48                    pha
00D4D3  2  20 41 D5              jsr SetupPlatformRope       ;do a sub to figure out where to put new bg tiles
00D4D6  2  A5 01                 lda $01                     ;write name table address to vram buffer
00D4D8  2  9D 01 03              sta VRAM_Buffer1,x          ;first the high byte, then the low
00D4DB  2  A5 00                 lda $00
00D4DD  2  9D 02 03              sta VRAM_Buffer1+1,x
00D4E0  2  A9 02                 lda #$02                    ;set length for 2 bytes
00D4E2  2  9D 03 03              sta VRAM_Buffer1+2,x
00D4E5  2  B9 A0 00              lda Enemy_Y_Speed,y         ;if platform moving upwards, branch
00D4E8  2  30 0D                 bmi EraseR1                 ;to do something else
00D4EA  2  A9 A2                 lda #$a2
00D4EC  2  9D 04 03              sta VRAM_Buffer1+3,x        ;otherwise put tile numbers for left
00D4EF  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram buffer
00D4F1  2  9D 05 03              sta VRAM_Buffer1+4,x
00D4F4  2  4C FF D4              jmp OtherRope               ;jump to skip this part
00D4F7  2  A9 24        EraseR1: lda #$24                    ;put blank tiles in vram buffer
00D4F9  2  9D 04 03              sta VRAM_Buffer1+3,x        ;to erase rope
00D4FC  2  9D 05 03              sta VRAM_Buffer1+4,x
00D4FF  2               
00D4FF  2               OtherRope:
00D4FF  2  B9 1E 00              lda Enemy_State,y           ;get offset of other platform from state
00D502  2  A8                    tay                         ;use as Y here
00D503  2  68                    pla                         ;pull second copy of vertical speed from stack
00D504  2  49 FF                 eor #$ff                    ;invert bits to reverse speed
00D506  2  20 41 D5              jsr SetupPlatformRope       ;do sub again to figure out where to put bg tiles
00D509  2  A5 01                 lda $01                     ;write name table address to vram buffer
00D50B  2  9D 06 03              sta VRAM_Buffer1+5,x        ;this time we're doing putting tiles for
00D50E  2  A5 00                 lda $00                     ;the other platform
00D510  2  9D 07 03              sta VRAM_Buffer1+6,x
00D513  2  A9 02                 lda #$02
00D515  2  9D 08 03              sta VRAM_Buffer1+7,x        ;set length again for 2 bytes
00D518  2  68                    pla                         ;pull first copy of vertical speed from stack
00D519  2  10 0D                 bpl EraseR2                 ;if moving upwards (note inversion earlier), skip this
00D51B  2  A9 A2                 lda #$a2
00D51D  2  9D 09 03              sta VRAM_Buffer1+8,x        ;otherwise put tile numbers for left
00D520  2  A9 A3                 lda #$a3                    ;and right sides of rope in vram
00D522  2  9D 0A 03              sta VRAM_Buffer1+9,x        ;transfer buffer
00D525  2  4C 30 D5              jmp EndRp                   ;jump to skip this part
00D528  2  A9 24        EraseR2: lda #$24                    ;put blank tiles in vram buffer
00D52A  2  9D 09 03              sta VRAM_Buffer1+8,x        ;to erase rope
00D52D  2  9D 0A 03              sta VRAM_Buffer1+9,x
00D530  2  A9 00        EndRp:   lda #$00                    ;put null terminator at the end
00D532  2  9D 0B 03              sta VRAM_Buffer1+10,x
00D535  2  AD 00 03              lda VRAM_Buffer1_Offset     ;add ten bytes to the vram buffer offset
00D538  2  18                    clc                         ;and store
00D539  2  69 0A                 adc #10
00D53B  2  8D 00 03              sta VRAM_Buffer1_Offset
00D53E  2  A6 08        ExitRp:  ldx ObjectOffset            ;get enemy object buffer offset and leave
00D540  2  60                    rts
00D541  2               
00D541  2               SetupPlatformRope:
00D541  2  48                   pha                     ;save second/third copy to stack
00D542  2  B9 87 00             lda Enemy_X_Position,y  ;get horizontal coordinate
00D545  2  18                   clc
00D546  2  69 08                adc #$08                ;add eight pixels
00D548  2  AE CC 06             ldx SecondaryHardMode   ;if secondary hard mode flag set,
00D54B  2  D0 03                bne GetLRp              ;use coordinate as-is
00D54D  2  18                   clc
00D54E  2  69 10                adc #$10                ;otherwise add sixteen more pixels
00D550  2  48           GetLRp: pha                     ;save modified horizontal coordinate to stack
00D551  2  B9 6E 00             lda Enemy_PageLoc,y
00D554  2  69 00                adc #$00                ;add carry to page location
00D556  2  85 02                sta $02                 ;and save here
00D558  2  68                   pla                     ;pull modified horizontal coordinate
00D559  2  29 F0                and #%11110000          ;from the stack, mask out low nybble
00D55B  2  4A                   lsr                     ;and shift three bits to the right
00D55C  2  4A                   lsr
00D55D  2  4A                   lsr
00D55E  2  85 00                sta $00                 ;store result here as part of name table low byte
00D560  2  B6 CF                ldx Enemy_Y_Position,y  ;get vertical coordinate
00D562  2  68                   pla                     ;get second/third copy of vertical speed from stack
00D563  2  10 05                bpl GetHRp              ;skip this part if moving downwards or not at all
00D565  2  8A                   txa
00D566  2  18                   clc
00D567  2  69 08                adc #$08                ;add eight to vertical coordinate and
00D569  2  AA                   tax                     ;save as X
00D56A  2  8A           GetHRp: txa                     ;move vertical coordinate to A
00D56B  2  AE 00 03             ldx VRAM_Buffer1_Offset ;get vram buffer offset
00D56E  2  0A                   asl
00D56F  2  2A                   rol                     ;rotate d7 to d0 and d6 into carry
00D570  2  48                   pha                     ;save modified vertical coordinate to stack
00D571  2  2A                   rol                     ;rotate carry to d0, thus d7 and d6 are at 2 LSB
00D572  2  29 03                and #%00000011          ;mask out all bits but d7 and d6, then set
00D574  2  09 20                ora #%00100000          ;d5 to get appropriate high byte of name table
00D576  2  85 01                sta $01                 ;address, then store
00D578  2  A5 02                lda $02                 ;get saved page location from earlier
00D57A  2  29 01                and #$01                ;mask out all but LSB
00D57C  2  0A                   asl
00D57D  2  0A                   asl                     ;shift twice to the left and save with the
00D57E  2  05 01                ora $01                 ;rest of the bits of the high byte, to get
00D580  2  85 01                sta $01                 ;the proper name table and the right place on it
00D582  2  68                   pla                     ;get modified vertical coordinate from stack
00D583  2  29 E0                and #%11100000          ;mask out low nybble and LSB of high nybble
00D585  2  18                   clc
00D586  2  65 00                adc $00                 ;add to horizontal part saved here
00D588  2  85 00                sta $00                 ;save as name table low byte
00D58A  2  B9 CF 00             lda Enemy_Y_Position,y
00D58D  2  C9 E8                cmp #$e8                ;if vertical position not below the
00D58F  2  90 06                bcc ExPRp               ;bottom of the screen, we're done, branch to leave
00D591  2  A5 00                lda $00
00D593  2  29 BF                and #%10111111          ;mask out d6 of low byte of name table address
00D595  2  85 00                sta $00
00D597  2  60           ExPRp:  rts                     ;leave!
00D598  2               
00D598  2               InitPlatformFall:
00D598  2  98                 tya                        ;move offset of other platform from Y to X
00D599  2  AA                 tax
00D59A  2  20 AF F1           jsr GetEnemyOffscreenBits  ;get offscreen bits
00D59D  2  A9 06              lda #$06
00D59F  2  20 11 DA           jsr SetupFloateyNumber     ;award 1000 points to player
00D5A2  2  AD AD 03           lda Player_Rel_XPos
00D5A5  2  9D 17 01           sta FloateyNum_X_Pos,x     ;put floatey number coordinates where player is
00D5A8  2  A5 CE              lda Player_Y_Position
00D5AA  2  9D 1E 01           sta FloateyNum_Y_Pos,x
00D5AD  2  A9 01              lda #$01                   ;set moving direction as flag for
00D5AF  2  95 46              sta Enemy_MovingDir,x      ;falling platforms
00D5B1  2               
00D5B1  2               StopPlatforms:
00D5B1  2  20 63 C3           jsr InitVStf             ;initialize vertical speed and low byte
00D5B4  2  99 A0 00           sta Enemy_Y_Speed,y      ;for both platforms and leave
00D5B7  2  99 34 04           sta Enemy_Y_MoveForce,y
00D5BA  2  60                 rts
00D5BB  2               
00D5BB  2               PlatformFall:
00D5BB  2  98                 tya                         ;save offset for other platform to stack
00D5BC  2  48                 pha
00D5BD  2  20 6B BF           jsr MoveFallingPlatform     ;make current platform fall
00D5C0  2  68                 pla
00D5C1  2  AA                 tax                         ;pull offset from stack and save to X
00D5C2  2  20 6B BF           jsr MoveFallingPlatform     ;make other platform fall
00D5C5  2  A6 08              ldx ObjectOffset
00D5C7  2  BD A2 03           lda PlatformCollisionFlag,x ;if player not standing on either platform,
00D5CA  2  30 04              bmi ExPF                    ;skip this part
00D5CC  2  AA                 tax                         ;transfer collision flag offset as offset to X
00D5CD  2  20 21 DC           jsr PositionPlayerOnVPlat   ;and position player appropriately
00D5D0  2  A6 08        ExPF: ldx ObjectOffset            ;get enemy object buffer offset and leave
00D5D2  2  60                 rts
00D5D3  2               
00D5D3  2               ;--------------------------------
00D5D3  2               
00D5D3  2               YMovingPlatform:
00D5D3  2  B5 A0                lda Enemy_Y_Speed,x          ;if platform moving up or down, skip ahead to
00D5D5  2  1D 34 04             ora Enemy_Y_MoveForce,x      ;check on other position
00D5D8  2  D0 15                bne ChkYCenterPos
00D5DA  2  9D 17 04             sta Enemy_YMF_Dummy,x        ;initialize dummy variable
00D5DD  2  B5 CF                lda Enemy_Y_Position,x
00D5DF  2  DD 01 04             cmp YPlatformTopYPos,x       ;if current vertical position => top position, branch
00D5E2  2  B0 0B                bcs ChkYCenterPos            ;ahead of all this
00D5E4  2  A5 09                lda FrameCounter
00D5E6  2  29 07                and #%00000111               ;check for every eighth frame
00D5E8  2  D0 02                bne SkipIY
00D5EA  2  F6 CF                inc Enemy_Y_Position,x       ;increase vertical position every eighth frame
00D5EC  2  4C FE D5     SkipIY: jmp ChkYPCollision           ;skip ahead to last part
00D5EF  2               
00D5EF  2               ChkYCenterPos:
00D5EF  2  B5 CF                lda Enemy_Y_Position,x       ;if current vertical position < central position, branch
00D5F1  2  D5 58                cmp YPlatformCenterYPos,x    ;to slow ascent/move downwards
00D5F3  2  90 06                bcc YMDown
00D5F5  2  20 B7 BF             jsr MovePlatformUp           ;otherwise start slowing descent/moving upwards
00D5F8  2  4C FE D5             jmp ChkYPCollision
00D5FB  2  20 B4 BF     YMDown: jsr MovePlatformDown         ;start slowing ascent/moving downwards
00D5FE  2               
00D5FE  2               ChkYPCollision:
00D5FE  2  BD A2 03            lda PlatformCollisionFlag,x  ;if collision flag not set here, branch
00D601  2  30 03               bmi ExYPl                    ;to leave
00D603  2  20 21 DC            jsr PositionPlayerOnVPlat    ;otherwise position player appropriately
00D606  2  60           ExYPl: rts                          ;leave
00D607  2               
00D607  2               ;--------------------------------
00D607  2               ;$00 - used as adder to position player hotizontally
00D607  2               
00D607  2               XMovingPlatform:
00D607  2  A9 0E              lda #$0e                     ;load preset maximum value for secondary counter
00D609  2  20 47 CB           jsr XMoveCntr_Platform       ;do a sub to increment counters for movement
00D60C  2  20 66 CB           jsr MoveWithXMCntrs          ;do a sub to move platform accordingly, and return value
00D60F  2  BD A2 03           lda PlatformCollisionFlag,x  ;if no collision with player,
00D612  2  30 1C              bmi ExXMP                    ;branch ahead to leave
00D614  2               
00D614  2               PositionPlayerOnHPlat:
00D614  2  A5 86                 lda Player_X_Position
00D616  2  18                    clc                       ;add saved value from second subroutine to
00D617  2  65 00                 adc $00                   ;current player's position to position
00D619  2  85 86                 sta Player_X_Position     ;player accordingly in horizontal position
00D61B  2  A5 6D                 lda Player_PageLoc        ;get player's page location
00D61D  2  A4 00                 ldy $00                   ;check to see if saved value here is positive or negative
00D61F  2  30 05                 bmi PPHSubt               ;if negative, branch to subtract
00D621  2  69 00                 adc #$00                  ;otherwise add carry to page location
00D623  2  4C 28 D6              jmp SetPVar               ;jump to skip subtraction
00D626  2  E9 00        PPHSubt: sbc #$00                  ;subtract borrow from page location
00D628  2  85 6D        SetPVar: sta Player_PageLoc        ;save result to player's page location
00D62A  2  8C A1 03              sty Platform_X_Scroll     ;put saved value from second sub here to be used later
00D62D  2  20 21 DC              jsr PositionPlayerOnVPlat ;position player vertically and appropriately
00D630  2  60           ExXMP:   rts                       ;and we are done here
00D631  2               
00D631  2               ;--------------------------------
00D631  2               
00D631  2               DropPlatform:
00D631  2  BD A2 03            lda PlatformCollisionFlag,x  ;if no collision between platform and player
00D634  2  30 06               bmi ExDPl                    ;occurred, just leave without moving anything
00D636  2  20 88 BF            jsr MoveDropPlatform         ;otherwise do a sub to move platform down very quickly
00D639  2  20 21 DC            jsr PositionPlayerOnVPlat    ;do a sub to position player appropriately
00D63C  2  60           ExDPl: rts                          ;leave
00D63D  2               
00D63D  2               ;--------------------------------
00D63D  2               ;$00 - residual value from sub
00D63D  2               
00D63D  2               RightPlatform:
00D63D  2  20 02 BF            jsr MoveEnemyHorizontally     ;move platform with current horizontal speed, if any
00D640  2  85 00               sta $00                       ;store saved value here (residual code)
00D642  2  BD A2 03            lda PlatformCollisionFlag,x   ;check collision flag, if no collision between player
00D645  2  30 07               bmi ExRPl                     ;and platform, branch ahead, leave speed unaltered
00D647  2  A9 10               lda #$10
00D649  2  95 58               sta Enemy_X_Speed,x           ;otherwise set new speed (gets moving if motionless)
00D64B  2  20 14 D6            jsr PositionPlayerOnHPlat     ;use saved value from earlier sub to position player
00D64E  2  60           ExRPl: rts                           ;then leave
00D64F  2               
00D64F  2               ;--------------------------------
00D64F  2               
00D64F  2               MoveLargeLiftPlat:
00D64F  2  20 5B D6           jsr MoveLiftPlatforms  ;execute common to all large and small lift platforms
00D652  2  4C FE D5           jmp ChkYPCollision     ;branch to position player correctly
00D655  2               
00D655  2               MoveSmallPlatform:
00D655  2  20 5B D6           jsr MoveLiftPlatforms      ;execute common to all large and small lift platforms
00D658  2  4C 71 D6           jmp ChkSmallPlatCollision  ;branch to position player correctly
00D65B  2               
00D65B  2               MoveLiftPlatforms:
00D65B  2  AD 47 07           lda TimerControl         ;if master timer control set, skip all of this
00D65E  2  D0 19              bne ExLiftP              ;and branch to leave
00D660  2  BD 17 04           lda Enemy_YMF_Dummy,x
00D663  2  18                 clc                      ;add contents of movement amount to whatever's here
00D664  2  7D 34 04           adc Enemy_Y_MoveForce,x
00D667  2  9D 17 04           sta Enemy_YMF_Dummy,x
00D66A  2  B5 CF              lda Enemy_Y_Position,x   ;add whatever vertical speed is set to current
00D66C  2  75 A0              adc Enemy_Y_Speed,x      ;vertical position plus carry to move up or down
00D66E  2  95 CF              sta Enemy_Y_Position,x   ;and then leave
00D670  2  60                 rts
00D671  2               
00D671  2               ChkSmallPlatCollision:
00D671  2  BD A2 03              lda PlatformCollisionFlag,x ;get bounding box counter saved in collision flag
00D674  2  F0 03                 beq ExLiftP                 ;if none found, leave player position alone
00D676  2  20 19 DC              jsr PositionPlayerOnS_Plat  ;use to position player correctly
00D679  2  60           ExLiftP: rts                         ;then leave
00D67A  2               
00D67A  2               ;-------------------------------------------------------------------------------------
00D67A  2               ;$00 - page location of extended left boundary
00D67A  2               ;$01 - extended left boundary position
00D67A  2               ;$02 - page location of extended right boundary
00D67A  2               ;$03 - extended right boundary position
00D67A  2               
00D67A  2               OffscreenBoundsCheck:
00D67A  2  B5 16                  lda Enemy_ID,x          ;check for cheep-cheep object
00D67C  2  C9 14                  cmp #FlyingCheepCheep   ;branch to leave if found
00D67E  2  F0 55                  beq ExScrnBd
00D680  2  AD 1C 07               lda ScreenLeft_X_Pos    ;get horizontal coordinate for left side of screen
00D683  2  B4 16                  ldy Enemy_ID,x
00D685  2  C0 05                  cpy #HammerBro          ;check for hammer bro object
00D687  2  F0 04                  beq LimitB
00D689  2  C0 0D                  cpy #PiranhaPlant       ;check for piranha plant object
00D68B  2  D0 02                  bne ExtendLB            ;these two will be erased sooner than others if too far left
00D68D  2  69 38        LimitB:   adc #$38                ;add 56 pixels to coordinate if hammer bro or piranha plant
00D68F  2  E9 48        ExtendLB: sbc #$48                ;subtract 72 pixels regardless of enemy object
00D691  2  85 01                  sta $01                 ;store result here
00D693  2  AD 1A 07               lda ScreenLeft_PageLoc
00D696  2  E9 00                  sbc #$00                ;subtract borrow from page location of left side
00D698  2  85 00                  sta $00                 ;store result here
00D69A  2  AD 1D 07               lda ScreenRight_X_Pos   ;add 72 pixels to the right side horizontal coordinate
00D69D  2  69 48                  adc #$48
00D69F  2  85 03                  sta $03                 ;store result here
00D6A1  2  AD 1B 07               lda ScreenRight_PageLoc
00D6A4  2  69 00                  adc #$00                ;then add the carry to the page location
00D6A6  2  85 02                  sta $02                 ;and store result here
00D6A8  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D6AA  2  C5 01                  cmp $01                 ;to modified horizontal left edge coordinate to get carry
00D6AC  2  B5 6E                  lda Enemy_PageLoc,x
00D6AE  2  E5 00                  sbc $00                 ;then subtract it from the page coordinate of the enemy object
00D6B0  2  30 20                  bmi TooFar              ;if enemy object is too far left, branch to erase it
00D6B2  2  B5 87                  lda Enemy_X_Position,x  ;compare horizontal coordinate of the enemy object
00D6B4  2  C5 03                  cmp $03                 ;to modified horizontal right edge coordinate to get carry
00D6B6  2  B5 6E                  lda Enemy_PageLoc,x
00D6B8  2  E5 02                  sbc $02                 ;then subtract it from the page coordinate of the enemy object
00D6BA  2  30 19                  bmi ExScrnBd            ;if enemy object is on the screen, leave, do not erase enemy
00D6BC  2  B5 1E                  lda Enemy_State,x       ;if at this point, enemy is offscreen to the right, so check
00D6BE  2  C9 05                  cmp #HammerBro          ;if in state used by spiny's egg, do not erase
00D6C0  2  F0 13                  beq ExScrnBd
00D6C2  2  C0 0D                  cpy #PiranhaPlant       ;if piranha plant, do not erase
00D6C4  2  F0 0F                  beq ExScrnBd
00D6C6  2  C0 30                  cpy #FlagpoleFlagObject ;if flagpole flag, do not erase
00D6C8  2  F0 0B                  beq ExScrnBd
00D6CA  2  C0 31                  cpy #StarFlagObject     ;if star flag, do not erase
00D6CC  2  F0 07                  beq ExScrnBd
00D6CE  2  C0 32                  cpy #JumpspringObject   ;if jumpspring, do not erase
00D6D0  2  F0 03                  beq ExScrnBd            ;erase all others too far to the right
00D6D2  2  20 98 C9     TooFar:   jsr EraseEnemyObject    ;erase object if necessary
00D6D5  2  60           ExScrnBd: rts                     ;leave
00D6D6  2               
00D6D6  2               ;-------------------------------------------------------------------------------------
00D6D6  2               
00D6D6  2               ;some unused space
00D6D6  2  FF FF FF           .byte $ff, $ff, $ff
00D6D9  2               
00D6D9  2               ;-------------------------------------------------------------------------------------
00D6D9  2               ;$01 - enemy buffer offset
00D6D9  2               
00D6D9  2               FireballEnemyCollision:
00D6D9  2  B5 24              lda Fireball_State,x  ;check to see if fireball state is set at all
00D6DB  2  F0 56              beq ExitFBallEnemy    ;branch to leave if not
00D6DD  2  0A                 asl
00D6DE  2  B0 53              bcs ExitFBallEnemy    ;branch to leave also if d7 in state is set
00D6E0  2  A5 09              lda FrameCounter
00D6E2  2  4A                 lsr                   ;get LSB of frame counter
00D6E3  2  B0 4E              bcs ExitFBallEnemy    ;branch to leave if set (do routine every other frame)
00D6E5  2  8A                 txa
00D6E6  2  0A                 asl                   ;multiply fireball offset by four
00D6E7  2  0A                 asl
00D6E8  2  18                 clc
00D6E9  2  69 1C              adc #$1c              ;then add $1c or 28 bytes to it
00D6EB  2  A8                 tay                   ;to use fireball's bounding box coordinates
00D6EC  2  A2 04              ldx #$04
00D6EE  2               
00D6EE  2               FireballEnemyCDLoop:
00D6EE  2  86 01                   stx $01                     ;store enemy object offset here
00D6F0  2  98                      tya
00D6F1  2  48                      pha                         ;push fireball offset to the stack
00D6F2  2  B5 1E                   lda Enemy_State,x
00D6F4  2  29 20                   and #%00100000              ;check to see if d5 is set in enemy state
00D6F6  2  D0 34                   bne NoFToECol               ;if so, skip to next enemy slot
00D6F8  2  B5 0F                   lda Enemy_Flag,x            ;check to see if buffer flag is set
00D6FA  2  F0 30                   beq NoFToECol               ;if not, skip to next enemy slot
00D6FC  2  B5 16                   lda Enemy_ID,x              ;check enemy identifier
00D6FE  2  C9 24                   cmp #$24
00D700  2  90 04                   bcc GoombaDie               ;if < $24, branch to check further
00D702  2  C9 2B                   cmp #$2b
00D704  2  90 26                   bcc NoFToECol               ;if in range $24-$2a, skip to next enemy slot
00D706  2  C9 06        GoombaDie: cmp #Goomba                 ;check for goomba identifier
00D708  2  D0 06                   bne NotGoomba               ;if not found, continue with code
00D70A  2  B5 1E                   lda Enemy_State,x           ;otherwise check for defeated state
00D70C  2  C9 02                   cmp #$02                    ;if stomped or otherwise defeated,
00D70E  2  B0 1C                   bcs NoFToECol               ;skip to next enemy slot
00D710  2  BD D8 03     NotGoomba: lda EnemyOffscrBitsMasked,x ;if any masked offscreen bits set,
00D713  2  D0 17                   bne NoFToECol               ;skip to next enemy slot
00D715  2  8A                      txa
00D716  2  0A                      asl                         ;otherwise multiply enemy offset by four
00D717  2  0A                      asl
00D718  2  18                      clc
00D719  2  69 04                   adc #$04                    ;add 4 bytes to it
00D71B  2  AA                      tax                         ;to use enemy's bounding box coordinates
00D71C  2  20 27 E3                jsr SprObjectCollisionCore  ;do fireball-to-enemy collision detection
00D71F  2  A6 08                   ldx ObjectOffset            ;return fireball's original offset
00D721  2  90 09                   bcc NoFToECol               ;if carry clear, no collision, thus do next enemy slot
00D723  2  A9 80                   lda #%10000000
00D725  2  95 24                   sta Fireball_State,x        ;set d7 in enemy state
00D727  2  A6 01                   ldx $01                     ;get enemy offset
00D729  2  20 3E D7                jsr HandleEnemyFBallCol     ;jump to handle fireball to enemy collision
00D72C  2  68           NoFToECol: pla                         ;pull fireball offset from stack
00D72D  2  A8                      tay                         ;put it in Y
00D72E  2  A6 01                   ldx $01                     ;get enemy object offset
00D730  2  CA                      dex                         ;decrement it
00D731  2  10 BB                   bpl FireballEnemyCDLoop     ;loop back until collision detection done on all enemies
00D733  2               
00D733  2               ExitFBallEnemy:
00D733  2  A6 08              ldx ObjectOffset                 ;get original fireball offset and leave
00D735  2  60                 rts
00D736  2               
00D736  2               BowserIdentities:
00D736  2  06 00 02 12        .byte Goomba, GreenKoopa, BuzzyBeetle, Spiny, Lakitu, Bloober, HammerBro, Bowser
00D73A  2  11 07 05 2D  
00D73E  2               
00D73E  2               HandleEnemyFBallCol:
00D73E  2  20 52 F1           jsr RelativeEnemyPosition  ;get relative coordinate of enemy
00D741  2  A6 01              ldx $01                    ;get current enemy object offset
00D743  2  B5 0F              lda Enemy_Flag,x           ;check buffer flag for d7 set
00D745  2  10 0B              bpl ChkBuzzyBeetle         ;branch if not set to continue
00D747  2  29 0F              and #%00001111             ;otherwise mask out high nybble and
00D749  2  AA                 tax                        ;use low nybble as enemy offset
00D74A  2  B5 16              lda Enemy_ID,x
00D74C  2  C9 2D              cmp #Bowser                ;check enemy identifier for bowser
00D74E  2  F0 0C              beq HurtBowser             ;branch if found
00D750  2  A6 01              ldx $01                    ;otherwise retrieve current enemy offset
00D752  2               
00D752  2               ChkBuzzyBeetle:
00D752  2  B5 16              lda Enemy_ID,x
00D754  2  C9 02              cmp #BuzzyBeetle           ;check for buzzy beetle
00D756  2  F0 6B              beq ExHCF                  ;branch if found to leave (buzzy beetles fireproof)
00D758  2  C9 2D              cmp #Bowser                ;check for bowser one more time (necessary if d7 of flag was clear)
00D75A  2  D0 2D              bne ChkOtherEnemies        ;if not found, branch to check other enemies
00D75C  2               
00D75C  2               HurtBowser:
00D75C  2  CE 83 04               dec BowserHitPoints        ;decrement bowser's hit points
00D75F  2  D0 62                  bne ExHCF                  ;if bowser still has hit points, branch to leave
00D761  2  20 63 C3               jsr InitVStf               ;otherwise do sub to init vertical speed and movement force
00D764  2  95 58                  sta Enemy_X_Speed,x        ;initialize horizontal speed
00D766  2  8D CB 06               sta EnemyFrenzyBuffer      ;init enemy frenzy buffer
00D769  2  A9 FE                  lda #$fe
00D76B  2  95 A0                  sta Enemy_Y_Speed,x        ;set vertical speed to make defeated bowser jump a little
00D76D  2  AC 5F 07               ldy WorldNumber            ;use world number as offset
00D770  2  B9 36 D7               lda BowserIdentities,y     ;get enemy identifier to replace bowser with
00D773  2  95 16                  sta Enemy_ID,x             ;set as new enemy identifier
00D775  2  A9 20                  lda #$20                   ;set A to use starting value for state
00D777  2  C0 03                  cpy #$03                   ;check to see if using offset of 3 or more
00D779  2  B0 02                  bcs SetDBSte               ;branch if so
00D77B  2  09 03                  ora #$03                   ;otherwise add 3 to enemy state
00D77D  2  95 1E        SetDBSte: sta Enemy_State,x          ;set defeated enemy state
00D77F  2  A9 80                  lda #Sfx_BowserFall
00D781  2  85 FE                  sta Square2SoundQueue      ;load bowser defeat sound
00D783  2  A6 01                  ldx $01                    ;get enemy offset
00D785  2  A9 09                  lda #$09                   ;award 5000 points to player for defeating bowser
00D787  2  D0 33                  bne EnemySmackScore        ;unconditional branch to award points
00D789  2               
00D789  2               ChkOtherEnemies:
00D789  2  C9 08              cmp #BulletBill_FrenzyVar
00D78B  2  F0 36              beq ExHCF                 ;branch to leave if bullet bill (frenzy variant)
00D78D  2  C9 0C              cmp #Podoboo
00D78F  2  F0 32              beq ExHCF                 ;branch to leave if podoboo
00D791  2  C9 15              cmp #$15
00D793  2  B0 2E              bcs ExHCF                 ;branch to leave if identifier => $15
00D795  2               
00D795  2               ShellOrBlockDefeat:
00D795  2  B5 16              lda Enemy_ID,x            ;check for piranha plant
00D797  2  C9 0D              cmp #PiranhaPlant
00D799  2  D0 06              bne StnE                  ;branch if not found
00D79B  2  B5 CF              lda Enemy_Y_Position,x
00D79D  2  69 18              adc #$18                  ;add 24 pixels to enemy object's vertical position
00D79F  2  95 CF              sta Enemy_Y_Position,x
00D7A1  2  20 1B E0     StnE: jsr ChkToStunEnemies      ;do yet another sub
00D7A4  2  B5 1E              lda Enemy_State,x
00D7A6  2  29 1F              and #%00011111            ;mask out 2 MSB of enemy object's state
00D7A8  2  09 20              ora #%00100000            ;set d5 to defeat enemy and save as new state
00D7AA  2  95 1E              sta Enemy_State,x
00D7AC  2  A9 02              lda #$02                  ;award 200 points by default
00D7AE  2  B4 16              ldy Enemy_ID,x            ;check for hammer bro
00D7B0  2  C0 05              cpy #HammerBro
00D7B2  2  D0 02              bne GoombaPoints          ;branch if not found
00D7B4  2  A9 06              lda #$06                  ;award 1000 points for hammer bro
00D7B6  2               
00D7B6  2               GoombaPoints:
00D7B6  2  C0 06              cpy #Goomba               ;check for goomba
00D7B8  2  D0 02              bne EnemySmackScore       ;branch if not found
00D7BA  2  A9 01              lda #$01                  ;award 100 points for goomba
00D7BC  2               
00D7BC  2               EnemySmackScore:
00D7BC  2  20 11 DA            jsr SetupFloateyNumber   ;update necessary score variables
00D7BF  2  A9 08               lda #Sfx_EnemySmack      ;play smack enemy sound
00D7C1  2  85 FF               sta Square1SoundQueue
00D7C3  2  60           ExHCF: rts                      ;and now let's leave
00D7C4  2               
00D7C4  2               ;-------------------------------------------------------------------------------------
00D7C4  2               
00D7C4  2               PlayerHammerCollision:
00D7C4  2  A5 09                lda FrameCounter          ;get frame counter
00D7C6  2  4A                   lsr                       ;shift d0 into carry
00D7C7  2  90 36                bcc ExPHC                 ;branch to leave if d0 not set to execute every other frame
00D7C9  2  AD 47 07             lda TimerControl          ;if either master timer control
00D7CC  2  0D D6 03             ora Misc_OffscreenBits    ;or any offscreen bits for hammer are set,
00D7CF  2  D0 2E                bne ExPHC                 ;branch to leave
00D7D1  2  8A                   txa
00D7D2  2  0A                   asl                       ;multiply misc object offset by four
00D7D3  2  0A                   asl
00D7D4  2  18                   clc
00D7D5  2  69 24                adc #$24                  ;add 36 or $24 bytes to get proper offset
00D7D7  2  A8                   tay                       ;for misc object bounding box coordinates
00D7D8  2  20 25 E3             jsr PlayerCollisionCore   ;do player-to-hammer collision detection
00D7DB  2  A6 08                ldx ObjectOffset          ;get misc object offset
00D7DD  2  90 1B                bcc ClHCol                ;if no collision, then branch
00D7DF  2  BD BE 06             lda Misc_Collision_Flag,x ;otherwise read collision flag
00D7E2  2  D0 1B                bne ExPHC                 ;if collision flag already set, branch to leave
00D7E4  2  A9 01                lda #$01
00D7E6  2  9D BE 06             sta Misc_Collision_Flag,x ;otherwise set collision flag now
00D7E9  2  B5 64                lda Misc_X_Speed,x
00D7EB  2  49 FF                eor #$ff                  ;get two's compliment of
00D7ED  2  18                   clc                       ;hammer's horizontal speed
00D7EE  2  69 01                adc #$01
00D7F0  2  95 64                sta Misc_X_Speed,x        ;set to send hammer flying the opposite direction
00D7F2  2  AD 9F 07             lda StarInvincibleTimer   ;if star mario invincibility timer set,
00D7F5  2  D0 08                bne ExPHC                 ;branch to leave
00D7F7  2  4C 2C D9             jmp InjurePlayer          ;otherwise jump to hurt player, do not return
00D7FA  2  A9 00        ClHCol: lda #$00                  ;clear collision flag
00D7FC  2  9D BE 06             sta Misc_Collision_Flag,x
00D7FF  2  60           ExPHC:  rts
00D800  2               
00D800  2               ;-------------------------------------------------------------------------------------
00D800  2               
00D800  2               HandlePowerUpCollision:
00D800  2  20 98 C9           jsr EraseEnemyObject    ;erase the power-up object
00D803  2  A9 06              lda #$06
00D805  2  20 11 DA           jsr SetupFloateyNumber  ;award 1000 points to player by default
00D808  2  A9 20              lda #Sfx_PowerUpGrab
00D80A  2  85 FE              sta Square2SoundQueue   ;play the power-up sound
00D80C  2  A5 39              lda PowerUpType         ;check power-up type
00D80E  2  C9 02              cmp #$02
00D810  2  90 0E              bcc Shroom_Flower_PUp   ;if mushroom or fire flower, branch
00D812  2  C9 03              cmp #$03
00D814  2  F0 24              beq SetFor1Up           ;if 1-up mushroom, branch
00D816  2  A9 23              lda #$23                ;otherwise set star mario invincibility
00D818  2  8D 9F 07           sta StarInvincibleTimer ;timer, and load the star mario music
00D81B  2  A9 40              lda #StarPowerMusic     ;into the area music queue, then leave
00D81D  2  85 FB              sta AreaMusicQueue
00D81F  2  60                 rts
00D820  2               
00D820  2               Shroom_Flower_PUp:
00D820  2  AD 56 07           lda PlayerStatus    ;if player status = small, branch
00D823  2  F0 1B              beq UpToSuper
00D825  2  C9 01              cmp #$01            ;if player status not super, leave
00D827  2  D0 23              bne NoPUp
00D829  2  A6 08              ldx ObjectOffset    ;get enemy offset, not necessary
00D82B  2  A9 02              lda #$02            ;set player status to fiery
00D82D  2  8D 56 07           sta PlayerStatus
00D830  2  20 F1 85           jsr GetPlayerColors ;run sub to change colors of player
00D833  2  A6 08              ldx ObjectOffset    ;get enemy offset again, and again not necessary
00D835  2  A9 0C              lda #$0c            ;set value to be used by subroutine tree (fiery)
00D837  2  4C 47 D8           jmp UpToFiery       ;jump to set values accordingly
00D83A  2               
00D83A  2               SetFor1Up:
00D83A  2  A9 0B              lda #$0b                 ;change 1000 points into 1-up instead
00D83C  2  9D 10 01           sta FloateyNum_Control,x ;and then leave
00D83F  2  60                 rts
00D840  2               
00D840  2               UpToSuper:
00D840  2  A9 01               lda #$01         ;set player status to super
00D842  2  8D 56 07            sta PlayerStatus
00D845  2  A9 09               lda #$09         ;set value to be used by subroutine tree (super)
00D847  2               
00D847  2               UpToFiery:
00D847  2  A0 00               ldy #$00         ;set value to be used as new player state
00D849  2  20 48 D9            jsr SetPRout     ;set values to stop certain things in motion
00D84C  2  60           NoPUp: rts
00D84D  2               
00D84D  2               ;--------------------------------
00D84D  2               
00D84D  2               ResidualXSpdData:
00D84D  2  18 E8              .byte $18, $e8
00D84F  2               
00D84F  2               KickedShellXSpdData:
00D84F  2  30 D0              .byte $30, $d0
00D851  2               
00D851  2               DemotedKoopaXSpdData:
00D851  2  08 F8              .byte $08, $f8
00D853  2               
00D853  2               PlayerEnemyCollision:
00D853  2  A5 09                 lda FrameCounter            ;check counter for d0 set
00D855  2  4A                    lsr
00D856  2  B0 F4                 bcs NoPUp                   ;if set, branch to leave
00D858  2  20 41 DC              jsr CheckPlayerVertical     ;if player object is completely offscreen or
00D85B  2  B0 23                 bcs NoPECol                 ;if down past 224th pixel row, branch to leave
00D85D  2  BD D8 03              lda EnemyOffscrBitsMasked,x ;if current enemy is offscreen by any amount,
00D860  2  D0 1E                 bne NoPECol                 ;go ahead and branch to leave
00D862  2  A5 0E                 lda GameEngineSubroutine
00D864  2  C9 08                 cmp #$08                    ;if not set to run player control routine
00D866  2  D0 18                 bne NoPECol                 ;on next frame, branch to leave
00D868  2  B5 1E                 lda Enemy_State,x
00D86A  2  29 20                 and #%00100000              ;if enemy state has d5 set, branch to leave
00D86C  2  D0 12                 bne NoPECol
00D86E  2  20 52 DC              jsr GetEnemyBoundBoxOfs     ;get bounding box offset for current enemy object
00D871  2  20 25 E3              jsr PlayerCollisionCore     ;do collision detection on player vs. enemy
00D874  2  A6 08                 ldx ObjectOffset            ;get enemy object buffer offset
00D876  2  B0 09                 bcs CheckForPUpCollision    ;if collision, branch past this part here
00D878  2  BD 91 04              lda Enemy_CollisionBits,x
00D87B  2  29 FE                 and #%11111110              ;otherwise, clear d0 of current enemy object's
00D87D  2  9D 91 04              sta Enemy_CollisionBits,x   ;collision bit
00D880  2  60           NoPECol: rts
00D881  2               
00D881  2               CheckForPUpCollision:
00D881  2  B4 16               ldy Enemy_ID,x
00D883  2  C0 2E               cpy #PowerUpObject            ;check for power-up object
00D885  2  D0 03               bne EColl                     ;if not found, branch to next part
00D887  2  4C 00 D8            jmp HandlePowerUpCollision    ;otherwise, unconditional jump backwards
00D88A  2  AD 9F 07     EColl: lda StarInvincibleTimer       ;if star mario invincibility timer expired,
00D88D  2  F0 06               beq HandlePECollisions        ;perform task here, otherwise kill enemy like
00D88F  2  4C 95 D7            jmp ShellOrBlockDefeat        ;hit with a shell, or from beneath
00D892  2               
00D892  2               KickedShellPtsData:
00D892  2  0A 06 04           .byte $0a, $06, $04
00D895  2               
00D895  2               HandlePECollisions:
00D895  2  BD 91 04            lda Enemy_CollisionBits,x    ;check enemy collision bits for d0 set
00D898  2  29 01               and #%00000001               ;or for being offscreen at all
00D89A  2  1D D8 03            ora EnemyOffscrBitsMasked,x
00D89D  2  D0 59               bne ExPEC                    ;branch to leave if either is true
00D89F  2  A9 01               lda #$01
00D8A1  2  1D 91 04            ora Enemy_CollisionBits,x    ;otherwise set d0 now
00D8A4  2  9D 91 04            sta Enemy_CollisionBits,x
00D8A7  2  C0 12               cpy #Spiny                   ;branch if spiny
00D8A9  2  F0 4E               beq ChkForPlayerInjury
00D8AB  2  C0 0D               cpy #PiranhaPlant            ;branch if piranha plant
00D8AD  2  F0 7D               beq InjurePlayer
00D8AF  2  C0 0C               cpy #Podoboo                 ;branch if podoboo
00D8B1  2  F0 79               beq InjurePlayer
00D8B3  2  C0 33               cpy #BulletBill_CannonVar    ;branch if bullet bill
00D8B5  2  F0 42               beq ChkForPlayerInjury
00D8B7  2  C0 15               cpy #$15                     ;branch if object => $15
00D8B9  2  B0 71               bcs InjurePlayer
00D8BB  2  AD 4E 07            lda AreaType                 ;branch if water type level
00D8BE  2  F0 6C               beq InjurePlayer
00D8C0  2  B5 1E               lda Enemy_State,x            ;branch if d7 of enemy state was set
00D8C2  2  0A                  asl
00D8C3  2  B0 34               bcs ChkForPlayerInjury
00D8C5  2  B5 1E               lda Enemy_State,x            ;mask out all but 3 LSB of enemy state
00D8C7  2  29 07               and #%00000111
00D8C9  2  C9 02               cmp #$02                     ;branch if enemy is in normal or falling state
00D8CB  2  90 2C               bcc ChkForPlayerInjury
00D8CD  2  B5 16               lda Enemy_ID,x               ;branch to leave if goomba in defeated state
00D8CF  2  C9 06               cmp #Goomba
00D8D1  2  F0 25               beq ExPEC
00D8D3  2  A9 08               lda #Sfx_EnemySmack          ;play smack enemy sound
00D8D5  2  85 FF               sta Square1SoundQueue
00D8D7  2  B5 1E               lda Enemy_State,x            ;set d7 in enemy state, thus become moving shell
00D8D9  2  09 80               ora #%10000000
00D8DB  2  95 1E               sta Enemy_State,x
00D8DD  2  20 05 DA            jsr EnemyFacePlayer          ;set moving direction and get offset
00D8E0  2  B9 4F D8            lda KickedShellXSpdData,y    ;load and set horizontal speed data with offset
00D8E3  2  95 58               sta Enemy_X_Speed,x
00D8E5  2  A9 03               lda #$03                     ;add three to whatever the stomp counter contains
00D8E7  2  18                  clc                          ;to give points for kicking the shell
00D8E8  2  6D 84 04            adc StompChainCounter
00D8EB  2  BC 96 07            ldy EnemyIntervalTimer,x     ;check shell enemy's timer
00D8EE  2  C0 03               cpy #$03                     ;if above a certain point, branch using the points
00D8F0  2  B0 03               bcs KSPts                    ;data obtained from the stomp counter + 3
00D8F2  2  B9 92 D8            lda KickedShellPtsData,y     ;otherwise, set points based on proximity to timer expiration
00D8F5  2  20 11 DA     KSPts: jsr SetupFloateyNumber       ;set values for floatey number now
00D8F8  2  60           ExPEC: rts                          ;leave!!!
00D8F9  2               
00D8F9  2               ChkForPlayerInjury:
00D8F9  2  A5 9F                  lda Player_Y_Speed     ;check player's vertical speed
00D8FB  2  30 02                  bmi ChkInj             ;perform procedure below if player moving upwards
00D8FD  2  D0 6A                  bne EnemyStomped       ;or not at all, and branch elsewhere if moving downwards
00D8FF  2  B5 16        ChkInj:   lda Enemy_ID,x         ;branch if enemy object < $07
00D901  2  C9 07                  cmp #Bloober
00D903  2  90 09                  bcc ChkETmrs
00D905  2  A5 CE                  lda Player_Y_Position  ;add 12 pixels to player's vertical position
00D907  2  18                     clc
00D908  2  69 0C                  adc #$0c
00D90A  2  D5 CF                  cmp Enemy_Y_Position,x ;compare modified player's position to enemy's position
00D90C  2  90 5B                  bcc EnemyStomped       ;branch if this player's position above (less than) enemy's
00D90E  2  AD 91 07     ChkETmrs: lda StompTimer         ;check stomp timer
00D911  2  D0 56                  bne EnemyStomped       ;branch if set
00D913  2  AD 9E 07               lda InjuryTimer        ;check to see if injured invincibility timer still
00D916  2  D0 3D                  bne ExInjColRoutines   ;counting down, and branch elsewhere to leave if so
00D918  2  AD AD 03               lda Player_Rel_XPos
00D91B  2  CD AE 03               cmp Enemy_Rel_XPos     ;if player's relative position to the left of enemy's
00D91E  2  90 03                  bcc TInjE              ;relative position, branch here
00D920  2  4C F6 D9               jmp ChkEnemyFaceRight  ;otherwise do a jump here
00D923  2  B5 46        TInjE:    lda Enemy_MovingDir,x  ;if enemy moving towards the left,
00D925  2  C9 01                  cmp #$01               ;branch, otherwise do a jump here
00D927  2  D0 03                  bne InjurePlayer       ;to turn the enemy around
00D929  2  4C FF D9               jmp LInj
00D92C  2               
00D92C  2               InjurePlayer:
00D92C  2  AD 9E 07           lda InjuryTimer          ;check again to see if injured invincibility timer is
00D92F  2  D0 24              bne ExInjColRoutines     ;at zero, and branch to leave if so
00D931  2               
00D931  2               ForceInjury:
00D931  2  AE 56 07               ldx PlayerStatus          ;check player's status
00D934  2  F0 22                  beq KillPlayer            ;branch if small
00D936  2  8D 56 07               sta PlayerStatus          ;otherwise set player's status to small
00D939  2  A9 08                  lda #$08
00D93B  2  8D 9E 07               sta InjuryTimer           ;set injured invincibility timer
00D93E  2  0A                     asl
00D93F  2  85 FF                  sta Square1SoundQueue     ;play pipedown/injury sound
00D941  2  20 F1 85               jsr GetPlayerColors       ;change player's palette if necessary
00D944  2  A9 0A                  lda #$0a                  ;set subroutine to run on next frame
00D946  2  A0 01        SetKRout: ldy #$01                  ;set new player state
00D948  2  85 0E        SetPRout: sta GameEngineSubroutine  ;load new value to run subroutine on next frame
00D94A  2  84 1D                  sty Player_State          ;store new player state
00D94C  2  A0 FF                  ldy #$ff
00D94E  2  8C 47 07               sty TimerControl          ;set master timer control flag to halt timers
00D951  2  C8                     iny
00D952  2  8C 75 07               sty ScrollAmount          ;initialize scroll speed
00D955  2               
00D955  2               ExInjColRoutines:
00D955  2  A6 08              ldx ObjectOffset              ;get enemy offset and leave
00D957  2  60                 rts
00D958  2               
00D958  2               KillPlayer:
00D958  2  86 57              stx Player_X_Speed   ;halt player's horizontal movement by initializing speed
00D95A  2  E8                 inx
00D95B  2  86 FC              stx EventMusicQueue  ;set event music queue to death music
00D95D  2  A9 FC              lda #$fc
00D95F  2  85 9F              sta Player_Y_Speed   ;set new vertical speed
00D961  2  A9 0B              lda #$0b             ;set subroutine to run on next frame
00D963  2  D0 E1              bne SetKRout         ;branch to set player's state and other things
00D965  2               
00D965  2               StompedEnemyPtsData:
00D965  2  02 06 05 06        .byte $02, $06, $05, $06
00D969  2               
00D969  2               EnemyStomped:
00D969  2  B5 16              lda Enemy_ID,x             ;check for spiny, branch to hurt player
00D96B  2  C9 12              cmp #Spiny                 ;if found
00D96D  2  F0 BD              beq InjurePlayer
00D96F  2  A9 04              lda #Sfx_EnemyStomp        ;otherwise play stomp/swim sound
00D971  2  85 FF              sta Square1SoundQueue
00D973  2  B5 16              lda Enemy_ID,x
00D975  2  A0 00              ldy #$00                   ;initialize points data offset for stomped enemies
00D977  2  C9 14              cmp #FlyingCheepCheep      ;branch for cheep-cheep
00D979  2  F0 1B              beq EnemyStompedPts
00D97B  2  C9 08              cmp #BulletBill_FrenzyVar  ;branch for either bullet bill object
00D97D  2  F0 17              beq EnemyStompedPts
00D97F  2  C9 33              cmp #BulletBill_CannonVar
00D981  2  F0 13              beq EnemyStompedPts
00D983  2  C9 0C              cmp #Podoboo               ;branch for podoboo (this branch is logically impossible
00D985  2  F0 0F              beq EnemyStompedPts        ;for cpu to take due to earlier checking of podoboo)
00D987  2  C8                 iny                        ;increment points data offset
00D988  2  C9 05              cmp #HammerBro             ;branch for hammer bro
00D98A  2  F0 0A              beq EnemyStompedPts
00D98C  2  C8                 iny                        ;increment points data offset
00D98D  2  C9 11              cmp #Lakitu                ;branch for lakitu
00D98F  2  F0 05              beq EnemyStompedPts
00D991  2  C8                 iny                        ;increment points data offset
00D992  2  C9 07              cmp #Bloober               ;branch if NOT bloober
00D994  2  D0 1D              bne ChkForDemoteKoopa
00D996  2               
00D996  2               EnemyStompedPts:
00D996  2  B9 65 D9           lda StompedEnemyPtsData,y  ;load points data using offset in Y
00D999  2  20 11 DA           jsr SetupFloateyNumber     ;run sub to set floatey number controls
00D99C  2  B5 46              lda Enemy_MovingDir,x
00D99E  2  48                 pha                        ;save enemy movement direction to stack
00D99F  2  20 2F E0           jsr SetStun                ;run sub to kill enemy
00D9A2  2  68                 pla
00D9A3  2  95 46              sta Enemy_MovingDir,x      ;return enemy movement direction from stack
00D9A5  2  A9 20              lda #%00100000
00D9A7  2  95 1E              sta Enemy_State,x          ;set d5 in enemy state
00D9A9  2  20 63 C3           jsr InitVStf               ;nullify vertical speed, physics-related thing,
00D9AC  2  95 58              sta Enemy_X_Speed,x        ;and horizontal speed
00D9AE  2  A9 FD              lda #$fd                   ;set player's vertical speed, to give bounce
00D9B0  2  85 9F              sta Player_Y_Speed
00D9B2  2  60                 rts
00D9B3  2               
00D9B3  2               ChkForDemoteKoopa:
00D9B3  2  C9 09              cmp #$09                   ;branch elsewhere if enemy object < $09
00D9B5  2  90 1D              bcc HandleStompedShellE
00D9B7  2  29 01              and #%00000001             ;demote koopa paratroopas to ordinary troopas
00D9B9  2  95 16              sta Enemy_ID,x
00D9BB  2  A0 00              ldy #$00                   ;return enemy to normal state
00D9BD  2  94 1E              sty Enemy_State,x
00D9BF  2  A9 03              lda #$03                   ;award 400 points to the player
00D9C1  2  20 11 DA           jsr SetupFloateyNumber
00D9C4  2  20 63 C3           jsr InitVStf               ;nullify physics-related thing and vertical speed
00D9C7  2  20 05 DA           jsr EnemyFacePlayer        ;turn enemy around if necessary
00D9CA  2  B9 51 D8           lda DemotedKoopaXSpdData,y
00D9CD  2  95 58              sta Enemy_X_Speed,x        ;set appropriate moving speed based on direction
00D9CF  2  4C F1 D9           jmp SBnce                  ;then move onto something else
00D9D2  2               
00D9D2  2               RevivalRateData:
00D9D2  2  10 0B              .byte $10, $0b
00D9D4  2               
00D9D4  2               HandleStompedShellE:
00D9D4  2  A9 04               lda #$04                   ;set defeated state for enemy
00D9D6  2  95 1E               sta Enemy_State,x
00D9D8  2  EE 84 04            inc StompChainCounter      ;increment the stomp counter
00D9DB  2  AD 84 04            lda StompChainCounter      ;add whatever is in the stomp counter
00D9DE  2  18                  clc                        ;to whatever is in the stomp timer
00D9DF  2  6D 91 07            adc StompTimer
00D9E2  2  20 11 DA            jsr SetupFloateyNumber     ;award points accordingly
00D9E5  2  EE 91 07            inc StompTimer             ;increment stomp timer of some sort
00D9E8  2  AC 6A 07            ldy PrimaryHardMode        ;check primary hard mode flag
00D9EB  2  B9 D2 D9            lda RevivalRateData,y      ;load timer setting according to flag
00D9EE  2  9D 96 07            sta EnemyIntervalTimer,x   ;set as enemy timer to revive stomped enemy
00D9F1  2  A9 FC        SBnce: lda #$fc                   ;set player's vertical speed for bounce
00D9F3  2  85 9F               sta Player_Y_Speed         ;and then leave!!!
00D9F5  2  60                  rts
00D9F6  2               
00D9F6  2               ChkEnemyFaceRight:
00D9F6  2  B5 46               lda Enemy_MovingDir,x ;check to see if enemy is moving to the right
00D9F8  2  C9 01               cmp #$01
00D9FA  2  D0 03               bne LInj              ;if not, branch
00D9FC  2  4C 2C D9            jmp InjurePlayer      ;otherwise go back to hurt player
00D9FF  2  20 1C DB     LInj:  jsr EnemyTurnAround   ;turn the enemy around, if necessary
00DA02  2  4C 2C D9            jmp InjurePlayer      ;go back to hurt player
00DA05  2               
00DA05  2               
00DA05  2               EnemyFacePlayer:
00DA05  2  A0 01               ldy #$01               ;set to move right by default
00DA07  2  20 43 E1            jsr PlayerEnemyDiff    ;get horizontal difference between player and enemy
00DA0A  2  10 01               bpl SFcRt              ;if enemy is to the right of player, do not increment
00DA0C  2  C8                  iny                    ;otherwise, increment to set to move to the left
00DA0D  2  94 46        SFcRt: sty Enemy_MovingDir,x  ;set moving direction here
00DA0F  2  88                  dey                    ;then decrement to use as a proper offset
00DA10  2  60                  rts
00DA11  2               
00DA11  2               SetupFloateyNumber:
00DA11  2  9D 10 01            sta FloateyNum_Control,x ;set number of points control for floatey numbers
00DA14  2  A9 30               lda #$30
00DA16  2  9D 2C 01            sta FloateyNum_Timer,x   ;set timer for floatey numbers
00DA19  2  B5 CF               lda Enemy_Y_Position,x
00DA1B  2  9D 1E 01            sta FloateyNum_Y_Pos,x   ;set vertical coordinate
00DA1E  2  AD AE 03            lda Enemy_Rel_XPos
00DA21  2  9D 17 01            sta FloateyNum_X_Pos,x   ;set horizontal coordinate and leave
00DA24  2  60           ExSFN: rts
00DA25  2               
00DA25  2               ;-------------------------------------------------------------------------------------
00DA25  2               ;$01 - used to hold enemy offset for second enemy
00DA25  2               
00DA25  2               SetBitsMask:
00DA25  2  80 40 20 10        .byte %10000000, %01000000, %00100000, %00010000, %00001000, %00000100, %00000010
00DA29  2  08 04 02     
00DA2C  2               
00DA2C  2               ClearBitsMask:
00DA2C  2  7F BF DF EF        .byte %01111111, %10111111, %11011111, %11101111, %11110111, %11111011, %11111101
00DA30  2  F7 FB FD     
00DA33  2               
00DA33  2               EnemiesCollision:
00DA33  2  A5 09                lda FrameCounter            ;check counter for d0 set
00DA35  2  4A                   lsr
00DA36  2  90 EC                bcc ExSFN                   ;if d0 not set, leave
00DA38  2  AD 4E 07             lda AreaType
00DA3B  2  F0 E7                beq ExSFN                   ;if water area type, leave
00DA3D  2  B5 16                lda Enemy_ID,x
00DA3F  2  C9 15                cmp #$15                    ;if enemy object => $15, branch to leave
00DA41  2  B0 6E                bcs ExitECRoutine
00DA43  2  C9 11                cmp #Lakitu                 ;if lakitu, branch to leave
00DA45  2  F0 6A                beq ExitECRoutine
00DA47  2  C9 0D                cmp #PiranhaPlant           ;if piranha plant, branch to leave
00DA49  2  F0 66                beq ExitECRoutine
00DA4B  2  BD D8 03             lda EnemyOffscrBitsMasked,x ;if masked offscreen bits nonzero, branch to leave
00DA4E  2  D0 61                bne ExitECRoutine
00DA50  2  20 52 DC             jsr GetEnemyBoundBoxOfs     ;otherwise, do sub, get appropriate bounding box offset for
00DA53  2  CA                   dex                         ;first enemy we're going to compare, then decrement for second
00DA54  2  30 5B                bmi ExitECRoutine           ;branch to leave if there are no other enemies
00DA56  2  86 01        ECLoop: stx $01                     ;save enemy object buffer offset for second enemy here
00DA58  2  98                   tya                         ;save first enemy's bounding box offset to stack
00DA59  2  48                   pha
00DA5A  2  B5 0F                lda Enemy_Flag,x            ;check enemy object enable flag
00DA5C  2  F0 4C                beq ReadyNextEnemy          ;branch if flag not set
00DA5E  2  B5 16                lda Enemy_ID,x
00DA60  2  C9 15                cmp #$15                    ;check for enemy object => $15
00DA62  2  B0 46                bcs ReadyNextEnemy          ;branch if true
00DA64  2  C9 11                cmp #Lakitu
00DA66  2  F0 42                beq ReadyNextEnemy          ;branch if enemy object is lakitu
00DA68  2  C9 0D                cmp #PiranhaPlant
00DA6A  2  F0 3E                beq ReadyNextEnemy          ;branch if enemy object is piranha plant
00DA6C  2  BD D8 03             lda EnemyOffscrBitsMasked,x
00DA6F  2  D0 39                bne ReadyNextEnemy          ;branch if masked offscreen bits set
00DA71  2  8A                   txa                         ;get second enemy object's bounding box offset
00DA72  2  0A                   asl                         ;multiply by four, then add four
00DA73  2  0A                   asl
00DA74  2  18                   clc
00DA75  2  69 04                adc #$04
00DA77  2  AA                   tax                         ;use as new contents of X
00DA78  2  20 27 E3             jsr SprObjectCollisionCore  ;do collision detection using the two enemies here
00DA7B  2  A6 08                ldx ObjectOffset            ;use first enemy offset for X
00DA7D  2  A4 01                ldy $01                     ;use second enemy offset for Y
00DA7F  2  90 20                bcc NoEnemyCollision        ;if carry clear, no collision, branch ahead of this
00DA81  2  B5 1E                lda Enemy_State,x
00DA83  2  19 1E 00             ora Enemy_State,y           ;check both enemy states for d7 set
00DA86  2  29 80                and #%10000000
00DA88  2  D0 11                bne YesEC                   ;branch if at least one of them is set
00DA8A  2  B9 91 04             lda Enemy_CollisionBits,y   ;load first enemy's collision-related bits
00DA8D  2  3D 25 DA             and SetBitsMask,x           ;check to see if bit connected to second enemy is
00DA90  2  D0 18                bne ReadyNextEnemy          ;already set, and move onto next enemy slot if set
00DA92  2  B9 91 04             lda Enemy_CollisionBits,y
00DA95  2  1D 25 DA             ora SetBitsMask,x           ;if the bit is not set, set it now
00DA98  2  99 91 04             sta Enemy_CollisionBits,y
00DA9B  2  20 B4 DA     YesEC:  jsr ProcEnemyCollisions     ;react according to the nature of collision
00DA9E  2  4C AA DA             jmp ReadyNextEnemy          ;move onto next enemy slot
00DAA1  2               
00DAA1  2               NoEnemyCollision:
00DAA1  2  B9 91 04           lda Enemy_CollisionBits,y     ;load first enemy's collision-related bits
00DAA4  2  3D 2C DA           and ClearBitsMask,x           ;clear bit connected to second enemy
00DAA7  2  99 91 04           sta Enemy_CollisionBits,y     ;then move onto next enemy slot
00DAAA  2               
00DAAA  2               ReadyNextEnemy:
00DAAA  2  68                 pla              ;get first enemy's bounding box offset from the stack
00DAAB  2  A8                 tay              ;use as Y again
00DAAC  2  A6 01              ldx $01          ;get and decrement second enemy's object buffer offset
00DAAE  2  CA                 dex
00DAAF  2  10 A5              bpl ECLoop       ;loop until all enemy slots have been checked
00DAB1  2               
00DAB1  2               ExitECRoutine:
00DAB1  2  A6 08              ldx ObjectOffset ;get enemy object buffer offset
00DAB3  2  60                 rts              ;leave
00DAB4  2               
00DAB4  2               ProcEnemyCollisions:
00DAB4  2  B9 1E 00           lda Enemy_State,y        ;check both enemy states for d5 set
00DAB7  2  15 1E              ora Enemy_State,x
00DAB9  2  29 20              and #%00100000           ;if d5 is set in either state, or both, branch
00DABB  2  D0 33              bne ExitProcessEColl     ;to leave and do nothing else at this point
00DABD  2  B5 1E              lda Enemy_State,x
00DABF  2  C9 06              cmp #$06                 ;if second enemy state < $06, branch elsewhere
00DAC1  2  90 2E              bcc ProcSecondEnemyColl
00DAC3  2  B5 16              lda Enemy_ID,x           ;check second enemy identifier for hammer bro
00DAC5  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00DAC7  2  F0 27              beq ExitProcessEColl
00DAC9  2  B9 1E 00           lda Enemy_State,y        ;check first enemy state for d7 set
00DACC  2  0A                 asl
00DACD  2  90 0A              bcc ShellCollisions      ;branch if d7 is clear
00DACF  2  A9 06              lda #$06
00DAD1  2  20 11 DA           jsr SetupFloateyNumber   ;award 1000 points for killing enemy
00DAD4  2  20 95 D7           jsr ShellOrBlockDefeat   ;then kill enemy, then load
00DAD7  2  A4 01              ldy $01                  ;original offset of second enemy
00DAD9  2               
00DAD9  2               ShellCollisions:
00DAD9  2  98                 tya                      ;move Y to X
00DADA  2  AA                 tax
00DADB  2  20 95 D7           jsr ShellOrBlockDefeat   ;kill second enemy
00DADE  2  A6 08              ldx ObjectOffset
00DAE0  2  BD 25 01           lda ShellChainCounter,x  ;get chain counter for shell
00DAE3  2  18                 clc
00DAE4  2  69 04              adc #$04                 ;add four to get appropriate point offset
00DAE6  2  A6 01              ldx $01
00DAE8  2  20 11 DA           jsr SetupFloateyNumber   ;award appropriate number of points for second enemy
00DAEB  2  A6 08              ldx ObjectOffset         ;load original offset of first enemy
00DAED  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00DAF0  2               
00DAF0  2               ExitProcessEColl:
00DAF0  2  60                 rts                      ;leave!!!
00DAF1  2               
00DAF1  2               ProcSecondEnemyColl:
00DAF1  2  B9 1E 00           lda Enemy_State,y        ;if first enemy state < $06, branch elsewhere
00DAF4  2  C9 06              cmp #$06
00DAF6  2  90 1D              bcc MoveEOfs
00DAF8  2  B9 16 00           lda Enemy_ID,y           ;check first enemy identifier for hammer bro
00DAFB  2  C9 05              cmp #HammerBro           ;if hammer bro found in alt state, branch to leave
00DAFD  2  F0 F1              beq ExitProcessEColl
00DAFF  2  20 95 D7           jsr ShellOrBlockDefeat   ;otherwise, kill first enemy
00DB02  2  A4 01              ldy $01
00DB04  2  B9 25 01           lda ShellChainCounter,y  ;get chain counter for shell
00DB07  2  18                 clc
00DB08  2  69 04              adc #$04                 ;add four to get appropriate point offset
00DB0A  2  A6 08              ldx ObjectOffset
00DB0C  2  20 11 DA           jsr SetupFloateyNumber   ;award appropriate number of points for first enemy
00DB0F  2  A6 01              ldx $01                  ;load original offset of second enemy
00DB11  2  FE 25 01           inc ShellChainCounter,x  ;increment chain counter for additional enemies
00DB14  2  60                 rts                      ;leave!!!
00DB15  2               
00DB15  2               MoveEOfs:
00DB15  2  98                 tya                      ;move Y ($01) to X
00DB16  2  AA                 tax
00DB17  2  20 1C DB           jsr EnemyTurnAround      ;do the sub here using value from $01
00DB1A  2  A6 08              ldx ObjectOffset         ;then do it again using value from $08
00DB1C  2               
00DB1C  2               EnemyTurnAround:
00DB1C  2  B5 16               lda Enemy_ID,x           ;check for specific enemies
00DB1E  2  C9 0D               cmp #PiranhaPlant
00DB20  2  F0 22               beq ExTA                 ;if piranha plant, leave
00DB22  2  C9 11               cmp #Lakitu
00DB24  2  F0 1E               beq ExTA                 ;if lakitu, leave
00DB26  2  C9 05               cmp #HammerBro
00DB28  2  F0 1A               beq ExTA                 ;if hammer bro, leave
00DB2A  2  C9 12               cmp #Spiny
00DB2C  2  F0 08               beq RXSpd                ;if spiny, turn it around
00DB2E  2  C9 0E               cmp #GreenParatroopaJump
00DB30  2  F0 04               beq RXSpd                ;if green paratroopa, turn it around
00DB32  2  C9 07               cmp #$07
00DB34  2  B0 0E               bcs ExTA                 ;if any OTHER enemy object => $07, leave
00DB36  2  B5 58        RXSpd: lda Enemy_X_Speed,x      ;load horizontal speed
00DB38  2  49 FF               eor #$ff                 ;get two's compliment for horizontal speed
00DB3A  2  A8                  tay
00DB3B  2  C8                  iny
00DB3C  2  94 58               sty Enemy_X_Speed,x      ;store as new horizontal speed
00DB3E  2  B5 46               lda Enemy_MovingDir,x
00DB40  2  49 03               eor #%00000011           ;invert moving direction and store, then leave
00DB42  2  95 46               sta Enemy_MovingDir,x    ;thus effectively turning the enemy around
00DB44  2  60           ExTA:  rts                      ;leave!!!
00DB45  2               
00DB45  2               ;-------------------------------------------------------------------------------------
00DB45  2               ;$00 - vertical position of platform
00DB45  2               
00DB45  2               LargePlatformCollision:
00DB45  2  A9 FF               lda #$ff                     ;save value here
00DB47  2  9D A2 03            sta PlatformCollisionFlag,x
00DB4A  2  AD 47 07            lda TimerControl             ;check master timer control
00DB4D  2  D0 29               bne ExLPC                    ;if set, branch to leave
00DB4F  2  B5 1E               lda Enemy_State,x            ;if d7 set in object state,
00DB51  2  30 25               bmi ExLPC                    ;branch to leave
00DB53  2  B5 16               lda Enemy_ID,x
00DB55  2  C9 24               cmp #$24                     ;check enemy object identifier for
00DB57  2  D0 06               bne ChkForPlayerC_LargeP     ;balance platform, branch if not found
00DB59  2  B5 1E               lda Enemy_State,x
00DB5B  2  AA                  tax                          ;set state as enemy offset here
00DB5C  2  20 5F DB            jsr ChkForPlayerC_LargeP     ;perform code with state offset, then original offset, in X
00DB5F  2               
00DB5F  2               ChkForPlayerC_LargeP:
00DB5F  2  20 41 DC            jsr CheckPlayerVertical      ;figure out if player is below a certain point
00DB62  2  B0 14               bcs ExLPC                    ;or offscreen, branch to leave if true
00DB64  2  8A                  txa
00DB65  2  20 54 DC            jsr GetEnemyBoundBoxOfsArg   ;get bounding box offset in Y
00DB68  2  B5 CF               lda Enemy_Y_Position,x       ;store vertical coordinate in
00DB6A  2  85 00               sta $00                      ;temp variable for now
00DB6C  2  8A                  txa                          ;send offset we're on to the stack
00DB6D  2  48                  pha
00DB6E  2  20 25 E3            jsr PlayerCollisionCore      ;do player-to-platform collision detection
00DB71  2  68                  pla                          ;retrieve offset from the stack
00DB72  2  AA                  tax
00DB73  2  90 03               bcc ExLPC                    ;if no collision, branch to leave
00DB75  2  20 BC DB            jsr ProcLPlatCollisions      ;otherwise collision, perform sub
00DB78  2  A6 08        ExLPC: ldx ObjectOffset             ;get enemy object buffer offset and leave
00DB7A  2  60                  rts
00DB7B  2               
00DB7B  2               ;--------------------------------
00DB7B  2               ;$00 - counter for bounding boxes
00DB7B  2               
00DB7B  2               SmallPlatformCollision:
00DB7B  2  AD 47 07           lda TimerControl             ;if master timer control set,
00DB7E  2  D0 37              bne ExSPC                    ;branch to leave
00DB80  2  9D A2 03           sta PlatformCollisionFlag,x  ;otherwise initialize collision flag
00DB83  2  20 41 DC           jsr CheckPlayerVertical      ;do a sub to see if player is below a certain point
00DB86  2  B0 2F              bcs ExSPC                    ;or entirely offscreen, and branch to leave if true
00DB88  2  A9 02              lda #$02
00DB8A  2  85 00              sta $00                      ;load counter here for 2 bounding boxes
00DB8C  2               
00DB8C  2               ChkSmallPlatLoop:
00DB8C  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00DB8E  2  20 52 DC           jsr GetEnemyBoundBoxOfs    ;get bounding box offset in Y
00DB91  2  29 02              and #%00000010             ;if d1 of offscreen lower nybble bits was set
00DB93  2  D0 22              bne ExSPC                  ;then branch to leave
00DB95  2  B9 AD 04           lda BoundingBox_UL_YPos,y  ;check top of platform's bounding box for being
00DB98  2  C9 20              cmp #$20                   ;above a specific point
00DB9A  2  90 05              bcc MoveBoundBox           ;if so, branch, don't do collision detection
00DB9C  2  20 25 E3           jsr PlayerCollisionCore    ;otherwise, perform player-to-platform collision detection
00DB9F  2  B0 19              bcs ProcSPlatCollisions    ;skip ahead if collision
00DBA1  2               
00DBA1  2               MoveBoundBox:
00DBA1  2  B9 AD 04            lda BoundingBox_UL_YPos,y  ;move bounding box vertical coordinates
00DBA4  2  18                  clc                        ;128 pixels downwards
00DBA5  2  69 80               adc #$80
00DBA7  2  99 AD 04            sta BoundingBox_UL_YPos,y
00DBAA  2  B9 AF 04            lda BoundingBox_DR_YPos,y
00DBAD  2  18                  clc
00DBAE  2  69 80               adc #$80
00DBB0  2  99 AF 04            sta BoundingBox_DR_YPos,y
00DBB3  2  C6 00               dec $00                    ;decrement counter we set earlier
00DBB5  2  D0 D5               bne ChkSmallPlatLoop       ;loop back until both bounding boxes are checked
00DBB7  2  A6 08        ExSPC: ldx ObjectOffset           ;get enemy object buffer offset, then leave
00DBB9  2  60                  rts
00DBBA  2               
00DBBA  2               ;--------------------------------
00DBBA  2               
00DBBA  2               ProcSPlatCollisions:
00DBBA  2  A6 08              ldx ObjectOffset             ;return enemy object buffer offset to X, then continue
00DBBC  2               
00DBBC  2               ProcLPlatCollisions:
00DBBC  2  B9 AF 04           lda BoundingBox_DR_YPos,y    ;get difference by subtracting the top
00DBBF  2  38                 sec                          ;of the player's bounding box from the bottom
00DBC0  2  ED AD 04           sbc BoundingBox_UL_YPos      ;of the platform's bounding box
00DBC3  2  C9 04              cmp #$04                     ;if difference too large or negative,
00DBC5  2  B0 08              bcs ChkForTopCollision       ;branch, do not alter vertical speed of player
00DBC7  2  A5 9F              lda Player_Y_Speed           ;check to see if player's vertical speed is moving down
00DBC9  2  10 04              bpl ChkForTopCollision       ;if so, don't mess with it
00DBCB  2  A9 01              lda #$01                     ;otherwise, set vertical
00DBCD  2  85 9F              sta Player_Y_Speed           ;speed of player to kill jump
00DBCF  2               
00DBCF  2               ChkForTopCollision:
00DBCF  2  AD AF 04           lda BoundingBox_DR_YPos      ;get difference by subtracting the top
00DBD2  2  38                 sec                          ;of the platform's bounding box from the bottom
00DBD3  2  F9 AD 04           sbc BoundingBox_UL_YPos,y    ;of the player's bounding box
00DBD6  2  C9 06              cmp #$06
00DBD8  2  B0 1B              bcs PlatformSideCollisions   ;if difference not close enough, skip all of this
00DBDA  2  A5 9F              lda Player_Y_Speed
00DBDC  2  30 17              bmi PlatformSideCollisions   ;if player's vertical speed moving upwards, skip this
00DBDE  2  A5 00              lda $00                      ;get saved bounding box counter from earlier
00DBE0  2  B4 16              ldy Enemy_ID,x
00DBE2  2  C0 2B              cpy #$2b                     ;if either of the two small platform objects are found,
00DBE4  2  F0 05              beq SetCollisionFlag         ;regardless of which one, branch to use bounding box counter
00DBE6  2  C0 2C              cpy #$2c                     ;as contents of collision flag
00DBE8  2  F0 01              beq SetCollisionFlag
00DBEA  2  8A                 txa                          ;otherwise use enemy object buffer offset
00DBEB  2               
00DBEB  2               SetCollisionFlag:
00DBEB  2  A6 08              ldx ObjectOffset             ;get enemy object buffer offset
00DBED  2  9D A2 03           sta PlatformCollisionFlag,x  ;save either bounding box counter or enemy offset here
00DBF0  2  A9 00              lda #$00
00DBF2  2  85 1D              sta Player_State             ;set player state to normal then leave
00DBF4  2  60                 rts
00DBF5  2               
00DBF5  2               PlatformSideCollisions:
00DBF5  2  A9 01                 lda #$01                   ;set value here to indicate possible horizontal
00DBF7  2  85 00                 sta $00                    ;collision on left side of platform
00DBF9  2  AD AE 04              lda BoundingBox_DR_XPos    ;get difference by subtracting platform's left edge
00DBFC  2  38                    sec                        ;from player's right edge
00DBFD  2  F9 AC 04              sbc BoundingBox_UL_XPos,y
00DC00  2  C9 08                 cmp #$08                   ;if difference close enough, skip all of this
00DC02  2  90 0D                 bcc SideC
00DC04  2  E6 00                 inc $00                    ;otherwise increment value set here for right side collision
00DC06  2  B9 AE 04              lda BoundingBox_DR_XPos,y  ;get difference by subtracting player's left edge
00DC09  2  18                    clc                        ;from platform's right edge
00DC0A  2  ED AC 04              sbc BoundingBox_UL_XPos
00DC0D  2  C9 09                 cmp #$09                   ;if difference not close enough, skip subroutine
00DC0F  2  B0 03                 bcs NoSideC                ;and instead branch to leave (no collision)
00DC11  2  20 4B DF     SideC:   jsr ImpedePlayerMove       ;deal with horizontal collision
00DC14  2  A6 08        NoSideC: ldx ObjectOffset           ;return with enemy object buffer offset
00DC16  2  60                    rts
00DC17  2               
00DC17  2               ;-------------------------------------------------------------------------------------
00DC17  2               
00DC17  2               PlayerPosSPlatData:
00DC17  2  80 00              .byte $80, $00
00DC19  2               
00DC19  2               PositionPlayerOnS_Plat:
00DC19  2  A8                 tay                        ;use bounding box counter saved in collision flag
00DC1A  2  B5 CF              lda Enemy_Y_Position,x     ;for offset
00DC1C  2  18                 clc                        ;add positioning data using offset to the vertical
00DC1D  2  79 16 DC           adc PlayerPosSPlatData-1,y ;coordinate
00DC20  2  2C                 .byte $2c                    ;BIT instruction opcode
00DC21  2               
00DC21  2               PositionPlayerOnVPlat:
00DC21  2  B5 CF                 lda Enemy_Y_Position,x    ;get vertical coordinate
00DC23  2  A4 0E                 ldy GameEngineSubroutine
00DC25  2  C0 0B                 cpy #$0b                  ;if certain routine being executed on this frame,
00DC27  2  F0 17                 beq ExPlPos               ;skip all of this
00DC29  2  B4 B6                 ldy Enemy_Y_HighPos,x
00DC2B  2  C0 01                 cpy #$01                  ;if vertical high byte offscreen, skip this
00DC2D  2  D0 11                 bne ExPlPos
00DC2F  2  38                    sec                       ;subtract 32 pixels from vertical coordinate
00DC30  2  E9 20                 sbc #$20                  ;for the player object's height
00DC32  2  85 CE                 sta Player_Y_Position     ;save as player's new vertical coordinate
00DC34  2  98                    tya
00DC35  2  E9 00                 sbc #$00                  ;subtract borrow and store as player's
00DC37  2  85 B5                 sta Player_Y_HighPos      ;new vertical high byte
00DC39  2  A9 00                 lda #$00
00DC3B  2  85 9F                 sta Player_Y_Speed        ;initialize vertical speed and low byte of force
00DC3D  2  8D 33 04              sta Player_Y_MoveForce    ;and then leave
00DC40  2  60           ExPlPos: rts
00DC41  2               
00DC41  2               ;-------------------------------------------------------------------------------------
00DC41  2               
00DC41  2               CheckPlayerVertical:
00DC41  2  AD D0 03            lda Player_OffscreenBits  ;if player object is completely offscreen
00DC44  2  C9 F0               cmp #$f0                  ;vertically, leave this routine
00DC46  2  B0 09               bcs ExCPV
00DC48  2  A4 B5               ldy Player_Y_HighPos      ;if player high vertical byte is not
00DC4A  2  88                  dey                       ;within the screen, leave this routine
00DC4B  2  D0 04               bne ExCPV
00DC4D  2  A5 CE               lda Player_Y_Position     ;if on the screen, check to see how far down
00DC4F  2  C9 D0               cmp #$d0                  ;the player is vertically
00DC51  2  60           ExCPV: rts
00DC52  2               
00DC52  2               ;-------------------------------------------------------------------------------------
00DC52  2               
00DC52  2               GetEnemyBoundBoxOfs:
00DC52  2  A5 08              lda ObjectOffset         ;get enemy object buffer offset
00DC54  2               
00DC54  2               GetEnemyBoundBoxOfsArg:
00DC54  2  0A                 asl                      ;multiply A by four, then add four
00DC55  2  0A                 asl                      ;to skip player's bounding box
00DC56  2  18                 clc
00DC57  2  69 04              adc #$04
00DC59  2  A8                 tay                      ;send to Y
00DC5A  2  AD D1 03           lda Enemy_OffscreenBits  ;get offscreen bits for enemy object
00DC5D  2  29 0F              and #%00001111           ;save low nybble
00DC5F  2  C9 0F              cmp #%00001111           ;check for all bits set
00DC61  2  60                 rts
00DC62  2               
00DC62  2               ;-------------------------------------------------------------------------------------
00DC62  2               ;$00-$01 - used to hold many values, essentially temp variables
00DC62  2               ;$04 - holds lower nybble of vertical coordinate from block buffer routine
00DC62  2               ;$eb - used to hold block buffer adder
00DC62  2               
00DC62  2               PlayerBGUpperExtent:
00DC62  2  20 10              .byte $20, $10
00DC64  2               
00DC64  2               PlayerBGCollision:
00DC64  2  AD 16 07               lda DisableCollisionDet   ;if collision detection disabled flag set,
00DC67  2  D0 2E                  bne ExPBGCol              ;branch to leave
00DC69  2  A5 0E                  lda GameEngineSubroutine
00DC6B  2  C9 0B                  cmp #$0b                  ;if running routine #11 or $0b
00DC6D  2  F0 28                  beq ExPBGCol              ;branch to leave
00DC6F  2  C9 04                  cmp #$04
00DC71  2  90 24                  bcc ExPBGCol              ;if running routines $00-$03 branch to leave
00DC73  2  A9 01                  lda #$01                  ;load default player state for swimming
00DC75  2  AC 04 07               ldy SwimmingFlag          ;if swimming flag set,
00DC78  2  D0 0A                  bne SetPSte               ;branch ahead to set default state
00DC7A  2  A5 1D                  lda Player_State          ;if player in normal state,
00DC7C  2  F0 04                  beq SetFallS              ;branch to set default state for falling
00DC7E  2  C9 03                  cmp #$03
00DC80  2  D0 04                  bne ChkOnScr              ;if in any other state besides climbing, skip to next part
00DC82  2  A9 02        SetFallS: lda #$02                  ;load default player state for falling
00DC84  2  85 1D        SetPSte:  sta Player_State          ;set whatever player state is appropriate
00DC86  2  A5 B5        ChkOnScr: lda Player_Y_HighPos
00DC88  2  C9 01                  cmp #$01                  ;check player's vertical high byte for still on the screen
00DC8A  2  D0 0B                  bne ExPBGCol              ;branch to leave if not
00DC8C  2  A9 FF                  lda #$ff
00DC8E  2  8D 90 04               sta Player_CollisionBits  ;initialize player's collision flag
00DC91  2  A5 CE                  lda Player_Y_Position
00DC93  2  C9 CF                  cmp #$cf                  ;check player's vertical coordinate
00DC95  2  90 01                  bcc ChkCollSize           ;if not too close to the bottom of screen, continue
00DC97  2  60           ExPBGCol: rts                       ;otherwise leave
00DC98  2               
00DC98  2               ChkCollSize:
00DC98  2  A0 02                 ldy #$02                    ;load default offset
00DC9A  2  AD 14 07              lda CrouchingFlag
00DC9D  2  D0 0C                 bne GBBAdr                  ;if player crouching, skip ahead
00DC9F  2  AD 54 07              lda PlayerSize
00DCA2  2  D0 07                 bne GBBAdr                  ;if player small, skip ahead
00DCA4  2  88                    dey                         ;otherwise decrement offset for big player not crouching
00DCA5  2  AD 04 07              lda SwimmingFlag
00DCA8  2  D0 01                 bne GBBAdr                  ;if swimming flag set, skip ahead
00DCAA  2  88                    dey                         ;otherwise decrement offset
00DCAB  2  B9 AD E3     GBBAdr:  lda BlockBufferAdderData,y  ;get value using offset
00DCAE  2  85 EB                 sta $eb                     ;store value here
00DCB0  2  A8                    tay                         ;put value into Y, as offset for block buffer routine
00DCB1  2  AE 54 07              ldx PlayerSize              ;get player's size as offset
00DCB4  2  AD 14 07              lda CrouchingFlag
00DCB7  2  F0 01                 beq HeadChk                 ;if player not crouching, branch ahead
00DCB9  2  E8                    inx                         ;otherwise increment size as offset
00DCBA  2  A5 CE        HeadChk: lda Player_Y_Position       ;get player's vertical coordinate
00DCBC  2  DD 62 DC              cmp PlayerBGUpperExtent,x   ;compare with upper extent value based on offset
00DCBF  2  90 35                 bcc DoFootCheck             ;if player is too high, skip this part
00DCC1  2  20 E9 E3              jsr BlockBufferColli_Head   ;do player-to-bg collision detection on top of
00DCC4  2  F0 30                 beq DoFootCheck             ;player, and branch if nothing above player's head
00DCC6  2  20 A1 DF              jsr CheckForCoinMTiles      ;check to see if player touched coin with their head
00DCC9  2  B0 4F                 bcs AwardTouchedCoin        ;if so, branch to some other part of code
00DCCB  2  A4 9F                 ldy Player_Y_Speed          ;check player's vertical speed
00DCCD  2  10 27                 bpl DoFootCheck             ;if player not moving upwards, branch elsewhere
00DCCF  2  A4 04                 ldy $04                     ;check lower nybble of vertical coordinate returned
00DCD1  2  C0 04                 cpy #$04                    ;from collision detection routine
00DCD3  2  90 21                 bcc DoFootCheck             ;if low nybble < 4, branch
00DCD5  2  20 8F DF              jsr CheckForSolidMTiles     ;check to see what player's head bumped on
00DCD8  2  B0 10                 bcs SolidOrClimb            ;if player collided with solid metatile, branch
00DCDA  2  AC 4E 07              ldy AreaType                ;otherwise check area type
00DCDD  2  F0 13                 beq NYSpd                   ;if water level, branch ahead
00DCDF  2  AC 84 07              ldy BlockBounceTimer        ;if block bounce timer not expired,
00DCE2  2  D0 0E                 bne NYSpd                   ;branch ahead, do not process collision
00DCE4  2  20 ED BC              jsr PlayerHeadCollision     ;otherwise do a sub to process collision
00DCE7  2  4C F6 DC              jmp DoFootCheck             ;jump ahead to skip these other parts here
00DCEA  2               
00DCEA  2               SolidOrClimb:
00DCEA  2  C9 26               cmp #$26               ;if climbing metatile,
00DCEC  2  F0 04               beq NYSpd              ;branch ahead and do not play sound
00DCEE  2  A9 02               lda #Sfx_Bump
00DCF0  2  85 FF               sta Square1SoundQueue  ;otherwise load bump sound
00DCF2  2  A9 01        NYSpd: lda #$01               ;set player's vertical speed to nullify
00DCF4  2  85 9F               sta Player_Y_Speed     ;jump or swim
00DCF6  2               
00DCF6  2               DoFootCheck:
00DCF6  2  A4 EB              ldy $eb                    ;get block buffer adder offset
00DCF8  2  A5 CE              lda Player_Y_Position
00DCFA  2  C9 CF              cmp #$cf                   ;check to see how low player is
00DCFC  2  B0 60              bcs DoPlayerSideCheck      ;if player is too far down on screen, skip all of this
00DCFE  2  20 E8 E3           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom left of player
00DD01  2  20 A1 DF           jsr CheckForCoinMTiles     ;check to see if player touched coin with their left foot
00DD04  2  B0 14              bcs AwardTouchedCoin       ;if so, branch to some other part of code
00DD06  2  48                 pha                        ;save bottom left metatile to stack
00DD07  2  20 E8 E3           jsr BlockBufferColli_Feet  ;do player-to-bg collision detection on bottom right of player
00DD0A  2  85 00              sta $00                    ;save bottom right metatile here
00DD0C  2  68                 pla
00DD0D  2  85 01              sta $01                    ;pull bottom left metatile and save here
00DD0F  2  D0 0C              bne ChkFootMTile           ;if anything here, skip this part
00DD11  2  A5 00              lda $00                    ;otherwise check for anything in bottom right metatile
00DD13  2  F0 49              beq DoPlayerSideCheck      ;and skip ahead if not
00DD15  2  20 A1 DF           jsr CheckForCoinMTiles     ;check to see if player touched coin with their right foot
00DD18  2  90 03              bcc ChkFootMTile           ;if not, skip unconditional jump and continue code
00DD1A  2               
00DD1A  2               AwardTouchedCoin:
00DD1A  2  4C 05 DE           jmp HandleCoinMetatile     ;follow the code to erase coin and award to player 1 coin
00DD1D  2               
00DD1D  2               ChkFootMTile:
00DD1D  2  20 9A DF               jsr CheckForClimbMTiles    ;check to see if player landed on climbable metatiles
00DD20  2  B0 3C                  bcs DoPlayerSideCheck      ;if so, branch
00DD22  2  A4 9F                  ldy Player_Y_Speed         ;check player's vertical speed
00DD24  2  30 38                  bmi DoPlayerSideCheck      ;if player moving upwards, branch
00DD26  2  C9 C5                  cmp #$c5
00DD28  2  D0 03                  bne ContChk                ;if player did not touch axe, skip ahead
00DD2A  2  4C 0E DE               jmp HandleAxeMetatile      ;otherwise jump to set modes of operation
00DD2D  2  20 BD DE     ContChk:  jsr ChkInvisibleMTiles     ;do sub to check for hidden coin or 1-up blocks
00DD30  2  F0 2C                  beq DoPlayerSideCheck      ;if either found, branch
00DD32  2  AC 0E 07               ldy JumpspringAnimCtrl     ;if jumpspring animating right now,
00DD35  2  D0 23                  bne InitSteP               ;branch ahead
00DD37  2  A4 04                  ldy $04                    ;check lower nybble of vertical coordinate returned
00DD39  2  C0 05                  cpy #$05                   ;from collision detection routine
00DD3B  2  90 07                  bcc LandPlyr               ;if lower nybble < 5, branch
00DD3D  2  A5 45                  lda Player_MovingDir
00DD3F  2  85 00                  sta $00                    ;use player's moving direction as temp variable
00DD41  2  4C 4B DF               jmp ImpedePlayerMove       ;jump to impede player's movement in that direction
00DD44  2  20 C4 DE     LandPlyr: jsr ChkForLandJumpSpring   ;do sub to check for jumpspring metatiles and deal with it
00DD47  2  A9 F0                  lda #$f0
00DD49  2  25 CE                  and Player_Y_Position      ;mask out lower nybble of player's vertical position
00DD4B  2  85 CE                  sta Player_Y_Position      ;and store as new vertical position to land player properly
00DD4D  2  20 E8 DE               jsr HandlePipeEntry        ;do sub to process potential pipe entry
00DD50  2  A9 00                  lda #$00
00DD52  2  85 9F                  sta Player_Y_Speed         ;initialize vertical speed and fractional
00DD54  2  8D 33 04               sta Player_Y_MoveForce     ;movement force to stop player's vertical movement
00DD57  2  8D 84 04               sta StompChainCounter      ;initialize enemy stomp counter
00DD5A  2  A9 00        InitSteP: lda #$00
00DD5C  2  85 1D                  sta Player_State           ;set player's state to normal
00DD5E  2               
00DD5E  2               DoPlayerSideCheck:
00DD5E  2  A4 EB              ldy $eb       ;get block buffer adder offset
00DD60  2  C8                 iny
00DD61  2  C8                 iny           ;increment offset 2 bytes to use adders for side collisions
00DD62  2  A9 02              lda #$02      ;set value here to be used as counter
00DD64  2  85 00              sta $00
00DD66  2               
00DD66  2               SideCheckLoop:
00DD66  2  C8                  iny                       ;move onto the next one
00DD67  2  84 EB               sty $eb                   ;store it
00DD69  2  A5 CE               lda Player_Y_Position
00DD6B  2  C9 20               cmp #$20                  ;check player's vertical position
00DD6D  2  90 16               bcc BHalf                 ;if player is in status bar area, branch ahead to skip this part
00DD6F  2  C9 E4               cmp #$e4
00DD71  2  B0 28               bcs ExSCH                 ;branch to leave if player is too far down
00DD73  2  20 EC E3            jsr BlockBufferColli_Side ;do player-to-bg collision detection on one half of player
00DD76  2  F0 0D               beq BHalf                 ;branch ahead if nothing found
00DD78  2  C9 1C               cmp #$1c                  ;otherwise check for pipe metatiles
00DD7A  2  F0 09               beq BHalf                 ;if collided with sideways pipe (top), branch ahead
00DD7C  2  C9 6B               cmp #$6b
00DD7E  2  F0 05               beq BHalf                 ;if collided with water pipe (top), branch ahead
00DD80  2  20 9A DF            jsr CheckForClimbMTiles   ;do sub to see if player bumped into anything climbable
00DD83  2  90 17               bcc CheckSideMTiles       ;if not, branch to alternate section of code
00DD85  2  A4 EB        BHalf: ldy $eb                   ;load block adder offset
00DD87  2  C8                  iny                       ;increment it
00DD88  2  A5 CE               lda Player_Y_Position     ;get player's vertical position
00DD8A  2  C9 08               cmp #$08
00DD8C  2  90 0D               bcc ExSCH                 ;if too high, branch to leave
00DD8E  2  C9 D0               cmp #$d0
00DD90  2  B0 09               bcs ExSCH                 ;if too low, branch to leave
00DD92  2  20 EC E3            jsr BlockBufferColli_Side ;do player-to-bg collision detection on other half of player
00DD95  2  D0 05               bne CheckSideMTiles       ;if something found, branch
00DD97  2  C6 00               dec $00                   ;otherwise decrement counter
00DD99  2  D0 CB               bne SideCheckLoop         ;run code until both sides of player are checked
00DD9B  2  60           ExSCH: rts                       ;leave
00DD9C  2               
00DD9C  2               CheckSideMTiles:
00DD9C  2  20 BD DE               jsr ChkInvisibleMTiles     ;check for hidden or coin 1-up blocks
00DD9F  2  F0 61                  beq ExCSM                  ;branch to leave if either found
00DDA1  2  20 9A DF               jsr CheckForClimbMTiles    ;check for climbable metatiles
00DDA4  2  90 03                  bcc ContSChk               ;if not found, skip and continue with code
00DDA6  2  4C 2E DE               jmp HandleClimbing         ;otherwise jump to handle climbing
00DDA9  2  20 A1 DF     ContSChk: jsr CheckForCoinMTiles     ;check to see if player touched coin
00DDAC  2  B0 57                  bcs HandleCoinMetatile     ;if so, execute code to erase coin and award to player 1 coin
00DDAE  2  20 DD DE               jsr ChkJumpspringMetatiles ;check for jumpspring metatiles
00DDB1  2  90 08                  bcc ChkPBtm                ;if not found, branch ahead to continue cude
00DDB3  2  AD 0E 07               lda JumpspringAnimCtrl     ;otherwise check jumpspring animation control
00DDB6  2  D0 4A                  bne ExCSM                  ;branch to leave if set
00DDB8  2  4C FF DD               jmp StopPlayerMove         ;otherwise jump to impede player's movement
00DDBB  2  A4 1D        ChkPBtm:  ldy Player_State           ;get player's state
00DDBD  2  C0 00                  cpy #$00                   ;check for player's state set to normal
00DDBF  2  D0 3E                  bne StopPlayerMove         ;if not, branch to impede player's movement
00DDC1  2  A4 33                  ldy PlayerFacingDir        ;get player's facing direction
00DDC3  2  88                     dey
00DDC4  2  D0 39                  bne StopPlayerMove         ;if facing left, branch to impede movement
00DDC6  2  C9 6C                  cmp #$6c                   ;otherwise check for pipe metatiles
00DDC8  2  F0 04                  beq PipeDwnS               ;if collided with sideways pipe (bottom), branch
00DDCA  2  C9 1F                  cmp #$1f                   ;if collided with water pipe (bottom), continue
00DDCC  2  D0 31                  bne StopPlayerMove         ;otherwise branch to impede player's movement
00DDCE  2  AD C4 03     PipeDwnS: lda Player_SprAttrib       ;check player's attributes
00DDD1  2  D0 04                  bne PlyrPipe               ;if already set, branch, do not play sound again
00DDD3  2  A0 10                  ldy #Sfx_PipeDown_Injury
00DDD5  2  84 FF                  sty Square1SoundQueue      ;otherwise load pipedown/injury sound
00DDD7  2  09 20        PlyrPipe: ora #%00100000
00DDD9  2  8D C4 03               sta Player_SprAttrib       ;set background priority bit in player attributes
00DDDC  2  A5 86                  lda Player_X_Position
00DDDE  2  29 0F                  and #%00001111             ;get lower nybble of player's horizontal coordinate
00DDE0  2  F0 0E                  beq ChkGERtn               ;if at zero, branch ahead to skip this part
00DDE2  2  A0 00                  ldy #$00                   ;set default offset for timer setting data
00DDE4  2  AD 1A 07               lda ScreenLeft_PageLoc     ;load page location for left side of screen
00DDE7  2  F0 01                  beq SetCATmr               ;if at page zero, use default offset
00DDE9  2  C8                     iny                        ;otherwise increment offset
00DDEA  2  B9 03 DE     SetCATmr: lda AreaChangeTimerData,y  ;set timer for change of area as appropriate
00DDED  2  8D DE 06               sta ChangeAreaTimer
00DDF0  2  A5 0E        ChkGERtn: lda GameEngineSubroutine   ;get number of game engine routine running
00DDF2  2  C9 07                  cmp #$07
00DDF4  2  F0 0C                  beq ExCSM                  ;if running player entrance routine or
00DDF6  2  C9 08                  cmp #$08                   ;player control routine, go ahead and branch to leave
00DDF8  2  D0 08                  bne ExCSM
00DDFA  2  A9 02                  lda #$02
00DDFC  2  85 0E                  sta GameEngineSubroutine   ;otherwise set sideways pipe entry routine to run
00DDFE  2  60                     rts                        ;and leave
00DDFF  2               
00DDFF  2               ;--------------------------------
00DDFF  2               ;$02 - high nybble of vertical coordinate from block buffer
00DDFF  2               ;$04 - low nybble of horizontal coordinate from block buffer
00DDFF  2               ;$06-$07 - block buffer address
00DDFF  2               
00DDFF  2               StopPlayerMove:
00DDFF  2  20 4B DF            jsr ImpedePlayerMove      ;stop player's movement
00DE02  2  60           ExCSM: rts                       ;leave
00DE03  2               
00DE03  2               AreaChangeTimerData:
00DE03  2  A0 34              .byte $a0, $34
00DE05  2               
00DE05  2               HandleCoinMetatile:
00DE05  2  20 1C DE           jsr ErACM             ;do sub to erase coin metatile from block buffer
00DE08  2  EE 48 07           inc CoinTallyFor1Ups  ;increment coin tally used for 1-up blocks
00DE0B  2  4C FE BB           jmp GiveOneCoin       ;update coin amount and tally on the screen
00DE0E  2               
00DE0E  2               HandleAxeMetatile:
00DE0E  2  A9 00               lda #$00
00DE10  2  8D 72 07            sta OperMode_Task   ;reset secondary mode
00DE13  2  A9 02               lda #$02
00DE15  2  8D 70 07            sta OperMode        ;set primary mode to autoctrl mode
00DE18  2  A9 18               lda #$18
00DE1A  2  85 57               sta Player_X_Speed  ;set horizontal speed and continue to erase axe metatile
00DE1C  2  A4 02        ErACM: ldy $02             ;load vertical high nybble offset for block buffer
00DE1E  2  A9 00               lda #$00            ;load blank metatile
00DE20  2  91 06               sta ($06),y         ;store to remove old contents from block buffer
00DE22  2  4C 4D 8A            jmp RemoveCoin_Axe  ;update the screen accordingly
00DE25  2               
00DE25  2               ;--------------------------------
00DE25  2               ;$02 - high nybble of vertical coordinate from block buffer
00DE25  2               ;$04 - low nybble of horizontal coordinate from block buffer
00DE25  2               ;$06-$07 - block buffer address
00DE25  2               
00DE25  2               ClimbXPosAdder:
00DE25  2  F9 07              .byte $f9, $07
00DE27  2               
00DE27  2               ClimbPLocAdder:
00DE27  2  FF 00              .byte $ff, $00
00DE29  2               
00DE29  2               FlagpoleYPosData:
00DE29  2  18 22 50 68        .byte $18, $22, $50, $68, $90
00DE2D  2  90           
00DE2E  2               
00DE2E  2               HandleClimbing:
00DE2E  2  A4 04              ldy $04            ;check low nybble of horizontal coordinate returned from
00DE30  2  C0 06              cpy #$06           ;collision detection routine against certain values, this
00DE32  2  90 04              bcc ExHC           ;makes actual physical part of vine or flagpole thinner
00DE34  2  C0 0A              cpy #$0a           ;than 16 pixels
00DE36  2  90 01              bcc ChkForFlagpole
00DE38  2  60           ExHC: rts                ;leave if too far left or too far right
00DE39  2               
00DE39  2               ChkForFlagpole:
00DE39  2  C9 24              cmp #$24               ;check climbing metatiles
00DE3B  2  F0 04              beq FlagpoleCollision  ;branch if flagpole ball found
00DE3D  2  C9 25              cmp #$25
00DE3F  2  D0 39              bne VineCollision      ;branch to alternate code if flagpole shaft not found
00DE41  2               
00DE41  2               FlagpoleCollision:
00DE41  2  A5 0E              lda GameEngineSubroutine
00DE43  2  C9 05              cmp #$05                  ;check for end-of-level routine running
00DE45  2  F0 41              beq PutPlayerOnVine       ;if running, branch to end of climbing code
00DE47  2  A9 01              lda #$01
00DE49  2  85 33              sta PlayerFacingDir       ;set player's facing direction to right
00DE4B  2  EE 23 07           inc ScrollLock            ;set scroll lock flag
00DE4E  2  A5 0E              lda GameEngineSubroutine
00DE50  2  C9 04              cmp #$04                  ;check for flagpole slide routine running
00DE52  2  F0 1F              beq RunFR                 ;if running, branch to end of flagpole code here
00DE54  2  A9 33              lda #BulletBill_CannonVar ;load identifier for bullet bills (cannon variant)
00DE56  2  20 16 97           jsr KillEnemies           ;get rid of them
00DE59  2  A9 80              lda #Silence
00DE5B  2  85 FC              sta EventMusicQueue       ;silence music
00DE5D  2  4A                 lsr
00DE5E  2  8D 13 07           sta FlagpoleSoundQueue    ;load flagpole sound into flagpole sound queue
00DE61  2  A2 04              ldx #$04                  ;start at end of vertical coordinate data
00DE63  2  A5 CE              lda Player_Y_Position
00DE65  2  8D 0F 07           sta FlagpoleCollisionYPos ;store player's vertical coordinate here to be used later
00DE68  2               
00DE68  2               ChkFlagpoleYPosLoop:
00DE68  2  DD 29 DE            cmp FlagpoleYPosData,x    ;compare with current vertical coordinate data
00DE6B  2  B0 03               bcs MtchF                 ;if player's => current, branch to use current offset
00DE6D  2  CA                  dex                       ;otherwise decrement offset to use
00DE6E  2  D0 F8               bne ChkFlagpoleYPosLoop   ;do this until all data is checked (use last one if all checked)
00DE70  2  8E 0F 01     MtchF: stx FlagpoleScore         ;store offset here to be used later
00DE73  2  A9 04        RunFR: lda #$04
00DE75  2  85 0E               sta GameEngineSubroutine  ;set value to run flagpole slide routine
00DE77  2  4C 88 DE            jmp PutPlayerOnVine       ;jump to end of climbing code
00DE7A  2               
00DE7A  2               VineCollision:
00DE7A  2  C9 26              cmp #$26                  ;check for climbing metatile used on vines
00DE7C  2  D0 0A              bne PutPlayerOnVine
00DE7E  2  A5 CE              lda Player_Y_Position     ;check player's vertical coordinate
00DE80  2  C9 20              cmp #$20                  ;for being in status bar area
00DE82  2  B0 04              bcs PutPlayerOnVine       ;branch if not that far up
00DE84  2  A9 01              lda #$01
00DE86  2  85 0E              sta GameEngineSubroutine  ;otherwise set to run autoclimb routine next frame
00DE88  2               
00DE88  2               PutPlayerOnVine:
00DE88  2  A9 03                 lda #$03                ;set player state to climbing
00DE8A  2  85 1D                 sta Player_State
00DE8C  2  A9 00                 lda #$00                ;nullify player's horizontal speed
00DE8E  2  85 57                 sta Player_X_Speed      ;and fractional horizontal movement force
00DE90  2  8D 05 07              sta Player_X_MoveForce
00DE93  2  A5 86                 lda Player_X_Position   ;get player's horizontal coordinate
00DE95  2  38                    sec
00DE96  2  ED 1C 07              sbc ScreenLeft_X_Pos    ;subtract from left side horizontal coordinate
00DE99  2  C9 10                 cmp #$10
00DE9B  2  B0 04                 bcs SetVXPl             ;if 16 or more pixels difference, do not alter facing direction
00DE9D  2  A9 02                 lda #$02
00DE9F  2  85 33                 sta PlayerFacingDir     ;otherwise force player to face left
00DEA1  2  A4 33        SetVXPl: ldy PlayerFacingDir     ;get current facing direction, use as offset
00DEA3  2  A5 06                 lda $06                 ;get low byte of block buffer address
00DEA5  2  0A                    asl
00DEA6  2  0A                    asl                     ;move low nybble to high
00DEA7  2  0A                    asl
00DEA8  2  0A                    asl
00DEA9  2  18                    clc
00DEAA  2  79 24 DE              adc ClimbXPosAdder-1,y  ;add pixels depending on facing direction
00DEAD  2  85 86                 sta Player_X_Position   ;store as player's horizontal coordinate
00DEAF  2  A5 06                 lda $06                 ;get low byte of block buffer address again
00DEB1  2  D0 09                 bne ExPVne              ;if not zero, branch
00DEB3  2  AD 1B 07              lda ScreenRight_PageLoc ;load page location of right side of screen
00DEB6  2  18                    clc
00DEB7  2  79 26 DE              adc ClimbPLocAdder-1,y  ;add depending on facing location
00DEBA  2  85 6D                 sta Player_PageLoc      ;store as player's page location
00DEBC  2  60           ExPVne:  rts                     ;finally, we're done!
00DEBD  2               
00DEBD  2               ;--------------------------------
00DEBD  2               
00DEBD  2               ChkInvisibleMTiles:
00DEBD  2  C9 5F                 cmp #$5f       ;check for hidden coin block
00DEBF  2  F0 02                 beq ExCInvT    ;branch to leave if found
00DEC1  2  C9 60                 cmp #$60       ;check for hidden 1-up block
00DEC3  2  60           ExCInvT: rts            ;leave with zero flag set if either found
00DEC4  2               
00DEC4  2               ;--------------------------------
00DEC4  2               ;$00-$01 - used to hold bottom right and bottom left metatiles (in that order)
00DEC4  2               ;$00 - used as flag by ImpedePlayerMove to restrict specific movement
00DEC4  2               
00DEC4  2               ChkForLandJumpSpring:
00DEC4  2  20 DD DE             jsr ChkJumpspringMetatiles  ;do sub to check if player landed on jumpspring
00DEC7  2  90 13                bcc ExCJSp                  ;if carry not set, jumpspring not found, therefore leave
00DEC9  2  A9 70                lda #$70
00DECB  2  8D 09 07             sta VerticalForce           ;otherwise set vertical movement force for player
00DECE  2  A9 F9                lda #$f9
00DED0  2  8D DB 06             sta JumpspringForce         ;set default jumpspring force
00DED3  2  A9 03                lda #$03
00DED5  2  8D 86 07             sta JumpspringTimer         ;set jumpspring timer to be used later
00DED8  2  4A                   lsr
00DED9  2  8D 0E 07             sta JumpspringAnimCtrl      ;set jumpspring animation control to start animating
00DEDC  2  60           ExCJSp: rts                         ;and leave
00DEDD  2               
00DEDD  2               ChkJumpspringMetatiles:
00DEDD  2  C9 67                 cmp #$67      ;check for top jumpspring metatile
00DEDF  2  F0 05                 beq JSFnd     ;branch to set carry if found
00DEE1  2  C9 68                 cmp #$68      ;check for bottom jumpspring metatile
00DEE3  2  18                    clc           ;clear carry flag
00DEE4  2  D0 01                 bne NoJSFnd   ;branch to use cleared carry if not found
00DEE6  2  38           JSFnd:   sec           ;set carry if found
00DEE7  2  60           NoJSFnd: rts           ;leave
00DEE8  2               
00DEE8  2               HandlePipeEntry:
00DEE8  2  A5 0B                 lda Up_Down_Buttons       ;check saved controller bits from earlier
00DEEA  2  29 04                 and #%00000100            ;for pressing down
00DEEC  2  F0 5C                 beq ExPipeE               ;if not pressing down, branch to leave
00DEEE  2  A5 00                 lda $00
00DEF0  2  C9 11                 cmp #$11                  ;check right foot metatile for warp pipe right metatile
00DEF2  2  D0 56                 bne ExPipeE               ;branch to leave if not found
00DEF4  2  A5 01                 lda $01
00DEF6  2  C9 10                 cmp #$10                  ;check left foot metatile for warp pipe left metatile
00DEF8  2  D0 50                 bne ExPipeE               ;branch to leave if not found
00DEFA  2  A9 30                 lda #$30
00DEFC  2  8D DE 06              sta ChangeAreaTimer       ;set timer for change of area
00DEFF  2  A9 03                 lda #$03
00DF01  2  85 0E                 sta GameEngineSubroutine  ;set to run vertical pipe entry routine on next frame
00DF03  2  A9 10                 lda #Sfx_PipeDown_Injury
00DF05  2  85 FF                 sta Square1SoundQueue     ;load pipedown/injury sound
00DF07  2  A9 20                 lda #%00100000
00DF09  2  8D C4 03              sta Player_SprAttrib      ;set background priority bit in player's attributes
00DF0C  2  AD D6 06              lda WarpZoneControl       ;check warp zone control
00DF0F  2  F0 39                 beq ExPipeE               ;branch to leave if none found
00DF11  2  29 03                 and #%00000011            ;mask out all but 2 LSB
00DF13  2  0A                    asl
00DF14  2  0A                    asl                       ;multiply by four
00DF15  2  AA                    tax                       ;save as offset to warp zone numbers (starts at left pipe)
00DF16  2  A5 86                 lda Player_X_Position     ;get player's horizontal position
00DF18  2  C9 60                 cmp #$60
00DF1A  2  90 06                 bcc GetWNum               ;if player at left, not near middle, use offset and skip ahead
00DF1C  2  E8                    inx                       ;otherwise increment for middle pipe
00DF1D  2  C9 A0                 cmp #$a0
00DF1F  2  90 01                 bcc GetWNum               ;if player at middle, but not too far right, use offset and skip
00DF21  2  E8                    inx                       ;otherwise increment for last pipe
00DF22  2  BC F2 87     GetWNum: ldy WarpZoneNumbers,x     ;get warp zone numbers
00DF25  2  88                    dey                       ;decrement for use as world number
00DF26  2  8C 5F 07              sty WorldNumber           ;store as world number and offset
00DF29  2  BE B4 9C              ldx WorldAddrOffsets,y    ;get offset to where this world's area offsets are
00DF2C  2  BD BC 9C              lda AreaAddrOffsets,x     ;get area offset based on world offset
00DF2F  2  8D 50 07              sta AreaPointer           ;store area offset here to be used to change areas
00DF32  2  A9 80                 lda #Silence
00DF34  2  85 FC                 sta EventMusicQueue       ;silence music
00DF36  2  A9 00                 lda #$00
00DF38  2  8D 51 07              sta EntrancePage          ;initialize starting page number
00DF3B  2  8D 60 07              sta AreaNumber            ;initialize area number used for area address offset
00DF3E  2  8D 5C 07              sta LevelNumber           ;initialize level number used for world display
00DF41  2  8D 52 07              sta AltEntranceControl    ;initialize mode of entry
00DF44  2  EE 5D 07              inc Hidden1UpFlag         ;set flag for hidden 1-up blocks
00DF47  2  EE 57 07              inc FetchNewGameTimerFlag ;set flag to load new game timer
00DF4A  2  60           ExPipeE: rts                       ;leave!!!
00DF4B  2               
00DF4B  2               ImpedePlayerMove:
00DF4B  2  A9 00               lda #$00                  ;initialize value here
00DF4D  2  A4 57               ldy Player_X_Speed        ;get player's horizontal speed
00DF4F  2  A6 00               ldx $00                   ;check value set earlier for
00DF51  2  CA                  dex                       ;left side collision
00DF52  2  D0 0A               bne RImpd                 ;if right side collision, skip this part
00DF54  2  E8                  inx                       ;return value to X
00DF55  2  C0 00               cpy #$00                  ;if player moving to the left,
00DF57  2  30 28               bmi ExIPM                 ;branch to invert bit and leave
00DF59  2  A9 FF               lda #$ff                  ;otherwise load A with value to be used later
00DF5B  2  4C 66 DF            jmp NXSpd                 ;and jump to affect movement
00DF5E  2  A2 02        RImpd: ldx #$02                  ;return $02 to X
00DF60  2  C0 01               cpy #$01                  ;if player moving to the right,
00DF62  2  10 1D               bpl ExIPM                 ;branch to invert bit and leave
00DF64  2  A9 01               lda #$01                  ;otherwise load A with value to be used here
00DF66  2  A0 10        NXSpd: ldy #$10
00DF68  2  8C 85 07            sty SideCollisionTimer    ;set timer of some sort
00DF6B  2  A0 00               ldy #$00
00DF6D  2  84 57               sty Player_X_Speed        ;nullify player's horizontal speed
00DF6F  2  C9 00               cmp #$00                  ;if value set in A not set to $ff,
00DF71  2  10 01               bpl PlatF                 ;branch ahead, do not decrement Y
00DF73  2  88                  dey                       ;otherwise decrement Y now
00DF74  2  84 00        PlatF: sty $00                   ;store Y as high bits of horizontal adder
00DF76  2  18                  clc
00DF77  2  65 86               adc Player_X_Position     ;add contents of A to player's horizontal
00DF79  2  85 86               sta Player_X_Position     ;position to move player left or right
00DF7B  2  A5 6D               lda Player_PageLoc
00DF7D  2  65 00               adc $00                   ;add high bits and carry to
00DF7F  2  85 6D               sta Player_PageLoc        ;page location if necessary
00DF81  2  8A           ExIPM: txa                       ;invert contents of X
00DF82  2  49 FF               eor #$ff
00DF84  2  2D 90 04            and Player_CollisionBits  ;mask out bit that was set here
00DF87  2  8D 90 04            sta Player_CollisionBits  ;store to clear bit
00DF8A  2  60                  rts
00DF8B  2               
00DF8B  2               ;--------------------------------
00DF8B  2               
00DF8B  2               SolidMTileUpperExt:
00DF8B  2  10 61 88 C4        .byte $10, $61, $88, $c4
00DF8F  2               
00DF8F  2               CheckForSolidMTiles:
00DF8F  2  20 B0 DF           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DF92  2  DD 8B DF           cmp SolidMTileUpperExt,x  ;compare current metatile with solid metatiles
00DF95  2  60                 rts
00DF96  2               
00DF96  2               ClimbMTileUpperExt:
00DF96  2  24 6D 8A C6        .byte $24, $6d, $8a, $c6
00DF9A  2               
00DF9A  2               CheckForClimbMTiles:
00DF9A  2  20 B0 DF           jsr GetMTileAttrib        ;find appropriate offset based on metatile's 2 MSB
00DF9D  2  DD 96 DF           cmp ClimbMTileUpperExt,x  ;compare current metatile with climbable metatiles
00DFA0  2  60                 rts
00DFA1  2               
00DFA1  2               CheckForCoinMTiles:
00DFA1  2  C9 C2                 cmp #$c2              ;check for regular coin
00DFA3  2  F0 06                 beq CoinSd            ;branch if found
00DFA5  2  C9 C3                 cmp #$c3              ;check for underwater coin
00DFA7  2  F0 02                 beq CoinSd            ;branch if found
00DFA9  2  18                    clc                   ;otherwise clear carry and leave
00DFAA  2  60                    rts
00DFAB  2  A9 01        CoinSd:  lda #Sfx_CoinGrab
00DFAD  2  85 FE                 sta Square2SoundQueue ;load coin grab sound and leave
00DFAF  2  60                    rts
00DFB0  2               
00DFB0  2               GetMTileAttrib:
00DFB0  2  A8                  tay            ;save metatile value into Y
00DFB1  2  29 C0               and #%11000000 ;mask out all but 2 MSB
00DFB3  2  0A                  asl
00DFB4  2  2A                  rol            ;shift and rotate d7-d6 to d1-d0
00DFB5  2  2A                  rol
00DFB6  2  AA                  tax            ;use as offset for metatile data
00DFB7  2  98                  tya            ;get original metatile value back
00DFB8  2  60           ExEBG: rts            ;leave
00DFB9  2               
00DFB9  2               ;-------------------------------------------------------------------------------------
00DFB9  2               ;$06-$07 - address from block buffer routine
00DFB9  2               
00DFB9  2               EnemyBGCStateData:
00DFB9  2  01 01 02 02        .byte $01, $01, $02, $02, $02, $05
00DFBD  2  02 05        
00DFBF  2               
00DFBF  2               EnemyBGCXSpdData:
00DFBF  2  10 F0              .byte $10, $f0
00DFC1  2               
00DFC1  2               EnemyToBGCollisionDet:
00DFC1  2  B5 1E              lda Enemy_State,x        ;check enemy state for d6 set
00DFC3  2  29 20              and #%00100000
00DFC5  2  D0 F1              bne ExEBG                ;if set, branch to leave
00DFC7  2  20 5B E1           jsr SubtEnemyYPos        ;otherwise, do a subroutine here
00DFCA  2  90 EC              bcc ExEBG                ;if enemy vertical coord + 62 < 68, branch to leave
00DFCC  2  B4 16              ldy Enemy_ID,x
00DFCE  2  C0 12              cpy #Spiny               ;if enemy object is not spiny, branch elsewhere
00DFD0  2  D0 06              bne DoIDCheckBGColl
00DFD2  2  B5 CF              lda Enemy_Y_Position,x
00DFD4  2  C9 25              cmp #$25                 ;if enemy vertical coordinate < 36 branch to leave
00DFD6  2  90 E0              bcc ExEBG
00DFD8  2               
00DFD8  2               DoIDCheckBGColl:
00DFD8  2  C0 0E               cpy #GreenParatroopaJump ;check for some other enemy object
00DFDA  2  D0 03               bne HBChk                ;branch if not found
00DFDC  2  4C 63 E1            jmp EnemyJump            ;otherwise jump elsewhere
00DFDF  2  C0 05        HBChk: cpy #HammerBro           ;check for hammer bro
00DFE1  2  D0 03               bne CInvu                ;branch if not found
00DFE3  2  4C 85 E1            jmp HammerBroBGColl      ;otherwise jump elsewhere
00DFE6  2  C0 12        CInvu: cpy #Spiny               ;if enemy object is spiny, branch
00DFE8  2  F0 08               beq YesIn
00DFEA  2  C0 2E               cpy #PowerUpObject       ;if special power-up object, branch
00DFEC  2  F0 04               beq YesIn
00DFEE  2  C0 07               cpy #$07                 ;if enemy object =>$07, branch to leave
00DFF0  2  B0 74               bcs ExEBGChk
00DFF2  2  20 AE E1     YesIn: jsr ChkUnderEnemy        ;if enemy object < $07, or = $12 or $2e, do this sub
00DFF5  2  D0 03               bne HandleEToBGCollision ;if block underneath enemy, branch
00DFF7  2               
00DFF7  2               NoEToBGCollision:
00DFF7  2  4C E2 E0            jmp ChkForRedKoopa       ;otherwise skip and do something else
00DFFA  2               
00DFFA  2               ;--------------------------------
00DFFA  2               ;$02 - vertical coordinate from block buffer routine
00DFFA  2               
00DFFA  2               HandleEToBGCollision:
00DFFA  2  20 B5 E1           jsr ChkForNonSolids       ;if something is underneath enemy, find out what
00DFFD  2  F0 F8              beq NoEToBGCollision      ;if blank $26, coins, or hidden blocks, jump, enemy falls through
00DFFF  2  C9 23              cmp #$23
00E001  2  D0 64              bne LandEnemyProperly     ;check for blank metatile $23 and branch if not found
00E003  2  A4 02              ldy $02                   ;get vertical coordinate used to find block
00E005  2  A9 00              lda #$00                  ;store default blank metatile in that spot so we won't
00E007  2  91 06              sta ($06),y               ;trigger this routine accidentally again
00E009  2  B5 16              lda Enemy_ID,x
00E00B  2  C9 15              cmp #$15                  ;if enemy object => $15, branch ahead
00E00D  2  B0 0C              bcs ChkToStunEnemies
00E00F  2  C9 06              cmp #Goomba               ;if enemy object not goomba, branch ahead of this routine
00E011  2  D0 03              bne GiveOEPoints
00E013  2  20 8E E1           jsr KillEnemyAboveBlock   ;if enemy object IS goomba, do this sub
00E016  2               
00E016  2               GiveOEPoints:
00E016  2  A9 01              lda #$01                  ;award 100 points for hitting block beneath enemy
00E018  2  20 11 DA           jsr SetupFloateyNumber
00E01B  2               
00E01B  2               ChkToStunEnemies:
00E01B  2  C9 09                  cmp #$09                   ;perform many comparisons on enemy object identifier
00E01D  2  90 10                  bcc SetStun
00E01F  2  C9 11                  cmp #$11                   ;if the enemy object identifier is equal to the values
00E021  2  B0 0C                  bcs SetStun                ;$09, $0e, $0f or $10, it will be modified, and not
00E023  2  C9 0A                  cmp #$0a                   ;modified if not any of those values, note that piranha plant will
00E025  2  90 04                  bcc Demote                 ;always fail this test because A will still have vertical
00E027  2  C9 0D                  cmp #PiranhaPlant          ;coordinate from previous addition, also these comparisons
00E029  2  90 04                  bcc SetStun                ;are only necessary if branching from $d7a1
00E02B  2  29 01        Demote:   and #%00000001             ;erase all but LSB, essentially turning enemy object
00E02D  2  95 16                  sta Enemy_ID,x             ;into green or red koopa troopa to demote them
00E02F  2  B5 1E        SetStun:  lda Enemy_State,x          ;load enemy state
00E031  2  29 F0                  and #%11110000             ;save high nybble
00E033  2  09 02                  ora #%00000010
00E035  2  95 1E                  sta Enemy_State,x          ;set d1 of enemy state
00E037  2  D6 CF                  dec Enemy_Y_Position,x
00E039  2  D6 CF                  dec Enemy_Y_Position,x     ;subtract two pixels from enemy's vertical position
00E03B  2  B5 16                  lda Enemy_ID,x
00E03D  2  C9 07                  cmp #Bloober               ;check for bloober object
00E03F  2  F0 07                  beq SetWYSpd
00E041  2  A9 FD                  lda #$fd                   ;set default vertical speed
00E043  2  AC 4E 07               ldy AreaType
00E046  2  D0 02                  bne SetNotW                ;if area type not water, set as speed, otherwise
00E048  2  A9 FF        SetWYSpd: lda #$ff                   ;change the vertical speed
00E04A  2  95 A0        SetNotW:  sta Enemy_Y_Speed,x        ;set vertical speed now
00E04C  2  A0 01                  ldy #$01
00E04E  2  20 43 E1               jsr PlayerEnemyDiff        ;get horizontal difference between player and enemy object
00E051  2  10 01                  bpl ChkBBill               ;branch if enemy is to the right of player
00E053  2  C8                     iny                        ;increment Y if not
00E054  2  B5 16        ChkBBill: lda Enemy_ID,x
00E056  2  C9 33                  cmp #BulletBill_CannonVar  ;check for bullet bill (cannon variant)
00E058  2  F0 06                  beq NoCDirF
00E05A  2  C9 08                  cmp #BulletBill_FrenzyVar  ;check for bullet bill (frenzy variant)
00E05C  2  F0 02                  beq NoCDirF                ;branch if either found, direction does not change
00E05E  2  94 46                  sty Enemy_MovingDir,x      ;store as moving direction
00E060  2  88           NoCDirF:  dey                        ;decrement and use as offset
00E061  2  B9 BF DF               lda EnemyBGCXSpdData,y     ;get proper horizontal speed
00E064  2  95 58                  sta Enemy_X_Speed,x        ;and store, then leave
00E066  2  60           ExEBGChk: rts
00E067  2               
00E067  2               ;--------------------------------
00E067  2               ;$04 - low nybble of vertical coordinate from block buffer routine
00E067  2               
00E067  2               LandEnemyProperly:
00E067  2  A5 04               lda $04                 ;check lower nybble of vertical coordinate saved earlier
00E069  2  38                  sec
00E06A  2  E9 08               sbc #$08                ;subtract eight pixels
00E06C  2  C9 05               cmp #$05                ;used to determine whether enemy landed from falling
00E06E  2  B0 72               bcs ChkForRedKoopa      ;branch if lower nybble in range of $0d-$0f before subtract
00E070  2  B5 1E               lda Enemy_State,x
00E072  2  29 40               and #%01000000          ;branch if d6 in enemy state is set
00E074  2  D0 57               bne LandEnemyInitState
00E076  2  B5 1E               lda Enemy_State,x
00E078  2  0A                  asl                     ;branch if d7 in enemy state is not set
00E079  2  90 03               bcc ChkLandedEnemyState
00E07B  2  4C FE E0     SChkA: jmp DoEnemySideCheck    ;if lower nybble < $0d, d7 set but d6 not set, jump here
00E07E  2               
00E07E  2               ChkLandedEnemyState:
00E07E  2  B5 1E                   lda Enemy_State,x         ;if enemy in normal state, branch back to jump here
00E080  2  F0 F9                   beq SChkA
00E082  2  C9 05                   cmp #$05                  ;if in state used by spiny's egg
00E084  2  F0 1F                   beq ProcEnemyDirection    ;then branch elsewhere
00E086  2  C9 03                   cmp #$03                  ;if already in state used by koopas and buzzy beetles
00E088  2  B0 1A                   bcs ExSteChk              ;or in higher numbered state, branch to leave
00E08A  2  B5 1E                   lda Enemy_State,x         ;load enemy state again (why?)
00E08C  2  C9 02                   cmp #$02                  ;if not in $02 state (used by koopas and buzzy beetles)
00E08E  2  D0 15                   bne ProcEnemyDirection    ;then branch elsewhere
00E090  2  A9 10                   lda #$10                  ;load default timer here
00E092  2  B4 16                   ldy Enemy_ID,x            ;check enemy identifier for spiny
00E094  2  C0 12                   cpy #Spiny
00E096  2  D0 02                   bne SetForStn             ;branch if not found
00E098  2  A9 00                   lda #$00                  ;set timer for $00 if spiny
00E09A  2  9D 96 07     SetForStn: sta EnemyIntervalTimer,x  ;set timer here
00E09D  2  A9 03                   lda #$03                  ;set state here, apparently used to render
00E09F  2  95 1E                   sta Enemy_State,x         ;upside-down koopas and buzzy beetles
00E0A1  2  20 4F E1                jsr EnemyLanding          ;then land it properly
00E0A4  2  60           ExSteChk:  rts                       ;then leave
00E0A5  2               
00E0A5  2               ProcEnemyDirection:
00E0A5  2  B5 16                 lda Enemy_ID,x            ;check enemy identifier for goomba
00E0A7  2  C9 06                 cmp #Goomba               ;branch if found
00E0A9  2  F0 22                 beq LandEnemyInitState
00E0AB  2  C9 12                 cmp #Spiny                ;check for spiny
00E0AD  2  D0 0E                 bne InvtD                 ;branch if not found
00E0AF  2  A9 01                 lda #$01
00E0B1  2  95 46                 sta Enemy_MovingDir,x     ;send enemy moving to the right by default
00E0B3  2  A9 08                 lda #$08
00E0B5  2  95 58                 sta Enemy_X_Speed,x       ;set horizontal speed accordingly
00E0B7  2  A5 09                 lda FrameCounter
00E0B9  2  29 07                 and #%00000111            ;if timed appropriately, spiny will skip over
00E0BB  2  F0 10                 beq LandEnemyInitState    ;trying to face the player
00E0BD  2  A0 01        InvtD:   ldy #$01                  ;load 1 for enemy to face the left (inverted here)
00E0BF  2  20 43 E1              jsr PlayerEnemyDiff       ;get horizontal difference between player and enemy
00E0C2  2  10 01                 bpl CNwCDir               ;if enemy to the right of player, branch
00E0C4  2  C8                    iny                       ;if to the left, increment by one for enemy to face right (inverted)
00E0C5  2  98           CNwCDir: tya
00E0C6  2  D5 46                 cmp Enemy_MovingDir,x     ;compare direction in A with current direction in memory
00E0C8  2  D0 03                 bne LandEnemyInitState
00E0CA  2  20 24 E1              jsr ChkForBump_HammerBroJ ;if equal, not facing in correct dir, do sub to turn around
00E0CD  2               
00E0CD  2               LandEnemyInitState:
00E0CD  2  20 4F E1           jsr EnemyLanding       ;land enemy properly
00E0D0  2  B5 1E              lda Enemy_State,x
00E0D2  2  29 80              and #%10000000         ;if d7 of enemy state is set, branch
00E0D4  2  D0 05              bne NMovShellFallBit
00E0D6  2  A9 00              lda #$00               ;otherwise initialize enemy state and leave
00E0D8  2  95 1E              sta Enemy_State,x      ;note this will also turn spiny's egg into spiny
00E0DA  2  60                 rts
00E0DB  2               
00E0DB  2               NMovShellFallBit:
00E0DB  2  B5 1E              lda Enemy_State,x   ;nullify d6 of enemy state, save other bits
00E0DD  2  29 BF              and #%10111111      ;and store, then leave
00E0DF  2  95 1E              sta Enemy_State,x
00E0E1  2  60                 rts
00E0E2  2               
00E0E2  2               ;--------------------------------
00E0E2  2               
00E0E2  2               ChkForRedKoopa:
00E0E2  2  B5 16                     lda Enemy_ID,x            ;check for red koopa troopa $03
00E0E4  2  C9 03                     cmp #RedKoopa
00E0E6  2  D0 04                     bne Chk2MSBSt             ;branch if not found
00E0E8  2  B5 1E                     lda Enemy_State,x
00E0EA  2  F0 38                     beq ChkForBump_HammerBroJ ;if enemy found and in normal state, branch
00E0EC  2  B5 1E        Chk2MSBSt:   lda Enemy_State,x         ;save enemy state into Y
00E0EE  2  A8                        tay
00E0EF  2  0A                        asl                       ;check for d7 set
00E0F0  2  90 07                     bcc GetSteFromD           ;branch if not set
00E0F2  2  B5 1E                     lda Enemy_State,x
00E0F4  2  09 40                     ora #%01000000            ;set d6
00E0F6  2  4C FC E0                  jmp SetD6Ste              ;jump ahead of this part
00E0F9  2  B9 B9 DF     GetSteFromD: lda EnemyBGCStateData,y   ;load new enemy state with old as offset
00E0FC  2  95 1E        SetD6Ste:    sta Enemy_State,x         ;set as new state
00E0FE  2               
00E0FE  2               ;--------------------------------
00E0FE  2               ;$00 - used to store bitmask (not used but initialized here)
00E0FE  2               ;$eb - used in DoEnemySideCheck as counter and to compare moving directions
00E0FE  2               
00E0FE  2               DoEnemySideCheck:
00E0FE  2  B5 CF                  lda Enemy_Y_Position,x     ;if enemy within status bar, branch to leave
00E100  2  C9 20                  cmp #$20                   ;because there's nothing there that impedes movement
00E102  2  90 1F                  bcc ExESdeC
00E104  2  A0 16                  ldy #$16                   ;start by finding block to the left of enemy ($00,$14)
00E106  2  A9 02                  lda #$02                   ;set value here in what is also used as
00E108  2  85 EB                  sta $eb                    ;OAM data offset
00E10A  2  A5 EB        SdeCLoop: lda $eb                    ;check value
00E10C  2  D5 46                  cmp Enemy_MovingDir,x      ;compare value against moving direction
00E10E  2  D0 0C                  bne NextSdeC               ;branch if different and do not seek block there
00E110  2  A9 01                  lda #$01                   ;set flag in A for save horizontal coordinate
00E112  2  20 88 E3               jsr BlockBufferChk_Enemy   ;find block to left or right of enemy object
00E115  2  F0 05                  beq NextSdeC               ;if nothing found, branch
00E117  2  20 B5 E1               jsr ChkForNonSolids        ;check for non-solid blocks
00E11A  2  D0 08                  bne ChkForBump_HammerBroJ  ;branch if not found
00E11C  2  C6 EB        NextSdeC: dec $eb                    ;move to the next direction
00E11E  2  C8                     iny
00E11F  2  C0 18                  cpy #$18                   ;increment Y, loop only if Y < $18, thus we check
00E121  2  90 E7                  bcc SdeCLoop               ;enemy ($00, $14) and ($10, $14) pixel coordinates
00E123  2  60           ExESdeC:  rts
00E124  2               
00E124  2               ChkForBump_HammerBroJ:
00E124  2  E0 05                cpx #$05               ;check if we're on the special use slot
00E126  2  F0 09                beq NoBump             ;and if so, branch ahead and do not play sound
00E128  2  B5 1E                lda Enemy_State,x      ;if enemy state d7 not set, branch
00E12A  2  0A                   asl                    ;ahead and do not play sound
00E12B  2  90 04                bcc NoBump
00E12D  2  A9 02                lda #Sfx_Bump          ;otherwise, play bump sound
00E12F  2  85 FF                sta Square1SoundQueue  ;sound will never be played if branching from ChkForRedKoopa
00E131  2  B5 16        NoBump: lda Enemy_ID,x         ;check for hammer bro
00E133  2  C9 05                cmp #$05
00E135  2  D0 09                bne InvEnemyDir        ;branch if not found
00E137  2  A9 00                lda #$00
00E139  2  85 00                sta $00                ;initialize value here for bitmask
00E13B  2  A0 FA                ldy #$fa               ;load default vertical speed for jumping
00E13D  2  4C 37 CA             jmp SetHJ              ;jump to code that makes hammer bro jump
00E140  2               
00E140  2               InvEnemyDir:
00E140  2  4C 36 DB           jmp RXSpd     ;jump to turn the enemy around
00E143  2               
00E143  2               ;--------------------------------
00E143  2               ;$00 - used to hold horizontal difference between player and enemy
00E143  2               
00E143  2               PlayerEnemyDiff:
00E143  2  B5 87              lda Enemy_X_Position,x  ;get distance between enemy object's
00E145  2  38                 sec                     ;horizontal coordinate and the player's
00E146  2  E5 86              sbc Player_X_Position   ;horizontal coordinate
00E148  2  85 00              sta $00                 ;and store here
00E14A  2  B5 6E              lda Enemy_PageLoc,x
00E14C  2  E5 6D              sbc Player_PageLoc      ;subtract borrow, then leave
00E14E  2  60                 rts
00E14F  2               
00E14F  2               ;--------------------------------
00E14F  2               
00E14F  2               EnemyLanding:
00E14F  2  20 63 C3           jsr InitVStf            ;do something here to vertical speed and something else
00E152  2  B5 CF              lda Enemy_Y_Position,x
00E154  2  29 F0              and #%11110000          ;save high nybble of vertical coordinate, and
00E156  2  09 08              ora #%00001000          ;set d3, then store, probably used to set enemy object
00E158  2  95 CF              sta Enemy_Y_Position,x  ;neatly on whatever it's landing on
00E15A  2  60                 rts
00E15B  2               
00E15B  2               SubtEnemyYPos:
00E15B  2  B5 CF              lda Enemy_Y_Position,x  ;add 62 pixels to enemy object's
00E15D  2  18                 clc                     ;vertical coordinate
00E15E  2  69 3E              adc #$3e
00E160  2  C9 44              cmp #$44                ;compare against a certain range
00E162  2  60                 rts                     ;and leave with flags set for conditional branch
00E163  2               
00E163  2               EnemyJump:
00E163  2  20 5B E1             jsr SubtEnemyYPos     ;do a sub here
00E166  2  90 1A                bcc DoSide            ;if enemy vertical coord + 62 < 68, branch to leave
00E168  2  B5 A0                lda Enemy_Y_Speed,x
00E16A  2  18                   clc                   ;add two to vertical speed
00E16B  2  69 02                adc #$02
00E16D  2  C9 03                cmp #$03              ;if green paratroopa not falling, branch ahead
00E16F  2  90 11                bcc DoSide
00E171  2  20 AE E1             jsr ChkUnderEnemy     ;otherwise, check to see if green paratroopa is
00E174  2  F0 0C                beq DoSide            ;standing on anything, then branch to same place if not
00E176  2  20 B5 E1             jsr ChkForNonSolids   ;check for non-solid blocks
00E179  2  F0 07                beq DoSide            ;branch if found
00E17B  2  20 4F E1             jsr EnemyLanding      ;change vertical coordinate and speed
00E17E  2  A9 FD                lda #$fd
00E180  2  95 A0                sta Enemy_Y_Speed,x   ;make the paratroopa jump again
00E182  2  4C FE E0     DoSide: jmp DoEnemySideCheck  ;check for horizontal blockage, then leave
00E185  2               
00E185  2               ;--------------------------------
00E185  2               
00E185  2               HammerBroBGColl:
00E185  2  20 AE E1           jsr ChkUnderEnemy    ;check to see if hammer bro is standing on anything
00E188  2  F0 1D              beq NoUnderHammerBro
00E18A  2  C9 23              cmp #$23             ;check for blank metatile $23 and branch if not found
00E18C  2  D0 08              bne UnderHammerBro
00E18E  2               
00E18E  2               KillEnemyAboveBlock:
00E18E  2  20 95 D7           jsr ShellOrBlockDefeat  ;do this sub to kill enemy
00E191  2  A9 FC              lda #$fc                ;alter vertical speed of enemy and leave
00E193  2  95 A0              sta Enemy_Y_Speed,x
00E195  2  60                 rts
00E196  2               
00E196  2               UnderHammerBro:
00E196  2  BD 8A 07           lda EnemyFrameTimer,x ;check timer used by hammer bro
00E199  2  D0 0C              bne NoUnderHammerBro  ;branch if not expired
00E19B  2  B5 1E              lda Enemy_State,x
00E19D  2  29 88              and #%10001000        ;save d7 and d3 from enemy state, nullify other bits
00E19F  2  95 1E              sta Enemy_State,x     ;and store
00E1A1  2  20 4F E1           jsr EnemyLanding      ;modify vertical coordinate, speed and something else
00E1A4  2  4C FE E0           jmp DoEnemySideCheck  ;then check for horizontal blockage and leave
00E1A7  2               
00E1A7  2               NoUnderHammerBro:
00E1A7  2  B5 1E              lda Enemy_State,x  ;if hammer bro is not standing on anything, set d0
00E1A9  2  09 01              ora #$01           ;in the enemy state to indicate jumping or falling, then leave
00E1AB  2  95 1E              sta Enemy_State,x
00E1AD  2  60                 rts
00E1AE  2               
00E1AE  2               ChkUnderEnemy:
00E1AE  2  A9 00              lda #$00                  ;set flag in A for save vertical coordinate
00E1B0  2  A0 15              ldy #$15                  ;set Y to check the bottom middle (8,18) of enemy object
00E1B2  2  4C 88 E3           jmp BlockBufferChk_Enemy  ;hop to it!
00E1B5  2               
00E1B5  2               ChkForNonSolids:
00E1B5  2  C9 26               cmp #$26       ;blank metatile used for vines?
00E1B7  2  F0 0E               beq NSFnd
00E1B9  2  C9 C2               cmp #$c2       ;regular coin?
00E1BB  2  F0 0A               beq NSFnd
00E1BD  2  C9 C3               cmp #$c3       ;underwater coin?
00E1BF  2  F0 06               beq NSFnd
00E1C1  2  C9 5F               cmp #$5f       ;hidden coin block?
00E1C3  2  F0 02               beq NSFnd
00E1C5  2  C9 60               cmp #$60       ;hidden 1-up block?
00E1C7  2  60           NSFnd: rts
00E1C8  2               
00E1C8  2               ;-------------------------------------------------------------------------------------
00E1C8  2               
00E1C8  2               FireballBGCollision:
00E1C8  2  B5 D5              lda Fireball_Y_Position,x   ;check fireball's vertical coordinate
00E1CA  2  C9 18              cmp #$18
00E1CC  2  90 21              bcc ClearBounceFlag         ;if within the status bar area of the screen, branch ahead
00E1CE  2  20 9C E3           jsr BlockBufferChk_FBall    ;do fireball to background collision detection on bottom of it
00E1D1  2  F0 1C              beq ClearBounceFlag         ;if nothing underneath fireball, branch
00E1D3  2  20 B5 E1           jsr ChkForNonSolids         ;check for non-solid metatiles
00E1D6  2  F0 17              beq ClearBounceFlag         ;branch if any found
00E1D8  2  B5 A6              lda Fireball_Y_Speed,x      ;if fireball's vertical speed set to move upwards,
00E1DA  2  30 18              bmi InitFireballExplode     ;branch to set exploding bit in fireball's state
00E1DC  2  B5 3A              lda FireballBouncingFlag,x  ;if bouncing flag already set,
00E1DE  2  D0 14              bne InitFireballExplode     ;branch to set exploding bit in fireball's state
00E1E0  2  A9 FD              lda #$fd
00E1E2  2  95 A6              sta Fireball_Y_Speed,x      ;otherwise set vertical speed to move upwards (give it bounce)
00E1E4  2  A9 01              lda #$01
00E1E6  2  95 3A              sta FireballBouncingFlag,x  ;set bouncing flag
00E1E8  2  B5 D5              lda Fireball_Y_Position,x
00E1EA  2  29 F8              and #$f8                    ;modify vertical coordinate to land it properly
00E1EC  2  95 D5              sta Fireball_Y_Position,x   ;store as new vertical coordinate
00E1EE  2  60                 rts                         ;leave
00E1EF  2               
00E1EF  2               ClearBounceFlag:
00E1EF  2  A9 00              lda #$00
00E1F1  2  95 3A              sta FireballBouncingFlag,x  ;clear bouncing flag by default
00E1F3  2  60                 rts                         ;leave
00E1F4  2               
00E1F4  2               InitFireballExplode:
00E1F4  2  A9 80              lda #$80
00E1F6  2  95 24              sta Fireball_State,x        ;set exploding flag in fireball's state
00E1F8  2  A9 02              lda #Sfx_Bump
00E1FA  2  85 FF              sta Square1SoundQueue       ;load bump sound
00E1FC  2  60                 rts                         ;leave
00E1FD  2               
00E1FD  2               ;-------------------------------------------------------------------------------------
00E1FD  2               ;$00 - used to hold one of bitmasks, or offset
00E1FD  2               ;$01 - used for relative X coordinate, also used to store middle screen page location
00E1FD  2               ;$02 - used for relative Y coordinate, also used to store middle screen coordinate
00E1FD  2               
00E1FD  2               ;this data added to relative coordinates of sprite objects
00E1FD  2               ;stored in order: left edge, top edge, right edge, bottom edge
00E1FD  2               BoundBoxCtrlData:
00E1FD  2  02 08 0E 20        .byte $02, $08, $0e, $20
00E201  2  03 14 0D 20        .byte $03, $14, $0d, $20
00E205  2  02 14 0E 20        .byte $02, $14, $0e, $20
00E209  2  02 09 0E 15        .byte $02, $09, $0e, $15
00E20D  2  00 00 18 06        .byte $00, $00, $18, $06
00E211  2  00 00 20 0D        .byte $00, $00, $20, $0d
00E215  2  00 00 30 0D        .byte $00, $00, $30, $0d
00E219  2  00 00 08 08        .byte $00, $00, $08, $08
00E21D  2  06 04 0A 08        .byte $06, $04, $0a, $08
00E221  2  03 0E 0D 14        .byte $03, $0e, $0d, $14
00E225  2  00 02 10 15        .byte $00, $02, $10, $15
00E229  2  04 04 0C 1C        .byte $04, $04, $0c, $1c
00E22D  2               
00E22D  2               GetFireballBoundBox:
00E22D  2  8A                 txa         ;add seven bytes to offset
00E22E  2  18                 clc         ;to use in routines as offset for fireball
00E22F  2  69 07              adc #$07
00E231  2  AA                 tax
00E232  2  A0 02              ldy #$02    ;set offset for relative coordinates
00E234  2  D0 07              bne FBallB  ;unconditional branch
00E236  2               
00E236  2               GetMiscBoundBox:
00E236  2  8A                   txa                       ;add nine bytes to offset
00E237  2  18                   clc                       ;to use in routines as offset for misc object
00E238  2  69 09                adc #$09
00E23A  2  AA                   tax
00E23B  2  A0 06                ldy #$06                  ;set offset for relative coordinates
00E23D  2  20 9C E2     FBallB: jsr BoundingBoxCore       ;get bounding box coordinates
00E240  2  4C DE E2             jmp CheckRightScreenBBox  ;jump to handle any offscreen coordinates
00E243  2               
00E243  2               GetEnemyBoundBox:
00E243  2  A0 48              ldy #$48                 ;store bitmask here for now
00E245  2  84 00              sty $00
00E247  2  A0 44              ldy #$44                 ;store another bitmask here for now and jump
00E249  2  4C 52 E2           jmp GetMaskedOffScrBits
00E24C  2               
00E24C  2               SmallPlatformBoundBox:
00E24C  2  A0 08              ldy #$08                 ;store bitmask here for now
00E24E  2  84 00              sty $00
00E250  2  A0 04              ldy #$04                 ;store another bitmask here for now
00E252  2               
00E252  2               GetMaskedOffScrBits:
00E252  2  B5 87                lda Enemy_X_Position,x      ;get enemy object position relative
00E254  2  38                   sec                         ;to the left side of the screen
00E255  2  ED 1C 07             sbc ScreenLeft_X_Pos
00E258  2  85 01                sta $01                     ;store here
00E25A  2  B5 6E                lda Enemy_PageLoc,x         ;subtract borrow from current page location
00E25C  2  ED 1A 07             sbc ScreenLeft_PageLoc      ;of left side
00E25F  2  30 06                bmi CMBits                  ;if enemy object is beyond left edge, branch
00E261  2  05 01                ora $01
00E263  2  F0 02                beq CMBits                  ;if precisely at the left edge, branch
00E265  2  A4 00                ldy $00                     ;if to the right of left edge, use value in $00 for A
00E267  2  98           CMBits: tya                         ;otherwise use contents of Y
00E268  2  2D D1 03             and Enemy_OffscreenBits     ;preserve bitwise whatever's in here
00E26B  2  9D D8 03             sta EnemyOffscrBitsMasked,x ;save masked offscreen bits here
00E26E  2  D0 19                bne MoveBoundBoxOffscreen   ;if anything set here, branch
00E270  2  4C 7C E2             jmp SetupEOffsetFBBox       ;otherwise, do something else
00E273  2               
00E273  2               LargePlatformBoundBox:
00E273  2  E8                 inx                        ;increment X to get the proper offset
00E274  2  20 F6 F1           jsr GetXOffscreenBits      ;then jump directly to the sub for horizontal offscreen bits
00E277  2  CA                 dex                        ;decrement to return to original offset
00E278  2  C9 FE              cmp #$fe                   ;if completely offscreen, branch to put entire bounding
00E27A  2  B0 0D              bcs MoveBoundBoxOffscreen  ;box offscreen, otherwise start getting coordinates
00E27C  2               
00E27C  2               SetupEOffsetFBBox:
00E27C  2  8A                 txa                        ;add 1 to offset to properly address
00E27D  2  18                 clc                        ;the enemy object memory locations
00E27E  2  69 01              adc #$01
00E280  2  AA                 tax
00E281  2  A0 01              ldy #$01                   ;load 1 as offset here, same reason
00E283  2  20 9C E2           jsr BoundingBoxCore        ;do a sub to get the coordinates of the bounding box
00E286  2  4C DE E2           jmp CheckRightScreenBBox   ;jump to handle offscreen coordinates of bounding box
00E289  2               
00E289  2               MoveBoundBoxOffscreen:
00E289  2  8A                 txa                            ;multiply offset by 4
00E28A  2  0A                 asl
00E28B  2  0A                 asl
00E28C  2  A8                 tay                            ;use as offset here
00E28D  2  A9 FF              lda #$ff
00E28F  2  99 B0 04           sta EnemyBoundingBoxCoord,y    ;load value into four locations here and leave
00E292  2  99 B1 04           sta EnemyBoundingBoxCoord+1,y
00E295  2  99 B2 04           sta EnemyBoundingBoxCoord+2,y
00E298  2  99 B3 04           sta EnemyBoundingBoxCoord+3,y
00E29B  2  60                 rts
00E29C  2               
00E29C  2               BoundingBoxCore:
00E29C  2  86 00              stx $00                     ;save offset here
00E29E  2  B9 B8 03           lda SprObject_Rel_YPos,y    ;store object coordinates relative to screen
00E2A1  2  85 02              sta $02                     ;vertically and horizontally, respectively
00E2A3  2  B9 AD 03           lda SprObject_Rel_XPos,y
00E2A6  2  85 01              sta $01
00E2A8  2  8A                 txa                         ;multiply offset by four and save to stack
00E2A9  2  0A                 asl
00E2AA  2  0A                 asl
00E2AB  2  48                 pha
00E2AC  2  A8                 tay                         ;use as offset for Y, X is left alone
00E2AD  2  BD 99 04           lda SprObj_BoundBoxCtrl,x   ;load value here to be used as offset for X
00E2B0  2  0A                 asl                         ;multiply that by four and use as X
00E2B1  2  0A                 asl
00E2B2  2  AA                 tax
00E2B3  2  A5 01              lda $01                     ;add the first number in the bounding box data to the
00E2B5  2  18                 clc                         ;relative horizontal coordinate using enemy object offset
00E2B6  2  7D FD E1           adc BoundBoxCtrlData,x      ;and store somewhere using same offset * 4
00E2B9  2  99 AC 04           sta BoundingBox_UL_Corner,y ;store here
00E2BC  2  A5 01              lda $01
00E2BE  2  18                 clc
00E2BF  2  7D FF E1           adc BoundBoxCtrlData+2,x    ;add the third number in the bounding box data to the
00E2C2  2  99 AE 04           sta BoundingBox_LR_Corner,y ;relative horizontal coordinate and store
00E2C5  2  E8                 inx                         ;increment both offsets
00E2C6  2  C8                 iny
00E2C7  2  A5 02              lda $02                     ;add the second number to the relative vertical coordinate
00E2C9  2  18                 clc                         ;using incremented offset and store using the other
00E2CA  2  7D FD E1           adc BoundBoxCtrlData,x      ;incremented offset
00E2CD  2  99 AC 04           sta BoundingBox_UL_Corner,y
00E2D0  2  A5 02              lda $02
00E2D2  2  18                 clc
00E2D3  2  7D FF E1           adc BoundBoxCtrlData+2,x    ;add the fourth number to the relative vertical coordinate
00E2D6  2  99 AE 04           sta BoundingBox_LR_Corner,y ;and store
00E2D9  2  68                 pla                         ;get original offset loaded into $00 * y from stack
00E2DA  2  A8                 tay                         ;use as Y
00E2DB  2  A6 00              ldx $00                     ;get original offset and use as X again
00E2DD  2  60                 rts
00E2DE  2               
00E2DE  2               CheckRightScreenBBox:
00E2DE  2  AD 1C 07            lda ScreenLeft_X_Pos       ;add 128 pixels to left side of screen
00E2E1  2  18                  clc                        ;and store as horizontal coordinate of middle
00E2E2  2  69 80               adc #$80
00E2E4  2  85 02               sta $02
00E2E6  2  AD 1A 07            lda ScreenLeft_PageLoc     ;add carry to page location of left side of screen
00E2E9  2  69 00               adc #$00                   ;and store as page location of middle
00E2EB  2  85 01               sta $01
00E2ED  2  B5 86               lda SprObject_X_Position,x ;get horizontal coordinate
00E2EF  2  C5 02               cmp $02                    ;compare against middle horizontal coordinate
00E2F1  2  B5 6D               lda SprObject_PageLoc,x    ;get page location
00E2F3  2  E5 01               sbc $01                    ;subtract from middle page location
00E2F5  2  90 15               bcc CheckLeftScreenBBox    ;if object is on the left side of the screen, branch
00E2F7  2  B9 AE 04            lda BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00E2FA  2  30 0D               bmi NoOfs                  ;coordinates, branch if still on the screen
00E2FC  2  A9 FF               lda #$ff                   ;load offscreen value here to use on one or both horizontal sides
00E2FE  2  BE AC 04            ldx BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00E301  2  30 03               bmi SORte                  ;coordinates, and branch if still on the screen
00E303  2  99 AC 04            sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00E306  2  99 AE 04     SORte: sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00E309  2  A6 08        NoOfs: ldx ObjectOffset           ;get object offset and leave
00E30B  2  60                  rts
00E30C  2               
00E30C  2               CheckLeftScreenBBox:
00E30C  2  B9 AC 04             lda BoundingBox_UL_XPos,y  ;check left-side edge of bounding box for offscreen
00E30F  2  10 11                bpl NoOfs2                 ;coordinates, and branch if still on the screen
00E311  2  C9 A0                cmp #$a0                   ;check to see if left-side edge is in the middle of the
00E313  2  90 0D                bcc NoOfs2                 ;screen or really offscreen, and branch if still on
00E315  2  A9 00                lda #$00
00E317  2  BE AE 04             ldx BoundingBox_DR_XPos,y  ;check right-side edge of bounding box for offscreen
00E31A  2  10 03                bpl SOLft                  ;coordinates, branch if still onscreen
00E31C  2  99 AE 04             sta BoundingBox_DR_XPos,y  ;store offscreen value for right side
00E31F  2  99 AC 04     SOLft:  sta BoundingBox_UL_XPos,y  ;store offscreen value for left side
00E322  2  A6 08        NoOfs2: ldx ObjectOffset           ;get object offset and leave
00E324  2  60                   rts
00E325  2               
00E325  2               ;-------------------------------------------------------------------------------------
00E325  2               ;$06 - second object's offset
00E325  2               ;$07 - counter
00E325  2               
00E325  2               PlayerCollisionCore:
00E325  2  A2 00              ldx #$00     ;initialize X to use player's bounding box for comparison
00E327  2               
00E327  2               SprObjectCollisionCore:
00E327  2  84 06              sty $06      ;save contents of Y here
00E329  2  A9 01              lda #$01
00E32B  2  85 07              sta $07      ;save value 1 here as counter, compare horizontal coordinates first
00E32D  2               
00E32D  2               CollisionCoreLoop:
00E32D  2  B9 AC 04           lda BoundingBox_UL_Corner,y  ;compare left/top coordinates
00E330  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first and second objects' bounding boxes
00E333  2  B0 2A              bcs FirstBoxGreater          ;if first left/top => second, branch
00E335  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;otherwise compare to right/bottom of second
00E338  2  90 12              bcc SecondBoxVerticalChk     ;if first left/top < second right/bottom, branch elsewhere
00E33A  2  F0 42              beq CollisionFound           ;if somehow equal, collision, thus branch
00E33C  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;if somehow greater, check to see if bottom of
00E33F  2  D9 AC 04           cmp BoundingBox_UL_Corner,y  ;first object's bounding box is greater than its top
00E342  2  90 3A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00E344  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;otherwise compare bottom of first bounding box to the top
00E347  2  B0 35              bcs CollisionFound           ;of second box, and if equal or greater, collision, thus branch
00E349  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00E34B  2  60                 rts                          ;note horizontal wrapping never occurs
00E34C  2               
00E34C  2               SecondBoxVerticalChk:
00E34C  2  BD AE 04           lda BoundingBox_LR_Corner,x  ;check to see if the vertical bottom of the box
00E34F  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;is greater than the vertical top
00E352  2  90 2A              bcc CollisionFound           ;if somehow less, vertical wrap collision, thus branch
00E354  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare horizontal right or vertical bottom
00E357  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;of first box with horizontal left or vertical top of second box
00E35A  2  B0 22              bcs CollisionFound           ;if equal or greater, collision, thus branch
00E35C  2  A4 06              ldy $06                      ;otherwise return with carry clear and Y = $0006
00E35E  2  60                 rts
00E35F  2               
00E35F  2               FirstBoxGreater:
00E35F  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;compare first and second box horizontal left/vertical top again
00E362  2  F0 1A              beq CollisionFound           ;if first coordinate = second, collision, thus branch
00E364  2  DD AE 04           cmp BoundingBox_LR_Corner,x  ;if not, compare with second object right or bottom edge
00E367  2  90 15              bcc CollisionFound           ;if left/top of first less than or equal to right/bottom of second
00E369  2  F0 13              beq CollisionFound           ;then collision, thus branch
00E36B  2  D9 AE 04           cmp BoundingBox_LR_Corner,y  ;otherwise check to see if top of first box is greater than bottom
00E36E  2  90 0A              bcc NoCollisionFound         ;if less than or equal, no collision, branch to end
00E370  2  F0 08              beq NoCollisionFound
00E372  2  B9 AE 04           lda BoundingBox_LR_Corner,y  ;otherwise compare bottom of first to top of second
00E375  2  DD AC 04           cmp BoundingBox_UL_Corner,x  ;if bottom of first is greater than top of second, vertical wrap
00E378  2  B0 04              bcs CollisionFound           ;collision, and branch, otherwise, proceed onwards here
00E37A  2               
00E37A  2               NoCollisionFound:
00E37A  2  18                 clc          ;clear carry, then load value set earlier, then leave
00E37B  2  A4 06              ldy $06      ;like previous ones, if horizontal coordinates do not collide, we do
00E37D  2  60                 rts          ;not bother checking vertical ones, because what's the point?
00E37E  2               
00E37E  2               CollisionFound:
00E37E  2  E8                 inx                    ;increment offsets on both objects to check
00E37F  2  C8                 iny                    ;the vertical coordinates
00E380  2  C6 07              dec $07                ;decrement counter to reflect this
00E382  2  10 A9              bpl CollisionCoreLoop  ;if counter not expired, branch to loop
00E384  2  38                 sec                    ;otherwise we already did both sets, therefore collision, so set carry
00E385  2  A4 06              ldy $06                ;load original value set here earlier, then leave
00E387  2  60                 rts
00E388  2               
00E388  2               ;-------------------------------------------------------------------------------------
00E388  2               ;$02 - modified y coordinate
00E388  2               ;$03 - stores metatile involved in block buffer collisions
00E388  2               ;$04 - comes in with offset to block buffer adder data, goes out with low nybble x/y coordinate
00E388  2               ;$05 - modified x coordinate
00E388  2               ;$06-$07 - block buffer address
00E388  2               
00E388  2               BlockBufferChk_Enemy:
00E388  2  48                 pha        ;save contents of A to stack
00E389  2  8A                 txa
00E38A  2  18                 clc        ;add 1 to X to run sub with enemy offset in mind
00E38B  2  69 01              adc #$01
00E38D  2  AA                 tax
00E38E  2  68                 pla        ;pull A from stack and jump elsewhere
00E38F  2  4C A5 E3           jmp BBChk_E
00E392  2               
00E392  2               ResidualMiscObjectCode:
00E392  2  8A                 txa
00E393  2  18                 clc           ;supposedly used once to set offset for
00E394  2  69 0D              adc #$0d      ;miscellaneous objects
00E396  2  AA                 tax
00E397  2  A0 1B              ldy #$1b      ;supposedly used once to set offset for block buffer data
00E399  2  4C A3 E3           jmp ResJmpM   ;probably used in early stages to do misc to bg collision detection
00E39C  2               
00E39C  2               BlockBufferChk_FBall:
00E39C  2  A0 1A                 ldy #$1a                  ;set offset for block buffer adder data
00E39E  2  8A                    txa
00E39F  2  18                    clc
00E3A0  2  69 07                 adc #$07                  ;add seven bytes to use
00E3A2  2  AA                    tax
00E3A3  2  A9 00        ResJmpM: lda #$00                  ;set A to return vertical coordinate
00E3A5  2  20 F0 E3     BBChk_E: jsr BlockBufferCollision  ;do collision detection subroutine for sprite object
00E3A8  2  A6 08                 ldx ObjectOffset          ;get object offset
00E3AA  2  C9 00                 cmp #$00                  ;check to see if object bumped into anything
00E3AC  2  60                    rts
00E3AD  2               
00E3AD  2               BlockBufferAdderData:
00E3AD  2  00 07 0E           .byte $00, $07, $0e
00E3B0  2               
00E3B0  2               BlockBuffer_X_Adder:
00E3B0  2  08 03 0C 02        .byte $08, $03, $0c, $02, $02, $0d, $0d, $08
00E3B4  2  02 0D 0D 08  
00E3B8  2  03 0C 02 02        .byte $03, $0c, $02, $02, $0d, $0d, $08, $03
00E3BC  2  0D 0D 08 03  
00E3C0  2  0C 02 02 0D        .byte $0c, $02, $02, $0d, $0d, $08, $00, $10
00E3C4  2  0D 08 00 10  
00E3C8  2  04 14 04 04        .byte $04, $14, $04, $04
00E3CC  2               
00E3CC  2               BlockBuffer_Y_Adder:
00E3CC  2  04 20 20 08        .byte $04, $20, $20, $08, $18, $08, $18, $02
00E3D0  2  18 08 18 02  
00E3D4  2  20 20 08 18        .byte $20, $20, $08, $18, $08, $18, $12, $20
00E3D8  2  08 18 12 20  
00E3DC  2  20 18 18 18        .byte $20, $18, $18, $18, $18, $18, $14, $14
00E3E0  2  18 18 14 14  
00E3E4  2  06 06 08 10        .byte $06, $06, $08, $10
00E3E8  2               
00E3E8  2               BlockBufferColli_Feet:
00E3E8  2  C8                  iny            ;if branched here, increment to next set of adders
00E3E9  2               
00E3E9  2               BlockBufferColli_Head:
00E3E9  2  A9 00               lda #$00       ;set flag to return vertical coordinate
00E3EB  2  2C                  .byte $2c        ;BIT instruction opcode
00E3EC  2               
00E3EC  2               BlockBufferColli_Side:
00E3EC  2  A9 01               lda #$01       ;set flag to return horizontal coordinate
00E3EE  2  A2 00               ldx #$00       ;set offset for player object
00E3F0  2               
00E3F0  2               BlockBufferCollision:
00E3F0  2  48                  pha                         ;save contents of A to stack
00E3F1  2  84 04               sty $04                     ;save contents of Y here
00E3F3  2  B9 B0 E3            lda BlockBuffer_X_Adder,y   ;add horizontal coordinate
00E3F6  2  18                  clc                         ;of object to value obtained using Y as offset
00E3F7  2  75 86               adc SprObject_X_Position,x
00E3F9  2  85 05               sta $05                     ;store here
00E3FB  2  B5 6D               lda SprObject_PageLoc,x
00E3FD  2  69 00               adc #$00                    ;add carry to page location
00E3FF  2  29 01               and #$01                    ;get LSB, mask out all other bits
00E401  2  4A                  lsr                         ;move to carry
00E402  2  05 05               ora $05                     ;get stored value
00E404  2  6A                  ror                         ;rotate carry to MSB of A
00E405  2  4A                  lsr                         ;and effectively move high nybble to
00E406  2  4A                  lsr                         ;lower, LSB which became MSB will be
00E407  2  4A                  lsr                         ;d4 at this point
00E408  2  20 E1 9B            jsr GetBlockBufferAddr      ;get address of block buffer into $06, $07
00E40B  2  A4 04               ldy $04                     ;get old contents of Y
00E40D  2  B5 CE               lda SprObject_Y_Position,x  ;get vertical coordinate of object
00E40F  2  18                  clc
00E410  2  79 CC E3            adc BlockBuffer_Y_Adder,y   ;add it to value obtained using Y as offset
00E413  2  29 F0               and #%11110000              ;mask out low nybble
00E415  2  38                  sec
00E416  2  E9 20               sbc #$20                    ;subtract 32 pixels for the status bar
00E418  2  85 02               sta $02                     ;store result here
00E41A  2  A8                  tay                         ;use as offset for block buffer
00E41B  2  B1 06               lda ($06),y                 ;check current content of block buffer
00E41D  2  85 03               sta $03                     ;and store here
00E41F  2  A4 04               ldy $04                     ;get old contents of Y again
00E421  2  68                  pla                         ;pull A from stack
00E422  2  D0 05               bne RetXC                   ;if A = 1, branch
00E424  2  B5 CE               lda SprObject_Y_Position,x  ;if A = 0, load vertical coordinate
00E426  2  4C 2B E4            jmp RetYC                   ;and jump
00E429  2  B5 86        RetXC: lda SprObject_X_Position,x  ;otherwise load horizontal coordinate
00E42B  2  29 0F        RetYC: and #%00001111              ;and mask out high nybble
00E42D  2  85 04               sta $04                     ;store masked out result here
00E42F  2  A5 03               lda $03                     ;get saved content of block buffer
00E431  2  60                  rts                         ;and leave
00E432  2               
00E432  2               ;-------------------------------------------------------------------------------------
00E432  2               
00E432  2               ;unused byte
00E432  2  FF                 .byte $ff
00E433  2               
00E433  2               ;-------------------------------------------------------------------------------------
00E433  2               ;$00 - offset to vine Y coordinate adder
00E433  2               ;$02 - offset to sprite data
00E433  2               
00E433  2               VineYPosAdder:
00E433  2  00 30              .byte $00, $30
00E435  2               
00E435  2               DrawVine:
00E435  2  84 00                 sty $00                    ;save offset here
00E437  2  AD B9 03              lda Enemy_Rel_YPos         ;get relative vertical coordinate
00E43A  2  18                    clc
00E43B  2  79 33 E4              adc VineYPosAdder,y        ;add value using offset in Y to get value
00E43E  2  BE 9A 03              ldx VineObjOffset,y        ;get offset to vine
00E441  2  BC E5 06              ldy Enemy_SprDataOffset,x  ;get sprite data offset
00E444  2  84 02                 sty $02                    ;store sprite data offset here
00E446  2  20 AE E4              jsr SixSpriteStacker       ;stack six sprites on top of each other vertically
00E449  2  AD AE 03              lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00E44C  2  99 03 02              sta Sprite_X_Position,y    ;store in first, third and fifth sprites
00E44F  2  99 0B 02              sta Sprite_X_Position+8,y
00E452  2  99 13 02              sta Sprite_X_Position+16,y
00E455  2  18                    clc
00E456  2  69 06                 adc #$06                   ;add six pixels to second, fourth and sixth sprites
00E458  2  99 07 02              sta Sprite_X_Position+4,y  ;to give characteristic staggered vine shape to
00E45B  2  99 0F 02              sta Sprite_X_Position+12,y ;our vertical stack of sprites
00E45E  2  99 17 02              sta Sprite_X_Position+20,y
00E461  2  A9 21                 lda #%00100001             ;set bg priority and palette attribute bits
00E463  2  99 02 02              sta Sprite_Attributes,y    ;set in first, third and fifth sprites
00E466  2  99 0A 02              sta Sprite_Attributes+8,y
00E469  2  99 12 02              sta Sprite_Attributes+16,y
00E46C  2  09 40                 ora #%01000000             ;additionally, set horizontal flip bit
00E46E  2  99 06 02              sta Sprite_Attributes+4,y  ;for second, fourth and sixth sprites
00E471  2  99 0E 02              sta Sprite_Attributes+12,y
00E474  2  99 16 02              sta Sprite_Attributes+20,y
00E477  2  A2 05                 ldx #$05                   ;set tiles for six sprites
00E479  2  A9 E1        VineTL:  lda #$e1                   ;set tile number for sprite
00E47B  2  99 01 02              sta Sprite_Tilenumber,y
00E47E  2  C8                    iny                        ;move offset to next sprite data
00E47F  2  C8                    iny
00E480  2  C8                    iny
00E481  2  C8                    iny
00E482  2  CA                    dex                        ;move onto next sprite
00E483  2  10 F4                 bpl VineTL                 ;loop until all sprites are done
00E485  2  A4 02                 ldy $02                    ;get original offset
00E487  2  A5 00                 lda $00                    ;get offset to vine adding data
00E489  2  D0 05                 bne SkpVTop                ;if offset not zero, skip this part
00E48B  2  A9 E0                 lda #$e0
00E48D  2  99 01 02              sta Sprite_Tilenumber,y    ;set other tile number for top of vine
00E490  2  A2 00        SkpVTop: ldx #$00                   ;start with the first sprite again
00E492  2  AD 9D 03     ChkFTop: lda VineStart_Y_Position   ;get original starting vertical coordinate
00E495  2  38                    sec
00E496  2  F9 00 02              sbc Sprite_Y_Position,y    ;subtract top-most sprite's Y coordinate
00E499  2  C9 64                 cmp #$64                   ;if two coordinates are less than 100/$64 pixels
00E49B  2  90 05                 bcc NextVSp                ;apart, skip this to leave sprite alone
00E49D  2  A9 F8                 lda #$f8
00E49F  2  99 00 02              sta Sprite_Y_Position,y    ;otherwise move sprite offscreen
00E4A2  2  C8           NextVSp: iny                        ;move offset to next OAM data
00E4A3  2  C8                    iny
00E4A4  2  C8                    iny
00E4A5  2  C8                    iny
00E4A6  2  E8                    inx                        ;move onto next sprite
00E4A7  2  E0 06                 cpx #$06                   ;do this until all sprites are checked
00E4A9  2  D0 E7                 bne ChkFTop
00E4AB  2  A4 00                 ldy $00                    ;return offset set earlier
00E4AD  2  60                    rts
00E4AE  2               
00E4AE  2               SixSpriteStacker:
00E4AE  2  A2 06               ldx #$06           ;do six sprites
00E4B0  2  99 00 02     StkLp: sta Sprite_Data,y  ;store X or Y coordinate into OAM data
00E4B3  2  18                  clc
00E4B4  2  69 08               adc #$08           ;add eight pixels
00E4B6  2  C8                  iny
00E4B7  2  C8                  iny                ;move offset four bytes forward
00E4B8  2  C8                  iny
00E4B9  2  C8                  iny
00E4BA  2  CA                  dex                ;do another sprite
00E4BB  2  D0 F3               bne StkLp          ;do this until all sprites are done
00E4BD  2  A4 02               ldy $02            ;get saved OAM data offset and leave
00E4BF  2  60                  rts
00E4C0  2               
00E4C0  2               ;-------------------------------------------------------------------------------------
00E4C0  2               
00E4C0  2               FirstSprXPos:
00E4C0  2  04 00 04 00        .byte $04, $00, $04, $00
00E4C4  2               
00E4C4  2               FirstSprYPos:
00E4C4  2  00 04 00 04        .byte $00, $04, $00, $04
00E4C8  2               
00E4C8  2               SecondSprXPos:
00E4C8  2  00 08 00 08        .byte $00, $08, $00, $08
00E4CC  2               
00E4CC  2               SecondSprYPos:
00E4CC  2  08 00 08 00        .byte $08, $00, $08, $00
00E4D0  2               
00E4D0  2               FirstSprTilenum:
00E4D0  2  80 82 81 83        .byte $80, $82, $81, $83
00E4D4  2               
00E4D4  2               SecondSprTilenum:
00E4D4  2  81 83 80 82        .byte $81, $83, $80, $82
00E4D8  2               
00E4D8  2               HammerSprAttrib:
00E4D8  2  03 03 C3 C3        .byte $03, $03, $c3, $c3
00E4DC  2               
00E4DC  2               DrawHammer:
00E4DC  2  BC F3 06                 ldy Misc_SprDataOffset,x    ;get misc object OAM data offset
00E4DF  2  AD 47 07                 lda TimerControl
00E4E2  2  D0 08                    bne ForceHPose              ;if master timer control set, skip this part
00E4E4  2  B5 2A                    lda Misc_State,x            ;otherwise get hammer's state
00E4E6  2  29 7F                    and #%01111111              ;mask out d7
00E4E8  2  C9 01                    cmp #$01                    ;check to see if set to 1 yet
00E4EA  2  F0 04                    beq GetHPose                ;if so, branch
00E4EC  2  A2 00        ForceHPose: ldx #$00                    ;reset offset here
00E4EE  2  F0 07                    beq RenderH                 ;do unconditional branch to rendering part
00E4F0  2  A5 09        GetHPose:   lda FrameCounter            ;get frame counter
00E4F2  2  4A                       lsr                         ;move d3-d2 to d1-d0
00E4F3  2  4A                       lsr
00E4F4  2  29 03                    and #%00000011              ;mask out all but d1-d0 (changes every four frames)
00E4F6  2  AA                       tax                         ;use as timing offset
00E4F7  2  AD BE 03     RenderH:    lda Misc_Rel_YPos           ;get relative vertical coordinate
00E4FA  2  18                       clc
00E4FB  2  7D C4 E4                 adc FirstSprYPos,x          ;add first sprite vertical adder based on offset
00E4FE  2  99 00 02                 sta Sprite_Y_Position,y     ;store as sprite Y coordinate for first sprite
00E501  2  18                       clc
00E502  2  7D CC E4                 adc SecondSprYPos,x         ;add second sprite vertical adder based on offset
00E505  2  99 04 02                 sta Sprite_Y_Position+4,y   ;store as sprite Y coordinate for second sprite
00E508  2  AD B3 03                 lda Misc_Rel_XPos           ;get relative horizontal coordinate
00E50B  2  18                       clc
00E50C  2  7D C0 E4                 adc FirstSprXPos,x          ;add first sprite horizontal adder based on offset
00E50F  2  99 03 02                 sta Sprite_X_Position,y     ;store as sprite X coordinate for first sprite
00E512  2  18                       clc
00E513  2  7D C8 E4                 adc SecondSprXPos,x         ;add second sprite horizontal adder based on offset
00E516  2  99 07 02                 sta Sprite_X_Position+4,y   ;store as sprite X coordinate for second sprite
00E519  2  BD D0 E4                 lda FirstSprTilenum,x
00E51C  2  99 01 02                 sta Sprite_Tilenumber,y     ;get and store tile number of first sprite
00E51F  2  BD D4 E4                 lda SecondSprTilenum,x
00E522  2  99 05 02                 sta Sprite_Tilenumber+4,y   ;get and store tile number of second sprite
00E525  2  BD D8 E4                 lda HammerSprAttrib,x
00E528  2  99 02 02                 sta Sprite_Attributes,y     ;get and store attribute bytes for both
00E52B  2  99 06 02                 sta Sprite_Attributes+4,y   ;note in this case they use the same data
00E52E  2  A6 08                    ldx ObjectOffset            ;get misc object offset
00E530  2  AD D6 03                 lda Misc_OffscreenBits
00E533  2  29 FC                    and #%11111100              ;check offscreen bits
00E535  2  F0 09                    beq NoHOffscr               ;if all bits clear, leave object alone
00E537  2  A9 00                    lda #$00
00E539  2  95 2A                    sta Misc_State,x            ;otherwise nullify misc object state
00E53B  2  A9 F8                    lda #$f8
00E53D  2  20 C1 E5                 jsr DumpTwoSpr              ;do sub to move hammer sprites offscreen
00E540  2  60           NoHOffscr:  rts                         ;leave
00E541  2               
00E541  2               ;-------------------------------------------------------------------------------------
00E541  2               ;$00-$01 - used to hold tile numbers ($01 addressed in draw floatey number part)
00E541  2               ;$02 - used to hold Y coordinate for floatey number
00E541  2               ;$03 - residual byte used for flip (but value set here affects nothing)
00E541  2               ;$04 - attribute byte for floatey number
00E541  2               ;$05 - used as X coordinate for floatey number
00E541  2               
00E541  2               FlagpoleScoreNumTiles:
00E541  2  F9 50              .byte $f9, $50
00E543  2  F7 50              .byte $f7, $50
00E545  2  FA FB              .byte $fa, $fb
00E547  2  F8 FB              .byte $f8, $fb
00E549  2  F6 FB              .byte $f6, $fb
00E54B  2               
00E54B  2               FlagpoleGfxHandler:
00E54B  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get sprite data offset for flagpole flag
00E54E  2  AD AE 03           lda Enemy_Rel_XPos             ;get relative horizontal coordinate
00E551  2  99 03 02           sta Sprite_X_Position,y        ;store as X coordinate for first sprite
00E554  2  18                 clc
00E555  2  69 08              adc #$08                       ;add eight pixels and store
00E557  2  99 07 02           sta Sprite_X_Position+4,y      ;as X coordinate for second and third sprites
00E55A  2  99 0B 02           sta Sprite_X_Position+8,y
00E55D  2  18                 clc
00E55E  2  69 0C              adc #$0c                       ;add twelve more pixels and
00E560  2  85 05              sta $05                        ;store here to be used later by floatey number
00E562  2  B5 CF              lda Enemy_Y_Position,x         ;get vertical coordinate
00E564  2  20 C1 E5           jsr DumpTwoSpr                 ;and do sub to dump into first and second sprites
00E567  2  69 08              adc #$08                       ;add eight pixels
00E569  2  99 08 02           sta Sprite_Y_Position+8,y      ;and store into third sprite
00E56C  2  AD 0D 01           lda FlagpoleFNum_Y_Pos         ;get vertical coordinate for floatey number
00E56F  2  85 02              sta $02                        ;store it here
00E571  2  A9 01              lda #$01
00E573  2  85 03              sta $03                        ;set value for flip which will not be used, and
00E575  2  85 04              sta $04                        ;attribute byte for floatey number
00E577  2  99 02 02           sta Sprite_Attributes,y        ;set attribute bytes for all three sprites
00E57A  2  99 06 02           sta Sprite_Attributes+4,y
00E57D  2  99 0A 02           sta Sprite_Attributes+8,y
00E580  2  A9 7E              lda #$7e
00E582  2  99 01 02           sta Sprite_Tilenumber,y        ;put triangle shaped tile
00E585  2  99 09 02           sta Sprite_Tilenumber+8,y      ;into first and third sprites
00E588  2  A9 7F              lda #$7f
00E58A  2  99 05 02           sta Sprite_Tilenumber+4,y      ;put skull tile into second sprite
00E58D  2  AD 0F 07           lda FlagpoleCollisionYPos      ;get vertical coordinate at time of collision
00E590  2  F0 15              beq ChkFlagOffscreen           ;if zero, branch ahead
00E592  2  98                 tya
00E593  2  18                 clc                            ;add 12 bytes to sprite data offset
00E594  2  69 0C              adc #$0c
00E596  2  A8                 tay                            ;put back in Y
00E597  2  AD 0F 01           lda FlagpoleScore              ;get offset used to award points for touching flagpole
00E59A  2  0A                 asl                            ;multiply by 2 to get proper offset here
00E59B  2  AA                 tax
00E59C  2  BD 41 E5           lda FlagpoleScoreNumTiles,x    ;get appropriate tile data
00E59F  2  85 00              sta $00
00E5A1  2  BD 42 E5           lda FlagpoleScoreNumTiles+1,x
00E5A4  2  20 B2 EB           jsr DrawOneSpriteRow           ;use it to render floatey number
00E5A7  2               
00E5A7  2               ChkFlagOffscreen:
00E5A7  2  A6 08              ldx ObjectOffset               ;get object offset for flag
00E5A9  2  BC E5 06           ldy Enemy_SprDataOffset,x      ;get OAM data offset
00E5AC  2  AD D1 03           lda Enemy_OffscreenBits        ;get offscreen bits
00E5AF  2  29 0E              and #%00001110                 ;mask out all but d3-d1
00E5B1  2  F0 14              beq ExitDumpSpr                ;if none of these bits set, branch to leave
00E5B3  2               
00E5B3  2               ;-------------------------------------------------------------------------------------
00E5B3  2               
00E5B3  2               MoveSixSpritesOffscreen:
00E5B3  2  A9 F8              lda #$f8                  ;set offscreen coordinate if jumping here
00E5B5  2               
00E5B5  2               DumpSixSpr:
00E5B5  2  99 14 02           sta Sprite_Data+20,y      ;dump A contents
00E5B8  2  99 10 02           sta Sprite_Data+16,y      ;into third row sprites
00E5BB  2               
00E5BB  2               DumpFourSpr:
00E5BB  2  99 0C 02           sta Sprite_Data+12,y      ;into second row sprites
00E5BE  2               
00E5BE  2               DumpThreeSpr:
00E5BE  2  99 08 02           sta Sprite_Data+8,y
00E5C1  2               
00E5C1  2               DumpTwoSpr:
00E5C1  2  99 04 02           sta Sprite_Data+4,y       ;and into first row sprites
00E5C4  2  99 00 02           sta Sprite_Data,y
00E5C7  2               
00E5C7  2               ExitDumpSpr:
00E5C7  2  60                 rts
00E5C8  2               
00E5C8  2               ;-------------------------------------------------------------------------------------
00E5C8  2               
00E5C8  2               DrawLargePlatform:
00E5C8  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E5CB  2  84 02              sty $02                     ;store here
00E5CD  2  C8                 iny                         ;add 3 to it for offset
00E5CE  2  C8                 iny                         ;to X coordinate
00E5CF  2  C8                 iny
00E5D0  2  AD AE 03           lda Enemy_Rel_XPos          ;get horizontal relative coordinate
00E5D3  2  20 AE E4           jsr SixSpriteStacker        ;store X coordinates using A as base, stack horizontally
00E5D6  2  A6 08              ldx ObjectOffset
00E5D8  2  B5 CF              lda Enemy_Y_Position,x      ;get vertical coordinate
00E5DA  2  20 BB E5           jsr DumpFourSpr             ;dump into first four sprites as Y coordinate
00E5DD  2  AC 4E 07           ldy AreaType
00E5E0  2  C0 03              cpy #$03                    ;check for castle-type level
00E5E2  2  F0 05              beq ShrinkPlatform
00E5E4  2  AC CC 06           ldy SecondaryHardMode       ;check for secondary hard mode flag set
00E5E7  2  F0 02              beq SetLast2Platform        ;branch if not set elsewhere
00E5E9  2               
00E5E9  2               ShrinkPlatform:
00E5E9  2  A9 F8              lda #$f8                    ;load offscreen coordinate if flag set or castle-type level
00E5EB  2               
00E5EB  2               SetLast2Platform:
00E5EB  2  BC E5 06           ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E5EE  2  99 10 02           sta Sprite_Y_Position+16,y  ;store vertical coordinate or offscreen
00E5F1  2  99 14 02           sta Sprite_Y_Position+20,y  ;coordinate into last two sprites as Y coordinate
00E5F4  2  A9 5B              lda #$5b                    ;load default tile for platform (girder)
00E5F6  2  AE 43 07           ldx CloudTypeOverride
00E5F9  2  F0 02              beq SetPlatformTilenum      ;if cloud level override flag not set, use
00E5FB  2  A9 75              lda #$75                    ;otherwise load other tile for platform (puff)
00E5FD  2               
00E5FD  2               SetPlatformTilenum:
00E5FD  2  A6 08                ldx ObjectOffset            ;get enemy object buffer offset
00E5FF  2  C8                   iny                         ;increment Y for tile offset
00E600  2  20 B5 E5             jsr DumpSixSpr              ;dump tile number into all six sprites
00E603  2  A9 02                lda #$02                    ;set palette controls
00E605  2  C8                   iny                         ;increment Y for sprite attributes
00E606  2  20 B5 E5             jsr DumpSixSpr              ;dump attributes into all six sprites
00E609  2  E8                   inx                         ;increment X for enemy objects
00E60A  2  20 F6 F1             jsr GetXOffscreenBits       ;get offscreen bits again
00E60D  2  CA                   dex
00E60E  2  BC E5 06             ldy Enemy_SprDataOffset,x   ;get OAM data offset
00E611  2  0A                   asl                         ;rotate d7 into carry, save remaining
00E612  2  48                   pha                         ;bits to the stack
00E613  2  90 05                bcc SChk2
00E615  2  A9 F8                lda #$f8                    ;if d7 was set, move first sprite offscreen
00E617  2  99 00 02             sta Sprite_Y_Position,y
00E61A  2  68           SChk2:  pla                         ;get bits from stack
00E61B  2  0A                   asl                         ;rotate d6 into carry
00E61C  2  48                   pha                         ;save to stack
00E61D  2  90 05                bcc SChk3
00E61F  2  A9 F8                lda #$f8                    ;if d6 was set, move second sprite offscreen
00E621  2  99 04 02             sta Sprite_Y_Position+4,y
00E624  2  68           SChk3:  pla                         ;get bits from stack
00E625  2  0A                   asl                         ;rotate d5 into carry
00E626  2  48                   pha                         ;save to stack
00E627  2  90 05                bcc SChk4
00E629  2  A9 F8                lda #$f8                    ;if d5 was set, move third sprite offscreen
00E62B  2  99 08 02             sta Sprite_Y_Position+8,y
00E62E  2  68           SChk4:  pla                         ;get bits from stack
00E62F  2  0A                   asl                         ;rotate d4 into carry
00E630  2  48                   pha                         ;save to stack
00E631  2  90 05                bcc SChk5
00E633  2  A9 F8                lda #$f8                    ;if d4 was set, move fourth sprite offscreen
00E635  2  99 0C 02             sta Sprite_Y_Position+12,y
00E638  2  68           SChk5:  pla                         ;get bits from stack
00E639  2  0A                   asl                         ;rotate d3 into carry
00E63A  2  48                   pha                         ;save to stack
00E63B  2  90 05                bcc SChk6
00E63D  2  A9 F8                lda #$f8                    ;if d3 was set, move fifth sprite offscreen
00E63F  2  99 10 02             sta Sprite_Y_Position+16,y
00E642  2  68           SChk6:  pla                         ;get bits from stack
00E643  2  0A                   asl                         ;rotate d2 into carry
00E644  2  90 05                bcc SLChk                   ;save to stack
00E646  2  A9 F8                lda #$f8
00E648  2  99 14 02             sta Sprite_Y_Position+20,y  ;if d2 was set, move sixth sprite offscreen
00E64B  2  AD D1 03     SLChk:  lda Enemy_OffscreenBits     ;check d7 of offscreen bits
00E64E  2  0A                   asl                         ;and if d7 is not set, skip sub
00E64F  2  90 03                bcc ExDLPl
00E651  2  20 B3 E5             jsr MoveSixSpritesOffscreen ;otherwise branch to move all sprites offscreen
00E654  2  60           ExDLPl: rts
00E655  2               
00E655  2               ;-------------------------------------------------------------------------------------
00E655  2               
00E655  2               DrawFloateyNumber_Coin:
00E655  2  A5 09                  lda FrameCounter          ;get frame counter
00E657  2  4A                     lsr                       ;divide by 2
00E658  2  B0 02                  bcs NotRsNum              ;branch if d0 not set to raise number every other frame
00E65A  2  D6 DB                  dec Misc_Y_Position,x     ;otherwise, decrement vertical coordinate
00E65C  2  B5 DB        NotRsNum: lda Misc_Y_Position,x     ;get vertical coordinate
00E65E  2  20 C1 E5               jsr DumpTwoSpr            ;dump into both sprites
00E661  2  AD B3 03               lda Misc_Rel_XPos         ;get relative horizontal coordinate
00E664  2  99 03 02               sta Sprite_X_Position,y   ;store as X coordinate for first sprite
00E667  2  18                     clc
00E668  2  69 08                  adc #$08                  ;add eight pixels
00E66A  2  99 07 02               sta Sprite_X_Position+4,y ;store as X coordinate for second sprite
00E66D  2  A9 02                  lda #$02
00E66F  2  99 02 02               sta Sprite_Attributes,y   ;store attribute byte in both sprites
00E672  2  99 06 02               sta Sprite_Attributes+4,y
00E675  2  A9 F7                  lda #$f7
00E677  2  99 01 02               sta Sprite_Tilenumber,y   ;put tile numbers into both sprites
00E67A  2  A9 FB                  lda #$fb                  ;that resemble "200"
00E67C  2  99 05 02               sta Sprite_Tilenumber+4,y
00E67F  2  4C BD E6               jmp ExJCGfx               ;then jump to leave (why not an rts here instead?)
00E682  2               
00E682  2               JumpingCoinTiles:
00E682  2  60 61 62 63        .byte $60, $61, $62, $63
00E686  2               
00E686  2               JCoinGfxHandler:
00E686  2  BC F3 06              ldy Misc_SprDataOffset,x    ;get coin/floatey number's OAM data offset
00E689  2  B5 2A                 lda Misc_State,x            ;get state of misc object
00E68B  2  C9 02                 cmp #$02                    ;if 2 or greater,
00E68D  2  B0 C6                 bcs DrawFloateyNumber_Coin  ;branch to draw floatey number
00E68F  2  B5 DB                 lda Misc_Y_Position,x       ;store vertical coordinate as
00E691  2  99 00 02              sta Sprite_Y_Position,y     ;Y coordinate for first sprite
00E694  2  18                    clc
00E695  2  69 08                 adc #$08                    ;add eight pixels
00E697  2  99 04 02              sta Sprite_Y_Position+4,y   ;store as Y coordinate for second sprite
00E69A  2  AD B3 03              lda Misc_Rel_XPos           ;get relative horizontal coordinate
00E69D  2  99 03 02              sta Sprite_X_Position,y
00E6A0  2  99 07 02              sta Sprite_X_Position+4,y   ;store as X coordinate for first and second sprites
00E6A3  2  A5 09                 lda FrameCounter            ;get frame counter
00E6A5  2  4A                    lsr                         ;divide by 2 to alter every other frame
00E6A6  2  29 03                 and #%00000011              ;mask out d2-d1
00E6A8  2  AA                    tax                         ;use as graphical offset
00E6A9  2  BD 82 E6              lda JumpingCoinTiles,x      ;load tile number
00E6AC  2  C8                    iny                         ;increment OAM data offset to write tile numbers
00E6AD  2  20 C1 E5              jsr DumpTwoSpr              ;do sub to dump tile number into both sprites
00E6B0  2  88                    dey                         ;decrement to get old offset
00E6B1  2  A9 02                 lda #$02
00E6B3  2  99 02 02              sta Sprite_Attributes,y     ;set attribute byte in first sprite
00E6B6  2  A9 82                 lda #$82
00E6B8  2  99 06 02              sta Sprite_Attributes+4,y   ;set attribute byte with vertical flip in second sprite
00E6BB  2  A6 08                 ldx ObjectOffset            ;get misc object offset
00E6BD  2  60           ExJCGfx: rts                         ;leave
00E6BE  2               
00E6BE  2               ;-------------------------------------------------------------------------------------
00E6BE  2               ;$00-$01 - used to hold tiles for drawing the power-up, $00 also used to hold power-up type
00E6BE  2               ;$02 - used to hold bottom row Y position
00E6BE  2               ;$03 - used to hold flip control (not used here)
00E6BE  2               ;$04 - used to hold sprite attributes
00E6BE  2               ;$05 - used to hold X position
00E6BE  2               ;$07 - counter
00E6BE  2               
00E6BE  2               ;tiles arranged in top left, right, bottom left, right order
00E6BE  2               PowerUpGfxTable:
00E6BE  2  76 77 78 79        .byte $76, $77, $78, $79 ;regular mushroom
00E6C2  2  D6 D6 D9 D9        .byte $d6, $d6, $d9, $d9 ;fire flower
00E6C6  2  8D 8D E4 E4        .byte $8d, $8d, $e4, $e4 ;star
00E6CA  2  76 77 78 79        .byte $76, $77, $78, $79 ;1-up mushroom
00E6CE  2               
00E6CE  2               PowerUpAttributes:
00E6CE  2  02 01 02 01        .byte $02, $01, $02, $01
00E6D2  2               
00E6D2  2               DrawPowerUp:
00E6D2  2  AC EA 06           ldy Enemy_SprDataOffset+5  ;get power-up's sprite data offset
00E6D5  2  AD B9 03           lda Enemy_Rel_YPos         ;get relative vertical coordinate
00E6D8  2  18                 clc
00E6D9  2  69 08              adc #$08                   ;add eight pixels
00E6DB  2  85 02              sta $02                    ;store result here
00E6DD  2  AD AE 03           lda Enemy_Rel_XPos         ;get relative horizontal coordinate
00E6E0  2  85 05              sta $05                    ;store here
00E6E2  2  A6 39              ldx PowerUpType            ;get power-up type
00E6E4  2  BD CE E6           lda PowerUpAttributes,x    ;get attribute data for power-up type
00E6E7  2  0D CA 03           ora Enemy_SprAttrib+5      ;add background priority bit if set
00E6EA  2  85 04              sta $04                    ;store attributes here
00E6EC  2  8A                 txa
00E6ED  2  48                 pha                        ;save power-up type to the stack
00E6EE  2  0A                 asl
00E6EF  2  0A                 asl                        ;multiply by four to get proper offset
00E6F0  2  AA                 tax                        ;use as X
00E6F1  2  A9 01              lda #$01
00E6F3  2  85 07              sta $07                    ;set counter here to draw two rows of sprite object
00E6F5  2  85 03              sta $03                    ;init d1 of flip control
00E6F7  2               
00E6F7  2               PUpDrawLoop:
00E6F7  2  BD BE E6             lda PowerUpGfxTable,x      ;load left tile of power-up object
00E6FA  2  85 00                sta $00
00E6FC  2  BD BF E6             lda PowerUpGfxTable+1,x    ;load right tile
00E6FF  2  20 B2 EB             jsr DrawOneSpriteRow       ;branch to draw one row of our power-up object
00E702  2  C6 07                dec $07                    ;decrement counter
00E704  2  10 F1                bpl PUpDrawLoop            ;branch until two rows are drawn
00E706  2  AC EA 06             ldy Enemy_SprDataOffset+5  ;get sprite data offset again
00E709  2  68                   pla                        ;pull saved power-up type from the stack
00E70A  2  F0 2F                beq PUpOfs                 ;if regular mushroom, branch, do not change colors or flip
00E70C  2  C9 03                cmp #$03
00E70E  2  F0 2B                beq PUpOfs                 ;if 1-up mushroom, branch, do not change colors or flip
00E710  2  85 00                sta $00                    ;store power-up type here now
00E712  2  A5 09                lda FrameCounter           ;get frame counter
00E714  2  4A                   lsr                        ;divide by 2 to change colors every two frames
00E715  2  29 03                and #%00000011             ;mask out all but d1 and d0 (previously d2 and d1)
00E717  2  0D CA 03             ora Enemy_SprAttrib+5      ;add background priority bit if any set
00E71A  2  99 02 02             sta Sprite_Attributes,y    ;set as new palette bits for top left and
00E71D  2  99 06 02             sta Sprite_Attributes+4,y  ;top right sprites for fire flower and star
00E720  2  A6 00                ldx $00
00E722  2  CA                   dex                        ;check power-up type for fire flower
00E723  2  F0 06                beq FlipPUpRightSide       ;if found, skip this part
00E725  2  99 0A 02             sta Sprite_Attributes+8,y  ;otherwise set new palette bits  for bottom left
00E728  2  99 0E 02             sta Sprite_Attributes+12,y ;and bottom right sprites as well for star only
00E72B  2               
00E72B  2               FlipPUpRightSide:
00E72B  2  B9 06 02             lda Sprite_Attributes+4,y
00E72E  2  09 40                ora #%01000000             ;set horizontal flip bit for top right sprite
00E730  2  99 06 02             sta Sprite_Attributes+4,y
00E733  2  B9 0E 02             lda Sprite_Attributes+12,y
00E736  2  09 40                ora #%01000000             ;set horizontal flip bit for bottom right sprite
00E738  2  99 0E 02             sta Sprite_Attributes+12,y ;note these are only done for fire flower and star power-ups
00E73B  2  4C 64 EB     PUpOfs: jmp SprObjectOffscrChk     ;jump to check to see if power-up is offscreen at all, then leave
00E73E  2               
00E73E  2               ;-------------------------------------------------------------------------------------
00E73E  2               ;$00-$01 - used in DrawEnemyObjRow to hold sprite tile numbers
00E73E  2               ;$02 - used to store Y position
00E73E  2               ;$03 - used to store moving direction, used to flip enemies horizontally
00E73E  2               ;$04 - used to store enemy's sprite attributes
00E73E  2               ;$05 - used to store X position
00E73E  2               ;$eb - used to hold sprite data offset
00E73E  2               ;$ec - used to hold either altered enemy state or special value used in gfx handler as condition
00E73E  2               ;$ed - used to hold enemy state from buffer
00E73E  2               ;$ef - used to hold enemy code used in gfx handler (may or may not resemble Enemy_ID values)
00E73E  2               
00E73E  2               ;tiles arranged in top left, right, middle left, right, bottom left, right order
00E73E  2               EnemyGraphicsTable:
00E73E  2  FC FC AA AB        .byte $fc, $fc, $aa, $ab, $ac, $ad  ;buzzy beetle frame 1
00E742  2  AC AD        
00E744  2  FC FC AE AF        .byte $fc, $fc, $ae, $af, $b0, $b1  ;             frame 2
00E748  2  B0 B1        
00E74A  2  FC A5 A6 A7        .byte $fc, $a5, $a6, $a7, $a8, $a9  ;koopa troopa frame 1
00E74E  2  A8 A9        
00E750  2  FC A0 A1 A2        .byte $fc, $a0, $a1, $a2, $a3, $a4  ;             frame 2
00E754  2  A3 A4        
00E756  2  69 A5 6A A7        .byte $69, $a5, $6a, $a7, $a8, $a9  ;koopa paratroopa frame 1
00E75A  2  A8 A9        
00E75C  2  6B A0 6C A2        .byte $6b, $a0, $6c, $a2, $a3, $a4  ;                 frame 2
00E760  2  A3 A4        
00E762  2  FC FC 96 97        .byte $fc, $fc, $96, $97, $98, $99  ;spiny frame 1
00E766  2  98 99        
00E768  2  FC FC 9A 9B        .byte $fc, $fc, $9a, $9b, $9c, $9d  ;      frame 2
00E76C  2  9C 9D        
00E76E  2  FC FC 8F 8E        .byte $fc, $fc, $8f, $8e, $8e, $8f  ;spiny's egg frame 1
00E772  2  8E 8F        
00E774  2  FC FC 95 94        .byte $fc, $fc, $95, $94, $94, $95  ;            frame 2
00E778  2  94 95        
00E77A  2  FC FC DC DC        .byte $fc, $fc, $dc, $dc, $df, $df  ;bloober frame 1
00E77E  2  DF DF        
00E780  2  DC DC DD DD        .byte $dc, $dc, $dd, $dd, $de, $de  ;        frame 2
00E784  2  DE DE        
00E786  2  FC FC B2 B3        .byte $fc, $fc, $b2, $b3, $b4, $b5  ;cheep-cheep frame 1
00E78A  2  B4 B5        
00E78C  2  FC FC B6 B3        .byte $fc, $fc, $b6, $b3, $b7, $b5  ;            frame 2
00E790  2  B7 B5        
00E792  2  FC FC 70 71        .byte $fc, $fc, $70, $71, $72, $73  ;goomba
00E796  2  72 73        
00E798  2  FC FC 6E 6E        .byte $fc, $fc, $6e, $6e, $6f, $6f  ;koopa shell frame 1 (upside-down)
00E79C  2  6F 6F        
00E79E  2  FC FC 6D 6D        .byte $fc, $fc, $6d, $6d, $6f, $6f  ;            frame 2
00E7A2  2  6F 6F        
00E7A4  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6e, $6e  ;koopa shell frame 1 (rightsideup)
00E7A8  2  6E 6E        
00E7AA  2  FC FC 6F 6F        .byte $fc, $fc, $6f, $6f, $6d, $6d  ;            frame 2
00E7AE  2  6D 6D        
00E7B0  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;buzzy beetle shell frame 1 (rightsideup)
00E7B4  2  F5 F5        
00E7B6  2  FC FC F4 F4        .byte $fc, $fc, $f4, $f4, $f5, $f5  ;                   frame 2
00E7BA  2  F5 F5        
00E7BC  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;buzzy beetle shell frame 1 (upside-down)
00E7C0  2  F4 F4        
00E7C2  2  FC FC F5 F5        .byte $fc, $fc, $f5, $f5, $f4, $f4  ;                   frame 2
00E7C6  2  F4 F4        
00E7C8  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $ef, $ef  ;defeated goomba
00E7CC  2  EF EF        
00E7CE  2  B9 B8 BB BA        .byte $b9, $b8, $bb, $ba, $bc, $bc  ;lakitu frame 1
00E7D2  2  BC BC        
00E7D4  2  FC FC BD BD        .byte $fc, $fc, $bd, $bd, $bc, $bc  ;       frame 2
00E7D8  2  BC BC        
00E7DA  2  7A 7B DA DB        .byte $7a, $7b, $da, $db, $d8, $d8  ;princess
00E7DE  2  D8 D8        
00E7E0  2  CD CD CE CE        .byte $cd, $cd, $ce, $ce, $cf, $cf  ;mushroom retainer
00E7E4  2  CF CF        
00E7E6  2  7D 7C D1 8C        .byte $7d, $7c, $d1, $8c, $d3, $d2  ;hammer bro frame 1
00E7EA  2  D3 D2        
00E7EC  2  7D 7C 89 88        .byte $7d, $7c, $89, $88, $8b, $8a  ;           frame 2
00E7F0  2  8B 8A        
00E7F2  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $d3, $d2  ;           frame 3
00E7F6  2  D3 D2        
00E7F8  2  D5 D4 E3 E2        .byte $d5, $d4, $e3, $e2, $8b, $8a  ;           frame 4
00E7FC  2  8B 8A        
00E7FE  2  E5 E5 E6 E6        .byte $e5, $e5, $e6, $e6, $eb, $eb  ;piranha plant frame 1
00E802  2  EB EB        
00E804  2  EC EC ED ED        .byte $ec, $ec, $ed, $ed, $ee, $ee  ;              frame 2
00E808  2  EE EE        
00E80A  2  FC FC D0 D0        .byte $fc, $fc, $d0, $d0, $d7, $d7  ;podoboo
00E80E  2  D7 D7        
00E810  2  BF BE C1 C0        .byte $bf, $be, $c1, $c0, $c2, $fc  ;bowser front frame 1
00E814  2  C2 FC        
00E816  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $c8, $c7  ;bowser rear frame 1
00E81A  2  C8 C7        
00E81C  2  BF BE CA C9        .byte $bf, $be, $ca, $c9, $c2, $fc  ;       front frame 2
00E820  2  C2 FC        
00E822  2  C4 C3 C6 C5        .byte $c4, $c3, $c6, $c5, $cc, $cb  ;       rear frame 2
00E826  2  CC CB        
00E828  2  FC FC E8 E7        .byte $fc, $fc, $e8, $e7, $ea, $e9  ;bullet bill
00E82C  2  EA E9        
00E82E  2  F2 F2 F3 F3        .byte $f2, $f2, $f3, $f3, $f2, $f2  ;jumpspring frame 1
00E832  2  F2 F2        
00E834  2  F1 F1 F1 F1        .byte $f1, $f1, $f1, $f1, $fc, $fc  ;           frame 2
00E838  2  FC FC        
00E83A  2  F0 F0 FC FC        .byte $f0, $f0, $fc, $fc, $fc, $fc  ;           frame 3
00E83E  2  FC FC        
00E840  2               
00E840  2               EnemyGfxTableOffsets:
00E840  2  0C 0C 00 0C        .byte $0c, $0c, $00, $0c, $0c, $a8, $54, $3c
00E844  2  0C A8 54 3C  
00E848  2  EA 18 48 48        .byte $ea, $18, $48, $48, $cc, $c0, $18, $18
00E84C  2  CC C0 18 18  
00E850  2  18 90 24 FF        .byte $18, $90, $24, $ff, $48, $9c, $d2, $d8
00E854  2  48 9C D2 D8  
00E858  2  F0 F6 FC           .byte $f0, $f6, $fc
00E85B  2               
00E85B  2               EnemyAttributeData:
00E85B  2  01 02 03 02        .byte $01, $02, $03, $02, $01, $01, $03, $03
00E85F  2  01 01 03 03  
00E863  2  03 01 01 02        .byte $03, $01, $01, $02, $02, $21, $01, $02
00E867  2  02 21 01 02  
00E86B  2  01 01 02 FF        .byte $01, $01, $02, $ff, $02, $02, $01, $01
00E86F  2  02 02 01 01  
00E873  2  02 02 02           .byte $02, $02, $02
00E876  2               
00E876  2               EnemyAnimTimingBMask:
00E876  2  08 18              .byte $08, $18
00E878  2               
00E878  2               JumpspringFrameOffsets:
00E878  2  18 19 1A 19        .byte $18, $19, $1a, $19, $18
00E87C  2  18           
00E87D  2               
00E87D  2               EnemyGfxHandler:
00E87D  2  B5 CF              lda Enemy_Y_Position,x      ;get enemy object vertical position
00E87F  2  85 02              sta $02
00E881  2  AD AE 03           lda Enemy_Rel_XPos          ;get enemy object horizontal position
00E884  2  85 05              sta $05                     ;relative to screen
00E886  2  BC E5 06           ldy Enemy_SprDataOffset,x
00E889  2  84 EB              sty $eb                     ;get sprite data offset
00E88B  2  A9 00              lda #$00
00E88D  2  8D 09 01           sta VerticalFlipFlag        ;initialize vertical flip flag by default
00E890  2  B5 46              lda Enemy_MovingDir,x
00E892  2  85 03              sta $03                     ;get enemy object moving direction
00E894  2  BD C5 03           lda Enemy_SprAttrib,x
00E897  2  85 04              sta $04                     ;get enemy object sprite attributes
00E899  2  B5 16              lda Enemy_ID,x
00E89B  2  C9 0D              cmp #PiranhaPlant           ;is enemy object piranha plant?
00E89D  2  D0 0A              bne CheckForRetainerObj     ;if not, branch
00E89F  2  B4 58              ldy PiranhaPlant_Y_Speed,x
00E8A1  2  30 06              bmi CheckForRetainerObj     ;if piranha plant moving upwards, branch
00E8A3  2  BC 8A 07           ldy EnemyFrameTimer,x
00E8A6  2  F0 01              beq CheckForRetainerObj     ;if timer for movement expired, branch
00E8A8  2  60                 rts                         ;if all conditions fail, leave
00E8A9  2               
00E8A9  2               CheckForRetainerObj:
00E8A9  2  B5 1E              lda Enemy_State,x           ;store enemy state
00E8AB  2  85 ED              sta $ed
00E8AD  2  29 1F              and #%00011111              ;nullify all but 5 LSB and use as Y
00E8AF  2  A8                 tay
00E8B0  2  B5 16              lda Enemy_ID,x              ;check for mushroom retainer/princess object
00E8B2  2  C9 35              cmp #RetainerObject
00E8B4  2  D0 08              bne CheckForBulletBillCV    ;if not found, branch
00E8B6  2  A0 00              ldy #$00                    ;if found, nullify saved state in Y
00E8B8  2  A9 01              lda #$01                    ;set value that will not be used
00E8BA  2  85 03              sta $03
00E8BC  2  A9 15              lda #$15                    ;set value $15 as code for mushroom retainer/princess object
00E8BE  2               
00E8BE  2               CheckForBulletBillCV:
00E8BE  2  C9 33               cmp #BulletBill_CannonVar   ;otherwise check for bullet bill object
00E8C0  2  D0 13               bne CheckForJumpspring      ;if not found, branch again
00E8C2  2  C6 02               dec $02                     ;decrement saved vertical position
00E8C4  2  A9 03               lda #$03
00E8C6  2  BC 8A 07            ldy EnemyFrameTimer,x       ;get timer for enemy object
00E8C9  2  F0 02               beq SBBAt                   ;if expired, do not set priority bit
00E8CB  2  09 20               ora #%00100000              ;otherwise do so
00E8CD  2  85 04        SBBAt: sta $04                     ;set new sprite attributes
00E8CF  2  A0 00               ldy #$00                    ;nullify saved enemy state both in Y and in
00E8D1  2  84 ED               sty $ed                     ;memory location here
00E8D3  2  A9 08               lda #$08                    ;set specific value to unconditionally branch once
00E8D5  2               
00E8D5  2               CheckForJumpspring:
00E8D5  2  C9 32              cmp #JumpspringObject        ;check for jumpspring object
00E8D7  2  D0 08              bne CheckForPodoboo
00E8D9  2  A0 03              ldy #$03                     ;set enemy state -2 MSB here for jumpspring object
00E8DB  2  AE 0E 07           ldx JumpspringAnimCtrl       ;get current frame number for jumpspring object
00E8DE  2  BD 78 E8           lda JumpspringFrameOffsets,x ;load data using frame number as offset
00E8E1  2               
00E8E1  2               CheckForPodoboo:
00E8E1  2  85 EF              sta $ef                 ;store saved enemy object value here
00E8E3  2  84 EC              sty $ec                 ;and Y here (enemy state -2 MSB if not changed)
00E8E5  2  A6 08              ldx ObjectOffset        ;get enemy object offset
00E8E7  2  C9 0C              cmp #$0c                ;check for podoboo object
00E8E9  2  D0 07              bne CheckBowserGfxFlag  ;branch if not found
00E8EB  2  B5 A0              lda Enemy_Y_Speed,x     ;if moving upwards, branch
00E8ED  2  30 03              bmi CheckBowserGfxFlag
00E8EF  2  EE 09 01           inc VerticalFlipFlag    ;otherwise, set flag for vertical flip
00E8F2  2               
00E8F2  2               CheckBowserGfxFlag:
00E8F2  2  AD 6A 03                  lda BowserGfxFlag   ;if not drawing bowser at all, skip to something else
00E8F5  2  F0 09                     beq CheckForGoomba
00E8F7  2  A0 16                     ldy #$16            ;if set to 1, draw bowser's front
00E8F9  2  C9 01                     cmp #$01
00E8FB  2  F0 01                     beq SBwsrGfxOfs
00E8FD  2  C8                        iny                 ;otherwise draw bowser's rear
00E8FE  2  84 EF        SBwsrGfxOfs: sty $ef
00E900  2               
00E900  2               CheckForGoomba:
00E900  2  A4 EF                  ldy $ef               ;check value for goomba object
00E902  2  C0 06                  cpy #Goomba
00E904  2  D0 1D                  bne CheckBowserFront  ;branch if not found
00E906  2  B5 1E                  lda Enemy_State,x
00E908  2  C9 02                  cmp #$02              ;check for defeated state
00E90A  2  90 04                  bcc GmbaAnim          ;if not defeated, go ahead and animate
00E90C  2  A2 04                  ldx #$04              ;if defeated, write new value here
00E90E  2  86 EC                  stx $ec
00E910  2  29 20        GmbaAnim: and #%00100000        ;check for d5 set in enemy object state
00E912  2  0D 47 07               ora TimerControl      ;or timer disable flag set
00E915  2  D0 0C                  bne CheckBowserFront  ;if either condition true, do not animate goomba
00E917  2  A5 09                  lda FrameCounter
00E919  2  29 08                  and #%00001000        ;check for every eighth frame
00E91B  2  D0 06                  bne CheckBowserFront
00E91D  2  A5 03                  lda $03
00E91F  2  49 03                  eor #%00000011        ;invert bits to flip horizontally every eight frames
00E921  2  85 03                  sta $03               ;leave alone otherwise
00E923  2               
00E923  2               CheckBowserFront:
00E923  2  B9 5B E8                  lda EnemyAttributeData,y    ;load sprite attribute using enemy object
00E926  2  05 04                     ora $04                     ;as offset, and add to bits already loaded
00E928  2  85 04                     sta $04
00E92A  2  B9 40 E8                  lda EnemyGfxTableOffsets,y  ;load value based on enemy object as offset
00E92D  2  AA                        tax                         ;save as X
00E92E  2  A4 EC                     ldy $ec                     ;get previously saved value
00E930  2  AD 6A 03                  lda BowserGfxFlag
00E933  2  F0 30                     beq CheckForSpiny           ;if not drawing bowser object at all, skip all of this
00E935  2  C9 01                     cmp #$01
00E937  2  D0 13                     bne CheckBowserRear         ;if not drawing front part, branch to draw the rear part
00E939  2  AD 63 03                  lda BowserBodyControls      ;check bowser's body control bits
00E93C  2  10 02                     bpl ChkFrontSte             ;branch if d7 not set (control's bowser's mouth)
00E93E  2  A2 DE                     ldx #$de                    ;otherwise load offset for second frame
00E940  2  A5 ED        ChkFrontSte: lda $ed                     ;check saved enemy state
00E942  2  29 20                     and #%00100000              ;if bowser not defeated, do not set flag
00E944  2  F0 03                     beq DrawBowser
00E946  2               
00E946  2               FlipBowserOver:
00E946  2  8E 09 01           stx VerticalFlipFlag  ;set vertical flip flag to nonzero
00E949  2               
00E949  2               DrawBowser:
00E949  2  4C 4B EA           jmp DrawEnemyObject   ;draw bowser's graphics now
00E94C  2               
00E94C  2               CheckBowserRear:
00E94C  2  AD 63 03                 lda BowserBodyControls  ;check bowser's body control bits
00E94F  2  29 01                    and #$01
00E951  2  F0 02                    beq ChkRearSte          ;branch if d0 not set (control's bowser's feet)
00E953  2  A2 E4                    ldx #$e4                ;otherwise load offset for second frame
00E955  2  A5 ED        ChkRearSte: lda $ed                 ;check saved enemy state
00E957  2  29 20                    and #%00100000          ;if bowser not defeated, do not set flag
00E959  2  F0 EE                    beq DrawBowser
00E95B  2  A5 02                    lda $02                 ;subtract 16 pixels from
00E95D  2  38                       sec                     ;saved vertical coordinate
00E95E  2  E9 10                    sbc #$10
00E960  2  85 02                    sta $02
00E962  2  4C 46 E9                 jmp FlipBowserOver      ;jump to set vertical flip flag
00E965  2               
00E965  2               CheckForSpiny:
00E965  2  E0 24                cpx #$24               ;check if value loaded is for spiny
00E967  2  D0 11                bne CheckForLakitu     ;if not found, branch
00E969  2  C0 05                cpy #$05               ;if enemy state set to $05, do this,
00E96B  2  D0 0A                bne NotEgg             ;otherwise branch
00E96D  2  A2 30                ldx #$30               ;set to spiny egg offset
00E96F  2  A9 02                lda #$02
00E971  2  85 03                sta $03                ;set enemy direction to reverse sprites horizontally
00E973  2  A9 05                lda #$05
00E975  2  85 EC                sta $ec                ;set enemy state
00E977  2  4C CA E9     NotEgg: jmp CheckForHammerBro  ;skip a big chunk of this if we found spiny but not in egg
00E97A  2               
00E97A  2               CheckForLakitu:
00E97A  2  E0 90                cpx #$90                  ;check value for lakitu's offset loaded
00E97C  2  D0 12                bne CheckUpsideDownShell  ;branch if not loaded
00E97E  2  A5 ED                lda $ed
00E980  2  29 20                and #%00100000            ;check for d5 set in enemy state
00E982  2  D0 09                bne NoLAFr                ;branch if set
00E984  2  AD 8F 07             lda FrenzyEnemyTimer
00E987  2  C9 10                cmp #$10                  ;check timer to see if we've reached a certain range
00E989  2  B0 02                bcs NoLAFr                ;branch if not
00E98B  2  A2 96                ldx #$96                  ;if d6 not set and timer in range, load alt frame for lakitu
00E98D  2  4C 37 EA     NoLAFr: jmp CheckDefeatedState    ;skip this next part if we found lakitu but alt frame not needed
00E990  2               
00E990  2               CheckUpsideDownShell:
00E990  2  A5 EF              lda $ef                    ;check for enemy object => $04
00E992  2  C9 04              cmp #$04
00E994  2  B0 10              bcs CheckRightSideUpShell  ;branch if true
00E996  2  C0 02              cpy #$02
00E998  2  90 0C              bcc CheckRightSideUpShell  ;branch if enemy state < $02
00E99A  2  A2 5A              ldx #$5a                   ;set for upside-down koopa shell by default
00E99C  2  A4 EF              ldy $ef
00E99E  2  C0 02              cpy #BuzzyBeetle           ;check for buzzy beetle object
00E9A0  2  D0 04              bne CheckRightSideUpShell
00E9A2  2  A2 7E              ldx #$7e                   ;set for upside-down buzzy beetle shell if found
00E9A4  2  E6 02              inc $02                    ;increment vertical position by one pixel
00E9A6  2               
00E9A6  2               CheckRightSideUpShell:
00E9A6  2  A5 EC              lda $ec                ;check for value set here
00E9A8  2  C9 04              cmp #$04               ;if enemy state < $02, do not change to shell, if
00E9AA  2  D0 1E              bne CheckForHammerBro  ;enemy state => $02 but not = $04, leave shell upside-down
00E9AC  2  A2 72              ldx #$72               ;set right-side up buzzy beetle shell by default
00E9AE  2  E6 02              inc $02                ;increment saved vertical position by one pixel
00E9B0  2  A4 EF              ldy $ef
00E9B2  2  C0 02              cpy #BuzzyBeetle       ;check for buzzy beetle object
00E9B4  2  F0 04              beq CheckForDefdGoomba ;branch if found
00E9B6  2  A2 66              ldx #$66               ;change to right-side up koopa shell if not found
00E9B8  2  E6 02              inc $02                ;and increment saved vertical position again
00E9BA  2               
00E9BA  2               CheckForDefdGoomba:
00E9BA  2  C0 06              cpy #Goomba            ;check for goomba object (necessary if previously
00E9BC  2  D0 0C              bne CheckForHammerBro  ;failed buzzy beetle object test)
00E9BE  2  A2 54              ldx #$54               ;load for regular goomba
00E9C0  2  A5 ED              lda $ed                ;note that this only gets performed if enemy state => $02
00E9C2  2  29 20              and #%00100000         ;check saved enemy state for d5 set
00E9C4  2  D0 04              bne CheckForHammerBro  ;branch if set
00E9C6  2  A2 8A              ldx #$8a               ;load offset for defeated goomba
00E9C8  2  C6 02              dec $02                ;set different value and decrement saved vertical position
00E9CA  2               
00E9CA  2               CheckForHammerBro:
00E9CA  2  A4 08              ldy ObjectOffset
00E9CC  2  A5 EF              lda $ef                  ;check for hammer bro object
00E9CE  2  C9 05              cmp #HammerBro
00E9D0  2  D0 0C              bne CheckForBloober      ;branch if not found
00E9D2  2  A5 ED              lda $ed
00E9D4  2  F0 24              beq CheckToAnimateEnemy  ;branch if not in normal enemy state
00E9D6  2  29 08              and #%00001000
00E9D8  2  F0 5D              beq CheckDefeatedState   ;if d3 not set, branch further away
00E9DA  2  A2 B4              ldx #$b4                 ;otherwise load offset for different frame
00E9DC  2  D0 1C              bne CheckToAnimateEnemy  ;unconditional branch
00E9DE  2               
00E9DE  2               CheckForBloober:
00E9DE  2  E0 48              cpx #$48                 ;check for cheep-cheep offset loaded
00E9E0  2  F0 18              beq CheckToAnimateEnemy  ;branch if found
00E9E2  2  B9 96 07           lda EnemyIntervalTimer,y
00E9E5  2  C9 05              cmp #$05
00E9E7  2  B0 4E              bcs CheckDefeatedState   ;branch if some timer is above a certain point
00E9E9  2  E0 3C              cpx #$3c                 ;check for bloober offset loaded
00E9EB  2  D0 0D              bne CheckToAnimateEnemy  ;branch if not found this time
00E9ED  2  C9 01              cmp #$01
00E9EF  2  F0 46              beq CheckDefeatedState   ;branch if timer is set to certain point
00E9F1  2  E6 02              inc $02                  ;increment saved vertical coordinate three pixels
00E9F3  2  E6 02              inc $02
00E9F5  2  E6 02              inc $02
00E9F7  2  4C 29 EA           jmp CheckAnimationStop   ;and do something else
00E9FA  2               
00E9FA  2               CheckToAnimateEnemy:
00E9FA  2  A5 EF              lda $ef                  ;check for specific enemy objects
00E9FC  2  C9 06              cmp #Goomba
00E9FE  2  F0 37              beq CheckDefeatedState   ;branch if goomba
00EA00  2  C9 08              cmp #$08
00EA02  2  F0 33              beq CheckDefeatedState   ;branch if bullet bill (note both variants use $08 here)
00EA04  2  C9 0C              cmp #Podoboo
00EA06  2  F0 2F              beq CheckDefeatedState   ;branch if podoboo
00EA08  2  C9 18              cmp #$18                 ;branch if => $18
00EA0A  2  B0 2B              bcs CheckDefeatedState
00EA0C  2  A0 00              ldy #$00
00EA0E  2  C9 15              cmp #$15                 ;check for mushroom retainer/princess object
00EA10  2  D0 10              bne CheckForSecondFrame  ;which uses different code here, branch if not found
00EA12  2  C8                 iny                      ;residual instruction
00EA13  2  AD 5F 07           lda WorldNumber          ;are we on world 8?
00EA16  2  C9 07              cmp #World8
00EA18  2  B0 1D              bcs CheckDefeatedState   ;if so, leave the offset alone (use princess)
00EA1A  2  A2 A2              ldx #$a2                 ;otherwise, set for mushroom retainer object instead
00EA1C  2  A9 03              lda #$03                 ;set alternate state here
00EA1E  2  85 EC              sta $ec
00EA20  2  D0 15              bne CheckDefeatedState   ;unconditional branch
00EA22  2               
00EA22  2               CheckForSecondFrame:
00EA22  2  A5 09              lda FrameCounter            ;load frame counter
00EA24  2  39 76 E8           and EnemyAnimTimingBMask,y  ;mask it (partly residual, one byte not ever used)
00EA27  2  D0 0E              bne CheckDefeatedState      ;branch if timing is off
00EA29  2               
00EA29  2               CheckAnimationStop:
00EA29  2  A5 ED              lda $ed                 ;check saved enemy state
00EA2B  2  29 A0              and #%10100000          ;for d7 or d5, or check for timers stopped
00EA2D  2  0D 47 07           ora TimerControl
00EA30  2  D0 05              bne CheckDefeatedState  ;if either condition true, branch
00EA32  2  8A                 txa
00EA33  2  18                 clc
00EA34  2  69 06              adc #$06                ;add $06 to current enemy offset
00EA36  2  AA                 tax                     ;to animate various enemy objects
00EA37  2               
00EA37  2               CheckDefeatedState:
00EA37  2  A5 ED              lda $ed               ;check saved enemy state
00EA39  2  29 20              and #%00100000        ;for d5 set
00EA3B  2  F0 0E              beq DrawEnemyObject   ;branch if not set
00EA3D  2  A5 EF              lda $ef
00EA3F  2  C9 04              cmp #$04              ;check for saved enemy object => $04
00EA41  2  90 08              bcc DrawEnemyObject   ;branch if less
00EA43  2  A0 01              ldy #$01
00EA45  2  8C 09 01           sty VerticalFlipFlag  ;set vertical flip flag
00EA48  2  88                 dey
00EA49  2  84 EC              sty $ec               ;init saved value here
00EA4B  2               
00EA4B  2               DrawEnemyObject:
00EA4B  2  A4 EB              ldy $eb                    ;load sprite data offset
00EA4D  2  20 AA EB           jsr DrawEnemyObjRow        ;draw six tiles of data
00EA50  2  20 AA EB           jsr DrawEnemyObjRow        ;into sprite data
00EA53  2  20 AA EB           jsr DrawEnemyObjRow
00EA56  2  A6 08              ldx ObjectOffset           ;get enemy object offset
00EA58  2  BC E5 06           ldy Enemy_SprDataOffset,x  ;get sprite data offset
00EA5B  2  A5 EF              lda $ef
00EA5D  2  C9 08              cmp #$08                   ;get saved enemy object and check
00EA5F  2  D0 03              bne CheckForVerticalFlip   ;for bullet bill, branch if not found
00EA61  2               
00EA61  2               SkipToOffScrChk:
00EA61  2  4C 64 EB           jmp SprObjectOffscrChk     ;jump if found
00EA64  2               
00EA64  2               CheckForVerticalFlip:
00EA64  2  AD 09 01           lda VerticalFlipFlag       ;check if vertical flip flag is set here
00EA67  2  F0 3D              beq CheckForESymmetry      ;branch if not
00EA69  2  B9 02 02           lda Sprite_Attributes,y    ;get attributes of first sprite we dealt with
00EA6C  2  09 80              ora #%10000000             ;set bit for vertical flip
00EA6E  2  C8                 iny
00EA6F  2  C8                 iny                        ;increment two bytes so that we store the vertical flip
00EA70  2  20 B5 E5           jsr DumpSixSpr             ;in attribute bytes of enemy obj sprite data
00EA73  2  88                 dey
00EA74  2  88                 dey                        ;now go back to the Y coordinate offset
00EA75  2  98                 tya
00EA76  2  AA                 tax                        ;give offset to X
00EA77  2  A5 EF              lda $ef
00EA79  2  C9 05              cmp #HammerBro             ;check saved enemy object for hammer bro
00EA7B  2  F0 0D              beq FlipEnemyVertically
00EA7D  2  C9 11              cmp #Lakitu                ;check saved enemy object for lakitu
00EA7F  2  F0 09              beq FlipEnemyVertically    ;branch for hammer bro or lakitu
00EA81  2  C9 15              cmp #$15
00EA83  2  B0 05              bcs FlipEnemyVertically    ;also branch if enemy object => $15
00EA85  2  8A                 txa
00EA86  2  18                 clc
00EA87  2  69 08              adc #$08                   ;if not selected objects or => $15, set
00EA89  2  AA                 tax                        ;offset in X for next row
00EA8A  2               
00EA8A  2               FlipEnemyVertically:
00EA8A  2  BD 01 02           lda Sprite_Tilenumber,x     ;load first or second row tiles
00EA8D  2  48                 pha                         ;and save tiles to the stack
00EA8E  2  BD 05 02           lda Sprite_Tilenumber+4,x
00EA91  2  48                 pha
00EA92  2  B9 11 02           lda Sprite_Tilenumber+16,y  ;exchange third row tiles
00EA95  2  9D 01 02           sta Sprite_Tilenumber,x     ;with first or second row tiles
00EA98  2  B9 15 02           lda Sprite_Tilenumber+20,y
00EA9B  2  9D 05 02           sta Sprite_Tilenumber+4,x
00EA9E  2  68                 pla                         ;pull first or second row tiles from stack
00EA9F  2  99 15 02           sta Sprite_Tilenumber+20,y  ;and save in third row
00EAA2  2  68                 pla
00EAA3  2  99 11 02           sta Sprite_Tilenumber+16,y
00EAA6  2               
00EAA6  2               CheckForESymmetry:
00EAA6  2  AD 6A 03             lda BowserGfxFlag           ;are we drawing bowser at all?
00EAA9  2  D0 B6                bne SkipToOffScrChk         ;branch if so
00EAAB  2  A5 EF                lda $ef
00EAAD  2  A6 EC                ldx $ec                     ;get alternate enemy state
00EAAF  2  C9 05                cmp #$05                    ;check for hammer bro object
00EAB1  2  D0 03                bne ContES
00EAB3  2  4C 64 EB             jmp SprObjectOffscrChk      ;jump if found
00EAB6  2  C9 07        ContES: cmp #Bloober                ;check for bloober object
00EAB8  2  F0 1D                beq MirrorEnemyGfx
00EABA  2  C9 0D                cmp #PiranhaPlant           ;check for piranha plant object
00EABC  2  F0 19                beq MirrorEnemyGfx
00EABE  2  C9 0C                cmp #Podoboo                ;check for podoboo object
00EAC0  2  F0 15                beq MirrorEnemyGfx          ;branch if either of three are found
00EAC2  2  C9 12                cmp #Spiny                  ;check for spiny object
00EAC4  2  D0 04                bne ESRtnr                  ;branch closer if not found
00EAC6  2  E0 05                cpx #$05                    ;check spiny's state
00EAC8  2  D0 48                bne CheckToMirrorLakitu     ;branch if not an egg, otherwise
00EACA  2  C9 15        ESRtnr: cmp #$15                    ;check for princess/mushroom retainer object
00EACC  2  D0 05                bne SpnySC
00EACE  2  A9 42                lda #$42                    ;set horizontal flip on bottom right sprite
00EAD0  2  99 16 02             sta Sprite_Attributes+20,y  ;note that palette bits were already set earlier
00EAD3  2  E0 02        SpnySC: cpx #$02                    ;if alternate enemy state set to 1 or 0, branch
00EAD5  2  90 3B                bcc CheckToMirrorLakitu
00EAD7  2               
00EAD7  2               MirrorEnemyGfx:
00EAD7  2  AD 6A 03             lda BowserGfxFlag           ;if enemy object is bowser, skip all of this
00EADA  2  D0 36                bne CheckToMirrorLakitu
00EADC  2  B9 02 02             lda Sprite_Attributes,y     ;load attribute bits of first sprite
00EADF  2  29 A3                and #%10100011
00EAE1  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip, priority, and palette bits
00EAE4  2  99 0A 02             sta Sprite_Attributes+8,y   ;in left sprite column of enemy object OAM data
00EAE7  2  99 12 02             sta Sprite_Attributes+16,y
00EAEA  2  09 40                ora #%01000000              ;set horizontal flip
00EAEC  2  E0 05                cpx #$05                    ;check for state used by spiny's egg
00EAEE  2  D0 02                bne EggExc                  ;if alternate state not set to $05, branch
00EAF0  2  09 80                ora #%10000000              ;otherwise set vertical flip
00EAF2  2  99 06 02     EggExc: sta Sprite_Attributes+4,y   ;set bits of right sprite column
00EAF5  2  99 0E 02             sta Sprite_Attributes+12,y  ;of enemy object sprite data
00EAF8  2  99 16 02             sta Sprite_Attributes+20,y
00EAFB  2  E0 04                cpx #$04                    ;check alternate enemy state
00EAFD  2  D0 13                bne CheckToMirrorLakitu     ;branch if not $04
00EAFF  2  B9 0A 02             lda Sprite_Attributes+8,y   ;get second row left sprite attributes
00EB02  2  09 80                ora #%10000000
00EB04  2  99 0A 02             sta Sprite_Attributes+8,y   ;store bits with vertical flip in
00EB07  2  99 12 02             sta Sprite_Attributes+16,y  ;second and third row left sprites
00EB0A  2  09 40                ora #%01000000
00EB0C  2  99 0E 02             sta Sprite_Attributes+12,y  ;store with horizontal and vertical flip in
00EB0F  2  99 16 02             sta Sprite_Attributes+20,y  ;second and third row right sprites
00EB12  2               
00EB12  2               CheckToMirrorLakitu:
00EB12  2  A5 EF                lda $ef                     ;check for lakitu enemy object
00EB14  2  C9 11                cmp #Lakitu
00EB16  2  D0 36                bne CheckToMirrorJSpring    ;branch if not found
00EB18  2  AD 09 01             lda VerticalFlipFlag
00EB1B  2  D0 21                bne NVFLak                  ;branch if vertical flip flag not set
00EB1D  2  B9 12 02             lda Sprite_Attributes+16,y  ;save vertical flip and palette bits
00EB20  2  29 81                and #%10000001              ;in third row left sprite
00EB22  2  99 12 02             sta Sprite_Attributes+16,y
00EB25  2  B9 16 02             lda Sprite_Attributes+20,y  ;set horizontal flip and palette bits
00EB28  2  09 41                ora #%01000001              ;in third row right sprite
00EB2A  2  99 16 02             sta Sprite_Attributes+20,y
00EB2D  2  AE 8F 07             ldx FrenzyEnemyTimer        ;check timer
00EB30  2  E0 10                cpx #$10
00EB32  2  B0 30                bcs SprObjectOffscrChk      ;branch if timer has not reached a certain range
00EB34  2  99 0E 02             sta Sprite_Attributes+12,y  ;otherwise set same for second row right sprite
00EB37  2  29 81                and #%10000001
00EB39  2  99 0A 02             sta Sprite_Attributes+8,y   ;preserve vertical flip and palette bits for left sprite
00EB3C  2  90 26                bcc SprObjectOffscrChk      ;unconditional branch
00EB3E  2  B9 02 02     NVFLak: lda Sprite_Attributes,y     ;get first row left sprite attributes
00EB41  2  29 81                and #%10000001
00EB43  2  99 02 02             sta Sprite_Attributes,y     ;save vertical flip and palette bits
00EB46  2  B9 06 02             lda Sprite_Attributes+4,y   ;get first row right sprite attributes
00EB49  2  09 41                ora #%01000001              ;set horizontal flip and palette bits
00EB4B  2  99 06 02             sta Sprite_Attributes+4,y   ;note that vertical flip is left as-is
00EB4E  2               
00EB4E  2               CheckToMirrorJSpring:
00EB4E  2  A5 EF              lda $ef                     ;check for jumpspring object (any frame)
00EB50  2  C9 18              cmp #$18
00EB52  2  90 10              bcc SprObjectOffscrChk      ;branch if not jumpspring object at all
00EB54  2  A9 82              lda #$82
00EB56  2  99 0A 02           sta Sprite_Attributes+8,y   ;set vertical flip and palette bits of
00EB59  2  99 12 02           sta Sprite_Attributes+16,y  ;second and third row left sprites
00EB5C  2  09 40              ora #%01000000
00EB5E  2  99 0E 02           sta Sprite_Attributes+12,y  ;set, in addition to those, horizontal flip
00EB61  2  99 16 02           sta Sprite_Attributes+20,y  ;for second and third row right sprites
00EB64  2               
00EB64  2               SprObjectOffscrChk:
00EB64  2  A6 08                 ldx ObjectOffset          ;get enemy buffer offset
00EB66  2  AD D1 03              lda Enemy_OffscreenBits   ;check offscreen information
00EB69  2  4A                    lsr
00EB6A  2  4A                    lsr                       ;shift three times to the right
00EB6B  2  4A                    lsr                       ;which puts d2 into carry
00EB6C  2  48                    pha                       ;save to stack
00EB6D  2  90 05                 bcc LcChk                 ;branch if not set
00EB6F  2  A9 04                 lda #$04                  ;set for right column sprites
00EB71  2  20 C1 EB              jsr MoveESprColOffscreen  ;and move them offscreen
00EB74  2  68           LcChk:   pla                       ;get from stack
00EB75  2  4A                    lsr                       ;move d3 to carry
00EB76  2  48                    pha                       ;save to stack
00EB77  2  90 05                 bcc Row3C                 ;branch if not set
00EB79  2  A9 00                 lda #$00                  ;set for left column sprites,
00EB7B  2  20 C1 EB              jsr MoveESprColOffscreen  ;move them offscreen
00EB7E  2  68           Row3C:   pla                       ;get from stack again
00EB7F  2  4A                    lsr                       ;move d5 to carry this time
00EB80  2  4A                    lsr
00EB81  2  48                    pha                       ;save to stack again
00EB82  2  90 05                 bcc Row23C                ;branch if carry not set
00EB84  2  A9 10                 lda #$10                  ;set for third row of sprites
00EB86  2  20 B7 EB              jsr MoveESprRowOffscreen  ;and move them offscreen
00EB89  2  68           Row23C:  pla                       ;get from stack
00EB8A  2  4A                    lsr                       ;move d6 into carry
00EB8B  2  48                    pha                       ;save to stack
00EB8C  2  90 05                 bcc AllRowC
00EB8E  2  A9 08                 lda #$08                  ;set for second and third rows
00EB90  2  20 B7 EB              jsr MoveESprRowOffscreen  ;move them offscreen
00EB93  2  68           AllRowC: pla                       ;get from stack once more
00EB94  2  4A                    lsr                       ;move d7 into carry
00EB95  2  90 12                 bcc ExEGHandler
00EB97  2  20 B7 EB              jsr MoveESprRowOffscreen  ;move all sprites offscreen (A should be 0 by now)
00EB9A  2  B5 16                 lda Enemy_ID,x
00EB9C  2  C9 0C                 cmp #Podoboo              ;check enemy identifier for podoboo
00EB9E  2  F0 09                 beq ExEGHandler           ;skip this part if found, we do not want to erase podoboo!
00EBA0  2  B5 B6                 lda Enemy_Y_HighPos,x     ;check high byte of vertical position
00EBA2  2  C9 02                 cmp #$02                  ;if not yet past the bottom of the screen, branch
00EBA4  2  D0 03                 bne ExEGHandler
00EBA6  2  20 98 C9              jsr EraseEnemyObject      ;what it says
00EBA9  2               
00EBA9  2               ExEGHandler:
00EBA9  2  60                 rts
00EBAA  2               
00EBAA  2               DrawEnemyObjRow:
00EBAA  2  BD 3E E7           lda EnemyGraphicsTable,x    ;load two tiles of enemy graphics
00EBAD  2  85 00              sta $00
00EBAF  2  BD 3F E7           lda EnemyGraphicsTable+1,x
00EBB2  2               
00EBB2  2               DrawOneSpriteRow:
00EBB2  2  85 01              sta $01
00EBB4  2  4C 82 F2           jmp DrawSpriteObject        ;draw them
00EBB7  2               
00EBB7  2               MoveESprRowOffscreen:
00EBB7  2  18                 clc                         ;add A to enemy object OAM data offset
00EBB8  2  7D E5 06           adc Enemy_SprDataOffset,x
00EBBB  2  A8                 tay                         ;use as offset
00EBBC  2  A9 F8              lda #$f8
00EBBE  2  4C C1 E5           jmp DumpTwoSpr              ;move first row of sprites offscreen
00EBC1  2               
00EBC1  2               MoveESprColOffscreen:
00EBC1  2  18                 clc                         ;add A to enemy object OAM data offset
00EBC2  2  7D E5 06           adc Enemy_SprDataOffset,x
00EBC5  2  A8                 tay                         ;use as offset
00EBC6  2  20 4A EC           jsr MoveColOffscreen        ;move first and second row sprites in column offscreen
00EBC9  2  99 10 02           sta Sprite_Data+16,y        ;move third row sprite in column offscreen
00EBCC  2  60                 rts
00EBCD  2               
00EBCD  2               ;-------------------------------------------------------------------------------------
00EBCD  2               ;$00-$01 - tile numbers
00EBCD  2               ;$02 - relative Y position
00EBCD  2               ;$03 - horizontal flip flag (not used here)
00EBCD  2               ;$04 - attributes
00EBCD  2               ;$05 - relative X position
00EBCD  2               
00EBCD  2               DefaultBlockObjTiles:
00EBCD  2  85 85 86 86        .byte $85, $85, $86, $86             ;brick w/ line (these are sprite tiles, not BG!)
00EBD1  2               
00EBD1  2               DrawBlock:
00EBD1  2  AD BC 03                lda Block_Rel_YPos            ;get relative vertical coordinate of block object
00EBD4  2  85 02                   sta $02                       ;store here
00EBD6  2  AD B1 03                lda Block_Rel_XPos            ;get relative horizontal coordinate of block object
00EBD9  2  85 05                   sta $05                       ;store here
00EBDB  2  A9 03                   lda #$03
00EBDD  2  85 04                   sta $04                       ;set attribute byte here
00EBDF  2  4A                      lsr
00EBE0  2  85 03                   sta $03                       ;set horizontal flip bit here (will not be used)
00EBE2  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00EBE5  2  A2 00                   ldx #$00                      ;reset X for use as offset to tile data
00EBE7  2  BD CD EB     DBlkLoop:  lda DefaultBlockObjTiles,x    ;get left tile number
00EBEA  2  85 00                   sta $00                       ;set here
00EBEC  2  BD CE EB                lda DefaultBlockObjTiles+1,x  ;get right tile number
00EBEF  2  20 B2 EB                jsr DrawOneSpriteRow          ;do sub to write tile numbers to first row of sprites
00EBF2  2  E0 04                   cpx #$04                      ;check incremented offset
00EBF4  2  D0 F1                   bne DBlkLoop                  ;and loop back until all four sprites are done
00EBF6  2  A6 08                   ldx ObjectOffset              ;get block object offset
00EBF8  2  BC EC 06                ldy Block_SprDataOffset,x     ;get sprite data offset
00EBFB  2  AD 4E 07                lda AreaType
00EBFE  2  C9 01                   cmp #$01                      ;check for ground level type area
00EC00  2  F0 08                   beq ChkRep                    ;if found, branch to next part
00EC02  2  A9 86                   lda #$86
00EC04  2  99 01 02                sta Sprite_Tilenumber,y       ;otherwise remove brick tiles with lines
00EC07  2  99 05 02                sta Sprite_Tilenumber+4,y     ;and replace then with lineless brick tiles
00EC0A  2  BD E8 03     ChkRep:    lda Block_Metatile,x          ;check replacement metatile
00EC0D  2  C9 C4                   cmp #$c4                      ;if not used block metatile, then
00EC0F  2  D0 24                   bne BlkOffscr                 ;branch ahead to use current graphics
00EC11  2  A9 87                   lda #$87                      ;set A for used block tile
00EC13  2  C8                      iny                           ;increment Y to write to tile bytes
00EC14  2  20 BB E5                jsr DumpFourSpr               ;do sub to dump into all four sprites
00EC17  2  88                      dey                           ;return Y to original offset
00EC18  2  A9 03                   lda #$03                      ;set palette bits
00EC1A  2  AE 4E 07                ldx AreaType
00EC1D  2  CA                      dex                           ;check for ground level type area again
00EC1E  2  F0 01                   beq SetBFlip                  ;if found, use current palette bits
00EC20  2  4A                      lsr                           ;otherwise set to $01
00EC21  2  A6 08        SetBFlip:  ldx ObjectOffset              ;put block object offset back in X
00EC23  2  99 02 02                sta Sprite_Attributes,y       ;store attribute byte as-is in first sprite
00EC26  2  09 40                   ora #%01000000
00EC28  2  99 06 02                sta Sprite_Attributes+4,y     ;set horizontal flip bit for second sprite
00EC2B  2  09 80                   ora #%10000000
00EC2D  2  99 0E 02                sta Sprite_Attributes+12,y    ;set both flip bits for fourth sprite
00EC30  2  29 83                   and #%10000011
00EC32  2  99 0A 02                sta Sprite_Attributes+8,y     ;set vertical flip bit for third sprite
00EC35  2  AD D4 03     BlkOffscr: lda Block_OffscreenBits       ;get offscreen bits for block object
00EC38  2  48                      pha                           ;save to stack
00EC39  2  29 04                   and #%00000100                ;check to see if d2 in offscreen bits are set
00EC3B  2  F0 08                   beq PullOfsB                  ;if not set, branch, otherwise move sprites offscreen
00EC3D  2  A9 F8                   lda #$f8                      ;move offscreen two OAMs
00EC3F  2  99 04 02                sta Sprite_Y_Position+4,y     ;on the right side
00EC42  2  99 0C 02                sta Sprite_Y_Position+12,y
00EC45  2  68           PullOfsB:  pla                           ;pull offscreen bits from stack
00EC46  2  29 08        ChkLeftCo: and #%00001000                ;check to see if d3 in offscreen bits are set
00EC48  2  F0 08                   beq ExDBlk                    ;if not set, branch, otherwise move sprites offscreen
00EC4A  2               
00EC4A  2               MoveColOffscreen:
00EC4A  2  A9 F8                lda #$f8                   ;move offscreen two OAMs
00EC4C  2  99 00 02             sta Sprite_Y_Position,y    ;on the left side (or two rows of enemy on either side
00EC4F  2  99 08 02             sta Sprite_Y_Position+8,y  ;if branched here from enemy graphics handler)
00EC52  2  60           ExDBlk: rts
00EC53  2               
00EC53  2               ;-------------------------------------------------------------------------------------
00EC53  2               ;$00 - used to hold palette bits for attribute byte or relative X position
00EC53  2               
00EC53  2               DrawBrickChunks:
00EC53  2  A9 02                 lda #$02                   ;set palette bits here
00EC55  2  85 00                 sta $00
00EC57  2  A9 75                 lda #$75                   ;set tile number for ball (something residual, likely)
00EC59  2  A4 0E                 ldy GameEngineSubroutine
00EC5B  2  C0 05                 cpy #$05                   ;if end-of-level routine running,
00EC5D  2  F0 06                 beq DChunks                ;use palette and tile number assigned
00EC5F  2  A9 03                 lda #$03                   ;otherwise set different palette bits
00EC61  2  85 00                 sta $00
00EC63  2  A9 84                 lda #$84                   ;and set tile number for brick chunks
00EC65  2  BC EC 06     DChunks: ldy Block_SprDataOffset,x  ;get OAM data offset
00EC68  2  C8                    iny                        ;increment to start with tile bytes in OAM
00EC69  2  20 BB E5              jsr DumpFourSpr            ;do sub to dump tile number into all four sprites
00EC6C  2  A5 09                 lda FrameCounter           ;get frame counter
00EC6E  2  0A                    asl
00EC6F  2  0A                    asl
00EC70  2  0A                    asl                        ;move low nybble to high
00EC71  2  0A                    asl
00EC72  2  29 C0                 and #$c0                   ;get what was originally d3-d2 of low nybble
00EC74  2  05 00                 ora $00                    ;add palette bits
00EC76  2  C8                    iny                        ;increment offset for attribute bytes
00EC77  2  20 BB E5              jsr DumpFourSpr            ;do sub to dump attribute data into all four sprites
00EC7A  2  88                    dey
00EC7B  2  88                    dey                        ;decrement offset to Y coordinate
00EC7C  2  AD BC 03              lda Block_Rel_YPos         ;get first block object's relative vertical coordinate
00EC7F  2  20 C1 E5              jsr DumpTwoSpr             ;do sub to dump current Y coordinate into two sprites
00EC82  2  AD B1 03              lda Block_Rel_XPos         ;get first block object's relative horizontal coordinate
00EC85  2  99 03 02              sta Sprite_X_Position,y    ;save into X coordinate of first sprite
00EC88  2  BD F1 03              lda Block_Orig_XPos,x      ;get original horizontal coordinate
00EC8B  2  38                    sec
00EC8C  2  ED 1C 07              sbc ScreenLeft_X_Pos       ;subtract coordinate of left side from original coordinate
00EC8F  2  85 00                 sta $00                    ;store result as relative horizontal coordinate of original
00EC91  2  38                    sec
00EC92  2  ED B1 03              sbc Block_Rel_XPos         ;get difference of relative positions of original - current
00EC95  2  65 00                 adc $00                    ;add original relative position to result
00EC97  2  69 06                 adc #$06                   ;plus 6 pixels to position second brick chunk correctly
00EC99  2  99 07 02              sta Sprite_X_Position+4,y  ;save into X coordinate of second sprite
00EC9C  2  AD BD 03              lda Block_Rel_YPos+1       ;get second block object's relative vertical coordinate
00EC9F  2  99 08 02              sta Sprite_Y_Position+8,y
00ECA2  2  99 0C 02              sta Sprite_Y_Position+12,y ;dump into Y coordinates of third and fourth sprites
00ECA5  2  AD B2 03              lda Block_Rel_XPos+1       ;get second block object's relative horizontal coordinate
00ECA8  2  99 0B 02              sta Sprite_X_Position+8,y  ;save into X coordinate of third sprite
00ECAB  2  A5 00                 lda $00                    ;use original relative horizontal position
00ECAD  2  38                    sec
00ECAE  2  ED B2 03              sbc Block_Rel_XPos+1       ;get difference of relative positions of original - current
00ECB1  2  65 00                 adc $00                    ;add original relative position to result
00ECB3  2  69 06                 adc #$06                   ;plus 6 pixels to position fourth brick chunk correctly
00ECB5  2  99 0F 02              sta Sprite_X_Position+12,y ;save into X coordinate of fourth sprite
00ECB8  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits for block object
00ECBB  2  20 46 EC              jsr ChkLeftCo              ;do sub to move left half of sprites offscreen if necessary
00ECBE  2  AD D4 03              lda Block_OffscreenBits    ;get offscreen bits again
00ECC1  2  0A                    asl                        ;shift d7 into carry
00ECC2  2  90 05                 bcc ChnkOfs                ;if d7 not set, branch to last part
00ECC4  2  A9 F8                 lda #$f8
00ECC6  2  20 C1 E5              jsr DumpTwoSpr             ;otherwise move top sprites offscreen
00ECC9  2  A5 00        ChnkOfs: lda $00                    ;if relative position on left side of screen,
00ECCB  2  10 10                 bpl ExBCDr                 ;go ahead and leave
00ECCD  2  B9 03 02              lda Sprite_X_Position,y    ;otherwise compare left-side X coordinate
00ECD0  2  D9 07 02              cmp Sprite_X_Position+4,y  ;to right-side X coordinate
00ECD3  2  90 08                 bcc ExBCDr                 ;branch to leave if less
00ECD5  2  A9 F8                 lda #$f8                   ;otherwise move right half of sprites offscreen
00ECD7  2  99 04 02              sta Sprite_Y_Position+4,y
00ECDA  2  99 0C 02              sta Sprite_Y_Position+12,y
00ECDD  2  60           ExBCDr:  rts                        ;leave
00ECDE  2               
00ECDE  2               ;-------------------------------------------------------------------------------------
00ECDE  2               
00ECDE  2               DrawFireball:
00ECDE  2  BC F1 06           ldy FBall_SprDataOffset,x  ;get fireball's sprite data offset
00ECE1  2  AD BA 03           lda Fireball_Rel_YPos      ;get relative vertical coordinate
00ECE4  2  99 00 02           sta Sprite_Y_Position,y    ;store as sprite Y coordinate
00ECE7  2  AD AF 03           lda Fireball_Rel_XPos      ;get relative horizontal coordinate
00ECEA  2  99 03 02           sta Sprite_X_Position,y    ;store as sprite X coordinate, then do shared code
00ECED  2               
00ECED  2               DrawFirebar:
00ECED  2  A5 09               lda FrameCounter         ;get frame counter
00ECEF  2  4A                  lsr                      ;divide by four
00ECF0  2  4A                  lsr
00ECF1  2  48                  pha                      ;save result to stack
00ECF2  2  29 01               and #$01                 ;mask out all but last bit
00ECF4  2  49 64               eor #$64                 ;set either tile $64 or $65 as fireball tile
00ECF6  2  99 01 02            sta Sprite_Tilenumber,y  ;thus tile changes every four frames
00ECF9  2  68                  pla                      ;get from stack
00ECFA  2  4A                  lsr                      ;divide by four again
00ECFB  2  4A                  lsr
00ECFC  2  A9 02               lda #$02                 ;load value $02 to set palette in attrib byte
00ECFE  2  90 02               bcc FireA                ;if last bit shifted out was not set, skip this
00ED00  2  09 C0               ora #%11000000           ;otherwise flip both ways every eight frames
00ED02  2  99 02 02     FireA: sta Sprite_Attributes,y  ;store attribute byte and leave
00ED05  2  60                  rts
00ED06  2               
00ED06  2               ;-------------------------------------------------------------------------------------
00ED06  2               
00ED06  2               ExplosionTiles:
00ED06  2  68 67 66           .byte $68, $67, $66
00ED09  2               
00ED09  2               DrawExplosion_Fireball:
00ED09  2  BC EC 06           ldy Alt_SprDataOffset,x  ;get OAM data offset of alternate sort for fireball's explosion
00ED0C  2  B5 24              lda Fireball_State,x     ;load fireball state
00ED0E  2  F6 24              inc Fireball_State,x     ;increment state for next frame
00ED10  2  4A                 lsr                      ;divide by 2
00ED11  2  29 07              and #%00000111           ;mask out all but d3-d1
00ED13  2  C9 03              cmp #$03                 ;check to see if time to kill fireball
00ED15  2  B0 4A              bcs KillFireBall         ;branch if so, otherwise continue to draw explosion
00ED17  2               
00ED17  2               DrawExplosion_Fireworks:
00ED17  2  AA                 tax                         ;use whatever's in A for offset
00ED18  2  BD 06 ED           lda ExplosionTiles,x        ;get tile number using offset
00ED1B  2  C8                 iny                         ;increment Y (contains sprite data offset)
00ED1C  2  20 BB E5           jsr DumpFourSpr             ;and dump into tile number part of sprite data
00ED1F  2  88                 dey                         ;decrement Y so we have the proper offset again
00ED20  2  A6 08              ldx ObjectOffset            ;return enemy object buffer offset to X
00ED22  2  AD BA 03           lda Fireball_Rel_YPos       ;get relative vertical coordinate
00ED25  2  38                 sec                         ;subtract four pixels vertically
00ED26  2  E9 04              sbc #$04                    ;for first and third sprites
00ED28  2  99 00 02           sta Sprite_Y_Position,y
00ED2B  2  99 08 02           sta Sprite_Y_Position+8,y
00ED2E  2  18                 clc                         ;add eight pixels vertically
00ED2F  2  69 08              adc #$08                    ;for second and fourth sprites
00ED31  2  99 04 02           sta Sprite_Y_Position+4,y
00ED34  2  99 0C 02           sta Sprite_Y_Position+12,y
00ED37  2  AD AF 03           lda Fireball_Rel_XPos       ;get relative horizontal coordinate
00ED3A  2  38                 sec                         ;subtract four pixels horizontally
00ED3B  2  E9 04              sbc #$04                    ;for first and second sprites
00ED3D  2  99 03 02           sta Sprite_X_Position,y
00ED40  2  99 07 02           sta Sprite_X_Position+4,y
00ED43  2  18                 clc                         ;add eight pixels horizontally
00ED44  2  69 08              adc #$08                    ;for third and fourth sprites
00ED46  2  99 0B 02           sta Sprite_X_Position+8,y
00ED49  2  99 0F 02           sta Sprite_X_Position+12,y
00ED4C  2  A9 02              lda #$02                    ;set palette attributes for all sprites, but
00ED4E  2  99 02 02           sta Sprite_Attributes,y     ;set no flip at all for first sprite
00ED51  2  A9 82              lda #$82
00ED53  2  99 06 02           sta Sprite_Attributes+4,y   ;set vertical flip for second sprite
00ED56  2  A9 42              lda #$42
00ED58  2  99 0A 02           sta Sprite_Attributes+8,y   ;set horizontal flip for third sprite
00ED5B  2  A9 C2              lda #$c2
00ED5D  2  99 0E 02           sta Sprite_Attributes+12,y  ;set both flips for fourth sprite
00ED60  2  60                 rts                         ;we are done
00ED61  2               
00ED61  2               KillFireBall:
00ED61  2  A9 00              lda #$00                    ;clear fireball state to kill it
00ED63  2  95 24              sta Fireball_State,x
00ED65  2  60                 rts
00ED66  2               
00ED66  2               ;-------------------------------------------------------------------------------------
00ED66  2               
00ED66  2               DrawSmallPlatform:
00ED66  2  BC E5 06            ldy Enemy_SprDataOffset,x   ;get OAM data offset
00ED69  2  A9 5B               lda #$5b                    ;load tile number for small platforms
00ED6B  2  C8                  iny                         ;increment offset for tile numbers
00ED6C  2  20 B5 E5            jsr DumpSixSpr              ;dump tile number into all six sprites
00ED6F  2  C8                  iny                         ;increment offset for attributes
00ED70  2  A9 02               lda #$02                    ;load palette controls
00ED72  2  20 B5 E5            jsr DumpSixSpr              ;dump attributes into all six sprites
00ED75  2  88                  dey                         ;decrement for original offset
00ED76  2  88                  dey
00ED77  2  AD AE 03            lda Enemy_Rel_XPos          ;get relative horizontal coordinate
00ED7A  2  99 03 02            sta Sprite_X_Position,y
00ED7D  2  99 0F 02            sta Sprite_X_Position+12,y  ;dump as X coordinate into first and fourth sprites
00ED80  2  18                  clc
00ED81  2  69 08               adc #$08                    ;add eight pixels
00ED83  2  99 07 02            sta Sprite_X_Position+4,y   ;dump into second and fifth sprites
00ED86  2  99 13 02            sta Sprite_X_Position+16,y
00ED89  2  18                  clc
00ED8A  2  69 08               adc #$08                    ;add eight more pixels
00ED8C  2  99 0B 02            sta Sprite_X_Position+8,y   ;dump into third and sixth sprites
00ED8F  2  99 17 02            sta Sprite_X_Position+20,y
00ED92  2  B5 CF               lda Enemy_Y_Position,x      ;get vertical coordinate
00ED94  2  AA                  tax
00ED95  2  48                  pha                         ;save to stack
00ED96  2  E0 20               cpx #$20                    ;if vertical coordinate below status bar,
00ED98  2  B0 02               bcs TopSP                   ;do not mess with it
00ED9A  2  A9 F8               lda #$f8                    ;otherwise move first three sprites offscreen
00ED9C  2  20 BE E5     TopSP: jsr DumpThreeSpr            ;dump vertical coordinate into Y coordinates
00ED9F  2  68                  pla                         ;pull from stack
00EDA0  2  18                  clc
00EDA1  2  69 80               adc #$80                    ;add 128 pixels
00EDA3  2  AA                  tax
00EDA4  2  E0 20               cpx #$20                    ;if below status bar (taking wrap into account)
00EDA6  2  B0 02               bcs BotSP                   ;then do not change altered coordinate
00EDA8  2  A9 F8               lda #$f8                    ;otherwise move last three sprites offscreen
00EDAA  2  99 0C 02     BotSP: sta Sprite_Y_Position+12,y  ;dump vertical coordinate + 128 pixels
00EDAD  2  99 10 02            sta Sprite_Y_Position+16,y  ;into Y coordinates
00EDB0  2  99 14 02            sta Sprite_Y_Position+20,y
00EDB3  2  AD D1 03            lda Enemy_OffscreenBits     ;get offscreen bits
00EDB6  2  48                  pha                         ;save to stack
00EDB7  2  29 08               and #%00001000              ;check d3
00EDB9  2  F0 08               beq SOfs
00EDBB  2  A9 F8               lda #$f8                    ;if d3 was set, move first and
00EDBD  2  99 00 02            sta Sprite_Y_Position,y     ;fourth sprites offscreen
00EDC0  2  99 0C 02            sta Sprite_Y_Position+12,y
00EDC3  2  68           SOfs:  pla                         ;move out and back into stack
00EDC4  2  48                  pha
00EDC5  2  29 04               and #%00000100              ;check d2
00EDC7  2  F0 08               beq SOfs2
00EDC9  2  A9 F8               lda #$f8                    ;if d2 was set, move second and
00EDCB  2  99 04 02            sta Sprite_Y_Position+4,y   ;fifth sprites offscreen
00EDCE  2  99 10 02            sta Sprite_Y_Position+16,y
00EDD1  2  68           SOfs2: pla                         ;get from stack
00EDD2  2  29 02               and #%00000010              ;check d1
00EDD4  2  F0 08               beq ExSPl
00EDD6  2  A9 F8               lda #$f8                    ;if d1 was set, move third and
00EDD8  2  99 08 02            sta Sprite_Y_Position+8,y   ;sixth sprites offscreen
00EDDB  2  99 14 02            sta Sprite_Y_Position+20,y
00EDDE  2  A6 08        ExSPl: ldx ObjectOffset            ;get enemy object offset and leave
00EDE0  2  60                  rts
00EDE1  2               
00EDE1  2               ;-------------------------------------------------------------------------------------
00EDE1  2               
00EDE1  2               DrawBubble:
00EDE1  2  A4 B5                ldy Player_Y_HighPos        ;if player's vertical high position
00EDE3  2  88                   dey                         ;not within screen, skip all of this
00EDE4  2  D0 20                bne ExDBub
00EDE6  2  AD D3 03             lda Bubble_OffscreenBits    ;check air bubble's offscreen bits
00EDE9  2  29 08                and #%00001000
00EDEB  2  D0 19                bne ExDBub                  ;if bit set, branch to leave
00EDED  2  BC EE 06             ldy Bubble_SprDataOffset,x  ;get air bubble's OAM data offset
00EDF0  2  AD B0 03             lda Bubble_Rel_XPos         ;get relative horizontal coordinate
00EDF3  2  99 03 02             sta Sprite_X_Position,y     ;store as X coordinate here
00EDF6  2  AD BB 03             lda Bubble_Rel_YPos         ;get relative vertical coordinate
00EDF9  2  99 00 02             sta Sprite_Y_Position,y     ;store as Y coordinate here
00EDFC  2  A9 74                lda #$74
00EDFE  2  99 01 02             sta Sprite_Tilenumber,y     ;put air bubble tile into OAM data
00EE01  2  A9 02                lda #$02
00EE03  2  99 02 02             sta Sprite_Attributes,y     ;set attribute byte
00EE06  2  60           ExDBub: rts                         ;leave
00EE07  2               
00EE07  2               ;-------------------------------------------------------------------------------------
00EE07  2               ;$00 - used to store player's vertical offscreen bits
00EE07  2               
00EE07  2               PlayerGfxTblOffsets:
00EE07  2  20 28 C8 18        .byte $20, $28, $c8, $18, $00, $40, $50, $58
00EE0B  2  00 40 50 58  
00EE0F  2  80 88 B8 78        .byte $80, $88, $b8, $78, $60, $a0, $b0, $b8
00EE13  2  60 A0 B0 B8  
00EE17  2               
00EE17  2               ;tiles arranged in order, 2 tiles per row, top to bottom
00EE17  2               
00EE17  2               PlayerGraphicsTable:
00EE17  2               ;big player table
00EE17  2  00 01 02 03        .byte $00, $01, $02, $03, $04, $05, $06, $07 ;walking frame 1
00EE1B  2  04 05 06 07  
00EE1F  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $0e, $0f ;        frame 2
00EE23  2  0C 0D 0E 0F  
00EE27  2  10 11 12 13        .byte $10, $11, $12, $13, $14, $15, $16, $17 ;        frame 3
00EE2B  2  14 15 16 17  
00EE2F  2  18 19 1A 1B        .byte $18, $19, $1a, $1b, $1c, $1d, $1e, $1f ;skidding
00EE33  2  1C 1D 1E 1F  
00EE37  2  20 21 22 23        .byte $20, $21, $22, $23, $24, $25, $26, $27 ;jumping
00EE3B  2  24 25 26 27  
00EE3F  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $2c, $2d ;swimming frame 1
00EE43  2  2A 2B 2C 2D  
00EE47  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $30, $2c, $2d ;         frame 2
00EE4B  2  0C 30 2C 2D  
00EE4F  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $2e, $2f, $2c, $2d ;         frame 3
00EE53  2  2E 2F 2C 2D  
00EE57  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $5c, $5d ;climbing frame 1
00EE5B  2  2A 2B 5C 5D  
00EE5F  2  08 09 0A 0B        .byte $08, $09, $0a, $0b, $0c, $0d, $5e, $5f ;         frame 2
00EE63  2  0C 0D 5E 5F  
00EE67  2  FC FC 08 09        .byte $fc, $fc, $08, $09, $58, $59, $5a, $5a ;crouching
00EE6B  2  58 59 5A 5A  
00EE6F  2  08 09 28 29        .byte $08, $09, $28, $29, $2a, $2b, $0e, $0f ;fireball throwing
00EE73  2  2A 2B 0E 0F  
00EE77  2               
00EE77  2               ;small player table
00EE77  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $34, $35 ;walking frame 1
00EE7B  2  32 33 34 35  
00EE7F  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $36, $37, $38, $39 ;        frame 2
00EE83  2  36 37 38 39  
00EE87  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $3b, $3c ;        frame 3
00EE8B  2  3A 37 3B 3C  
00EE8F  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3d, $3e, $3f, $40 ;skidding
00EE93  2  3D 3E 3F 40  
00EE97  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $41, $42, $43 ;jumping
00EE9B  2  32 41 42 43  
00EE9F  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $45 ;swimming frame 1
00EEA3  2  32 33 44 45  
00EEA7  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $44, $47 ;         frame 2
00EEAB  2  32 33 44 47  
00EEAF  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $48, $49 ;         frame 3
00EEB3  2  32 33 48 49  
00EEB7  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $32, $33, $90, $91 ;climbing frame 1
00EEBB  2  32 33 90 91  
00EEBF  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $92, $93 ;         frame 2
00EEC3  2  3A 37 92 93  
00EEC7  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $9e, $9e, $9f, $9f ;killed
00EECB  2  9E 9E 9F 9F  
00EECF  2               
00EECF  2               ;used by both player sizes
00EECF  2  FC FC FC FC        .byte $fc, $fc, $fc, $fc, $3a, $37, $4f, $4f ;small player standing
00EED3  2  3A 37 4F 4F  
00EED7  2  FC FC 00 01        .byte $fc, $fc, $00, $01, $4c, $4d, $4e, $4e ;intermediate grow frame
00EEDB  2  4C 4D 4E 4E  
00EEDF  2  00 01 4C 4D        .byte $00, $01, $4c, $4d, $4a, $4a, $4b, $4b ;big player standing
00EEE3  2  4A 4A 4B 4B  
00EEE7  2               
00EEE7  2               SwimKickTileNum:
00EEE7  2  31 46              .byte $31, $46
00EEE9  2               
00EEE9  2               PlayerGfxHandler:
00EEE9  2  AD 9E 07             lda InjuryTimer             ;if player's injured invincibility timer
00EEEC  2  F0 05                beq CntPl                   ;not set, skip checkpoint and continue code
00EEEE  2  A5 09                lda FrameCounter
00EEF0  2  4A                   lsr                         ;otherwise check frame counter and branch
00EEF1  2  B0 40                bcs ExPGH                   ;to leave on every other frame (when d0 is set)
00EEF3  2  A5 0E        CntPl:  lda GameEngineSubroutine    ;if executing specific game engine routine,
00EEF5  2  C9 0B                cmp #$0b                    ;branch ahead to some other part
00EEF7  2  F0 47                beq PlayerKilled
00EEF9  2  AD 0B 07             lda PlayerChangeSizeFlag    ;if grow/shrink flag set
00EEFC  2  D0 3C                bne DoChangeSize            ;then branch to some other code
00EEFE  2  AC 04 07             ldy SwimmingFlag            ;if swimming flag set, branch to
00EF01  2  F0 31                beq FindPlayerAction        ;different part, do not return
00EF03  2  A5 1D                lda Player_State
00EF05  2  C9 00                cmp #$00                    ;if player status normal,
00EF07  2  F0 2B                beq FindPlayerAction        ;branch and do not return
00EF09  2  20 34 EF             jsr FindPlayerAction        ;otherwise jump and return
00EF0C  2  A5 09                lda FrameCounter
00EF0E  2  29 04                and #%00000100              ;check frame counter for d2 set (8 frames every
00EF10  2  D0 21                bne ExPGH                   ;eighth frame), and branch if set to leave
00EF12  2  AA                   tax                         ;initialize X to zero
00EF13  2  AC E4 06             ldy Player_SprDataOffset    ;get player sprite data offset
00EF16  2  A5 33                lda PlayerFacingDir         ;get player's facing direction
00EF18  2  4A                   lsr
00EF19  2  B0 04                bcs SwimKT                  ;if player facing to the right, use current offset
00EF1B  2  C8                   iny
00EF1C  2  C8                   iny                         ;otherwise move to next OAM data
00EF1D  2  C8                   iny
00EF1E  2  C8                   iny
00EF1F  2  AD 54 07     SwimKT: lda PlayerSize              ;check player's size
00EF22  2  F0 09                beq BigKTS                  ;if big, use first tile
00EF24  2  B9 19 02             lda Sprite_Tilenumber+24,y  ;check tile number of seventh/eighth sprite
00EF27  2  CD B5 EE             cmp SwimTileRepOffset       ;against tile number in player graphics table
00EF2A  2  F0 07                beq ExPGH                   ;if spr7/spr8 tile number = value, branch to leave
00EF2C  2  E8                   inx                         ;otherwise increment X for second tile
00EF2D  2  BD E7 EE     BigKTS: lda SwimKickTileNum,x       ;overwrite tile number in sprite 7/8
00EF30  2  99 19 02             sta Sprite_Tilenumber+24,y  ;to animate player's feet when swimming
00EF33  2  60           ExPGH:  rts                         ;then leave
00EF34  2               
00EF34  2               FindPlayerAction:
00EF34  2  20 EC EF           jsr ProcessPlayerAction       ;find proper offset to graphics table by player's actions
00EF37  2  4C 45 EF           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00EF3A  2               
00EF3A  2               DoChangeSize:
00EF3A  2  20 B0 F0           jsr HandleChangeSize          ;find proper offset to graphics table for grow/shrink
00EF3D  2  4C 45 EF           jmp PlayerGfxProcessing       ;draw player, then process for fireball throwing
00EF40  2               
00EF40  2               PlayerKilled:
00EF40  2  A0 0E              ldy #$0e                      ;load offset for player killed
00EF42  2  B9 07 EE           lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00EF45  2               
00EF45  2               PlayerGfxProcessing:
00EF45  2  8D D5 06            sta PlayerGfxOffset           ;store offset to graphics table here
00EF48  2  A9 04               lda #$04
00EF4A  2  20 BE EF            jsr RenderPlayerSub           ;draw player based on offset loaded
00EF4D  2  20 E9 F0            jsr ChkForPlayerAttrib        ;set horizontal flip bits as necessary
00EF50  2  AD 11 07            lda FireballThrowingTimer
00EF53  2  F0 25               beq PlayerOffscreenChk        ;if fireball throw timer not set, skip to the end
00EF55  2  A0 00               ldy #$00                      ;set value to initialize by default
00EF57  2  AD 81 07            lda PlayerAnimTimer           ;get animation frame timer
00EF5A  2  CD 11 07            cmp FireballThrowingTimer     ;compare to fireball throw timer
00EF5D  2  8C 11 07            sty FireballThrowingTimer     ;initialize fireball throw timer
00EF60  2  B0 18               bcs PlayerOffscreenChk        ;if animation frame timer => fireball throw timer skip to end
00EF62  2  8D 11 07            sta FireballThrowingTimer     ;otherwise store animation timer into fireball throw timer
00EF65  2  A0 07               ldy #$07                      ;load offset for throwing
00EF67  2  B9 07 EE            lda PlayerGfxTblOffsets,y     ;get offset to graphics table
00EF6A  2  8D D5 06            sta PlayerGfxOffset           ;store it for use later
00EF6D  2  A0 04               ldy #$04                      ;set to update four sprite rows by default
00EF6F  2  A5 57               lda Player_X_Speed
00EF71  2  05 0C               ora Left_Right_Buttons        ;check for horizontal speed or left/right button press
00EF73  2  F0 01               beq SUpdR                     ;if no speed or button press, branch using set value in Y
00EF75  2  88                  dey                           ;otherwise set to update only three sprite rows
00EF76  2  98           SUpdR: tya                           ;save in A for use
00EF77  2  20 BE EF            jsr RenderPlayerSub           ;in sub, draw player object again
00EF7A  2               
00EF7A  2               PlayerOffscreenChk:
00EF7A  2  AD D0 03                lda Player_OffscreenBits      ;get player's offscreen bits
00EF7D  2  4A                      lsr
00EF7E  2  4A                      lsr                           ;move vertical bits to low nybble
00EF7F  2  4A                      lsr
00EF80  2  4A                      lsr
00EF81  2  85 00                   sta $00                       ;store here
00EF83  2  A2 03                   ldx #$03                      ;check all four rows of player sprites
00EF85  2  AD E4 06                lda Player_SprDataOffset      ;get player's sprite data offset
00EF88  2  18                      clc
00EF89  2  69 18                   adc #$18                      ;add 24 bytes to start at bottom row
00EF8B  2  A8                      tay                           ;set as offset here
00EF8C  2  A9 F8        PROfsLoop: lda #$f8                      ;load offscreen Y coordinate just in case
00EF8E  2  46 00                   lsr $00                       ;shift bit into carry
00EF90  2  90 03                   bcc NPROffscr                 ;if bit not set, skip, do not move sprites
00EF92  2  20 C1 E5                jsr DumpTwoSpr                ;otherwise dump offscreen Y coordinate into sprite data
00EF95  2  98           NPROffscr: tya
00EF96  2  38                      sec                           ;subtract eight bytes to do
00EF97  2  E9 08                   sbc #$08                      ;next row up
00EF99  2  A8                      tay
00EF9A  2  CA                      dex                           ;decrement row counter
00EF9B  2  10 EF                   bpl PROfsLoop                 ;do this until all sprite rows are checked
00EF9D  2  60                      rts                           ;then we are done!
00EF9E  2               
00EF9E  2               ;-------------------------------------------------------------------------------------
00EF9E  2               
00EF9E  2               IntermediatePlayerData:
00EF9E  2  58 01 00 60          .byte $58, $01, $00, $60, $ff, $04
00EFA2  2  FF 04        
00EFA4  2               
00EFA4  2               DrawPlayer_Intermediate:
00EFA4  2  A2 05                  ldx #$05                       ;store data into zero page memory
00EFA6  2  BD 9E EF     PIntLoop: lda IntermediatePlayerData,x   ;load data to display player as he always
00EFA9  2  95 02                  sta $02,x                      ;appears on world/lives display
00EFAB  2  CA                     dex
00EFAC  2  10 F8                  bpl PIntLoop                   ;do this until all data is loaded
00EFAE  2  A2 B8                  ldx #$b8                       ;load offset for small standing
00EFB0  2  A0 04                  ldy #$04                       ;load sprite data offset
00EFB2  2  20 DC EF               jsr DrawPlayerLoop             ;draw player accordingly
00EFB5  2  AD 26 02               lda Sprite_Attributes+36       ;get empty sprite attributes
00EFB8  2  09 40                  ora #%01000000                 ;set horizontal flip bit for bottom-right sprite
00EFBA  2  8D 22 02               sta Sprite_Attributes+32       ;store and leave
00EFBD  2  60                     rts
00EFBE  2               
00EFBE  2               ;-------------------------------------------------------------------------------------
00EFBE  2               ;$00-$01 - used to hold tile numbers, $00 also used to hold upper extent of animation frames
00EFBE  2               ;$02 - vertical position
00EFBE  2               ;$03 - facing direction, used as horizontal flip control
00EFBE  2               ;$04 - attributes
00EFBE  2               ;$05 - horizontal position
00EFBE  2               ;$07 - number of rows to draw
00EFBE  2               ;these also used in IntermediatePlayerData
00EFBE  2               
00EFBE  2               RenderPlayerSub:
00EFBE  2  85 07                sta $07                      ;store number of rows of sprites to draw
00EFC0  2  AD AD 03             lda Player_Rel_XPos
00EFC3  2  8D 55 07             sta Player_Pos_ForScroll     ;store player's relative horizontal position
00EFC6  2  85 05                sta $05                      ;store it here also
00EFC8  2  AD B8 03             lda Player_Rel_YPos
00EFCB  2  85 02                sta $02                      ;store player's vertical position
00EFCD  2  A5 33                lda PlayerFacingDir
00EFCF  2  85 03                sta $03                      ;store player's facing direction
00EFD1  2  AD C4 03             lda Player_SprAttrib
00EFD4  2  85 04                sta $04                      ;store player's sprite attributes
00EFD6  2  AE D5 06             ldx PlayerGfxOffset          ;load graphics table offset
00EFD9  2  AC E4 06             ldy Player_SprDataOffset     ;get player's sprite data offset
00EFDC  2               
00EFDC  2               DrawPlayerLoop:
00EFDC  2  BD 17 EE             lda PlayerGraphicsTable,x    ;load player's left side
00EFDF  2  85 00                sta $00
00EFE1  2  BD 18 EE             lda PlayerGraphicsTable+1,x  ;now load right side
00EFE4  2  20 B2 EB             jsr DrawOneSpriteRow
00EFE7  2  C6 07                dec $07                      ;decrement rows of sprites to draw
00EFE9  2  D0 F1                bne DrawPlayerLoop           ;do this until all rows are drawn
00EFEB  2  60                   rts
00EFEC  2               
00EFEC  2               ProcessPlayerAction:
00EFEC  2  A5 1D                lda Player_State      ;get player's state
00EFEE  2  C9 03                cmp #$03
00EFF0  2  F0 52                beq ActionClimbing    ;if climbing, branch here
00EFF2  2  C9 02                cmp #$02
00EFF4  2  F0 3E                beq ActionFalling     ;if falling, branch here
00EFF6  2  C9 01                cmp #$01
00EFF8  2  D0 11                bne ProcOnGroundActs  ;if not jumping, branch here
00EFFA  2  AD 04 07             lda SwimmingFlag
00EFFD  2  D0 51                bne ActionSwimming    ;if swimming flag set, branch elsewhere
00EFFF  2  A0 06                ldy #$06              ;load offset for crouching
00F001  2  AD 14 07             lda CrouchingFlag     ;get crouching flag
00F004  2  D0 22                bne NonAnimatedActs   ;if set, branch to get offset for graphics table
00F006  2  A0 00                ldy #$00              ;otherwise load offset for jumping
00F008  2  4C 28 F0             jmp NonAnimatedActs   ;go to get offset to graphics table
00F00B  2               
00F00B  2               ProcOnGroundActs:
00F00B  2  A0 06                ldy #$06                   ;load offset for crouching
00F00D  2  AD 14 07             lda CrouchingFlag          ;get crouching flag
00F010  2  D0 16                bne NonAnimatedActs        ;if set, branch to get offset for graphics table
00F012  2  A0 02                ldy #$02                   ;load offset for standing
00F014  2  A5 57                lda Player_X_Speed         ;check player's horizontal speed
00F016  2  05 0C                ora Left_Right_Buttons     ;and left/right controller bits
00F018  2  F0 0E                beq NonAnimatedActs        ;if no speed or buttons pressed, use standing offset
00F01A  2  AD 00 07             lda Player_XSpeedAbsolute  ;load walking/running speed
00F01D  2  C9 09                cmp #$09
00F01F  2  90 1B                bcc ActionWalkRun          ;if less than a certain amount, branch, too slow to skid
00F021  2  A5 45                lda Player_MovingDir       ;otherwise check to see if moving direction
00F023  2  25 33                and PlayerFacingDir        ;and facing direction are the same
00F025  2  D0 15                bne ActionWalkRun          ;if moving direction = facing direction, branch, don't skid
00F027  2  C8                   iny                        ;otherwise increment to skid offset ($03)
00F028  2               
00F028  2               NonAnimatedActs:
00F028  2  20 91 F0             jsr GetGfxOffsetAdder      ;do a sub here to get offset adder for graphics table
00F02B  2  A9 00                lda #$00
00F02D  2  8D 0D 07             sta PlayerAnimCtrl         ;initialize animation frame control
00F030  2  B9 07 EE             lda PlayerGfxTblOffsets,y  ;load offset to graphics table using size as offset
00F033  2  60                   rts
00F034  2               
00F034  2               ActionFalling:
00F034  2  A0 04                ldy #$04                  ;load offset for walking/running
00F036  2  20 91 F0             jsr GetGfxOffsetAdder     ;get offset to graphics table
00F039  2  4C 62 F0             jmp GetCurrentAnimOffset  ;execute instructions for falling state
00F03C  2               
00F03C  2               ActionWalkRun:
00F03C  2  A0 04                ldy #$04               ;load offset for walking/running
00F03E  2  20 91 F0             jsr GetGfxOffsetAdder  ;get offset to graphics table
00F041  2  4C 68 F0             jmp FourFrameExtent    ;execute instructions for normal state
00F044  2               
00F044  2               ActionClimbing:
00F044  2  A0 05                ldy #$05               ;load offset for climbing
00F046  2  A5 9F                lda Player_Y_Speed     ;check player's vertical speed
00F048  2  F0 DE                beq NonAnimatedActs    ;if no speed, branch, use offset as-is
00F04A  2  20 91 F0             jsr GetGfxOffsetAdder  ;otherwise get offset for graphics table
00F04D  2  4C 6D F0             jmp ThreeFrameExtent   ;then skip ahead to more code
00F050  2               
00F050  2               ActionSwimming:
00F050  2  A0 01                ldy #$01               ;load offset for swimming
00F052  2  20 91 F0             jsr GetGfxOffsetAdder
00F055  2  AD 82 07             lda JumpSwimTimer      ;check jump/swim timer
00F058  2  0D 0D 07             ora PlayerAnimCtrl     ;and animation frame control
00F05B  2  D0 0B                bne FourFrameExtent    ;if any one of these set, branch ahead
00F05D  2  A5 0A                lda A_B_Buttons
00F05F  2  0A                   asl                    ;check for A button pressed
00F060  2  B0 06                bcs FourFrameExtent    ;branch to same place if A button pressed
00F062  2               
00F062  2               GetCurrentAnimOffset:
00F062  2  AD 0D 07             lda PlayerAnimCtrl         ;get animation frame control
00F065  2  4C D0 F0             jmp GetOffsetFromAnimCtrl  ;jump to get proper offset to graphics table
00F068  2               
00F068  2               FourFrameExtent:
00F068  2  A9 03                lda #$03              ;load upper extent for frame control
00F06A  2  4C 6F F0             jmp AnimationControl  ;jump to get offset and animate player object
00F06D  2               
00F06D  2               ThreeFrameExtent:
00F06D  2  A9 02                lda #$02              ;load upper extent for frame control for climbing
00F06F  2               
00F06F  2               AnimationControl:
00F06F  2  85 00                  sta $00                   ;store upper extent here
00F071  2  20 62 F0               jsr GetCurrentAnimOffset  ;get proper offset to graphics table
00F074  2  48                     pha                       ;save offset to stack
00F075  2  AD 81 07               lda PlayerAnimTimer       ;load animation frame timer
00F078  2  D0 15                  bne ExAnimC               ;branch if not expired
00F07A  2  AD 0C 07               lda PlayerAnimTimerSet    ;get animation frame timer amount
00F07D  2  8D 81 07               sta PlayerAnimTimer       ;and set timer accordingly
00F080  2  AD 0D 07               lda PlayerAnimCtrl
00F083  2  18                     clc                       ;add one to animation frame control
00F084  2  69 01                  adc #$01
00F086  2  C5 00                  cmp $00                   ;compare to upper extent
00F088  2  90 02                  bcc SetAnimC              ;if frame control + 1 < upper extent, use as next
00F08A  2  A9 00                  lda #$00                  ;otherwise initialize frame control
00F08C  2  8D 0D 07     SetAnimC: sta PlayerAnimCtrl        ;store as new animation frame control
00F08F  2  68           ExAnimC:  pla                       ;get offset to graphics table from stack and leave
00F090  2  60                     rts
00F091  2               
00F091  2               GetGfxOffsetAdder:
00F091  2  AD 54 07             lda PlayerSize  ;get player's size
00F094  2  F0 05                beq SzOfs       ;if player big, use current offset as-is
00F096  2  98                   tya             ;for big player
00F097  2  18                   clc             ;otherwise add eight bytes to offset
00F098  2  69 08                adc #$08        ;for small player
00F09A  2  A8                   tay
00F09B  2  60           SzOfs:  rts             ;go back
00F09C  2               
00F09C  2               ChangeSizeOffsetAdder:
00F09C  2  00 01 00 01          .byte $00, $01, $00, $01, $00, $01, $02, $00, $01, $02
00F0A0  2  00 01 02 00  
00F0A4  2  01 02        
00F0A6  2  02 00 02 00          .byte $02, $00, $02, $00, $02, $00, $02, $00, $02, $00
00F0AA  2  02 00 02 00  
00F0AE  2  02 00        
00F0B0  2               
00F0B0  2               HandleChangeSize:
00F0B0  2  AC 0D 07              ldy PlayerAnimCtrl           ;get animation frame control
00F0B3  2  A5 09                 lda FrameCounter
00F0B5  2  29 03                 and #%00000011               ;get frame counter and execute this code every
00F0B7  2  D0 0D                 bne GorSLog                  ;fourth frame, otherwise branch ahead
00F0B9  2  C8                    iny                          ;increment frame control
00F0BA  2  C0 0A                 cpy #$0a                     ;check for preset upper extent
00F0BC  2  90 05                 bcc CSzNext                  ;if not there yet, skip ahead to use
00F0BE  2  A0 00                 ldy #$00                     ;otherwise initialize both grow/shrink flag
00F0C0  2  8C 0B 07              sty PlayerChangeSizeFlag     ;and animation frame control
00F0C3  2  8C 0D 07     CSzNext: sty PlayerAnimCtrl           ;store proper frame control
00F0C6  2  AD 54 07     GorSLog: lda PlayerSize               ;get player's size
00F0C9  2  D0 0C                 bne ShrinkPlayer             ;if player small, skip ahead to next part
00F0CB  2  B9 9C F0              lda ChangeSizeOffsetAdder,y  ;get offset adder based on frame control as offset
00F0CE  2  A0 0F                 ldy #$0f                     ;load offset for player growing
00F0D0  2               
00F0D0  2               GetOffsetFromAnimCtrl:
00F0D0  2  0A                   asl                        ;multiply animation frame control
00F0D1  2  0A                   asl                        ;by eight to get proper amount
00F0D2  2  0A                   asl                        ;to add to our offset
00F0D3  2  79 07 EE             adc PlayerGfxTblOffsets,y  ;add to offset to graphics table
00F0D6  2  60                   rts                        ;and return with result in A
00F0D7  2               
00F0D7  2               ShrinkPlayer:
00F0D7  2  98                   tya                          ;add ten bytes to frame control as offset
00F0D8  2  18                   clc
00F0D9  2  69 0A                adc #$0a                     ;this thing apparently uses two of the swimming frames
00F0DB  2  AA                   tax                          ;to draw the player shrinking
00F0DC  2  A0 09                ldy #$09                     ;load offset for small player swimming
00F0DE  2  BD 9C F0             lda ChangeSizeOffsetAdder,x  ;get what would normally be offset adder
00F0E1  2  D0 02                bne ShrPlF                   ;and branch to use offset if nonzero
00F0E3  2  A0 01                ldy #$01                     ;otherwise load offset for big player swimming
00F0E5  2  B9 07 EE     ShrPlF: lda PlayerGfxTblOffsets,y    ;get offset to graphics table based on offset loaded
00F0E8  2  60                   rts                          ;and leave
00F0E9  2               
00F0E9  2               ChkForPlayerAttrib:
00F0E9  2  AC E4 06                ldy Player_SprDataOffset    ;get sprite data offset
00F0EC  2  A5 0E                   lda GameEngineSubroutine
00F0EE  2  C9 0B                   cmp #$0b                    ;if executing specific game engine routine,
00F0F0  2  F0 13                   beq KilledAtt               ;branch to change third and fourth row OAM attributes
00F0F2  2  AD D5 06                lda PlayerGfxOffset         ;get graphics table offset
00F0F5  2  C9 50                   cmp #$50
00F0F7  2  F0 1E                   beq C_S_IGAtt               ;if crouch offset, either standing offset,
00F0F9  2  C9 B8                   cmp #$b8                    ;or intermediate growing offset,
00F0FB  2  F0 1A                   beq C_S_IGAtt               ;go ahead and execute code to change
00F0FD  2  C9 C0                   cmp #$c0                    ;fourth row OAM attributes only
00F0FF  2  F0 16                   beq C_S_IGAtt
00F101  2  C9 C8                   cmp #$c8
00F103  2  D0 24                   bne ExPlyrAt                ;if none of these, branch to leave
00F105  2  B9 12 02     KilledAtt: lda Sprite_Attributes+16,y
00F108  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00F10A  2  99 12 02                sta Sprite_Attributes+16,y  ;for third row sprites and save
00F10D  2  B9 16 02                lda Sprite_Attributes+20,y
00F110  2  29 3F                   and #%00111111
00F112  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00F114  2  99 16 02                sta Sprite_Attributes+20,y  ;sprite in the third row
00F117  2  B9 1A 02     C_S_IGAtt: lda Sprite_Attributes+24,y
00F11A  2  29 3F                   and #%00111111              ;mask out horizontal and vertical flip bits
00F11C  2  99 1A 02                sta Sprite_Attributes+24,y  ;for fourth row sprites and save
00F11F  2  B9 1E 02                lda Sprite_Attributes+28,y
00F122  2  29 3F                   and #%00111111
00F124  2  09 40                   ora #%01000000              ;set horizontal flip bit for second
00F126  2  99 1E 02                sta Sprite_Attributes+28,y  ;sprite in the fourth row
00F129  2  60           ExPlyrAt:  rts                         ;leave
00F12A  2               
00F12A  2               ;-------------------------------------------------------------------------------------
00F12A  2               ;$00 - used in adding to get proper offset
00F12A  2               
00F12A  2               RelativePlayerPosition:
00F12A  2  A2 00                ldx #$00      ;set offsets for relative cooordinates
00F12C  2  A0 00                ldy #$00      ;routine to correspond to player object
00F12E  2  4C 42 F1             jmp RelWOfs   ;get the coordinates
00F131  2               
00F131  2               RelativeBubblePosition:
00F131  2  A0 01                ldy #$01                ;set for air bubble offsets
00F133  2  20 A8 F1             jsr GetProperObjOffset  ;modify X to get proper air bubble offset
00F136  2  A0 03                ldy #$03
00F138  2  4C 42 F1             jmp RelWOfs             ;get the coordinates
00F13B  2               
00F13B  2               RelativeFireballPosition:
00F13B  2  A0 00                 ldy #$00                    ;set for fireball offsets
00F13D  2  20 A8 F1              jsr GetProperObjOffset      ;modify X to get proper fireball offset
00F140  2  A0 02                 ldy #$02
00F142  2  20 71 F1     RelWOfs: jsr GetObjRelativePosition  ;get the coordinates
00F145  2  A6 08                 ldx ObjectOffset            ;return original offset
00F147  2  60                    rts                         ;leave
00F148  2               
00F148  2               RelativeMiscPosition:
00F148  2  A0 02                ldy #$02                ;set for misc object offsets
00F14A  2  20 A8 F1             jsr GetProperObjOffset  ;modify X to get proper misc object offset
00F14D  2  A0 06                ldy #$06
00F14F  2  4C 42 F1             jmp RelWOfs             ;get the coordinates
00F152  2               
00F152  2               RelativeEnemyPosition:
00F152  2  A9 01                lda #$01                     ;get coordinates of enemy object
00F154  2  A0 01                ldy #$01                     ;relative to the screen
00F156  2  4C 65 F1             jmp VariableObjOfsRelPos
00F159  2               
00F159  2               RelativeBlockPosition:
00F159  2  A9 09                lda #$09                     ;get coordinates of one block object
00F15B  2  A0 04                ldy #$04                     ;relative to the screen
00F15D  2  20 65 F1             jsr VariableObjOfsRelPos
00F160  2  E8                   inx                          ;adjust offset for other block object if any
00F161  2  E8                   inx
00F162  2  A9 09                lda #$09
00F164  2  C8                   iny                          ;adjust other and get coordinates for other one
00F165  2               
00F165  2               VariableObjOfsRelPos:
00F165  2  86 00                stx $00                     ;store value to add to A here
00F167  2  18                   clc
00F168  2  65 00                adc $00                     ;add A to value stored
00F16A  2  AA                   tax                         ;use as enemy offset
00F16B  2  20 71 F1             jsr GetObjRelativePosition
00F16E  2  A6 08                ldx ObjectOffset            ;reload old object offset and leave
00F170  2  60                   rts
00F171  2               
00F171  2               GetObjRelativePosition:
00F171  2  B5 CE                lda SprObject_Y_Position,x  ;load vertical coordinate low
00F173  2  99 B8 03             sta SprObject_Rel_YPos,y    ;store here
00F176  2  B5 86                lda SprObject_X_Position,x  ;load horizontal coordinate
00F178  2  38                   sec                         ;subtract left edge coordinate
00F179  2  ED 1C 07             sbc ScreenLeft_X_Pos
00F17C  2  99 AD 03             sta SprObject_Rel_XPos,y    ;store result here
00F17F  2  60                   rts
00F180  2               
00F180  2               ;-------------------------------------------------------------------------------------
00F180  2               ;$00 - used as temp variable to hold offscreen bits
00F180  2               
00F180  2               GetPlayerOffscreenBits:
00F180  2  A2 00                ldx #$00                 ;set offsets for player-specific variables
00F182  2  A0 00                ldy #$00                 ;and get offscreen information about player
00F184  2  4C C0 F1             jmp GetOffScreenBitsSet
00F187  2               
00F187  2               GetFireballOffscreenBits:
00F187  2  A0 00                ldy #$00                 ;set for fireball offsets
00F189  2  20 A8 F1             jsr GetProperObjOffset   ;modify X to get proper fireball offset
00F18C  2  A0 02                ldy #$02                 ;set other offset for fireball's offscreen bits
00F18E  2  4C C0 F1             jmp GetOffScreenBitsSet  ;and get offscreen information about fireball
00F191  2               
00F191  2               GetBubbleOffscreenBits:
00F191  2  A0 01                ldy #$01                 ;set for air bubble offsets
00F193  2  20 A8 F1             jsr GetProperObjOffset   ;modify X to get proper air bubble offset
00F196  2  A0 03                ldy #$03                 ;set other offset for airbubble's offscreen bits
00F198  2  4C C0 F1             jmp GetOffScreenBitsSet  ;and get offscreen information about air bubble
00F19B  2               
00F19B  2               GetMiscOffscreenBits:
00F19B  2  A0 02                ldy #$02                 ;set for misc object offsets
00F19D  2  20 A8 F1             jsr GetProperObjOffset   ;modify X to get proper misc object offset
00F1A0  2  A0 06                ldy #$06                 ;set other offset for misc object's offscreen bits
00F1A2  2  4C C0 F1             jmp GetOffScreenBitsSet  ;and get offscreen information about misc object
00F1A5  2               
00F1A5  2               ObjOffsetData:
00F1A5  2  07 16 0D             .byte $07, $16, $0d
00F1A8  2               
00F1A8  2               GetProperObjOffset:
00F1A8  2  8A                   txa                  ;move offset to A
00F1A9  2  18                   clc
00F1AA  2  79 A5 F1             adc ObjOffsetData,y  ;add amount of bytes to offset depending on setting in Y
00F1AD  2  AA                   tax                  ;put back in X and leave
00F1AE  2  60                   rts
00F1AF  2               
00F1AF  2               GetEnemyOffscreenBits:
00F1AF  2  A9 01                lda #$01                 ;set A to add 1 byte in order to get enemy offset
00F1B1  2  A0 01                ldy #$01                 ;set Y to put offscreen bits in Enemy_OffscreenBits
00F1B3  2  4C BA F1             jmp SetOffscrBitsOffset
00F1B6  2               
00F1B6  2               GetBlockOffscreenBits:
00F1B6  2  A9 09                lda #$09       ;set A to add 9 bytes in order to get block obj offset
00F1B8  2  A0 04                ldy #$04       ;set Y to put offscreen bits in Block_OffscreenBits
00F1BA  2               
00F1BA  2               SetOffscrBitsOffset:
00F1BA  2  86 00                stx $00
00F1BC  2  18                   clc           ;add contents of X to A to get
00F1BD  2  65 00                adc $00       ;appropriate offset, then give back to X
00F1BF  2  AA                   tax
00F1C0  2               
00F1C0  2               GetOffScreenBitsSet:
00F1C0  2  98                   tya                         ;save offscreen bits offset to stack for now
00F1C1  2  48                   pha
00F1C2  2  20 D7 F1             jsr RunOffscrBitsSubs
00F1C5  2  0A                   asl                         ;move low nybble to high nybble
00F1C6  2  0A                   asl
00F1C7  2  0A                   asl
00F1C8  2  0A                   asl
00F1C9  2  05 00                ora $00                     ;mask together with previously saved low nybble
00F1CB  2  85 00                sta $00                     ;store both here
00F1CD  2  68                   pla                         ;get offscreen bits offset from stack
00F1CE  2  A8                   tay
00F1CF  2  A5 00                lda $00                     ;get value here and store elsewhere
00F1D1  2  99 D0 03             sta SprObject_OffscrBits,y
00F1D4  2  A6 08                ldx ObjectOffset
00F1D6  2  60                   rts
00F1D7  2               
00F1D7  2               RunOffscrBitsSubs:
00F1D7  2  20 F6 F1             jsr GetXOffscreenBits  ;do subroutine here
00F1DA  2  4A                   lsr                    ;move high nybble to low
00F1DB  2  4A                   lsr
00F1DC  2  4A                   lsr
00F1DD  2  4A                   lsr
00F1DE  2  85 00                sta $00                ;store here
00F1E0  2  4C 39 F2             jmp GetYOffscreenBits
00F1E3  2               
00F1E3  2               ;--------------------------------
00F1E3  2               ;(these apply to these three subsections)
00F1E3  2               ;$04 - used to store proper offset
00F1E3  2               ;$05 - used as adder in DividePDiff
00F1E3  2               ;$06 - used to store preset value used to compare to pixel difference in $07
00F1E3  2               ;$07 - used to store difference between coordinates of object and screen edges
00F1E3  2               
00F1E3  2               XOffscreenBitsData:
00F1E3  2  7F 3F 1F 0F          .byte $7f, $3f, $1f, $0f, $07, $03, $01, $00
00F1E7  2  07 03 01 00  
00F1EB  2  80 C0 E0 F0          .byte $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
00F1EF  2  F8 FC FE FF  
00F1F3  2               
00F1F3  2               DefaultXOnscreenOfs:
00F1F3  2  07 0F 07             .byte $07, $0f, $07
00F1F6  2               
00F1F6  2               GetXOffscreenBits:
00F1F6  2  86 04                  stx $04                     ;save position in buffer to here
00F1F8  2  A0 01                  ldy #$01                    ;start with right side of screen
00F1FA  2  B9 1C 07     XOfsLoop: lda ScreenEdge_X_Pos,y      ;get pixel coordinate of edge
00F1FD  2  38                     sec                         ;get difference between pixel coordinate of edge
00F1FE  2  F5 86                  sbc SprObject_X_Position,x  ;and pixel coordinate of object position
00F200  2  85 07                  sta $07                     ;store here
00F202  2  B9 1A 07               lda ScreenEdge_PageLoc,y    ;get page location of edge
00F205  2  F5 6D                  sbc SprObject_PageLoc,x     ;subtract from page location of object position
00F207  2  BE F3 F1               ldx DefaultXOnscreenOfs,y   ;load offset value here
00F20A  2  C9 00                  cmp #$00
00F20C  2  30 10                  bmi XLdBData                ;if beyond right edge or in front of left edge, branch
00F20E  2  BE F4 F1               ldx DefaultXOnscreenOfs+1,y ;if not, load alternate offset value here
00F211  2  C9 01                  cmp #$01
00F213  2  10 09                  bpl XLdBData                ;if one page or more to the left of either edge, branch
00F215  2  A9 38                  lda #$38                    ;if no branching, load value here and store
00F217  2  85 06                  sta $06
00F219  2  A9 08                  lda #$08                    ;load some other value and execute subroutine
00F21B  2  20 6D F2               jsr DividePDiff
00F21E  2  BD E3 F1     XLdBData: lda XOffscreenBitsData,x    ;get bits here
00F221  2  A6 04                  ldx $04                     ;reobtain position in buffer
00F223  2  C9 00                  cmp #$00                    ;if bits not zero, branch to leave
00F225  2  D0 03                  bne ExXOfsBS
00F227  2  88                     dey                         ;otherwise, do left side of screen now
00F228  2  10 D0                  bpl XOfsLoop                ;branch if not already done with left side
00F22A  2  60           ExXOfsBS: rts
00F22B  2               
00F22B  2               ;--------------------------------
00F22B  2               
00F22B  2               YOffscreenBitsData:
00F22B  2  00 08 0C 0E          .byte $00, $08, $0c, $0e
00F22F  2  0F 07 03 01          .byte $0f, $07, $03, $01
00F233  2  00                   .byte $00
00F234  2               
00F234  2               DefaultYOnscreenOfs:
00F234  2  04 00 04             .byte $04, $00, $04
00F237  2               
00F237  2               HighPosUnitData:
00F237  2  FF 00                .byte $ff, $00
00F239  2               
00F239  2               GetYOffscreenBits:
00F239  2  86 04                  stx $04                      ;save position in buffer to here
00F23B  2  A0 01                  ldy #$01                     ;start with top of screen
00F23D  2  B9 37 F2     YOfsLoop: lda HighPosUnitData,y        ;load coordinate for edge of vertical unit
00F240  2  38                     sec
00F241  2  F5 CE                  sbc SprObject_Y_Position,x   ;subtract from vertical coordinate of object
00F243  2  85 07                  sta $07                      ;store here
00F245  2  A9 01                  lda #$01                     ;subtract one from vertical high byte of object
00F247  2  F5 B5                  sbc SprObject_Y_HighPos,x
00F249  2  BE 34 F2               ldx DefaultYOnscreenOfs,y    ;load offset value here
00F24C  2  C9 00                  cmp #$00
00F24E  2  30 10                  bmi YLdBData                 ;if under top of the screen or beyond bottom, branch
00F250  2  BE 35 F2               ldx DefaultYOnscreenOfs+1,y  ;if not, load alternate offset value here
00F253  2  C9 01                  cmp #$01
00F255  2  10 09                  bpl YLdBData                 ;if one vertical unit or more above the screen, branch
00F257  2  A9 20                  lda #$20                     ;if no branching, load value here and store
00F259  2  85 06                  sta $06
00F25B  2  A9 04                  lda #$04                     ;load some other value and execute subroutine
00F25D  2  20 6D F2               jsr DividePDiff
00F260  2  BD 2B F2     YLdBData: lda YOffscreenBitsData,x     ;get offscreen data bits using offset
00F263  2  A6 04                  ldx $04                      ;reobtain position in buffer
00F265  2  C9 00                  cmp #$00
00F267  2  D0 03                  bne ExYOfsBS                 ;if bits not zero, branch to leave
00F269  2  88                     dey                          ;otherwise, do bottom of the screen now
00F26A  2  10 D1                  bpl YOfsLoop
00F26C  2  60           ExYOfsBS: rts
00F26D  2               
00F26D  2               ;--------------------------------
00F26D  2               
00F26D  2               DividePDiff:
00F26D  2  85 05                  sta $05       ;store current value in A here
00F26F  2  A5 07                  lda $07       ;get pixel difference
00F271  2  C5 06                  cmp $06       ;compare to preset value
00F273  2  B0 0C                  bcs ExDivPD   ;if pixel difference >= preset value, branch
00F275  2  4A                     lsr           ;divide by eight
00F276  2  4A                     lsr
00F277  2  4A                     lsr
00F278  2  29 07                  and #$07      ;mask out all but 3 LSB
00F27A  2  C0 01                  cpy #$01      ;right side of the screen or top?
00F27C  2  B0 02                  bcs SetOscrO  ;if so, branch, use difference / 8 as offset
00F27E  2  65 05                  adc $05       ;if not, add value to difference / 8
00F280  2  AA           SetOscrO: tax           ;use as offset
00F281  2  60           ExDivPD:  rts           ;leave
00F282  2               
00F282  2               ;-------------------------------------------------------------------------------------
00F282  2               ;$00-$01 - tile numbers
00F282  2               ;$02 - Y coordinate
00F282  2               ;$03 - flip control
00F282  2               ;$04 - sprite attributes
00F282  2               ;$05 - X coordinate
00F282  2               
00F282  2               DrawSpriteObject:
00F282  2  A5 03                 lda $03                    ;get saved flip control bits
00F284  2  4A                    lsr
00F285  2  4A                    lsr                        ;move d1 into carry
00F286  2  A5 00                 lda $00
00F288  2  90 0C                 bcc NoHFlip                ;if d1 not set, branch
00F28A  2  99 05 02              sta Sprite_Tilenumber+4,y  ;store first tile into second sprite
00F28D  2  A5 01                 lda $01                    ;and second into first sprite
00F28F  2  99 01 02              sta Sprite_Tilenumber,y
00F292  2  A9 40                 lda #$40                   ;activate horizontal flip OAM attribute
00F294  2  D0 0A                 bne SetHFAt                ;and unconditionally branch
00F296  2  99 01 02     NoHFlip: sta Sprite_Tilenumber,y    ;store first tile into first sprite
00F299  2  A5 01                 lda $01                    ;and second into second sprite
00F29B  2  99 05 02              sta Sprite_Tilenumber+4,y
00F29E  2  A9 00                 lda #$00                   ;clear bit for horizontal flip
00F2A0  2  05 04        SetHFAt: ora $04                    ;add other OAM attributes if necessary
00F2A2  2  99 02 02              sta Sprite_Attributes,y    ;store sprite attributes
00F2A5  2  99 06 02              sta Sprite_Attributes+4,y
00F2A8  2  A5 02                 lda $02                    ;now the y coordinates
00F2AA  2  99 00 02              sta Sprite_Y_Position,y    ;note because they are
00F2AD  2  99 04 02              sta Sprite_Y_Position+4,y  ;side by side, they are the same
00F2B0  2  A5 05                 lda $05
00F2B2  2  99 03 02              sta Sprite_X_Position,y    ;store x coordinate, then
00F2B5  2  18                    clc                        ;add 8 pixels and store another to
00F2B6  2  69 08                 adc #$08                   ;put them side by side
00F2B8  2  99 07 02              sta Sprite_X_Position+4,y
00F2BB  2  A5 02                 lda $02                    ;add eight pixels to the next y
00F2BD  2  18                    clc                        ;coordinate
00F2BE  2  69 08                 adc #$08
00F2C0  2  85 02                 sta $02
00F2C2  2  98                    tya                        ;add eight to the offset in Y to
00F2C3  2  18                    clc                        ;move to the next two sprites
00F2C4  2  69 08                 adc #$08
00F2C6  2  A8                    tay
00F2C7  2  E8                    inx                        ;increment offset to return it to the
00F2C8  2  E8                    inx                        ;routine that called this subroutine
00F2C9  2  60                    rts
00F2CA  2               
00F2CA  2               ;-------------------------------------------------------------------------------------
00F2CA  2               
00F2CA  2               ;unused space
00F2CA  2  FF FF FF FF          .byte $ff, $ff, $ff, $ff, $ff, $ff
00F2CE  2  FF FF        
00F2D0  2               
00F2D0  2               ;-------------------------------------------------------------------------------------
00F2D0  2               
00F2D0  2               SoundEngine:
00F2D0  2  AD 70 07              lda OperMode              ;are we in title screen mode?
00F2D3  2  D0 04                 bne SndOn
00F2D5  2  8D 15 40              sta SND_MASTERCTRL_REG    ;if so, disable sound and leave
00F2D8  2  60                    rts
00F2D9  2  A9 FF        SndOn:   lda #$ff
00F2DB  2  8D 17 40              sta JOYPAD_PORT2          ;disable irqs and set frame counter mode???
00F2DE  2  A9 0F                 lda #$0f
00F2E0  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable first four channels
00F2E3  2  AD C6 07              lda PauseModeFlag         ;is sound already in pause mode?
00F2E6  2  D0 06                 bne InPause
00F2E8  2  A5 FA                 lda PauseSoundQueue       ;if not, check pause sfx queue
00F2EA  2  C9 01                 cmp #$01
00F2EC  2  D0 5D                 bne RunSoundSubroutines   ;if queue is empty, skip pause mode routine
00F2EE  2  AD B2 07     InPause: lda PauseSoundBuffer      ;check pause sfx buffer
00F2F1  2  D0 23                 bne ContPau
00F2F3  2  A5 FA                 lda PauseSoundQueue       ;check pause queue
00F2F5  2  F0 66                 beq SkipSoundSubroutines
00F2F7  2  8D B2 07              sta PauseSoundBuffer      ;if queue full, store in buffer and activate
00F2FA  2  8D C6 07              sta PauseModeFlag         ;pause mode to interrupt game sounds
00F2FD  2  A9 00                 lda #$00                  ;disable sound and clear sfx buffers
00F2FF  2  8D 15 40              sta SND_MASTERCTRL_REG
00F302  2  85 F1                 sta Square1SoundBuffer
00F304  2  85 F2                 sta Square2SoundBuffer
00F306  2  85 F3                 sta NoiseSoundBuffer
00F308  2  A9 0F                 lda #$0f
00F30A  2  8D 15 40              sta SND_MASTERCTRL_REG    ;enable sound again
00F30D  2  A9 2A                 lda #$2a                  ;store length of sound in pause counter
00F30F  2  8D BB 07              sta Squ1_SfxLenCounter
00F312  2  A9 44        PTone1F: lda #$44                  ;play first tone
00F314  2  D0 11                 bne PTRegC                ;unconditional branch
00F316  2  AD BB 07     ContPau: lda Squ1_SfxLenCounter    ;check pause length left
00F319  2  C9 24                 cmp #$24                  ;time to play second?
00F31B  2  F0 08                 beq PTone2F
00F31D  2  C9 1E                 cmp #$1e                  ;time to play first again?
00F31F  2  F0 F1                 beq PTone1F
00F321  2  C9 18                 cmp #$18                  ;time to play second again?
00F323  2  D0 09                 bne DecPauC               ;only load regs during times, otherwise skip
00F325  2  A9 64        PTone2F: lda #$64                  ;store reg contents and play the pause sfx
00F327  2  A2 84        PTRegC:  ldx #$84
00F329  2  A0 7F                 ldy #$7f
00F32B  2  20 88 F3              jsr PlaySqu1Sfx
00F32E  2  CE BB 07     DecPauC: dec Squ1_SfxLenCounter    ;decrement pause sfx counter
00F331  2  D0 2A                 bne SkipSoundSubroutines
00F333  2  A9 00                 lda #$00                  ;disable sound if in pause mode and
00F335  2  8D 15 40              sta SND_MASTERCTRL_REG    ;not currently playing the pause sfx
00F338  2  AD B2 07              lda PauseSoundBuffer      ;if no longer playing pause sfx, check to see
00F33B  2  C9 02                 cmp #$02                  ;if we need to be playing sound again
00F33D  2  D0 05                 bne SkipPIn
00F33F  2  A9 00                 lda #$00                  ;clear pause mode to allow game sounds again
00F341  2  8D C6 07              sta PauseModeFlag
00F344  2  A9 00        SkipPIn: lda #$00                  ;clear pause sfx buffer
00F346  2  8D B2 07              sta PauseSoundBuffer
00F349  2  F0 12                 beq SkipSoundSubroutines
00F34B  2               
00F34B  2               RunSoundSubroutines:
00F34B  2  20 1B F4              jsr Square1SfxHandler  ;play sfx on square channel 1
00F34E  2  20 7C F5              jsr Square2SfxHandler  ; ''  ''  '' square channel 2
00F351  2  20 67 F6              jsr NoiseSfxHandler    ; ''  ''  '' noise channel
00F354  2  20 94 F6              jsr MusicHandler       ;play music on all channels
00F357  2  A9 00                 lda #$00               ;clear the music queues
00F359  2  85 FB                 sta AreaMusicQueue
00F35B  2  85 FC                 sta EventMusicQueue
00F35D  2               
00F35D  2               SkipSoundSubroutines:
00F35D  2  A9 00                  lda #$00               ;clear the sound effects queues
00F35F  2  85 FF                  sta Square1SoundQueue
00F361  2  85 FE                  sta Square2SoundQueue
00F363  2  85 FD                  sta NoiseSoundQueue
00F365  2  85 FA                  sta PauseSoundQueue
00F367  2  AC C0 07               ldy DAC_Counter        ;load some sort of counter
00F36A  2  A5 F4                  lda AreaMusicBuffer
00F36C  2  29 03                  and #%00000011         ;check for specific music
00F36E  2  F0 07                  beq NoIncDAC
00F370  2  EE C0 07               inc DAC_Counter        ;increment and check counter
00F373  2  C0 30                  cpy #$30
00F375  2  90 06                  bcc StrWave            ;if not there yet, just store it
00F377  2  98           NoIncDAC: tya
00F378  2  F0 03                  beq StrWave            ;if we are at zero, do not decrement
00F37A  2  CE C0 07               dec DAC_Counter        ;decrement counter
00F37D  2  8C 11 40     StrWave:  sty SND_DELTA_REG+1    ;store into DMC load register (??)
00F380  2  60                     rts                    ;we are done here
00F381  2               
00F381  2               ;--------------------------------
00F381  2               
00F381  2               Dump_Squ1_Regs:
00F381  2  8C 01 40           sty SND_SQUARE1_REG+1  ;dump the contents of X and Y into square 1's control regs
00F384  2  8E 00 40           stx SND_SQUARE1_REG
00F387  2  60                 rts
00F388  2               
00F388  2               PlaySqu1Sfx:
00F388  2  20 81 F3           jsr Dump_Squ1_Regs     ;do sub to set ctrl regs for square 1, then set frequency regs
00F38B  2               
00F38B  2               SetFreq_Squ1:
00F38B  2  A2 00              ldx #$00               ;set frequency reg offset for square 1 sound channel
00F38D  2               
00F38D  2               Dump_Freq_Regs:
00F38D  2  A8                   tay
00F38E  2  B9 01 FF             lda FreqRegLookupTbl+1,y  ;use previous contents of A for sound reg offset
00F391  2  F0 0B                beq NoTone                ;if zero, then do not load
00F393  2  9D 02 40             sta SND_REGISTER+2,x      ;first byte goes into LSB of frequency divider
00F396  2  B9 00 FF             lda FreqRegLookupTbl,y    ;second byte goes into 3 MSB plus extra bit for
00F399  2  09 08                ora #%00001000            ;length counter
00F39B  2  9D 03 40             sta SND_REGISTER+3,x
00F39E  2  60           NoTone: rts
00F39F  2               
00F39F  2               Dump_Sq2_Regs:
00F39F  2  8E 04 40           stx SND_SQUARE2_REG    ;dump the contents of X and Y into square 2's control regs
00F3A2  2  8C 05 40           sty SND_SQUARE2_REG+1
00F3A5  2  60                 rts
00F3A6  2               
00F3A6  2               PlaySqu2Sfx:
00F3A6  2  20 9F F3           jsr Dump_Sq2_Regs      ;do sub to set ctrl regs for square 2, then set frequency regs
00F3A9  2               
00F3A9  2               SetFreq_Squ2:
00F3A9  2  A2 04              ldx #$04               ;set frequency reg offset for square 2 sound channel
00F3AB  2  D0 E0              bne Dump_Freq_Regs     ;unconditional branch
00F3AD  2               
00F3AD  2               SetFreq_Tri:
00F3AD  2  A2 08              ldx #$08               ;set frequency reg offset for triangle sound channel
00F3AF  2  D0 DC              bne Dump_Freq_Regs     ;unconditional branch
00F3B1  2               
00F3B1  2               ;--------------------------------
00F3B1  2               
00F3B1  2               SwimStompEnvelopeData:
00F3B1  2  9F 9B 98 96        .byte $9f, $9b, $98, $96, $95, $94, $92, $90
00F3B5  2  95 94 92 90  
00F3B9  2  90 9A 97 95        .byte $90, $9a, $97, $95, $93, $92
00F3BD  2  93 92        
00F3BF  2               
00F3BF  2               PlayFlagpoleSlide:
00F3BF  2  A9 40               lda #$40               ;store length of flagpole sound
00F3C1  2  8D BB 07            sta Squ1_SfxLenCounter
00F3C4  2  A9 62               lda #$62               ;load part of reg contents for flagpole sound
00F3C6  2  20 8B F3            jsr SetFreq_Squ1
00F3C9  2  A2 99               ldx #$99               ;now load the rest
00F3CB  2  D0 25               bne FPS2nd
00F3CD  2               
00F3CD  2               PlaySmallJump:
00F3CD  2  A9 26               lda #$26               ;branch here for small mario jumping sound
00F3CF  2  D0 02               bne JumpRegContents
00F3D1  2               
00F3D1  2               PlayBigJump:
00F3D1  2  A9 18               lda #$18               ;branch here for big mario jumping sound
00F3D3  2               
00F3D3  2               JumpRegContents:
00F3D3  2  A2 82               ldx #$82               ;note that small and big jump borrow each others' reg contents
00F3D5  2  A0 A7               ldy #$a7               ;anyway, this loads the first part of mario's jumping sound
00F3D7  2  20 88 F3            jsr PlaySqu1Sfx
00F3DA  2  A9 28               lda #$28               ;store length of sfx for both jumping sounds
00F3DC  2  8D BB 07            sta Squ1_SfxLenCounter ;then continue on here
00F3DF  2               
00F3DF  2               ContinueSndJump:
00F3DF  2  AD BB 07               lda Squ1_SfxLenCounter ;jumping sounds seem to be composed of three parts
00F3E2  2  C9 25                  cmp #$25               ;check for time to play second part yet
00F3E4  2  D0 06                  bne N2Prt
00F3E6  2  A2 5F                  ldx #$5f               ;load second part
00F3E8  2  A0 F6                  ldy #$f6
00F3EA  2  D0 08                  bne DmpJpFPS           ;unconditional branch
00F3EC  2  C9 20        N2Prt:    cmp #$20               ;check for third part
00F3EE  2  D0 29                  bne DecJpFPS
00F3F0  2  A2 48                  ldx #$48               ;load third part
00F3F2  2  A0 BC        FPS2nd:   ldy #$bc               ;the flagpole slide sound shares part of third part
00F3F4  2  20 81 F3     DmpJpFPS: jsr Dump_Squ1_Regs
00F3F7  2  D0 20                  bne DecJpFPS           ;unconditional branch outta here
00F3F9  2               
00F3F9  2               PlayFireballThrow:
00F3F9  2  A9 05                lda #$05
00F3FB  2  A0 99                ldy #$99                 ;load reg contents for fireball throw sound
00F3FD  2  D0 04                bne Fthrow               ;unconditional branch
00F3FF  2               
00F3FF  2               PlayBump:
00F3FF  2  A9 0A                  lda #$0a                ;load length of sfx and reg contents for bump sound
00F401  2  A0 93                  ldy #$93
00F403  2  A2 9E        Fthrow:   ldx #$9e                ;the fireball sound shares reg contents with the bump sound
00F405  2  8D BB 07               sta Squ1_SfxLenCounter
00F408  2  A9 0C                  lda #$0c                ;load offset for bump sound
00F40A  2  20 88 F3               jsr PlaySqu1Sfx
00F40D  2               
00F40D  2               ContinueBumpThrow:
00F40D  2  AD BB 07               lda Squ1_SfxLenCounter  ;check for second part of bump sound
00F410  2  C9 06                  cmp #$06
00F412  2  D0 05                  bne DecJpFPS
00F414  2  A9 BB                  lda #$bb                ;load second part directly
00F416  2  8D 01 40               sta SND_SQUARE1_REG+1
00F419  2  D0 60        DecJpFPS: bne BranchToDecLength1  ;unconditional branch
00F41B  2               
00F41B  2               
00F41B  2               Square1SfxHandler:
00F41B  2  A4 FF               ldy Square1SoundQueue   ;check for sfx in queue
00F41D  2  F0 20               beq CheckSfx1Buffer
00F41F  2  84 F1               sty Square1SoundBuffer  ;if found, put in buffer
00F421  2  30 AA               bmi PlaySmallJump       ;small jump
00F423  2  46 FF               lsr Square1SoundQueue
00F425  2  B0 AA               bcs PlayBigJump         ;big jump
00F427  2  46 FF               lsr Square1SoundQueue
00F429  2  B0 D4               bcs PlayBump            ;bump
00F42B  2  46 FF               lsr Square1SoundQueue
00F42D  2  B0 2C               bcs PlaySwimStomp       ;swim/stomp
00F42F  2  46 FF               lsr Square1SoundQueue
00F431  2  B0 4A               bcs PlaySmackEnemy      ;smack enemy
00F433  2  46 FF               lsr Square1SoundQueue
00F435  2  B0 7F               bcs PlayPipeDownInj     ;pipedown/injury
00F437  2  46 FF               lsr Square1SoundQueue
00F439  2  B0 BE               bcs PlayFireballThrow   ;fireball throw
00F43B  2  46 FF               lsr Square1SoundQueue
00F43D  2  B0 80               bcs PlayFlagpoleSlide   ;slide flagpole
00F43F  2               
00F43F  2               CheckSfx1Buffer:
00F43F  2  A5 F1               lda Square1SoundBuffer   ;check for sfx in buffer
00F441  2  F0 17               beq ExS1H                ;if not found, exit sub
00F443  2  30 9A               bmi ContinueSndJump      ;small mario jump
00F445  2  4A                  lsr
00F446  2  B0 97               bcs ContinueSndJump      ;big mario jump
00F448  2  4A                  lsr
00F449  2  B0 C2               bcs ContinueBumpThrow    ;bump
00F44B  2  4A                  lsr
00F44C  2  B0 1B               bcs ContinueSwimStomp    ;swim/stomp
00F44E  2  4A                  lsr
00F44F  2  B0 3C               bcs ContinueSmackEnemy   ;smack enemy
00F451  2  4A                  lsr
00F452  2  B0 67               bcs ContinuePipeDownInj  ;pipedown/injury
00F454  2  4A                  lsr
00F455  2  B0 B6               bcs ContinueBumpThrow    ;fireball throw
00F457  2  4A                  lsr
00F458  2  B0 48               bcs DecrementSfx1Length  ;slide flagpole
00F45A  2  60           ExS1H: rts
00F45B  2               
00F45B  2               PlaySwimStomp:
00F45B  2  A9 0E              lda #$0e               ;store length of swim/stomp sound
00F45D  2  8D BB 07           sta Squ1_SfxLenCounter
00F460  2  A0 9C              ldy #$9c               ;store reg contents for swim/stomp sound
00F462  2  A2 9E              ldx #$9e
00F464  2  A9 26              lda #$26
00F466  2  20 88 F3           jsr PlaySqu1Sfx
00F469  2               
00F469  2               ContinueSwimStomp:
00F469  2  AC BB 07           ldy Squ1_SfxLenCounter        ;look up reg contents in data section based on
00F46C  2  B9 B0 F3           lda SwimStompEnvelopeData-1,y ;length of sound left, used to control sound's
00F46F  2  8D 00 40           sta SND_SQUARE1_REG           ;envelope
00F472  2  C0 06              cpy #$06
00F474  2  D0 05              bne BranchToDecLength1
00F476  2  A9 9E              lda #$9e                      ;when the length counts down to a certain point, put this
00F478  2  8D 02 40           sta SND_SQUARE1_REG+2         ;directly into the LSB of square 1's frequency divider
00F47B  2               
00F47B  2               BranchToDecLength1:
00F47B  2  D0 25              bne DecrementSfx1Length  ;unconditional branch (regardless of how we got here)
00F47D  2               
00F47D  2               PlaySmackEnemy:
00F47D  2  A9 0E              lda #$0e                 ;store length of smack enemy sound
00F47F  2  A0 CB              ldy #$cb
00F481  2  A2 9F              ldx #$9f
00F483  2  8D BB 07           sta Squ1_SfxLenCounter
00F486  2  A9 28              lda #$28                 ;store reg contents for smack enemy sound
00F488  2  20 88 F3           jsr PlaySqu1Sfx
00F48B  2  D0 15              bne DecrementSfx1Length  ;unconditional branch
00F48D  2               
00F48D  2               ContinueSmackEnemy:
00F48D  2  AC BB 07             ldy Squ1_SfxLenCounter  ;check about halfway through
00F490  2  C0 08                cpy #$08
00F492  2  D0 09                bne SmSpc
00F494  2  A9 A0                lda #$a0                ;if we're at the about-halfway point, make the second tone
00F496  2  8D 02 40             sta SND_SQUARE1_REG+2   ;in the smack enemy sound
00F499  2  A9 9F                lda #$9f
00F49B  2  D0 02                bne SmTick
00F49D  2  A9 90        SmSpc:  lda #$90                ;this creates spaces in the sound, giving it its distinct noise
00F49F  2  8D 00 40     SmTick: sta SND_SQUARE1_REG
00F4A2  2               
00F4A2  2               DecrementSfx1Length:
00F4A2  2  CE BB 07           dec Squ1_SfxLenCounter    ;decrement length of sfx
00F4A5  2  D0 0E              bne ExSfx1
00F4A7  2               
00F4A7  2               StopSquare1Sfx:
00F4A7  2  A2 00                ldx #$00                ;if end of sfx reached, clear buffer
00F4A9  2  86 F1                stx $f1                 ;and stop making the sfx
00F4AB  2  A2 0E                ldx #$0e
00F4AD  2  8E 15 40             stx SND_MASTERCTRL_REG
00F4B0  2  A2 0F                ldx #$0f
00F4B2  2  8E 15 40             stx SND_MASTERCTRL_REG
00F4B5  2  60           ExSfx1: rts
00F4B6  2               
00F4B6  2               PlayPipeDownInj:
00F4B6  2  A9 2F              lda #$2f                ;load length of pipedown sound
00F4B8  2  8D BB 07           sta Squ1_SfxLenCounter
00F4BB  2               
00F4BB  2               ContinuePipeDownInj:
00F4BB  2  AD BB 07              lda Squ1_SfxLenCounter  ;some bitwise logic, forces the regs
00F4BE  2  4A                    lsr                     ;to be written to only during six specific times
00F4BF  2  B0 10                 bcs NoPDwnL             ;during which d3 must be set and d1-0 must be clear
00F4C1  2  4A                    lsr
00F4C2  2  B0 0D                 bcs NoPDwnL
00F4C4  2  29 02                 and #%00000010
00F4C6  2  F0 09                 beq NoPDwnL
00F4C8  2  A0 91                 ldy #$91                ;and this is where it actually gets written in
00F4CA  2  A2 9A                 ldx #$9a
00F4CC  2  A9 44                 lda #$44
00F4CE  2  20 88 F3              jsr PlaySqu1Sfx
00F4D1  2  4C A2 F4     NoPDwnL: jmp DecrementSfx1Length
00F4D4  2               
00F4D4  2               ;--------------------------------
00F4D4  2               
00F4D4  2               ExtraLifeFreqData:
00F4D4  2  58 02 54 56        .byte $58, $02, $54, $56, $4e, $44
00F4D8  2  4E 44        
00F4DA  2               
00F4DA  2               PowerUpGrabFreqData:
00F4DA  2  4C 52 4C 48        .byte $4c, $52, $4c, $48, $3e, $36, $3e, $36, $30
00F4DE  2  3E 36 3E 36  
00F4E2  2  30           
00F4E3  2  28 4A 50 4A        .byte $28, $4a, $50, $4a, $64, $3c, $32, $3c, $32
00F4E7  2  64 3C 32 3C  
00F4EB  2  32           
00F4EC  2  2C 24 3A 64        .byte $2c, $24, $3a, $64, $3a, $34, $2c, $22, $2c
00F4F0  2  3A 34 2C 22  
00F4F4  2  2C           
00F4F5  2               
00F4F5  2               ;residual frequency data
00F4F5  2  22 1C 14           .byte $22, $1c, $14
00F4F8  2               
00F4F8  2               PUp_VGrow_FreqData:
00F4F8  2  14 04 22 24        .byte $14, $04, $22, $24, $16, $04, $24, $26 ;used by both
00F4FC  2  16 04 24 26  
00F500  2  18 04 26 28        .byte $18, $04, $26, $28, $1a, $04, $28, $2a
00F504  2  1A 04 28 2A  
00F508  2  1C 04 2A 2C        .byte $1c, $04, $2a, $2c, $1e, $04, $2c, $2e ;used by vinegrow
00F50C  2  1E 04 2C 2E  
00F510  2  20 04 2E 30        .byte $20, $04, $2e, $30, $22, $04, $30, $32
00F514  2  22 04 30 32  
00F518  2               
00F518  2               PlayCoinGrab:
00F518  2  A9 35                lda #$35             ;load length of coin grab sound
00F51A  2  A2 8D                ldx #$8d             ;and part of reg contents
00F51C  2  D0 04                bne CGrab_TTickRegL
00F51E  2               
00F51E  2               PlayTimerTick:
00F51E  2  A9 06                lda #$06             ;load length of timer tick sound
00F520  2  A2 98                ldx #$98             ;and part of reg contents
00F522  2               
00F522  2               CGrab_TTickRegL:
00F522  2  8D BD 07             sta Squ2_SfxLenCounter
00F525  2  A0 7F                ldy #$7f                ;load the rest of reg contents
00F527  2  A9 42                lda #$42                ;of coin grab and timer tick sound
00F529  2  20 A6 F3             jsr PlaySqu2Sfx
00F52C  2               
00F52C  2               ContinueCGrabTTick:
00F52C  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second tone yet
00F52F  2  C9 30                cmp #$30                ;timer tick sound also executes this, not sure why
00F531  2  D0 05                bne N2Tone
00F533  2  A9 54                lda #$54                ;if so, load the tone directly into the reg
00F535  2  8D 06 40             sta SND_SQUARE2_REG+2
00F538  2  D0 2E        N2Tone: bne DecrementSfx2Length
00F53A  2               
00F53A  2               PlayBlast:
00F53A  2  A9 20                lda #$20                ;load length of fireworks/gunfire sound
00F53C  2  8D BD 07             sta Squ2_SfxLenCounter
00F53F  2  A0 94                ldy #$94                ;load reg contents of fireworks/gunfire sound
00F541  2  A9 5E                lda #$5e
00F543  2  D0 0B                bne SBlasJ
00F545  2               
00F545  2               ContinueBlast:
00F545  2  AD BD 07             lda Squ2_SfxLenCounter  ;check for time to play second part
00F548  2  C9 18                cmp #$18
00F54A  2  D0 1C                bne DecrementSfx2Length
00F54C  2  A0 93                ldy #$93                ;load second part reg contents then
00F54E  2  A9 18                lda #$18
00F550  2  D0 7F        SBlasJ: bne BlstSJp             ;unconditional branch to load rest of reg contents
00F552  2               
00F552  2               PlayPowerUpGrab:
00F552  2  A9 36                lda #$36                    ;load length of power-up grab sound
00F554  2  8D BD 07             sta Squ2_SfxLenCounter
00F557  2               
00F557  2               ContinuePowerUpGrab:
00F557  2  AD BD 07             lda Squ2_SfxLenCounter      ;load frequency reg based on length left over
00F55A  2  4A                   lsr                         ;divide by 2
00F55B  2  B0 0B                bcs DecrementSfx2Length     ;alter frequency every other frame
00F55D  2  A8                   tay
00F55E  2  B9 D9 F4             lda PowerUpGrabFreqData-1,y ;use length left over / 2 for frequency offset
00F561  2  A2 5D                ldx #$5d                    ;store reg contents of power-up grab sound
00F563  2  A0 7F                ldy #$7f
00F565  2               
00F565  2               LoadSqu2Regs:
00F565  2  20 A6 F3             jsr PlaySqu2Sfx
00F568  2               
00F568  2               DecrementSfx2Length:
00F568  2  CE BD 07             dec Squ2_SfxLenCounter   ;decrement length of sfx
00F56B  2  D0 0E                bne ExSfx2
00F56D  2               
00F56D  2               EmptySfx2Buffer:
00F56D  2  A2 00                ldx #$00                ;initialize square 2's sound effects buffer
00F56F  2  86 F2                stx Square2SoundBuffer
00F571  2               
00F571  2               StopSquare2Sfx:
00F571  2  A2 0D                ldx #$0d                ;stop playing the sfx
00F573  2  8E 15 40             stx SND_MASTERCTRL_REG
00F576  2  A2 0F                ldx #$0f
00F578  2  8E 15 40             stx SND_MASTERCTRL_REG
00F57B  2  60           ExSfx2: rts
00F57C  2               
00F57C  2               Square2SfxHandler:
00F57C  2  A5 F2                lda Square2SoundBuffer ;special handling for the 1-up sound to keep it
00F57E  2  29 40                and #Sfx_ExtraLife     ;from being interrupted by other sounds on square 2
00F580  2  D0 65                bne ContinueExtraLife
00F582  2  A4 FE                ldy Square2SoundQueue  ;check for sfx in queue
00F584  2  F0 20                beq CheckSfx2Buffer
00F586  2  84 F2                sty Square2SoundBuffer ;if found, put in buffer and check for the following
00F588  2  30 3E                bmi PlayBowserFall     ;bowser fall
00F58A  2  46 FE                lsr Square2SoundQueue
00F58C  2  B0 8A                bcs PlayCoinGrab       ;coin grab
00F58E  2  46 FE                lsr Square2SoundQueue
00F590  2  B0 6A                bcs PlayGrowPowerUp    ;power-up reveal
00F592  2  46 FE                lsr Square2SoundQueue
00F594  2  B0 6A                bcs PlayGrowVine       ;vine grow
00F596  2  46 FE                lsr Square2SoundQueue
00F598  2  B0 A0                bcs PlayBlast          ;fireworks/gunfire
00F59A  2  46 FE                lsr Square2SoundQueue
00F59C  2  B0 80                bcs PlayTimerTick      ;timer tick
00F59E  2  46 FE                lsr Square2SoundQueue
00F5A0  2  B0 B0                bcs PlayPowerUpGrab    ;power-up grab
00F5A2  2  46 FE                lsr Square2SoundQueue
00F5A4  2  B0 3C                bcs PlayExtraLife      ;1-up
00F5A6  2               
00F5A6  2               CheckSfx2Buffer:
00F5A6  2  A5 F2                lda Square2SoundBuffer   ;check for sfx in buffer
00F5A8  2  F0 17                beq ExS2H                ;if not found, exit sub
00F5AA  2  30 27                bmi ContinueBowserFall   ;bowser fall
00F5AC  2  4A                   lsr
00F5AD  2  B0 13                bcs Cont_CGrab_TTick     ;coin grab
00F5AF  2  4A                   lsr
00F5B0  2  B0 5D                bcs ContinueGrowItems    ;power-up reveal
00F5B2  2  4A                   lsr
00F5B3  2  B0 5A                bcs ContinueGrowItems    ;vine grow
00F5B5  2  4A                   lsr
00F5B6  2  B0 8D                bcs ContinueBlast        ;fireworks/gunfire
00F5B8  2  4A                   lsr
00F5B9  2  B0 07                bcs Cont_CGrab_TTick     ;timer tick
00F5BB  2  4A                   lsr
00F5BC  2  B0 99                bcs ContinuePowerUpGrab  ;power-up grab
00F5BE  2  4A                   lsr
00F5BF  2  B0 26                bcs ContinueExtraLife    ;1-up
00F5C1  2  60           ExS2H:  rts
00F5C2  2               
00F5C2  2               Cont_CGrab_TTick:
00F5C2  2  4C 2C F5             jmp ContinueCGrabTTick
00F5C5  2               
00F5C5  2               JumpToDecLength2:
00F5C5  2  4C 68 F5             jmp DecrementSfx2Length
00F5C8  2               
00F5C8  2               PlayBowserFall:
00F5C8  2  A9 38                 lda #$38                ;load length of bowser defeat sound
00F5CA  2  8D BD 07              sta Squ2_SfxLenCounter
00F5CD  2  A0 C4                 ldy #$c4                ;load contents of reg for bowser defeat sound
00F5CF  2  A9 18                 lda #$18
00F5D1  2  D0 0B        BlstSJp: bne PBFRegs
00F5D3  2               
00F5D3  2               ContinueBowserFall:
00F5D3  2  AD BD 07               lda Squ2_SfxLenCounter   ;check for almost near the end
00F5D6  2  C9 08                  cmp #$08
00F5D8  2  D0 8E                  bne DecrementSfx2Length
00F5DA  2  A0 A4                  ldy #$a4                 ;if so, load the rest of reg contents for bowser defeat sound
00F5DC  2  A9 5A                  lda #$5a
00F5DE  2  A2 9F        PBFRegs:  ldx #$9f                 ;the fireworks/gunfire sound shares part of reg contents here
00F5E0  2  D0 83        EL_LRegs: bne LoadSqu2Regs         ;this is an unconditional branch outta here
00F5E2  2               
00F5E2  2               PlayExtraLife:
00F5E2  2  A9 30                lda #$30                  ;load length of 1-up sound
00F5E4  2  8D BD 07             sta Squ2_SfxLenCounter
00F5E7  2               
00F5E7  2               ContinueExtraLife:
00F5E7  2  AD BD 07               lda Squ2_SfxLenCounter
00F5EA  2  A2 03                  ldx #$03                  ;load new tones only every eight frames
00F5EC  2  4A           DivLLoop: lsr
00F5ED  2  B0 D6                  bcs JumpToDecLength2      ;if any bits set here, branch to dec the length
00F5EF  2  CA                     dex
00F5F0  2  D0 FA                  bne DivLLoop              ;do this until all bits checked, if none set, continue
00F5F2  2  A8                     tay
00F5F3  2  B9 D3 F4               lda ExtraLifeFreqData-1,y ;load our reg contents
00F5F6  2  A2 82                  ldx #$82
00F5F8  2  A0 7F                  ldy #$7f
00F5FA  2  D0 E4                  bne EL_LRegs              ;unconditional branch
00F5FC  2               
00F5FC  2               PlayGrowPowerUp:
00F5FC  2  A9 10                lda #$10                ;load length of power-up reveal sound
00F5FE  2  D0 02                bne GrowItemRegs
00F600  2               
00F600  2               PlayGrowVine:
00F600  2  A9 20                lda #$20                ;load length of vine grow sound
00F602  2               
00F602  2               GrowItemRegs:
00F602  2  8D BD 07             sta Squ2_SfxLenCounter
00F605  2  A9 7F                lda #$7f                  ;load contents of reg for both sounds directly
00F607  2  8D 05 40             sta SND_SQUARE2_REG+1
00F60A  2  A9 00                lda #$00                  ;start secondary counter for both sounds
00F60C  2  8D BE 07             sta Sfx_SecondaryCounter
00F60F  2               
00F60F  2               ContinueGrowItems:
00F60F  2  EE BE 07             inc Sfx_SecondaryCounter  ;increment secondary counter for both sounds
00F612  2  AD BE 07             lda Sfx_SecondaryCounter  ;this sound doesn't decrement the usual counter
00F615  2  4A                   lsr                       ;divide by 2 to get the offset
00F616  2  A8                   tay
00F617  2  CC BD 07             cpy Squ2_SfxLenCounter    ;have we reached the end yet?
00F61A  2  F0 0C                beq StopGrowItems         ;if so, branch to jump, and stop playing sounds
00F61C  2  A9 9D                lda #$9d                  ;load contents of other reg directly
00F61E  2  8D 04 40             sta SND_SQUARE2_REG
00F621  2  B9 F8 F4             lda PUp_VGrow_FreqData,y  ;use secondary counter / 2 as offset for frequency regs
00F624  2  20 A9 F3             jsr SetFreq_Squ2
00F627  2  60                   rts
00F628  2               
00F628  2               StopGrowItems:
00F628  2  4C 6D F5             jmp EmptySfx2Buffer       ;branch to stop playing sounds
00F62B  2               
00F62B  2               ;--------------------------------
00F62B  2               
00F62B  2               BrickShatterFreqData:
00F62B  2  01 0E 0E 0D          .byte $01, $0e, $0e, $0d, $0b, $06, $0c, $0f
00F62F  2  0B 06 0C 0F  
00F633  2  0A 09 03 0D          .byte $0a, $09, $03, $0d, $08, $0d, $06, $0c
00F637  2  08 0D 06 0C  
00F63B  2               
00F63B  2               PlayBrickShatter:
00F63B  2  A9 20                lda #$20                 ;load length of brick shatter sound
00F63D  2  8D BF 07             sta Noise_SfxLenCounter
00F640  2               
00F640  2               ContinueBrickShatter:
00F640  2  AD BF 07             lda Noise_SfxLenCounter
00F643  2  4A                   lsr                         ;divide by 2 and check for bit set to use offset
00F644  2  90 12                bcc DecrementSfx3Length
00F646  2  A8                   tay
00F647  2  BE 2B F6             ldx BrickShatterFreqData,y  ;load reg contents of brick shatter sound
00F64A  2  B9 EA FF             lda BrickShatterEnvData,y
00F64D  2               
00F64D  2               PlayNoiseSfx:
00F64D  2  8D 0C 40             sta SND_NOISE_REG        ;play the sfx
00F650  2  8E 0E 40             stx SND_NOISE_REG+2
00F653  2  A9 18                lda #$18
00F655  2  8D 0F 40             sta SND_NOISE_REG+3
00F658  2               
00F658  2               DecrementSfx3Length:
00F658  2  CE BF 07             dec Noise_SfxLenCounter  ;decrement length of sfx
00F65B  2  D0 09                bne ExSfx3
00F65D  2  A9 F0                lda #$f0                 ;if done, stop playing the sfx
00F65F  2  8D 0C 40             sta SND_NOISE_REG
00F662  2  A9 00                lda #$00
00F664  2  85 F3                sta NoiseSoundBuffer
00F666  2  60           ExSfx3: rts
00F667  2               
00F667  2               NoiseSfxHandler:
00F667  2  A4 FD                ldy NoiseSoundQueue   ;check for sfx in queue
00F669  2  F0 0A                beq CheckNoiseBuffer
00F66B  2  84 F3                sty NoiseSoundBuffer  ;if found, put in buffer
00F66D  2  46 FD                lsr NoiseSoundQueue
00F66F  2  B0 CA                bcs PlayBrickShatter  ;brick shatter
00F671  2  46 FD                lsr NoiseSoundQueue
00F673  2  B0 0B                bcs PlayBowserFlame   ;bowser flame
00F675  2               
00F675  2               CheckNoiseBuffer:
00F675  2  A5 F3                lda NoiseSoundBuffer      ;check for sfx in buffer
00F677  2  F0 06                beq ExNH                  ;if not found, exit sub
00F679  2  4A                   lsr
00F67A  2  B0 C4                bcs ContinueBrickShatter  ;brick shatter
00F67C  2  4A                   lsr
00F67D  2  B0 06                bcs ContinueBowserFlame   ;bowser flame
00F67F  2  60           ExNH:   rts
00F680  2               
00F680  2               PlayBowserFlame:
00F680  2  A9 40                lda #$40                    ;load length of bowser flame sound
00F682  2  8D BF 07             sta Noise_SfxLenCounter
00F685  2               
00F685  2               ContinueBowserFlame:
00F685  2  AD BF 07             lda Noise_SfxLenCounter
00F688  2  4A                   lsr
00F689  2  A8                   tay
00F68A  2  A2 0F                ldx #$0f                    ;load reg contents of bowser flame sound
00F68C  2  B9 C9 FF             lda BowserFlameEnvData-1,y
00F68F  2  D0 BC                bne PlayNoiseSfx            ;unconditional branch here
00F691  2               
00F691  2               ;--------------------------------
00F691  2               
00F691  2               ContinueMusic:
00F691  2  4C 3A F7             jmp HandleSquare2Music  ;if we have music, start with square 2 channel
00F694  2               
00F694  2               MusicHandler:
00F694  2  A5 FC                lda EventMusicQueue     ;check event music queue
00F696  2  D0 0C                bne LoadEventMusic
00F698  2  A5 FB                lda AreaMusicQueue      ;check area music queue
00F69A  2  D0 2C                bne LoadAreaMusic
00F69C  2  AD B1 07             lda EventMusicBuffer    ;check both buffers
00F69F  2  05 F4                ora AreaMusicBuffer
00F6A1  2  D0 EE                bne ContinueMusic
00F6A3  2  60                   rts                     ;no music, then leave
00F6A4  2               
00F6A4  2               LoadEventMusic:
00F6A4  2  8D B1 07                sta EventMusicBuffer      ;copy event music queue contents to buffer
00F6A7  2  C9 01                   cmp #DeathMusic           ;is it death music?
00F6A9  2  D0 06                   bne NoStopSfx             ;if not, jump elsewhere
00F6AB  2  20 A7 F4                jsr StopSquare1Sfx        ;stop sfx in square 1 and 2
00F6AE  2  20 71 F5                jsr StopSquare2Sfx        ;but clear only square 1's sfx buffer
00F6B1  2  A6 F4        NoStopSfx: ldx AreaMusicBuffer
00F6B3  2  8E C5 07                stx AreaMusicBuffer_Alt   ;save current area music buffer to be re-obtained later
00F6B6  2  A0 00                   ldy #$00
00F6B8  2  8C C4 07                sty NoteLengthTblAdder    ;default value for additional length byte offset
00F6BB  2  84 F4                   sty AreaMusicBuffer       ;clear area music buffer
00F6BD  2  C9 40                   cmp #TimeRunningOutMusic  ;is it time running out music?
00F6BF  2  D0 30                   bne FindEventMusicHeader
00F6C1  2  A2 08                   ldx #$08                  ;load offset to be added to length byte of header
00F6C3  2  8E C4 07                stx NoteLengthTblAdder
00F6C6  2  D0 29                   bne FindEventMusicHeader  ;unconditional branch
00F6C8  2               
00F6C8  2               LoadAreaMusic:
00F6C8  2  C9 04                 cmp #$04                  ;is it underground music?
00F6CA  2  D0 03                 bne NoStop1               ;no, do not stop square 1 sfx
00F6CC  2  20 A7 F4              jsr StopSquare1Sfx
00F6CF  2  A0 10        NoStop1: ldy #$10                  ;start counter used only by ground level music
00F6D1  2  8C C7 07     GMLoopB: sty GroundMusicHeaderOfs
00F6D4  2               
00F6D4  2               HandleAreaMusicLoopB:
00F6D4  2  A0 00                 ldy #$00                  ;clear event music buffer
00F6D6  2  8C B1 07              sty EventMusicBuffer
00F6D9  2  85 F4                 sta AreaMusicBuffer       ;copy area music queue contents to buffer
00F6DB  2  C9 01                 cmp #$01                  ;is it ground level music?
00F6DD  2  D0 0E                 bne FindAreaMusicHeader
00F6DF  2  EE C7 07              inc GroundMusicHeaderOfs  ;increment but only if playing ground level music
00F6E2  2  AC C7 07              ldy GroundMusicHeaderOfs  ;is it time to loopback ground level music?
00F6E5  2  C0 32                 cpy #$32
00F6E7  2  D0 0C                 bne LoadHeader            ;branch ahead with alternate offset
00F6E9  2  A0 11                 ldy #$11
00F6EB  2  D0 E4                 bne GMLoopB               ;unconditional branch
00F6ED  2               
00F6ED  2               FindAreaMusicHeader:
00F6ED  2  A0 08                ldy #$08                   ;load Y for offset of area music
00F6EF  2  84 F7                sty MusicOffset_Square2    ;residual instruction here
00F6F1  2               
00F6F1  2               FindEventMusicHeader:
00F6F1  2  C8                   iny                       ;increment Y pointer based on previously loaded queue contents
00F6F2  2  4A                   lsr                       ;bit shift and increment until we find a set bit for music
00F6F3  2  90 FC                bcc FindEventMusicHeader
00F6F5  2               
00F6F5  2               LoadHeader:
00F6F5  2  B9 0C F9             lda MusicHeaderOffsetData,y  ;load offset for header
00F6F8  2  A8                   tay
00F6F9  2  B9 0D F9             lda MusicHeaderData,y        ;now load the header
00F6FC  2  85 F0                sta NoteLenLookupTblOfs
00F6FE  2  B9 0E F9             lda MusicHeaderData+1,y
00F701  2  85 F5                sta MusicDataLow
00F703  2  B9 0F F9             lda MusicHeaderData+2,y
00F706  2  85 F6                sta MusicDataHigh
00F708  2  B9 10 F9             lda MusicHeaderData+3,y
00F70B  2  85 F9                sta MusicOffset_Triangle
00F70D  2  B9 11 F9             lda MusicHeaderData+4,y
00F710  2  85 F8                sta MusicOffset_Square1
00F712  2  B9 12 F9             lda MusicHeaderData+5,y
00F715  2  8D B0 07             sta MusicOffset_Noise
00F718  2  8D C1 07             sta NoiseDataLoopbackOfs
00F71B  2  A9 01                lda #$01                     ;initialize music note counters
00F71D  2  8D B4 07             sta Squ2_NoteLenCounter
00F720  2  8D B6 07             sta Squ1_NoteLenCounter
00F723  2  8D B9 07             sta Tri_NoteLenCounter
00F726  2  8D BA 07             sta Noise_BeatLenCounter
00F729  2  A9 00                lda #$00                     ;initialize music data offset for square 2
00F72B  2  85 F7                sta MusicOffset_Square2
00F72D  2  8D CA 07             sta AltRegContentFlag        ;initialize alternate control reg data used by square 1
00F730  2  A9 0B                lda #$0b                     ;disable triangle channel and reenable it
00F732  2  8D 15 40             sta SND_MASTERCTRL_REG
00F735  2  A9 0F                lda #$0f
00F737  2  8D 15 40             sta SND_MASTERCTRL_REG
00F73A  2               
00F73A  2               HandleSquare2Music:
00F73A  2  CE B4 07             dec Squ2_NoteLenCounter  ;decrement square 2 note length
00F73D  2  D0 5F                bne MiscSqu2MusicTasks   ;is it time for more data?  if not, branch to end tasks
00F73F  2  A4 F7                ldy MusicOffset_Square2  ;increment square 2 music offset and fetch data
00F741  2  E6 F7                inc MusicOffset_Square2
00F743  2  B1 F5                lda (MusicData),y
00F745  2  F0 04                beq EndOfMusicData       ;if zero, the data is a null terminator
00F747  2  10 3D                bpl Squ2NoteHandler      ;if non-negative, data is a note
00F749  2  D0 2F                bne Squ2LengthHandler    ;otherwise it is length data
00F74B  2               
00F74B  2               EndOfMusicData:
00F74B  2  AD B1 07             lda EventMusicBuffer     ;check secondary buffer for time running out music
00F74E  2  C9 40                cmp #TimeRunningOutMusic
00F750  2  D0 05                bne NotTRO
00F752  2  AD C5 07             lda AreaMusicBuffer_Alt  ;load previously saved contents of primary buffer
00F755  2  D0 1D                bne MusicLoopBack        ;and start playing the song again if there is one
00F757  2  29 04        NotTRO: and #VictoryMusic        ;check for victory music (the only secondary that loops)
00F759  2  D0 1C                bne VictoryMLoopBack
00F75B  2  A5 F4                lda AreaMusicBuffer      ;check primary buffer for any music except pipe intro
00F75D  2  29 5F                and #%01011111
00F75F  2  D0 13                bne MusicLoopBack        ;if any area music except pipe intro, music loops
00F761  2  A9 00                lda #$00                 ;clear primary and secondary buffers and initialize
00F763  2  85 F4                sta AreaMusicBuffer      ;control regs of square and triangle channels
00F765  2  8D B1 07             sta EventMusicBuffer
00F768  2  8D 08 40             sta SND_TRIANGLE_REG
00F76B  2  A9 90                lda #$90
00F76D  2  8D 00 40             sta SND_SQUARE1_REG
00F770  2  8D 04 40             sta SND_SQUARE2_REG
00F773  2  60                   rts
00F774  2               
00F774  2               MusicLoopBack:
00F774  2  4C D4 F6             jmp HandleAreaMusicLoopB
00F777  2               
00F777  2               VictoryMLoopBack:
00F777  2  4C A4 F6             jmp LoadEventMusic
00F77A  2               
00F77A  2               Squ2LengthHandler:
00F77A  2  20 CB F8             jsr ProcessLengthData    ;store length of note
00F77D  2  8D B3 07             sta Squ2_NoteLenBuffer
00F780  2  A4 F7                ldy MusicOffset_Square2  ;fetch another byte (MUST NOT BE LENGTH BYTE!)
00F782  2  E6 F7                inc MusicOffset_Square2
00F784  2  B1 F5                lda (MusicData),y
00F786  2               
00F786  2               Squ2NoteHandler:
00F786  2  A6 F2                  ldx Square2SoundBuffer     ;is there a sound playing on this channel?
00F788  2  D0 0E                  bne SkipFqL1
00F78A  2  20 A9 F3               jsr SetFreq_Squ2           ;no, then play the note
00F78D  2  F0 03                  beq Rest                   ;check to see if note is rest
00F78F  2  20 D8 F8               jsr LoadControlRegs        ;if not, load control regs for square 2
00F792  2  8D B5 07     Rest:     sta Squ2_EnvelopeDataCtrl  ;save contents of A
00F795  2  20 9F F3               jsr Dump_Sq2_Regs          ;dump X and Y into square 2 control regs
00F798  2  AD B3 07     SkipFqL1: lda Squ2_NoteLenBuffer     ;save length in square 2 note counter
00F79B  2  8D B4 07               sta Squ2_NoteLenCounter
00F79E  2               
00F79E  2               MiscSqu2MusicTasks:
00F79E  2  A5 F2                   lda Square2SoundBuffer     ;is there a sound playing on square 2?
00F7A0  2  D0 1A                   bne HandleSquare1Music
00F7A2  2  AD B1 07                lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00F7A5  2  29 91                   and #%10010001             ;note that regs for death music or d4 are loaded by default
00F7A7  2  D0 13                   bne HandleSquare1Music
00F7A9  2  AC B5 07                ldy Squ2_EnvelopeDataCtrl  ;check for contents saved from LoadControlRegs
00F7AC  2  F0 03                   beq NoDecEnv1
00F7AE  2  CE B5 07                dec Squ2_EnvelopeDataCtrl  ;decrement unless already zero
00F7B1  2  20 F4 F8     NoDecEnv1: jsr LoadEnvelopeData       ;do a load of envelope data to replace default
00F7B4  2  8D 04 40                sta SND_SQUARE2_REG        ;based on offset set by first load unless playing
00F7B7  2  A2 7F                   ldx #$7f                   ;death music or d4 set on secondary buffer
00F7B9  2  8E 05 40                stx SND_SQUARE2_REG+1
00F7BC  2               
00F7BC  2               HandleSquare1Music:
00F7BC  2  A4 F8                ldy MusicOffset_Square1    ;is there a nonzero offset here?
00F7BE  2  F0 5A                beq HandleTriangleMusic    ;if not, skip ahead to the triangle channel
00F7C0  2  CE B6 07             dec Squ1_NoteLenCounter    ;decrement square 1 note length
00F7C3  2  D0 32                bne MiscSqu1MusicTasks     ;is it time for more data?
00F7C5  2               
00F7C5  2               FetchSqu1MusicData:
00F7C5  2  A4 F8                ldy MusicOffset_Square1    ;increment square 1 music offset and fetch data
00F7C7  2  E6 F8                inc MusicOffset_Square1
00F7C9  2  B1 F5                lda (MusicData),y
00F7CB  2  D0 0F                bne Squ1NoteHandler        ;if nonzero, then skip this part
00F7CD  2  A9 83                lda #$83
00F7CF  2  8D 00 40             sta SND_SQUARE1_REG        ;store some data into control regs for square 1
00F7D2  2  A9 94                lda #$94                   ;and fetch another byte of data, used to give
00F7D4  2  8D 01 40             sta SND_SQUARE1_REG+1      ;death music its unique sound
00F7D7  2  8D CA 07             sta AltRegContentFlag
00F7DA  2  D0 E9                bne FetchSqu1MusicData     ;unconditional branch
00F7DC  2               
00F7DC  2               Squ1NoteHandler:
00F7DC  2  20 C5 F8                jsr AlternateLengthHandler
00F7DF  2  8D B6 07                sta Squ1_NoteLenCounter    ;save contents of A in square 1 note counter
00F7E2  2  A4 F1                   ldy Square1SoundBuffer     ;is there a sound playing on square 1?
00F7E4  2  D0 34                   bne HandleTriangleMusic
00F7E6  2  8A                      txa
00F7E7  2  29 3E                   and #%00111110             ;change saved data to appropriate note format
00F7E9  2  20 8B F3                jsr SetFreq_Squ1           ;play the note
00F7EC  2  F0 03                   beq SkipCtrlL
00F7EE  2  20 D8 F8                jsr LoadControlRegs
00F7F1  2  8D B7 07     SkipCtrlL: sta Squ1_EnvelopeDataCtrl  ;save envelope offset
00F7F4  2  20 81 F3                jsr Dump_Squ1_Regs
00F7F7  2               
00F7F7  2               MiscSqu1MusicTasks:
00F7F7  2  A5 F1                      lda Square1SoundBuffer     ;is there a sound playing on square 1?
00F7F9  2  D0 1F                      bne HandleTriangleMusic
00F7FB  2  AD B1 07                   lda EventMusicBuffer       ;check for death music or d4 set on secondary buffer
00F7FE  2  29 91                      and #%10010001
00F800  2  D0 0E                      bne DeathMAltReg
00F802  2  AC B7 07                   ldy Squ1_EnvelopeDataCtrl  ;check saved envelope offset
00F805  2  F0 03                      beq NoDecEnv2
00F807  2  CE B7 07                   dec Squ1_EnvelopeDataCtrl  ;decrement unless already zero
00F80A  2  20 F4 F8     NoDecEnv2:    jsr LoadEnvelopeData       ;do a load of envelope data
00F80D  2  8D 00 40                   sta SND_SQUARE1_REG        ;based on offset set by first load
00F810  2  AD CA 07     DeathMAltReg: lda AltRegContentFlag      ;check for alternate control reg data
00F813  2  D0 02                      bne DoAltLoad
00F815  2  A9 7F                      lda #$7f                   ;load this value if zero, the alternate value
00F817  2  8D 01 40     DoAltLoad:    sta SND_SQUARE1_REG+1      ;if nonzero, and let's move on
00F81A  2               
00F81A  2               HandleTriangleMusic:
00F81A  2  A5 F9                lda MusicOffset_Triangle
00F81C  2  CE B9 07             dec Tri_NoteLenCounter    ;decrement triangle note length
00F81F  2  D0 4C                bne HandleNoiseMusic      ;is it time for more data?
00F821  2  A4 F9                ldy MusicOffset_Triangle  ;increment square 1 music offset and fetch data
00F823  2  E6 F9                inc MusicOffset_Triangle
00F825  2  B1 F5                lda (MusicData),y
00F827  2  F0 41                beq LoadTriCtrlReg        ;if zero, skip all this and move on to noise
00F829  2  10 13                bpl TriNoteHandler        ;if non-negative, data is note
00F82B  2  20 CB F8             jsr ProcessLengthData     ;otherwise, it is length data
00F82E  2  8D B8 07             sta Tri_NoteLenBuffer     ;save contents of A
00F831  2  A9 1F                lda #$1f
00F833  2  8D 08 40             sta SND_TRIANGLE_REG      ;load some default data for triangle control reg
00F836  2  A4 F9                ldy MusicOffset_Triangle  ;fetch another byte
00F838  2  E6 F9                inc MusicOffset_Triangle
00F83A  2  B1 F5                lda (MusicData),y
00F83C  2  F0 2C                beq LoadTriCtrlReg        ;check once more for nonzero data
00F83E  2               
00F83E  2               TriNoteHandler:
00F83E  2  20 AD F3               jsr SetFreq_Tri
00F841  2  AE B8 07               ldx Tri_NoteLenBuffer   ;save length in triangle note counter
00F844  2  8E B9 07               stx Tri_NoteLenCounter
00F847  2  AD B1 07               lda EventMusicBuffer
00F84A  2  29 6E                  and #%01101110          ;check for death music or d4 set on secondary buffer
00F84C  2  D0 06                  bne NotDOrD4            ;if playing any other secondary, skip primary buffer check
00F84E  2  A5 F4                  lda AreaMusicBuffer     ;check primary buffer for water or castle level music
00F850  2  29 0A                  and #%00001010
00F852  2  F0 19                  beq HandleNoiseMusic    ;if playing any other primary, or death or d4, go on to noise routine
00F854  2  8A           NotDOrD4: txa                     ;if playing water or castle music or any secondary
00F855  2  C9 12                  cmp #$12                ;besides death music or d4 set, check length of note
00F857  2  B0 0F                  bcs LongN
00F859  2  AD B1 07               lda EventMusicBuffer    ;check for win castle music again if not playing a long note
00F85C  2  29 08                  and #EndOfCastleMusic
00F85E  2  F0 04                  beq MediN
00F860  2  A9 0F                  lda #$0f                ;load value $0f if playing the win castle music and playing a short
00F862  2  D0 06                  bne LoadTriCtrlReg      ;note, load value $1f if playing water or castle level music or any
00F864  2  A9 1F        MediN:    lda #$1f                ;secondary besides death and d4 except win castle or win castle and playing
00F866  2  D0 02                  bne LoadTriCtrlReg      ;a short note, and load value $ff if playing a long note on water, castle
00F868  2  A9 FF        LongN:    lda #$ff                ;or any secondary (including win castle) except death and d4
00F86A  2               
00F86A  2               LoadTriCtrlReg:
00F86A  2  8D 08 40             sta SND_TRIANGLE_REG      ;save final contents of A into control reg for triangle
00F86D  2               
00F86D  2               HandleNoiseMusic:
00F86D  2  A5 F4                lda AreaMusicBuffer       ;check if playing underground or castle music
00F86F  2  29 F3                and #%11110011
00F871  2  F0 51                beq ExitMusicHandler      ;if so, skip the noise routine
00F873  2  CE BA 07             dec Noise_BeatLenCounter  ;decrement noise beat length
00F876  2  D0 4C                bne ExitMusicHandler      ;is it time for more data?
00F878  2               
00F878  2               FetchNoiseBeatData:
00F878  2  AC B0 07             ldy MusicOffset_Noise       ;increment noise beat offset and fetch data
00F87B  2  EE B0 07             inc MusicOffset_Noise
00F87E  2  B1 F5                lda (MusicData),y           ;get noise beat data, if nonzero, branch to handle
00F880  2  D0 08                bne NoiseBeatHandler
00F882  2  AD C1 07             lda NoiseDataLoopbackOfs    ;if data is zero, reload original noise beat offset
00F885  2  8D B0 07             sta MusicOffset_Noise       ;and loopback next time around
00F888  2  D0 EE                bne FetchNoiseBeatData      ;unconditional branch
00F88A  2               
00F88A  2               NoiseBeatHandler:
00F88A  2  20 C5 F8             jsr AlternateLengthHandler
00F88D  2  8D BA 07             sta Noise_BeatLenCounter    ;store length in noise beat counter
00F890  2  8A                   txa
00F891  2  29 3E                and #%00111110              ;reload data and erase length bits
00F893  2  F0 24                beq SilentBeat              ;if no beat data, silence
00F895  2  C9 30                cmp #$30                    ;check the beat data and play the appropriate
00F897  2  F0 18                beq LongBeat                ;noise accordingly
00F899  2  C9 20                cmp #$20
00F89B  2  F0 0C                beq StrongBeat
00F89D  2  29 10                and #%00010000
00F89F  2  F0 18                beq SilentBeat
00F8A1  2  A9 1C                lda #$1c        ;short beat data
00F8A3  2  A2 03                ldx #$03
00F8A5  2  A0 18                ldy #$18
00F8A7  2  D0 12                bne PlayBeat
00F8A9  2               
00F8A9  2               StrongBeat:
00F8A9  2  A9 1C                lda #$1c        ;strong beat data
00F8AB  2  A2 0C                ldx #$0c
00F8AD  2  A0 18                ldy #$18
00F8AF  2  D0 0A                bne PlayBeat
00F8B1  2               
00F8B1  2               LongBeat:
00F8B1  2  A9 1C                lda #$1c        ;long beat data
00F8B3  2  A2 03                ldx #$03
00F8B5  2  A0 58                ldy #$58
00F8B7  2  D0 02                bne PlayBeat
00F8B9  2               
00F8B9  2               SilentBeat:
00F8B9  2  A9 10                lda #$10        ;silence
00F8BB  2               
00F8BB  2               PlayBeat:
00F8BB  2  8D 0C 40             sta SND_NOISE_REG    ;load beat data into noise regs
00F8BE  2  8E 0E 40             stx SND_NOISE_REG+2
00F8C1  2  8C 0F 40             sty SND_NOISE_REG+3
00F8C4  2               
00F8C4  2               ExitMusicHandler:
00F8C4  2  60                   rts
00F8C5  2               
00F8C5  2               AlternateLengthHandler:
00F8C5  2  AA                   tax            ;save a copy of original byte into X
00F8C6  2  6A                   ror            ;save LSB from original byte into carry
00F8C7  2  8A                   txa            ;reload original byte and rotate three times
00F8C8  2  2A                   rol            ;turning xx00000x into 00000xxx, with the
00F8C9  2  2A                   rol            ;bit in carry as the MSB here
00F8CA  2  2A                   rol
00F8CB  2               
00F8CB  2               ProcessLengthData:
00F8CB  2  29 07                and #%00000111              ;clear all but the three LSBs
00F8CD  2  18                   clc
00F8CE  2  65 F0                adc $f0                     ;add offset loaded from first header byte
00F8D0  2  6D C4 07             adc NoteLengthTblAdder      ;add extra if time running out music
00F8D3  2  A8                   tay
00F8D4  2  B9 66 FF             lda MusicLengthLookupTbl,y  ;load length
00F8D7  2  60                   rts
00F8D8  2               
00F8D8  2               LoadControlRegs:
00F8D8  2  AD B1 07                lda EventMusicBuffer  ;check secondary buffer for win castle music
00F8DB  2  29 08                   and #EndOfCastleMusic
00F8DD  2  F0 04                   beq NotECstlM
00F8DF  2  A9 04                   lda #$04              ;this value is only used for win castle music
00F8E1  2  D0 0C                   bne AllMus            ;unconditional branch
00F8E3  2  A5 F4        NotECstlM: lda AreaMusicBuffer
00F8E5  2  29 7D                   and #%01111101        ;check primary buffer for water music
00F8E7  2  F0 04                   beq WaterMus
00F8E9  2  A9 08                   lda #$08              ;this is the default value for all other music
00F8EB  2  D0 02                   bne AllMus
00F8ED  2  A9 28        WaterMus:  lda #$28              ;this value is used for water music and all other event music
00F8EF  2  A2 82        AllMus:    ldx #$82              ;load contents of other sound regs for square 2
00F8F1  2  A0 7F                   ldy #$7f
00F8F3  2  60                      rts
00F8F4  2               
00F8F4  2               LoadEnvelopeData:
00F8F4  2  AD B1 07             lda EventMusicBuffer           ;check secondary buffer for win castle music
00F8F7  2  29 08                and #EndOfCastleMusic
00F8F9  2  F0 04                beq LoadUsualEnvData
00F8FB  2  B9 96 FF             lda EndOfCastleMusicEnvData,y  ;load data from offset for win castle music
00F8FE  2  60                   rts
00F8FF  2               
00F8FF  2               LoadUsualEnvData:
00F8FF  2  A5 F4                lda AreaMusicBuffer            ;check primary buffer for water music
00F901  2  29 7D                and #%01111101
00F903  2  F0 04                beq LoadWaterEventMusEnvData
00F905  2  B9 9A FF             lda AreaMusicEnvData,y         ;load default data from offset for all other music
00F908  2  60                   rts
00F909  2               
00F909  2               LoadWaterEventMusEnvData:
00F909  2  B9 A2 FF             lda WaterEventMusEnvData,y     ;load data from offset for water music and all other event music
00F90C  2  60                   rts
00F90D  2               
00F90D  2               ;--------------------------------
00F90D  2               
00F90D  2               ;music header offsets
00F90D  2               
00F90D  2               MusicHeaderData:
00F90D  2  A5                 .byte DeathMusHdr-MHD           ;event music
00F90E  2  59                 .byte GameOverMusHdr-MHD
00F90F  2  54                 .byte VictoryMusHdr-MHD
00F910  2  64                 .byte WinCastleMusHdr-MHD
00F911  2  59                 .byte GameOverMusHdr-MHD
00F912  2  3C                 .byte EndOfLevelMusHdr-MHD
00F913  2  31                 .byte TimeRunningOutHdr-MHD
00F914  2  4B                 .byte SilenceHdr-MHD
00F915  2               
00F915  2  69                 .byte GroundLevelPart1Hdr-MHD   ;area music
00F916  2  5E                 .byte WaterMusHdr-MHD
00F917  2  46                 .byte UndergroundMusHdr-MHD
00F918  2  4F                 .byte CastleMusHdr-MHD
00F919  2  36                 .byte Star_CloudHdr-MHD
00F91A  2  8D                 .byte GroundLevelLeadInHdr-MHD
00F91B  2  36                 .byte Star_CloudHdr-MHD
00F91C  2  4B                 .byte SilenceHdr-MHD
00F91D  2               
00F91D  2  8D                 .byte GroundLevelLeadInHdr-MHD  ;ground level music layout
00F91E  2  69 69              .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00F920  2  6F 75 6F 7B        .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00F924  2  6F 75 6F 7B        .byte GroundLevelPart2AHdr-MHD, GroundLevelPart2BHdr-MHD, GroundLevelPart2AHdr-MHD, GroundLevelPart2CHdr-MHD
00F928  2  81 87 81 8D        .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00F92C  2  69 69              .byte GroundLevelPart1Hdr-MHD, GroundLevelPart1Hdr-MHD
00F92E  2  93 99 93 9F        .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00F932  2  93 99 93 9F        .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00F936  2  81 87 81 8D        .byte GroundLevelPart3AHdr-MHD, GroundLevelPart3BHdr-MHD, GroundLevelPart3AHdr-MHD, GroundLevelLeadInHdr-MHD
00F93A  2  93 99 93 9F        .byte GroundLevelPart4AHdr-MHD, GroundLevelPart4BHdr-MHD, GroundLevelPart4AHdr-MHD, GroundLevelPart4CHdr-MHD
00F93E  2               
00F93E  2               ;music headers
00F93E  2               ;header format is as follows:
00F93E  2               ;1 byte - length byte offset
00F93E  2               ;2 bytes -  music data address
00F93E  2               ;1 byte - triangle data offset
00F93E  2               ;1 byte - square 1 data offset
00F93E  2               ;1 byte - noise data offset (not used by secondary music)
00F93E  2               
00F93E  2  08 72 FC 27  TimeRunningOutHdr:    .byte $08, <TimeRunOutMusData, >TimeRunOutMusData, $27, $18
00F942  2  18           
00F943  2  20 B8 F9 2E  Star_CloudHdr:        .byte $20, <Star_CloudMData, >Star_CloudMData, $2e, $1a, $40
00F947  2  1A 40        
00F949  2  20 B0 FC 3D  EndOfLevelMusHdr:     .byte $20, <WinLevelMusData, >WinLevelMusData, $3d, $21
00F94D  2  21           
00F94E  2  20 C4 FC 3F  ResidualHeaderData:   .byte $20, $c4, $fc, $3f, $1d
00F952  2  1D           
00F953  2  18 11 FD 00  UndergroundMusHdr:    .byte $18, <UndergroundMusData, >UndergroundMusData, $00, $00
00F957  2  00           
00F958  2  08 1C FA 00  SilenceHdr:           .byte $08, <SilenceData, >SilenceData, $00
00F95C  2  00 A4 FB 93  CastleMusHdr:         .byte $00, <CastleMusData, >CastleMusData, $93, $62
00F960  2  62           
00F961  2  10 C8 FE 24  VictoryMusHdr:        .byte $10, <VictoryMusData, >VictoryMusData, $24, $14
00F965  2  14           
00F966  2  18 45 FC 1E  GameOverMusHdr:       .byte $18, <GameOverMusData, >GameOverMusData, $1e, $14
00F96A  2  14           
00F96B  2  08 52 FD A0  WaterMusHdr:          .byte $08, <WaterMusData, >WaterMusData, $a0, $70, $68
00F96F  2  70 68        
00F971  2  08 51 FE 4C  WinCastleMusHdr:      .byte $08, <EndOfCastleMusData, >EndOfCastleMusData, $4c, $24
00F975  2  24           
00F976  2  18 01 FA 2D  GroundLevelPart1Hdr:  .byte $18, <GroundM_P1Data, >GroundM_P1Data, $2d, $1c, $b8
00F97A  2  1C B8        
00F97C  2  18 49 FA 20  GroundLevelPart2AHdr: .byte $18, <GroundM_P2AData, >GroundM_P2AData, $20, $12, $70
00F980  2  12 70        
00F982  2  18 75 FA 1B  GroundLevelPart2BHdr: .byte $18, <GroundM_P2BData, >GroundM_P2BData, $1b, $10, $44
00F986  2  10 44        
00F988  2  18 9D FA 11  GroundLevelPart2CHdr: .byte $18, <GroundM_P2CData, >GroundM_P2CData, $11, $0a, $1c
00F98C  2  0A 1C        
00F98E  2  18 C2 FA 2D  GroundLevelPart3AHdr: .byte $18, <GroundM_P3AData, >GroundM_P3AData, $2d, $10, $58
00F992  2  10 58        
00F994  2  18 DB FA 14  GroundLevelPart3BHdr: .byte $18, <GroundM_P3BData, >GroundM_P3BData, $14, $0d, $3f
00F998  2  0D 3F        
00F99A  2  18 F9 FA 15  GroundLevelLeadInHdr: .byte $18, <GroundMLdInData, >GroundMLdInData, $15, $0d, $21
00F99E  2  0D 21        
00F9A0  2  18 25 FB 18  GroundLevelPart4AHdr: .byte $18, <GroundM_P4AData, >GroundM_P4AData, $18, $10, $7a
00F9A4  2  10 7A        
00F9A6  2  18 4B FB 19  GroundLevelPart4BHdr: .byte $18, <GroundM_P4BData, >GroundM_P4BData, $19, $0f, $54
00F9AA  2  0F 54        
00F9AC  2  18 74 FB 1E  GroundLevelPart4CHdr: .byte $18, <GroundM_P4CData, >GroundM_P4CData, $1e, $12, $2b
00F9B0  2  12 2B        
00F9B2  2  18 72 FB 1E  DeathMusHdr:          .byte $18, <DeathMusData, >DeathMusData, $1e, $0f, $2d
00F9B6  2  0F 2D        
00F9B8  2               
00F9B8  2               ;--------------------------------
00F9B8  2               
00F9B8  2               ;MUSIC DATA
00F9B8  2               ;square 2/triangle format
00F9B8  2               ;d7 - length byte flag (0-note, 1-length)
00F9B8  2               ;if d7 is set to 0 and d6-d0 is nonzero:
00F9B8  2               ;d6-d0 - note offset in frequency look-up table (must be even)
00F9B8  2               ;if d7 is set to 1:
00F9B8  2               ;d6-d3 - unused
00F9B8  2               ;d2-d0 - length offset in length look-up table
00F9B8  2               ;value of $00 in square 2 data is used as null terminator, affects all sound channels
00F9B8  2               ;value of $00 in triangle data causes routine to skip note
00F9B8  2               
00F9B8  2               ;square 1 format
00F9B8  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00F9B8  2               ;d5-d1 - note offset in frequency look-up table
00F9B8  2               ;value of $00 in square 1 data is flag alternate control reg data to be loaded
00F9B8  2               
00F9B8  2               ;noise format
00F9B8  2               ;d7-d6, d0 - length offset in length look-up table (bit order is d0,d7,d6)
00F9B8  2               ;d5-d4 - beat type (0 - rest, 1 - short, 2 - strong, 3 - long)
00F9B8  2               ;d3-d1 - unused
00F9B8  2               ;value of $00 in noise data is used as null terminator, affects only noise
00F9B8  2               
00F9B8  2               ;all music data is organized into sections (unless otherwise stated):
00F9B8  2               ;square 2, square 1, triangle, noise
00F9B8  2               
00F9B8  2               Star_CloudMData:
00F9B8  2  84 2C 2C 2C        .byte $84, $2c, $2c, $2c, $82, $04, $2c, $04, $85, $2c, $84, $2c, $2c
00F9BC  2  82 04 2C 04  
00F9C0  2  85 2C 84 2C  
00F9C5  2  2A 2A 2A 82        .byte $2a, $2a, $2a, $82, $04, $2a, $04, $85, $2a, $84, $2a, $2a, $00
00F9C9  2  04 2A 04 85  
00F9CD  2  2A 84 2A 2A  
00F9D2  2               
00F9D2  2  1F 1F 1F 98        .byte $1f, $1f, $1f, $98, $1f, $1f, $98, $9e, $98, $1f
00F9D6  2  1F 1F 98 9E  
00F9DA  2  98 1F        
00F9DC  2  1D 1D 1D 94        .byte $1d, $1d, $1d, $94, $1d, $1d, $94, $9c, $94, $1d
00F9E0  2  1D 1D 94 9C  
00F9E4  2  94 1D        
00F9E6  2               
00F9E6  2  86 18 85 26        .byte $86, $18, $85, $26, $30, $84, $04, $26, $30
00F9EA  2  30 84 04 26  
00F9EE  2  30           
00F9EF  2  86 14 85 22        .byte $86, $14, $85, $22, $2c, $84, $04, $22, $2c
00F9F3  2  2C 84 04 22  
00F9F7  2  2C           
00F9F8  2               
00F9F8  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00F9FC  2  31 D0 C4 D0  
00FA00  2  00           
00FA01  2               
00FA01  2               GroundM_P1Data:
00FA01  2  85 2C 22 1C        .byte $85, $2c, $22, $1c, $84, $26, $2a, $82, $28, $26, $04
00FA05  2  84 26 2A 82  
00FA09  2  28 26 04     
00FA0C  2  87 22 34 3A        .byte $87, $22, $34, $3a, $82, $40, $04, $36, $84, $3a, $34
00FA10  2  82 40 04 36  
00FA14  2  84 3A 34     
00FA17  2  82 2C 30 85        .byte $82, $2c, $30, $85, $2a
00FA1B  2  2A           
00FA1C  2               
00FA1C  2               SilenceData:
00FA1C  2  00                 .byte $00
00FA1D  2               
00FA1D  2  5D 55 4D 15        .byte $5d, $55, $4d, $15, $19, $96, $15, $d5, $e3, $eb
00FA21  2  19 96 15 D5  
00FA25  2  E3 EB        
00FA27  2  2D A6 2B 27        .byte $2d, $a6, $2b, $27, $9c, $9e, $59
00FA2B  2  9C 9E 59     
00FA2E  2               
00FA2E  2  85 22 1C 14        .byte $85, $22, $1c, $14, $84, $1e, $22, $82, $20, $1e, $04, $87
00FA32  2  84 1E 22 82  
00FA36  2  20 1E 04 87  
00FA3A  2  1C 2C 34 82        .byte $1c, $2c, $34, $82, $36, $04, $30, $34, $04, $2c, $04, $26
00FA3E  2  36 04 30 34  
00FA42  2  04 2C 04 26  
00FA46  2  2A 85 22           .byte $2a, $85, $22
00FA49  2               
00FA49  2               GroundM_P2AData:
00FA49  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00FA4D  2  38 36 32 04  
00FA51  2  34           
00FA52  2  04 24 26 2C        .byte $04, $24, $26, $2c, $04, $26, $2c, $30, $00
00FA56  2  04 26 2C 30  
00FA5A  2  00           
00FA5B  2               
00FA5B  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00FA5F  2  2B AC 84     
00FA62  2  9C 9E A2 84        .byte $9c, $9e, $a2, $84, $94, $9c, $9e
00FA66  2  94 9C 9E     
00FA69  2               
00FA69  2  85 14 22 84        .byte $85, $14, $22, $84, $2c, $85, $1e
00FA6D  2  2C 85 1E     
00FA70  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $1e
00FA74  2  1E           
00FA75  2               
00FA75  2               GroundM_P2BData:
00FA75  2  84 04 82 3A        .byte $84, $04, $82, $3a, $38, $36, $32, $04, $34
00FA79  2  38 36 32 04  
00FA7D  2  34           
00FA7E  2  04 64 04 64        .byte $04, $64, $04, $64, $86, $64, $00
00FA82  2  86 64 00     
00FA85  2               
00FA85  2  05 B4 B2 B0        .byte $05, $b4, $b2, $b0, $2b, $ac, $84
00FA89  2  2B AC 84     
00FA8C  2  37 B6 B6 45        .byte $37, $b6, $b6, $45
00FA90  2               
00FA90  2  85 14 1C 82        .byte $85, $14, $1c, $82, $22, $84, $2c
00FA94  2  22 84 2C     
00FA97  2  4E 82 4E 84        .byte $4e, $82, $4e, $84, $4e, $22
00FA9B  2  4E 22        
00FA9D  2               
00FA9D  2               GroundM_P2CData:
00FA9D  2  84 04 85 32        .byte $84, $04, $85, $32, $85, $30, $86, $2c, $04, $00
00FAA1  2  85 30 86 2C  
00FAA5  2  04 00        
00FAA7  2               
00FAA7  2  05 A4 05 9E        .byte $05, $a4, $05, $9e, $05, $9d, $85
00FAAB  2  05 9D 85     
00FAAE  2               
00FAAE  2  84 14 85 24        .byte $84, $14, $85, $24, $28, $2c, $82
00FAB2  2  28 2C 82     
00FAB5  2  22 84 22 14        .byte $22, $84, $22, $14
00FAB9  2               
00FAB9  2  21 D0 C4 D0        .byte $21, $d0, $c4, $d0, $31, $d0, $c4, $d0, $00
00FABD  2  31 D0 C4 D0  
00FAC1  2  00           
00FAC2  2               
00FAC2  2               GroundM_P3AData:
00FAC2  2  82 2C 84 2C        .byte $82, $2c, $84, $2c, $2c, $82, $2c, $30
00FAC6  2  2C 82 2C 30  
00FACA  2  04 34 2C 04        .byte $04, $34, $2c, $04, $26, $86, $22, $00
00FACE  2  26 86 22 00  
00FAD2  2               
00FAD2  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $29, $a2, $1d, $9c, $95
00FAD6  2  29 A2 1D 9C  
00FADA  2  95           
00FADB  2               
00FADB  2               GroundM_P3BData:
00FADB  2  82 2C 2C 04        .byte $82, $2c, $2c, $04, $2c, $04, $2c, $30, $85, $34, $04, $04, $00
00FADF  2  2C 04 2C 30  
00FAE3  2  85 34 04 04  
00FAE8  2               
00FAE8  2  A4 25 25 A4        .byte $a4, $25, $25, $a4, $a8, $63, $04
00FAEC  2  A8 63 04     
00FAEF  2               
00FAEF  2               ;triangle data used by both sections of third part
00FAEF  2  85 0E 1A 84        .byte $85, $0e, $1a, $84, $24, $85, $22, $14, $84, $0c
00FAF3  2  24 85 22 14  
00FAF7  2  84 0C        
00FAF9  2               
00FAF9  2               GroundMLdInData:
00FAF9  2  82 34 84 34        .byte $82, $34, $84, $34, $34, $82, $2c, $84, $34, $86, $3a, $04, $00
00FAFD  2  34 82 2C 84  
00FB01  2  34 86 3A 04  
00FB06  2               
00FB06  2  A0 21 21 A0        .byte $a0, $21, $21, $a0, $21, $2b, $05, $a3
00FB0A  2  21 2B 05 A3  
00FB0E  2               
00FB0E  2  82 18 84 18        .byte $82, $18, $84, $18, $18, $82, $18, $18, $04, $86, $3a, $22
00FB12  2  18 82 18 18  
00FB16  2  04 86 3A 22  
00FB1A  2               
00FB1A  2               ;noise data used by lead-in and third part sections
00FB1A  2  31 90 31 90        .byte $31, $90, $31, $90, $31, $71, $31, $90, $90, $90, $00
00FB1E  2  31 71 31 90  
00FB22  2  90 90 00     
00FB25  2               
00FB25  2               GroundM_P4AData:
00FB25  2  82 34 84 2C        .byte $82, $34, $84, $2c, $85, $22, $84, $24
00FB29  2  85 22 84 24  
00FB2D  2  82 26 36 04        .byte $82, $26, $36, $04, $36, $86, $26, $00
00FB31  2  36 86 26 00  
00FB35  2               
00FB35  2  AC 27 5D 1D        .byte $ac, $27, $5d, $1d, $9e, $2d, $ac, $9f
00FB39  2  9E 2D AC 9F  
00FB3D  2               
00FB3D  2  85 14 82 20        .byte $85, $14, $82, $20, $84, $22, $2c
00FB41  2  84 22 2C     
00FB44  2  1E 1E 82 2C        .byte $1e, $1e, $82, $2c, $2c, $1e, $04
00FB48  2  2C 1E 04     
00FB4B  2               
00FB4B  2               GroundM_P4BData:
00FB4B  2  87 2A 40 40        .byte $87, $2a, $40, $40, $40, $3a, $36
00FB4F  2  40 3A 36     
00FB52  2  82 34 2C 04        .byte $82, $34, $2c, $04, $26, $86, $22, $00
00FB56  2  26 86 22 00  
00FB5A  2               
00FB5A  2  E3 F7 F7 F7        .byte $e3, $f7, $f7, $f7, $f5, $f1, $ac, $27, $9e, $9d
00FB5E  2  F5 F1 AC 27  
00FB62  2  9E 9D        
00FB64  2               
00FB64  2  85 18 82 1E        .byte $85, $18, $82, $1e, $84, $22, $2a
00FB68  2  84 22 2A     
00FB6B  2  22 22 82 2C        .byte $22, $22, $82, $2c, $2c, $22, $04
00FB6F  2  2C 22 04     
00FB72  2               
00FB72  2               DeathMusData:
00FB72  2  86 04              .byte $86, $04 ;death music share data with fourth part c of ground level music
00FB74  2               
00FB74  2               GroundM_P4CData:
00FB74  2  82 2A 36 04        .byte $82, $2a, $36, $04, $36, $87, $36, $34, $30, $86, $2c, $04, $00
00FB78  2  36 87 36 34  
00FB7C  2  30 86 2C 04  
00FB81  2               
00FB81  2  00 68 6A 6C        .byte $00, $68, $6a, $6c, $45 ;death music only
00FB85  2  45           
00FB86  2               
00FB86  2  A2 31 B0 F1        .byte $a2, $31, $b0, $f1, $ed, $eb, $a2, $1d, $9c, $95
00FB8A  2  ED EB A2 1D  
00FB8E  2  9C 95        
00FB90  2               
00FB90  2  86 04              .byte $86, $04 ;death music only
00FB92  2               
00FB92  2  85 22 82 22        .byte $85, $22, $82, $22, $87, $22, $26, $2a, $84, $2c, $22, $86, $14
00FB96  2  87 22 26 2A  
00FB9A  2  84 2C 22 86  
00FB9F  2               
00FB9F  2               ;noise data used by fourth part sections
00FB9F  2  51 90 31 11        .byte $51, $90, $31, $11, $00
00FBA3  2  00           
00FBA4  2               
00FBA4  2               CastleMusData:
00FBA4  2  80 22 28 22        .byte $80, $22, $28, $22, $26, $22, $24, $22, $26
00FBA8  2  26 22 24 22  
00FBAC  2  26           
00FBAD  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00FBB1  2  22 28 22 26  
00FBB5  2  22 28 22 26        .byte $22, $28, $22, $26, $22, $24, $22, $26
00FBB9  2  22 24 22 26  
00FBBD  2  22 28 22 2A        .byte $22, $28, $22, $2a, $22, $28, $22, $26
00FBC1  2  22 28 22 26  
00FBC5  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00FBC9  2  20 26 20 28  
00FBCD  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00FBD1  2  20 26 20 24  
00FBD5  2  20 26 20 24        .byte $20, $26, $20, $24, $20, $26, $20, $28
00FBD9  2  20 26 20 28  
00FBDD  2  20 26 20 28        .byte $20, $26, $20, $28, $20, $26, $20, $24
00FBE1  2  20 26 20 24  
00FBE5  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00FBE9  2  28 30 28 2E  
00FBED  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e
00FBF1  2  28 2C 28 2E  
00FBF5  2  28 30 28 32        .byte $28, $30, $28, $32, $28, $30, $28, $2e
00FBF9  2  28 30 28 2E  
00FBFD  2  28 30 28 2E        .byte $28, $30, $28, $2e, $28, $2c, $28, $2e, $00
00FC01  2  28 2C 28 2E  
00FC05  2  00           
00FC06  2               
00FC06  2  04 70 6E 6C        .byte $04, $70, $6e, $6c, $6e, $70, $72, $70, $6e
00FC0A  2  6E 70 72 70  
00FC0E  2  6E           
00FC0F  2  70 6E 6C 6E        .byte $70, $6e, $6c, $6e, $70, $72, $70, $6e
00FC13  2  70 72 70 6E  
00FC17  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00FC1B  2  6E 70 6E 6C  
00FC1F  2  6E 6C 6E 70        .byte $6e, $6c, $6e, $70, $6e, $70, $6e, $6c
00FC23  2  6E 70 6E 6C  
00FC27  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00FC2B  2  76 74 72 74  
00FC2F  2  76 78 76 74        .byte $76, $78, $76, $74, $76, $74, $72, $74
00FC33  2  76 74 72 74  
00FC37  2               
00FC37  2  84 1A 83 18        .byte $84, $1a, $83, $18, $20, $84, $1e, $83, $1c, $28
00FC3B  2  20 84 1E 83  
00FC3F  2  1C 28        
00FC41  2  26 1C 1A 1C        .byte $26, $1c, $1a, $1c
00FC45  2               
00FC45  2               GameOverMusData:
00FC45  2  82 2C 04 04        .byte $82, $2c, $04, $04, $22, $04, $04, $84, $1c, $87
00FC49  2  22 04 04 84  
00FC4D  2  1C 87        
00FC4F  2  26 2A 26 84        .byte $26, $2a, $26, $84, $24, $28, $24, $80, $22, $00
00FC53  2  24 28 24 80  
00FC57  2  22 00        
00FC59  2               
00FC59  2  9C 05 94 05        .byte $9c, $05, $94, $05, $0d, $9f, $1e, $9c, $98, $9d
00FC5D  2  0D 9F 1E 9C  
00FC61  2  98 9D        
00FC63  2               
00FC63  2  82 22 04 04        .byte $82, $22, $04, $04, $1c, $04, $04, $84, $14
00FC67  2  1C 04 04 84  
00FC6B  2  14           
00FC6C  2  86 1E 80 16        .byte $86, $1e, $80, $16, $80, $14
00FC70  2  80 14        
00FC72  2               
00FC72  2               TimeRunOutMusData:
00FC72  2  81 1C 30 04        .byte $81, $1c, $30, $04, $30, $30, $04, $1e, $32, $04, $32, $32
00FC76  2  30 30 04 1E  
00FC7A  2  32 04 32 32  
00FC7E  2  04 20 34 04        .byte $04, $20, $34, $04, $34, $34, $04, $36, $04, $84, $36, $00
00FC82  2  34 34 04 36  
00FC86  2  04 84 36 00  
00FC8A  2               
00FC8A  2  46 A4 64 A4        .byte $46, $a4, $64, $a4, $48, $a6, $66, $a6, $4a, $a8, $68, $a8
00FC8E  2  48 A6 66 A6  
00FC92  2  4A A8 68 A8  
00FC96  2  6A 44 2B           .byte $6a, $44, $2b
00FC99  2               
00FC99  2  81 2A 42 04        .byte $81, $2a, $42, $04, $42, $42, $04, $2c, $64, $04, $64, $64
00FC9D  2  42 42 04 2C  
00FCA1  2  64 04 64 64  
00FCA5  2  04 2E 46 04        .byte $04, $2e, $46, $04, $46, $46, $04, $22, $04, $84, $22
00FCA9  2  46 46 04 22  
00FCAD  2  04 84 22     
00FCB0  2               
00FCB0  2               WinLevelMusData:
00FCB0  2  87 04 06 0C        .byte $87, $04, $06, $0c, $14, $1c, $22, $86, $2c, $22
00FCB4  2  14 1C 22 86  
00FCB8  2  2C 22        
00FCBA  2  87 04 60 0E        .byte $87, $04, $60, $0e, $14, $1a, $24, $86, $2c, $24
00FCBE  2  14 1A 24 86  
00FCC2  2  2C 24        
00FCC4  2  87 04 08 10        .byte $87, $04, $08, $10, $18, $1e, $28, $86, $30, $30
00FCC8  2  18 1E 28 86  
00FCCC  2  30 30        
00FCCE  2  80 64 00           .byte $80, $64, $00
00FCD1  2               
00FCD1  2  CD D5 DD E3        .byte $cd, $d5, $dd, $e3, $ed, $f5, $bb, $b5, $cf, $d5
00FCD5  2  ED F5 BB B5  
00FCD9  2  CF D5        
00FCDB  2  DB E5 ED F3        .byte $db, $e5, $ed, $f3, $bd, $b3, $d1, $d9, $df, $e9
00FCDF  2  BD B3 D1 D9  
00FCE3  2  DF E9        
00FCE5  2  F1 F7 BF FF        .byte $f1, $f7, $bf, $ff, $ff, $ff, $34
00FCE9  2  FF FF 34     
00FCEC  2  00                 .byte $00 ;unused byte
00FCED  2               
00FCED  2  86 04 87 14        .byte $86, $04, $87, $14, $1c, $22, $86, $34, $84, $2c
00FCF1  2  1C 22 86 34  
00FCF5  2  84 2C        
00FCF7  2  04 04 04 87        .byte $04, $04, $04, $87, $14, $1a, $24, $86, $32, $84
00FCFB  2  14 1A 24 86  
00FCFF  2  32 84        
00FD01  2  2C 04 86 04        .byte $2c, $04, $86, $04, $87, $18, $1e, $28, $86, $36
00FD05  2  87 18 1E 28  
00FD09  2  86 36        
00FD0B  2  87 30 30 30        .byte $87, $30, $30, $30, $80, $2c
00FD0F  2  80 2C        
00FD11  2               
00FD11  2               ;square 2 and triangle use the same data, square 1 is unused
00FD11  2               UndergroundMusData:
00FD11  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00FD15  2  26 10 28 80  
00FD19  2  04           
00FD1A  2  82 14 2C 62        .byte $82, $14, $2c, $62, $26, $10, $28, $80, $04
00FD1E  2  26 10 28 80  
00FD22  2  04           
00FD23  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $80, $04
00FD27  2  18 60 1A 80  
00FD2B  2  04           
00FD2C  2  82 08 1E 5E        .byte $82, $08, $1e, $5e, $18, $60, $1a, $86, $04
00FD30  2  18 60 1A 86  
00FD34  2  04           
00FD35  2  83 1A 18 16        .byte $83, $1a, $18, $16, $84, $14, $1a, $18, $0e, $0c
00FD39  2  84 14 1A 18  
00FD3D  2  0E 0C        
00FD3F  2  16 83 14 20        .byte $16, $83, $14, $20, $1e, $1c, $28, $26, $87
00FD43  2  1E 1C 28 26  
00FD47  2  87           
00FD48  2  24 1A 12 10        .byte $24, $1a, $12, $10, $62, $0e, $80, $04, $04
00FD4C  2  62 0E 80 04  
00FD50  2  04           
00FD51  2  00                 .byte $00
00FD52  2               
00FD52  2               ;noise data directly follows square 2 here unlike in other songs
00FD52  2               WaterMusData:
00FD52  2  82 18 1C 20        .byte $82, $18, $1c, $20, $22, $26, $28
00FD56  2  22 26 28     
00FD59  2  81 2A 2A 2A        .byte $81, $2a, $2a, $2a, $04, $2a, $04, $83, $2a, $82, $22
00FD5D  2  04 2A 04 83  
00FD61  2  2A 82 22     
00FD64  2  86 34 32 34        .byte $86, $34, $32, $34, $81, $04, $22, $26, $2a, $2c, $30
00FD68  2  81 04 22 26  
00FD6C  2  2A 2C 30     
00FD6F  2  86 34 83 32        .byte $86, $34, $83, $32, $82, $36, $84, $34, $85, $04, $81, $22
00FD73  2  82 36 84 34  
00FD77  2  85 04 81 22  
00FD7B  2  86 30 2E 30        .byte $86, $30, $2e, $30, $81, $04, $22, $26, $2a, $2c, $2e
00FD7F  2  81 04 22 26  
00FD83  2  2A 2C 2E     
00FD86  2  86 30 83 22        .byte $86, $30, $83, $22, $82, $36, $84, $34, $85, $04, $81, $22
00FD8A  2  82 36 84 34  
00FD8E  2  85 04 81 22  
00FD92  2  86 3A 3A 3A        .byte $86, $3a, $3a, $3a, $82, $3a, $81, $40, $82, $04, $81, $3a
00FD96  2  82 3A 81 40  
00FD9A  2  82 04 81 3A  
00FD9E  2  86 36 36 36        .byte $86, $36, $36, $36, $82, $36, $81, $3a, $82, $04, $81, $36
00FDA2  2  82 36 81 3A  
00FDA6  2  82 04 81 36  
00FDAA  2  86 34 82 26        .byte $86, $34, $82, $26, $2a, $36
00FDAE  2  2A 36        
00FDB0  2  81 34 34 85        .byte $81, $34, $34, $85, $34, $81, $2a, $86, $2c, $00
00FDB4  2  34 81 2A 86  
00FDB8  2  2C 00        
00FDBA  2               
00FDBA  2  84 90 B0 84        .byte $84, $90, $b0, $84, $50, $50, $b0, $00
00FDBE  2  50 50 B0 00  
00FDC2  2               
00FDC2  2  98 96 94 92        .byte $98, $96, $94, $92, $94, $96, $58, $58, $58, $44
00FDC6  2  94 96 58 58  
00FDCA  2  58 44        
00FDCC  2  5C 44 9F A3        .byte $5c, $44, $9f, $a3, $a1, $a3, $85, $a3, $e0, $a6
00FDD0  2  A1 A3 85 A3  
00FDD4  2  E0 A6        
00FDD6  2  23 C4 9F 9D        .byte $23, $c4, $9f, $9d, $9f, $85, $9f, $d2, $a6, $23
00FDDA  2  9F 85 9F D2  
00FDDE  2  A6 23        
00FDE0  2  C4 B5 B1 AF        .byte $c4, $b5, $b1, $af, $85, $b1, $af, $ad, $85, $95
00FDE4  2  85 B1 AF AD  
00FDE8  2  85 95        
00FDEA  2  9E A2 AA 6A        .byte $9e, $a2, $aa, $6a, $6a, $6b, $5e, $9d
00FDEE  2  6A 6B 5E 9D  
00FDF2  2               
00FDF2  2  84 04 04 82        .byte $84, $04, $04, $82, $22, $86, $22
00FDF6  2  22 86 22     
00FDF9  2  82 14 22 2C        .byte $82, $14, $22, $2c, $12, $22, $2a, $14, $22, $2c
00FDFD  2  12 22 2A 14  
00FE01  2  22 2C        
00FE03  2  1C 22 2C 14        .byte $1c, $22, $2c, $14, $22, $2c, $12, $22, $2a, $14
00FE07  2  22 2C 12 22  
00FE0B  2  2A 14        
00FE0D  2  22 2C 1C 22        .byte $22, $2c, $1c, $22, $2c, $18, $22, $2a, $16, $20
00FE11  2  2C 18 22 2A  
00FE15  2  16 20        
00FE17  2  28 18 22 2A        .byte $28, $18, $22, $2a, $12, $22, $2a, $18, $22, $2a
00FE1B  2  12 22 2A 18  
00FE1F  2  22 2A        
00FE21  2  12 22 2A 14        .byte $12, $22, $2a, $14, $22, $2c, $0c, $22, $2c, $14, $22, $34, $12
00FE25  2  22 2C 0C 22  
00FE29  2  2C 14 22 34  
00FE2E  2  22 30 10 22        .byte $22, $30, $10, $22, $2e, $16, $22, $34, $18, $26
00FE32  2  2E 16 22 34  
00FE36  2  18 26        
00FE38  2  36 16 26 36        .byte $36, $16, $26, $36, $14, $26, $36, $12, $22, $36
00FE3C  2  14 26 36 12  
00FE40  2  22 36        
00FE42  2  5C 22 34 0C        .byte $5c, $22, $34, $0c, $22, $22, $81, $1e, $1e, $85, $1e
00FE46  2  22 22 81 1E  
00FE4A  2  1E 85 1E     
00FE4D  2  81 12 86 14        .byte $81, $12, $86, $14
00FE51  2               
00FE51  2               EndOfCastleMusData:
00FE51  2  81 2C 22 1C        .byte $81, $2c, $22, $1c, $2c, $22, $1c, $85, $2c, $04
00FE55  2  2C 22 1C 85  
00FE59  2  2C 04        
00FE5B  2  81 2E 24 1E        .byte $81, $2e, $24, $1e, $2e, $24, $1e, $85, $2e, $04
00FE5F  2  2E 24 1E 85  
00FE63  2  2E 04        
00FE65  2  81 32 28 22        .byte $81, $32, $28, $22, $32, $28, $22, $85, $32
00FE69  2  32 28 22 85  
00FE6D  2  32           
00FE6E  2  87 36 36 36        .byte $87, $36, $36, $36, $84, $3a, $00
00FE72  2  84 3A 00     
00FE75  2               
00FE75  2  5C 54 4C 5C        .byte $5c, $54, $4c, $5c, $54, $4c
00FE79  2  54 4C        
00FE7B  2  5C 1C 1C 5C        .byte $5c, $1c, $1c, $5c, $5c, $5c, $5c
00FE7F  2  5C 5C 5C     
00FE82  2  5E 56 4E 5E        .byte $5e, $56, $4e, $5e, $56, $4e
00FE86  2  56 4E        
00FE88  2  5E 1E 1E 5E        .byte $5e, $1e, $1e, $5e, $5e, $5e, $5e
00FE8C  2  5E 5E 5E     
00FE8F  2  62 5A 50 62        .byte $62, $5a, $50, $62, $5a, $50
00FE93  2  5A 50        
00FE95  2  62 22 22 62        .byte $62, $22, $22, $62, $e7, $e7, $e7, $2b
00FE99  2  E7 E7 E7 2B  
00FE9D  2               
00FE9D  2  86 14 81 14        .byte $86, $14, $81, $14, $80, $14, $14, $81, $14, $14, $14, $14
00FEA1  2  80 14 14 81  
00FEA5  2  14 14 14 14  
00FEA9  2  86 16 81 16        .byte $86, $16, $81, $16, $80, $16, $16, $81, $16, $16, $16, $16
00FEAD  2  80 16 16 81  
00FEB1  2  16 16 16 16  
00FEB5  2  81 28 22 1A        .byte $81, $28, $22, $1a, $28, $22, $1a, $28, $80, $28, $28
00FEB9  2  28 22 1A 28  
00FEBD  2  80 28 28     
00FEC0  2  81 28 87 2C        .byte $81, $28, $87, $2c, $2c, $2c, $84, $30
00FEC4  2  2C 2C 84 30  
00FEC8  2               
00FEC8  2               VictoryMusData:
00FEC8  2  83 04 84 0C        .byte $83, $04, $84, $0c, $83, $62, $10, $84, $12
00FECC  2  83 62 10 84  
00FED0  2  12           
00FED1  2  83 1C 22 1E        .byte $83, $1c, $22, $1e, $22, $26, $18, $1e, $04, $1c, $00
00FED5  2  22 26 18 1E  
00FED9  2  04 1C 00     
00FEDC  2               
00FEDC  2  E3 E1 E3 1D        .byte $e3, $e1, $e3, $1d, $de, $e0, $23
00FEE0  2  DE E0 23     
00FEE3  2  EC 75 74 F0        .byte $ec, $75, $74, $f0, $f4, $f6, $ea, $31, $2d
00FEE7  2  F4 F6 EA 31  
00FEEB  2  2D           
00FEEC  2               
00FEEC  2  83 12 14 04        .byte $83, $12, $14, $04, $18, $1a, $1c, $14
00FEF0  2  18 1A 1C 14  
00FEF4  2  26 22 1E 1C        .byte $26, $22, $1e, $1c, $18, $1e, $22, $0c, $14
00FEF8  2  18 1E 22 0C  
00FEFC  2  14           
00FEFD  2               
00FEFD  2               ;unused space
00FEFD  2  FF FF FF           .byte $ff, $ff, $ff
00FF00  2               
00FF00  2               FreqRegLookupTbl:
00FF00  2  00 88 00 2F        .byte $00, $88, $00, $2f, $00, $00
00FF04  2  00 00        
00FF06  2  02 A6 02 80        .byte $02, $a6, $02, $80, $02, $5c, $02, $3a
00FF0A  2  02 5C 02 3A  
00FF0E  2  02 1A 01 DF        .byte $02, $1a, $01, $df, $01, $c4, $01, $ab
00FF12  2  01 C4 01 AB  
00FF16  2  01 93 01 7C        .byte $01, $93, $01, $7c, $01, $67, $01, $53
00FF1A  2  01 67 01 53  
00FF1E  2  01 40 01 2E        .byte $01, $40, $01, $2e, $01, $1d, $01, $0d
00FF22  2  01 1D 01 0D  
00FF26  2  00 FE 00 EF        .byte $00, $fe, $00, $ef, $00, $e2, $00, $d5
00FF2A  2  00 E2 00 D5  
00FF2E  2  00 C9 00 BE        .byte $00, $c9, $00, $be, $00, $b3, $00, $a9
00FF32  2  00 B3 00 A9  
00FF36  2  00 A0 00 97        .byte $00, $a0, $00, $97, $00, $8e, $00, $86
00FF3A  2  00 8E 00 86  
00FF3E  2  00 77 00 7E        .byte $00, $77, $00, $7e, $00, $71, $00, $54
00FF42  2  00 71 00 54  
00FF46  2  00 64 00 5F        .byte $00, $64, $00, $5f, $00, $59, $00, $50
00FF4A  2  00 59 00 50  
00FF4E  2  00 47 00 43        .byte $00, $47, $00, $43, $00, $3b, $00, $35
00FF52  2  00 3B 00 35  
00FF56  2  00 2A 00 23        .byte $00, $2a, $00, $23, $04, $75, $03, $57
00FF5A  2  04 75 03 57  
00FF5E  2  02 F9 02 CF        .byte $02, $f9, $02, $cf, $01, $fc, $00, $6a
00FF62  2  01 FC 00 6A  
00FF66  2               
00FF66  2               MusicLengthLookupTbl:
00FF66  2  05 0A 14 28        .byte $05, $0a, $14, $28, $50, $1e, $3c, $02
00FF6A  2  50 1E 3C 02  
00FF6E  2  04 08 10 20        .byte $04, $08, $10, $20, $40, $18, $30, $0c
00FF72  2  40 18 30 0C  
00FF76  2  03 06 0C 18        .byte $03, $06, $0c, $18, $30, $12, $24, $08
00FF7A  2  30 12 24 08  
00FF7E  2  36 03 09 06        .byte $36, $03, $09, $06, $12, $1b, $24, $0c
00FF82  2  12 1B 24 0C  
00FF86  2  24 02 06 04        .byte $24, $02, $06, $04, $0c, $12, $18, $08
00FF8A  2  0C 12 18 08  
00FF8E  2  12 01 03 02        .byte $12, $01, $03, $02, $06, $09, $0c, $04
00FF92  2  06 09 0C 04  
00FF96  2               
00FF96  2               EndOfCastleMusicEnvData:
00FF96  2  98 99 9A 9B        .byte $98, $99, $9a, $9b
00FF9A  2               
00FF9A  2               AreaMusicEnvData:
00FF9A  2  90 94 94 95        .byte $90, $94, $94, $95, $95, $96, $97, $98
00FF9E  2  95 96 97 98  
00FFA2  2               
00FFA2  2               WaterEventMusEnvData:
00FFA2  2  90 91 92 92        .byte $90, $91, $92, $92, $93, $93, $93, $94
00FFA6  2  93 93 93 94  
00FFAA  2  94 94 94 94        .byte $94, $94, $94, $94, $94, $95, $95, $95
00FFAE  2  94 95 95 95  
00FFB2  2  95 95 95 96        .byte $95, $95, $95, $96, $96, $96, $96, $96
00FFB6  2  96 96 96 96  
00FFBA  2  96 96 96 96        .byte $96, $96, $96, $96, $96, $96, $96, $96
00FFBE  2  96 96 96 96  
00FFC2  2  96 96 96 96        .byte $96, $96, $96, $96, $95, $95, $94, $93
00FFC6  2  95 95 94 93  
00FFCA  2               
00FFCA  2               BowserFlameEnvData:
00FFCA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00FFCE  2  17 18 19 19  
00FFD2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00FFD6  2  1D 1E 1E 1F  
00FFDA  2  1F 1F 1F 1E        .byte $1f, $1f, $1f, $1e, $1d, $1c, $1e, $1f
00FFDE  2  1D 1C 1E 1F  
00FFE2  2  1F 1E 1D 1C        .byte $1f, $1e, $1d, $1c, $1a, $18, $16, $14
00FFE6  2  1A 18 16 14  
00FFEA  2               
00FFEA  2               BrickShatterEnvData:
00FFEA  2  15 16 16 17        .byte $15, $16, $16, $17, $17, $18, $19, $19
00FFEE  2  17 18 19 19  
00FFF2  2  1A 1A 1C 1D        .byte $1a, $1a, $1c, $1d, $1d, $1e, $1e, $1f
00FFF6  2  1D 1E 1E 1F  
00FFFA  2               
00FFFA  2               ;-------------------------------------------------------------------------------------
00FFFA  2               ;INTERRUPT VECTORS
00FFFA  2               
00FFFA  2               .res $FFFA - *, $FF
00FFFA  2  82 80              .word NonMaskableInterrupt
00FFFC  2  00 80              .word Start
00FFFE  2  F0 FF              .word $fff0  ;unused
010000  2               
010000  1               
010000  1               .segment "SMBCHR"
010000  1  03 0F 1F 1F  .incbin "smb.chr"
010004  1  1C 24 26 66  
010008  1  00 00 00 00  
010000  1               
